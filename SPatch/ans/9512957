
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.9.3 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.9.3</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Jan. 12, 2017, 10:47 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20170112104723.GB12847@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9512957/mbox/"
   >mbox</a>
|
   <a href="/patch/9512957/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9512957/">/patch/9512957/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	2DA80601E5 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 12 Jan 2017 10:47:32 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 0961C2868C
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 12 Jan 2017 10:47:32 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id EA394286B2; Thu, 12 Jan 2017 10:47:31 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 0E1D42868C
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 12 Jan 2017 10:47:20 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1751479AbdALKrR (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 12 Jan 2017 05:47:17 -0500
Received: from mail.linuxfoundation.org ([140.211.169.12]:51364 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1750807AbdALKrI (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 12 Jan 2017 05:47:08 -0500
Received: from localhost (unknown [78.192.101.3])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 9625598C;
	Thu, 12 Jan 2017 10:47:00 +0000 (UTC)
Date: Thu, 12 Jan 2017 11:47:23 +0100
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.9.3
Message-ID: &lt;20170112104723.GB12847@kroah.com&gt;
References: &lt;20170112104712.GA12847@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=iso-8859-1
Content-Disposition: inline
Content-Transfer-Encoding: 8bit
In-Reply-To: &lt;20170112104712.GA12847@kroah.com&gt;
User-Agent: Mutt/1.7.2 (2016-11-26)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Jan. 12, 2017, 10:47 a.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/conf.py b/Documentation/conf.py</span>
<span class="p_header">index bf6f310e5170..d769cd89a9f7 100644</span>
<span class="p_header">--- a/Documentation/conf.py</span>
<span class="p_header">+++ b/Documentation/conf.py</span>
<span class="p_chunk">@@ -37,7 +37,7 @@</span> <span class="p_context"> from load_config import loadConfig</span>
 extensions = [&#39;kernel-doc&#39;, &#39;rstFlatTable&#39;, &#39;kernel_include&#39;, &#39;cdomain&#39;]
 
 # The name of the math extension changed on Sphinx 1.4
<span class="p_del">-if minor &gt; 3:</span>
<span class="p_add">+if major == 1 and minor &gt; 3:</span>
     extensions.append(&quot;sphinx.ext.imgmath&quot;)
 else:
     extensions.append(&quot;sphinx.ext.pngmath&quot;)
<span class="p_chunk">@@ -332,6 +332,10 @@</span> <span class="p_context"> latex_elements = {</span>
      &#39;&#39;&#39;
 }
 
<span class="p_add">+# Fix reference escape troubles with Sphinx 1.4.x</span>
<span class="p_add">+if major == 1 and minor &gt; 3:</span>
<span class="p_add">+    latex_elements[&#39;preamble&#39;]  += &#39;\\renewcommand*{\\DUrole}[2]{ #2 }\n&#39;</span>
<span class="p_add">+</span>
 # Grouping the document tree into LaTeX files. List of tuples
 # (source start file, target name, title,
 #  author, documentclass [howto, manual, or own class]).
<span class="p_header">diff --git a/Documentation/media/index.rst b/Documentation/media/index.rst</span>
<span class="p_header">index e347a3e7bdef..7f8f0af620ce 100644</span>
<span class="p_header">--- a/Documentation/media/index.rst</span>
<span class="p_header">+++ b/Documentation/media/index.rst</span>
<span class="p_chunk">@@ -1,11 +1,6 @@</span> <span class="p_context"></span>
 Linux Media Subsystem Documentation
 ===================================
 
<span class="p_del">-.. Sphinx 1.4.x has a definition for DUrole that doesn&#39;t work on alltt blocks</span>
<span class="p_del">-.. raw:: latex</span>
<span class="p_del">-</span>
<span class="p_del">-	\renewcommand*{\DUrole}[2]{ #2 }</span>
<span class="p_del">-</span>
 Contents:
 
 .. toctree::
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index c9ce897465c5..ae42a0aaab06 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 9
<span class="p_del">-SUBLEVEL = 2</span>
<span class="p_add">+SUBLEVEL = 3</span>
 EXTRAVERSION =
 NAME = Roaring Lionus
 
<span class="p_header">diff --git a/arch/arm/boot/dts/r8a7794.dtsi b/arch/arm/boot/dts/r8a7794.dtsi</span>
<span class="p_header">index 9365580a194f..725ecb3c5fb4 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/r8a7794.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/r8a7794.dtsi</span>
<span class="p_chunk">@@ -1260,7 +1260,7 @@</span> <span class="p_context"></span>
 		mstp7_clks: mstp7_clks@e615014c {
 			compatible = &quot;renesas,r8a7794-mstp-clocks&quot;, &quot;renesas,cpg-mstp-clocks&quot;;
 			reg = &lt;0 0xe615014c 0 4&gt;, &lt;0 0xe61501c4 0 4&gt;;
<span class="p_del">-			clocks = &lt;&amp;mp_clk&gt;, &lt;&amp;mp_clk&gt;,</span>
<span class="p_add">+			clocks = &lt;&amp;mp_clk&gt;, &lt;&amp;hp_clk&gt;,</span>
 				 &lt;&amp;zs_clk&gt;, &lt;&amp;p_clk&gt;, &lt;&amp;p_clk&gt;, &lt;&amp;zs_clk&gt;,
 				 &lt;&amp;zs_clk&gt;, &lt;&amp;p_clk&gt;, &lt;&amp;p_clk&gt;, &lt;&amp;p_clk&gt;, &lt;&amp;p_clk&gt;,
 				 &lt;&amp;zx_clk&gt;;
<span class="p_header">diff --git a/arch/arm/boot/dts/sun7i-a20-bananapi-m1-plus.dts b/arch/arm/boot/dts/sun7i-a20-bananapi-m1-plus.dts</span>
<span class="p_header">index ba5bca0fe997..44377a98cc89 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/sun7i-a20-bananapi-m1-plus.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/sun7i-a20-bananapi-m1-plus.dts</span>
<span class="p_chunk">@@ -227,3 +227,8 @@</span> <span class="p_context"></span>
 	pinctrl-0 = &lt;&amp;uart0_pins_a&gt;;
 	status = &quot;okay&quot;;
 };
<span class="p_add">+</span>
<span class="p_add">+&amp;usbphy {</span>
<span class="p_add">+	/* VBUS on usb host ports are tied to DC5V and therefore always on */</span>
<span class="p_add">+	status = &quot;okay&quot;;</span>
<span class="p_add">+};</span>
<span class="p_header">diff --git a/arch/arm/crypto/aes-ce-glue.c b/arch/arm/crypto/aes-ce-glue.c</span>
<span class="p_header">index aef022a87c53..04410d9f5e72 100644</span>
<span class="p_header">--- a/arch/arm/crypto/aes-ce-glue.c</span>
<span class="p_header">+++ b/arch/arm/crypto/aes-ce-glue.c</span>
<span class="p_chunk">@@ -88,8 +88,13 @@</span> <span class="p_context"> static int ce_aes_expandkey(struct crypto_aes_ctx *ctx, const u8 *in_key,</span>
 		u32 *rki = ctx-&gt;key_enc + (i * kwords);
 		u32 *rko = rki + kwords;
 
<span class="p_add">+#ifndef CONFIG_CPU_BIG_ENDIAN</span>
 		rko[0] = ror32(ce_aes_sub(rki[kwords - 1]), 8);
 		rko[0] = rko[0] ^ rki[0] ^ rcon[i];
<span class="p_add">+#else</span>
<span class="p_add">+		rko[0] = rol32(ce_aes_sub(rki[kwords - 1]), 8);</span>
<span class="p_add">+		rko[0] = rko[0] ^ rki[0] ^ (rcon[i] &lt;&lt; 24);</span>
<span class="p_add">+#endif</span>
 		rko[1] = rko[0] ^ rki[1];
 		rko[2] = rko[1] ^ rki[2];
 		rko[3] = rko[2] ^ rki[3];
<span class="p_header">diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c</span>
<span class="p_header">index ed3d0e9f72ac..d7a43afdfac0 100644</span>
<span class="p_header">--- a/arch/arm/mach-davinci/da850.c</span>
<span class="p_header">+++ b/arch/arm/mach-davinci/da850.c</span>
<span class="p_chunk">@@ -319,6 +319,16 @@</span> <span class="p_context"> static struct clk emac_clk = {</span>
 	.gpsc		= 1,
 };
 
<span class="p_add">+/*</span>
<span class="p_add">+ * In order to avoid adding the emac_clk to the clock lookup table twice (and</span>
<span class="p_add">+ * screwing up the linked list in the process) create a separate clock for</span>
<span class="p_add">+ * mdio inheriting the rate from emac_clk.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static struct clk mdio_clk = {</span>
<span class="p_add">+	.name		= &quot;mdio&quot;,</span>
<span class="p_add">+	.parent		= &amp;emac_clk,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static struct clk mcasp_clk = {
 	.name		= &quot;mcasp&quot;,
 	.parent		= &amp;async3_clk,
<span class="p_chunk">@@ -494,7 +504,7 @@</span> <span class="p_context"> static struct clk_lookup da850_clks[] = {</span>
 	CLK(NULL,		&quot;arm&quot;,		&amp;arm_clk),
 	CLK(NULL,		&quot;rmii&quot;,		&amp;rmii_clk),
 	CLK(&quot;davinci_emac.1&quot;,	NULL,		&amp;emac_clk),
<span class="p_del">-	CLK(&quot;davinci_mdio.0&quot;,	&quot;fck&quot;,		&amp;emac_clk),</span>
<span class="p_add">+	CLK(&quot;davinci_mdio.0&quot;,	&quot;fck&quot;,		&amp;mdio_clk),</span>
 	CLK(&quot;davinci-mcasp.0&quot;,	NULL,		&amp;mcasp_clk),
 	CLK(&quot;davinci-mcbsp.0&quot;,	NULL,		&amp;mcbsp0_clk),
 	CLK(&quot;davinci-mcbsp.1&quot;,	NULL,		&amp;mcbsp1_clk),
<span class="p_header">diff --git a/arch/arm64/boot/dts/hisilicon/hip06.dtsi b/arch/arm64/boot/dts/hisilicon/hip06.dtsi</span>
<span class="p_header">index b548763366dd..af450413b9dd 100644</span>
<span class="p_header">--- a/arch/arm64/boot/dts/hisilicon/hip06.dtsi</span>
<span class="p_header">+++ b/arch/arm64/boot/dts/hisilicon/hip06.dtsi</span>
<span class="p_chunk">@@ -322,7 +322,7 @@</span> <span class="p_context"></span>
 			compatible = &quot;generic-ohci&quot;;
 			reg = &lt;0x0 0xa7030000 0x0 0x10000&gt;;
 			interrupt-parent = &lt;&amp;mbigen_usb&gt;;
<span class="p_del">-			interrupts = &lt;64 4&gt;;</span>
<span class="p_add">+			interrupts = &lt;640 4&gt;;</span>
 			dma-coherent;
 			status = &quot;disabled&quot;;
 		};
<span class="p_chunk">@@ -331,7 +331,7 @@</span> <span class="p_context"></span>
 			compatible = &quot;generic-ehci&quot;;
 			reg = &lt;0x0 0xa7020000 0x0 0x10000&gt;;
 			interrupt-parent = &lt;&amp;mbigen_usb&gt;;
<span class="p_del">-			interrupts = &lt;65 4&gt;;</span>
<span class="p_add">+			interrupts = &lt;641 4&gt;;</span>
 			dma-coherent;
 			status = &quot;disabled&quot;;
 		};
<span class="p_header">diff --git a/arch/arm64/crypto/aes-ce-ccm-core.S b/arch/arm64/crypto/aes-ce-ccm-core.S</span>
<span class="p_header">index a2a7fbcacc14..3363560c79b7 100644</span>
<span class="p_header">--- a/arch/arm64/crypto/aes-ce-ccm-core.S</span>
<span class="p_header">+++ b/arch/arm64/crypto/aes-ce-ccm-core.S</span>
<span class="p_chunk">@@ -9,6 +9,7 @@</span> <span class="p_context"></span>
  */
 
 #include &lt;linux/linkage.h&gt;
<span class="p_add">+#include &lt;asm/assembler.h&gt;</span>
 
 	.text
 	.arch	armv8-a+crypto
<span class="p_chunk">@@ -19,7 +20,7 @@</span> <span class="p_context"></span>
 	 */
 ENTRY(ce_aes_ccm_auth_data)
 	ldr	w8, [x3]			/* leftover from prev round? */
<span class="p_del">-	ld1	{v0.2d}, [x0]			/* load mac */</span>
<span class="p_add">+	ld1	{v0.16b}, [x0]			/* load mac */</span>
 	cbz	w8, 1f
 	sub	w8, w8, #16
 	eor	v1.16b, v1.16b, v1.16b
<span class="p_chunk">@@ -31,7 +32,7 @@</span> <span class="p_context"> ENTRY(ce_aes_ccm_auth_data)</span>
 	beq	8f				/* out of input? */
 	cbnz	w8, 0b
 	eor	v0.16b, v0.16b, v1.16b
<span class="p_del">-1:	ld1	{v3.2d}, [x4]			/* load first round key */</span>
<span class="p_add">+1:	ld1	{v3.16b}, [x4]			/* load first round key */</span>
 	prfm	pldl1strm, [x1]
 	cmp	w5, #12				/* which key size? */
 	add	x6, x4, #16
<span class="p_chunk">@@ -41,17 +42,17 @@</span> <span class="p_context"> ENTRY(ce_aes_ccm_auth_data)</span>
 	mov	v5.16b, v3.16b
 	b	4f
 2:	mov	v4.16b, v3.16b
<span class="p_del">-	ld1	{v5.2d}, [x6], #16		/* load 2nd round key */</span>
<span class="p_add">+	ld1	{v5.16b}, [x6], #16		/* load 2nd round key */</span>
 3:	aese	v0.16b, v4.16b
 	aesmc	v0.16b, v0.16b
<span class="p_del">-4:	ld1	{v3.2d}, [x6], #16		/* load next round key */</span>
<span class="p_add">+4:	ld1	{v3.16b}, [x6], #16		/* load next round key */</span>
 	aese	v0.16b, v5.16b
 	aesmc	v0.16b, v0.16b
<span class="p_del">-5:	ld1	{v4.2d}, [x6], #16		/* load next round key */</span>
<span class="p_add">+5:	ld1	{v4.16b}, [x6], #16		/* load next round key */</span>
 	subs	w7, w7, #3
 	aese	v0.16b, v3.16b
 	aesmc	v0.16b, v0.16b
<span class="p_del">-	ld1	{v5.2d}, [x6], #16		/* load next round key */</span>
<span class="p_add">+	ld1	{v5.16b}, [x6], #16		/* load next round key */</span>
 	bpl	3b
 	aese	v0.16b, v4.16b
 	subs	w2, w2, #16			/* last data? */
<span class="p_chunk">@@ -60,7 +61,7 @@</span> <span class="p_context"> ENTRY(ce_aes_ccm_auth_data)</span>
 	ld1	{v1.16b}, [x1], #16		/* load next input block */
 	eor	v0.16b, v0.16b, v1.16b		/* xor with mac */
 	bne	1b
<span class="p_del">-6:	st1	{v0.2d}, [x0]			/* store mac */</span>
<span class="p_add">+6:	st1	{v0.16b}, [x0]			/* store mac */</span>
 	beq	10f
 	adds	w2, w2, #16
 	beq	10f
<span class="p_chunk">@@ -79,7 +80,7 @@</span> <span class="p_context"> ENTRY(ce_aes_ccm_auth_data)</span>
 	adds	w7, w7, #1
 	bne	9b
 	eor	v0.16b, v0.16b, v1.16b
<span class="p_del">-	st1	{v0.2d}, [x0]</span>
<span class="p_add">+	st1	{v0.16b}, [x0]</span>
 10:	str	w8, [x3]
 	ret
 ENDPROC(ce_aes_ccm_auth_data)
<span class="p_chunk">@@ -89,27 +90,27 @@</span> <span class="p_context"> ENDPROC(ce_aes_ccm_auth_data)</span>
 	 * 			 u32 rounds);
 	 */
 ENTRY(ce_aes_ccm_final)
<span class="p_del">-	ld1	{v3.2d}, [x2], #16		/* load first round key */</span>
<span class="p_del">-	ld1	{v0.2d}, [x0]			/* load mac */</span>
<span class="p_add">+	ld1	{v3.16b}, [x2], #16		/* load first round key */</span>
<span class="p_add">+	ld1	{v0.16b}, [x0]			/* load mac */</span>
 	cmp	w3, #12				/* which key size? */
 	sub	w3, w3, #2			/* modified # of rounds */
<span class="p_del">-	ld1	{v1.2d}, [x1]			/* load 1st ctriv */</span>
<span class="p_add">+	ld1	{v1.16b}, [x1]			/* load 1st ctriv */</span>
 	bmi	0f
 	bne	3f
 	mov	v5.16b, v3.16b
 	b	2f
 0:	mov	v4.16b, v3.16b
<span class="p_del">-1:	ld1	{v5.2d}, [x2], #16		/* load next round key */</span>
<span class="p_add">+1:	ld1	{v5.16b}, [x2], #16		/* load next round key */</span>
 	aese	v0.16b, v4.16b
 	aesmc	v0.16b, v0.16b
 	aese	v1.16b, v4.16b
 	aesmc	v1.16b, v1.16b
<span class="p_del">-2:	ld1	{v3.2d}, [x2], #16		/* load next round key */</span>
<span class="p_add">+2:	ld1	{v3.16b}, [x2], #16		/* load next round key */</span>
 	aese	v0.16b, v5.16b
 	aesmc	v0.16b, v0.16b
 	aese	v1.16b, v5.16b
 	aesmc	v1.16b, v1.16b
<span class="p_del">-3:	ld1	{v4.2d}, [x2], #16		/* load next round key */</span>
<span class="p_add">+3:	ld1	{v4.16b}, [x2], #16		/* load next round key */</span>
 	subs	w3, w3, #3
 	aese	v0.16b, v3.16b
 	aesmc	v0.16b, v0.16b
<span class="p_chunk">@@ -120,47 +121,47 @@</span> <span class="p_context"> ENTRY(ce_aes_ccm_final)</span>
 	aese	v1.16b, v4.16b
 	/* final round key cancels out */
 	eor	v0.16b, v0.16b, v1.16b		/* en-/decrypt the mac */
<span class="p_del">-	st1	{v0.2d}, [x0]			/* store result */</span>
<span class="p_add">+	st1	{v0.16b}, [x0]			/* store result */</span>
 	ret
 ENDPROC(ce_aes_ccm_final)
 
 	.macro	aes_ccm_do_crypt,enc
 	ldr	x8, [x6, #8]			/* load lower ctr */
<span class="p_del">-	ld1	{v0.2d}, [x5]			/* load mac */</span>
<span class="p_del">-	rev	x8, x8				/* keep swabbed ctr in reg */</span>
<span class="p_add">+	ld1	{v0.16b}, [x5]			/* load mac */</span>
<span class="p_add">+CPU_LE(	rev	x8, x8			)	/* keep swabbed ctr in reg */</span>
 0:	/* outer loop */
<span class="p_del">-	ld1	{v1.1d}, [x6]			/* load upper ctr */</span>
<span class="p_add">+	ld1	{v1.8b}, [x6]			/* load upper ctr */</span>
 	prfm	pldl1strm, [x1]
 	add	x8, x8, #1
 	rev	x9, x8
 	cmp	w4, #12				/* which key size? */
 	sub	w7, w4, #2			/* get modified # of rounds */
 	ins	v1.d[1], x9			/* no carry in lower ctr */
<span class="p_del">-	ld1	{v3.2d}, [x3]			/* load first round key */</span>
<span class="p_add">+	ld1	{v3.16b}, [x3]			/* load first round key */</span>
 	add	x10, x3, #16
 	bmi	1f
 	bne	4f
 	mov	v5.16b, v3.16b
 	b	3f
 1:	mov	v4.16b, v3.16b
<span class="p_del">-	ld1	{v5.2d}, [x10], #16		/* load 2nd round key */</span>
<span class="p_add">+	ld1	{v5.16b}, [x10], #16		/* load 2nd round key */</span>
 2:	/* inner loop: 3 rounds, 2x interleaved */
 	aese	v0.16b, v4.16b
 	aesmc	v0.16b, v0.16b
 	aese	v1.16b, v4.16b
 	aesmc	v1.16b, v1.16b
<span class="p_del">-3:	ld1	{v3.2d}, [x10], #16		/* load next round key */</span>
<span class="p_add">+3:	ld1	{v3.16b}, [x10], #16		/* load next round key */</span>
 	aese	v0.16b, v5.16b
 	aesmc	v0.16b, v0.16b
 	aese	v1.16b, v5.16b
 	aesmc	v1.16b, v1.16b
<span class="p_del">-4:	ld1	{v4.2d}, [x10], #16		/* load next round key */</span>
<span class="p_add">+4:	ld1	{v4.16b}, [x10], #16		/* load next round key */</span>
 	subs	w7, w7, #3
 	aese	v0.16b, v3.16b
 	aesmc	v0.16b, v0.16b
 	aese	v1.16b, v3.16b
 	aesmc	v1.16b, v1.16b
<span class="p_del">-	ld1	{v5.2d}, [x10], #16		/* load next round key */</span>
<span class="p_add">+	ld1	{v5.16b}, [x10], #16		/* load next round key */</span>
 	bpl	2b
 	aese	v0.16b, v4.16b
 	aese	v1.16b, v4.16b
<span class="p_chunk">@@ -177,14 +178,14 @@</span> <span class="p_context"> ENDPROC(ce_aes_ccm_final)</span>
 	eor	v0.16b, v0.16b, v2.16b		/* xor mac with pt ^ rk[last] */
 	st1	{v1.16b}, [x0], #16		/* write output block */
 	bne	0b
<span class="p_del">-	rev	x8, x8</span>
<span class="p_del">-	st1	{v0.2d}, [x5]			/* store mac */</span>
<span class="p_add">+CPU_LE(	rev	x8, x8			)</span>
<span class="p_add">+	st1	{v0.16b}, [x5]			/* store mac */</span>
 	str	x8, [x6, #8]			/* store lsb end of ctr (BE) */
 5:	ret
 
 6:	eor	v0.16b, v0.16b, v5.16b		/* final round mac */
 	eor	v1.16b, v1.16b, v5.16b		/* final round enc */
<span class="p_del">-	st1	{v0.2d}, [x5]			/* store mac */</span>
<span class="p_add">+	st1	{v0.16b}, [x5]			/* store mac */</span>
 	add	w2, w2, #16			/* process partial tail block */
 7:	ldrb	w9, [x1], #1			/* get 1 byte of input */
 	umov	w6, v1.b[0]			/* get top crypted ctr byte */
<span class="p_header">diff --git a/arch/arm64/crypto/aes-ce-cipher.c b/arch/arm64/crypto/aes-ce-cipher.c</span>
<span class="p_header">index f7bd9bf0bbb3..50d9fe11d0c8 100644</span>
<span class="p_header">--- a/arch/arm64/crypto/aes-ce-cipher.c</span>
<span class="p_header">+++ b/arch/arm64/crypto/aes-ce-cipher.c</span>
<span class="p_chunk">@@ -47,24 +47,24 @@</span> <span class="p_context"> static void aes_cipher_encrypt(struct crypto_tfm *tfm, u8 dst[], u8 const src[])</span>
 	kernel_neon_begin_partial(4);
 
 	__asm__(&quot;	ld1	{v0.16b}, %[in]			;&quot;
<span class="p_del">-		&quot;	ld1	{v1.2d}, [%[key]], #16		;&quot;</span>
<span class="p_add">+		&quot;	ld1	{v1.16b}, [%[key]], #16		;&quot;</span>
 		&quot;	cmp	%w[rounds], #10			;&quot;
 		&quot;	bmi	0f				;&quot;
 		&quot;	bne	3f				;&quot;
 		&quot;	mov	v3.16b, v1.16b			;&quot;
 		&quot;	b	2f				;&quot;
 		&quot;0:	mov	v2.16b, v1.16b			;&quot;
<span class="p_del">-		&quot;	ld1	{v3.2d}, [%[key]], #16		;&quot;</span>
<span class="p_add">+		&quot;	ld1	{v3.16b}, [%[key]], #16		;&quot;</span>
 		&quot;1:	aese	v0.16b, v2.16b			;&quot;
 		&quot;	aesmc	v0.16b, v0.16b			;&quot;
<span class="p_del">-		&quot;2:	ld1	{v1.2d}, [%[key]], #16		;&quot;</span>
<span class="p_add">+		&quot;2:	ld1	{v1.16b}, [%[key]], #16		;&quot;</span>
 		&quot;	aese	v0.16b, v3.16b			;&quot;
 		&quot;	aesmc	v0.16b, v0.16b			;&quot;
<span class="p_del">-		&quot;3:	ld1	{v2.2d}, [%[key]], #16		;&quot;</span>
<span class="p_add">+		&quot;3:	ld1	{v2.16b}, [%[key]], #16		;&quot;</span>
 		&quot;	subs	%w[rounds], %w[rounds], #3	;&quot;
 		&quot;	aese	v0.16b, v1.16b			;&quot;
 		&quot;	aesmc	v0.16b, v0.16b			;&quot;
<span class="p_del">-		&quot;	ld1	{v3.2d}, [%[key]], #16		;&quot;</span>
<span class="p_add">+		&quot;	ld1	{v3.16b}, [%[key]], #16		;&quot;</span>
 		&quot;	bpl	1b				;&quot;
 		&quot;	aese	v0.16b, v2.16b			;&quot;
 		&quot;	eor	v0.16b, v0.16b, v3.16b		;&quot;
<span class="p_chunk">@@ -92,24 +92,24 @@</span> <span class="p_context"> static void aes_cipher_decrypt(struct crypto_tfm *tfm, u8 dst[], u8 const src[])</span>
 	kernel_neon_begin_partial(4);
 
 	__asm__(&quot;	ld1	{v0.16b}, %[in]			;&quot;
<span class="p_del">-		&quot;	ld1	{v1.2d}, [%[key]], #16		;&quot;</span>
<span class="p_add">+		&quot;	ld1	{v1.16b}, [%[key]], #16		;&quot;</span>
 		&quot;	cmp	%w[rounds], #10			;&quot;
 		&quot;	bmi	0f				;&quot;
 		&quot;	bne	3f				;&quot;
 		&quot;	mov	v3.16b, v1.16b			;&quot;
 		&quot;	b	2f				;&quot;
 		&quot;0:	mov	v2.16b, v1.16b			;&quot;
<span class="p_del">-		&quot;	ld1	{v3.2d}, [%[key]], #16		;&quot;</span>
<span class="p_add">+		&quot;	ld1	{v3.16b}, [%[key]], #16		;&quot;</span>
 		&quot;1:	aesd	v0.16b, v2.16b			;&quot;
 		&quot;	aesimc	v0.16b, v0.16b			;&quot;
<span class="p_del">-		&quot;2:	ld1	{v1.2d}, [%[key]], #16		;&quot;</span>
<span class="p_add">+		&quot;2:	ld1	{v1.16b}, [%[key]], #16		;&quot;</span>
 		&quot;	aesd	v0.16b, v3.16b			;&quot;
 		&quot;	aesimc	v0.16b, v0.16b			;&quot;
<span class="p_del">-		&quot;3:	ld1	{v2.2d}, [%[key]], #16		;&quot;</span>
<span class="p_add">+		&quot;3:	ld1	{v2.16b}, [%[key]], #16		;&quot;</span>
 		&quot;	subs	%w[rounds], %w[rounds], #3	;&quot;
 		&quot;	aesd	v0.16b, v1.16b			;&quot;
 		&quot;	aesimc	v0.16b, v0.16b			;&quot;
<span class="p_del">-		&quot;	ld1	{v3.2d}, [%[key]], #16		;&quot;</span>
<span class="p_add">+		&quot;	ld1	{v3.16b}, [%[key]], #16		;&quot;</span>
 		&quot;	bpl	1b				;&quot;
 		&quot;	aesd	v0.16b, v2.16b			;&quot;
 		&quot;	eor	v0.16b, v0.16b, v3.16b		;&quot;
<span class="p_chunk">@@ -173,7 +173,12 @@</span> <span class="p_context"> int ce_aes_expandkey(struct crypto_aes_ctx *ctx, const u8 *in_key,</span>
 		u32 *rki = ctx-&gt;key_enc + (i * kwords);
 		u32 *rko = rki + kwords;
 
<span class="p_add">+#ifndef CONFIG_CPU_BIG_ENDIAN</span>
 		rko[0] = ror32(aes_sub(rki[kwords - 1]), 8) ^ rcon[i] ^ rki[0];
<span class="p_add">+#else</span>
<span class="p_add">+		rko[0] = rol32(aes_sub(rki[kwords - 1]), 8) ^ (rcon[i] &lt;&lt; 24) ^</span>
<span class="p_add">+			 rki[0];</span>
<span class="p_add">+#endif</span>
 		rko[1] = rko[0] ^ rki[1];
 		rko[2] = rko[1] ^ rki[2];
 		rko[3] = rko[2] ^ rki[3];
<span class="p_header">diff --git a/arch/arm64/crypto/aes-ce.S b/arch/arm64/crypto/aes-ce.S</span>
<span class="p_header">index 78f3cfe92c08..b46093d567e5 100644</span>
<span class="p_header">--- a/arch/arm64/crypto/aes-ce.S</span>
<span class="p_header">+++ b/arch/arm64/crypto/aes-ce.S</span>
<span class="p_chunk">@@ -10,6 +10,7 @@</span> <span class="p_context"></span>
  */
 
 #include &lt;linux/linkage.h&gt;
<span class="p_add">+#include &lt;asm/assembler.h&gt;</span>
 
 #define AES_ENTRY(func)		ENTRY(ce_ ## func)
 #define AES_ENDPROC(func)	ENDPROC(ce_ ## func)
<span class="p_header">diff --git a/arch/arm64/crypto/aes-modes.S b/arch/arm64/crypto/aes-modes.S</span>
<span class="p_header">index f6e372c528eb..c53dbeae79f2 100644</span>
<span class="p_header">--- a/arch/arm64/crypto/aes-modes.S</span>
<span class="p_header">+++ b/arch/arm64/crypto/aes-modes.S</span>
<span class="p_chunk">@@ -386,7 +386,8 @@</span> <span class="p_context"> AES_ENDPROC(aes_ctr_encrypt)</span>
 	.endm
 
 .Lxts_mul_x:
<span class="p_del">-	.word		1, 0, 0x87, 0</span>
<span class="p_add">+CPU_LE(	.quad		1, 0x87		)</span>
<span class="p_add">+CPU_BE(	.quad		0x87, 1		)</span>
 
 AES_ENTRY(aes_xts_encrypt)
 	FRAME_PUSH
<span class="p_header">diff --git a/arch/arm64/crypto/aes-neon.S b/arch/arm64/crypto/aes-neon.S</span>
<span class="p_header">index b93170e1cc93..85f07ead7c5c 100644</span>
<span class="p_header">--- a/arch/arm64/crypto/aes-neon.S</span>
<span class="p_header">+++ b/arch/arm64/crypto/aes-neon.S</span>
<span class="p_chunk">@@ -9,6 +9,7 @@</span> <span class="p_context"></span>
  */
 
 #include &lt;linux/linkage.h&gt;
<span class="p_add">+#include &lt;asm/assembler.h&gt;</span>
 
 #define AES_ENTRY(func)		ENTRY(neon_ ## func)
 #define AES_ENDPROC(func)	ENDPROC(neon_ ## func)
<span class="p_chunk">@@ -83,13 +84,13 @@</span> <span class="p_context"></span>
 	.endm
 
 	.macro		do_block, enc, in, rounds, rk, rkp, i
<span class="p_del">-	ld1		{v15.16b}, [\rk]</span>
<span class="p_add">+	ld1		{v15.4s}, [\rk]</span>
 	add		\rkp, \rk, #16
 	mov		\i, \rounds
 1111:	eor		\in\().16b, \in\().16b, v15.16b		/* ^round key */
 	tbl		\in\().16b, {\in\().16b}, v13.16b	/* ShiftRows */
 	sub_bytes	\in
<span class="p_del">-	ld1		{v15.16b}, [\rkp], #16</span>
<span class="p_add">+	ld1		{v15.4s}, [\rkp], #16</span>
 	subs		\i, \i, #1
 	beq		2222f
 	.if		\enc == 1
<span class="p_chunk">@@ -229,7 +230,7 @@</span> <span class="p_context"></span>
 	.endm
 
 	.macro		do_block_2x, enc, in0, in1 rounds, rk, rkp, i
<span class="p_del">-	ld1		{v15.16b}, [\rk]</span>
<span class="p_add">+	ld1		{v15.4s}, [\rk]</span>
 	add		\rkp, \rk, #16
 	mov		\i, \rounds
 1111:	eor		\in0\().16b, \in0\().16b, v15.16b	/* ^round key */
<span class="p_chunk">@@ -237,7 +238,7 @@</span> <span class="p_context"></span>
 	sub_bytes_2x	\in0, \in1
 	tbl		\in0\().16b, {\in0\().16b}, v13.16b	/* ShiftRows */
 	tbl		\in1\().16b, {\in1\().16b}, v13.16b	/* ShiftRows */
<span class="p_del">-	ld1		{v15.16b}, [\rkp], #16</span>
<span class="p_add">+	ld1		{v15.4s}, [\rkp], #16</span>
 	subs		\i, \i, #1
 	beq		2222f
 	.if		\enc == 1
<span class="p_chunk">@@ -254,7 +255,7 @@</span> <span class="p_context"></span>
 	.endm
 
 	.macro		do_block_4x, enc, in0, in1, in2, in3, rounds, rk, rkp, i
<span class="p_del">-	ld1		{v15.16b}, [\rk]</span>
<span class="p_add">+	ld1		{v15.4s}, [\rk]</span>
 	add		\rkp, \rk, #16
 	mov		\i, \rounds
 1111:	eor		\in0\().16b, \in0\().16b, v15.16b	/* ^round key */
<span class="p_chunk">@@ -266,7 +267,7 @@</span> <span class="p_context"></span>
 	tbl		\in1\().16b, {\in1\().16b}, v13.16b	/* ShiftRows */
 	tbl		\in2\().16b, {\in2\().16b}, v13.16b	/* ShiftRows */
 	tbl		\in3\().16b, {\in3\().16b}, v13.16b	/* ShiftRows */
<span class="p_del">-	ld1		{v15.16b}, [\rkp], #16</span>
<span class="p_add">+	ld1		{v15.4s}, [\rkp], #16</span>
 	subs		\i, \i, #1
 	beq		2222f
 	.if		\enc == 1
<span class="p_chunk">@@ -306,12 +307,16 @@</span> <span class="p_context"></span>
 	.text
 	.align		4
 .LForward_ShiftRows:
<span class="p_del">-	.byte		0x0, 0x5, 0xa, 0xf, 0x4, 0x9, 0xe, 0x3</span>
<span class="p_del">-	.byte		0x8, 0xd, 0x2, 0x7, 0xc, 0x1, 0x6, 0xb</span>
<span class="p_add">+CPU_LE(	.byte		0x0, 0x5, 0xa, 0xf, 0x4, 0x9, 0xe, 0x3	)</span>
<span class="p_add">+CPU_LE(	.byte		0x8, 0xd, 0x2, 0x7, 0xc, 0x1, 0x6, 0xb	)</span>
<span class="p_add">+CPU_BE(	.byte		0xb, 0x6, 0x1, 0xc, 0x7, 0x2, 0xd, 0x8	)</span>
<span class="p_add">+CPU_BE(	.byte		0x3, 0xe, 0x9, 0x4, 0xf, 0xa, 0x5, 0x0	)</span>
 
 .LReverse_ShiftRows:
<span class="p_del">-	.byte		0x0, 0xd, 0xa, 0x7, 0x4, 0x1, 0xe, 0xb</span>
<span class="p_del">-	.byte		0x8, 0x5, 0x2, 0xf, 0xc, 0x9, 0x6, 0x3</span>
<span class="p_add">+CPU_LE(	.byte		0x0, 0xd, 0xa, 0x7, 0x4, 0x1, 0xe, 0xb	)</span>
<span class="p_add">+CPU_LE(	.byte		0x8, 0x5, 0x2, 0xf, 0xc, 0x9, 0x6, 0x3	)</span>
<span class="p_add">+CPU_BE(	.byte		0x3, 0x6, 0x9, 0xc, 0xf, 0x2, 0x5, 0x8	)</span>
<span class="p_add">+CPU_BE(	.byte		0xb, 0xe, 0x1, 0x4, 0x7, 0xa, 0xd, 0x0	)</span>
 
 .LForward_Sbox:
 	.byte		0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5
<span class="p_header">diff --git a/arch/arm64/crypto/ghash-ce-core.S b/arch/arm64/crypto/ghash-ce-core.S</span>
<span class="p_header">index dc457015884e..f0bb9f0b524f 100644</span>
<span class="p_header">--- a/arch/arm64/crypto/ghash-ce-core.S</span>
<span class="p_header">+++ b/arch/arm64/crypto/ghash-ce-core.S</span>
<span class="p_chunk">@@ -29,8 +29,8 @@</span> <span class="p_context"></span>
 	 *			   struct ghash_key const *k, const char *head)
 	 */
 ENTRY(pmull_ghash_update)
<span class="p_del">-	ld1		{SHASH.16b}, [x3]</span>
<span class="p_del">-	ld1		{XL.16b}, [x1]</span>
<span class="p_add">+	ld1		{SHASH.2d}, [x3]</span>
<span class="p_add">+	ld1		{XL.2d}, [x1]</span>
 	movi		MASK.16b, #0xe1
 	ext		SHASH2.16b, SHASH.16b, SHASH.16b, #8
 	shl		MASK.2d, MASK.2d, #57
<span class="p_chunk">@@ -74,6 +74,6 @@</span> <span class="p_context"> CPU_LE(	rev64		T1.16b, T1.16b	)</span>
 
 	cbnz		w0, 0b
 
<span class="p_del">-	st1		{XL.16b}, [x1]</span>
<span class="p_add">+	st1		{XL.2d}, [x1]</span>
 	ret
 ENDPROC(pmull_ghash_update)
<span class="p_header">diff --git a/arch/arm64/crypto/sha1-ce-core.S b/arch/arm64/crypto/sha1-ce-core.S</span>
<span class="p_header">index 033aae6d732a..c98e7e849f06 100644</span>
<span class="p_header">--- a/arch/arm64/crypto/sha1-ce-core.S</span>
<span class="p_header">+++ b/arch/arm64/crypto/sha1-ce-core.S</span>
<span class="p_chunk">@@ -78,7 +78,7 @@</span> <span class="p_context"> ENTRY(sha1_ce_transform)</span>
 	ld1r		{k3.4s}, [x6]
 
 	/* load state */
<span class="p_del">-	ldr		dga, [x0]</span>
<span class="p_add">+	ld1		{dgav.4s}, [x0]</span>
 	ldr		dgb, [x0, #16]
 
 	/* load sha1_ce_state::finalize */
<span class="p_chunk">@@ -144,7 +144,7 @@</span> <span class="p_context"> CPU_LE(	rev32		v11.16b, v11.16b	)</span>
 	b		1b
 
 	/* store new state */
<span class="p_del">-3:	str		dga, [x0]</span>
<span class="p_add">+3:	st1		{dgav.4s}, [x0]</span>
 	str		dgb, [x0, #16]
 	ret
 ENDPROC(sha1_ce_transform)
<span class="p_header">diff --git a/arch/arm64/crypto/sha2-ce-core.S b/arch/arm64/crypto/sha2-ce-core.S</span>
<span class="p_header">index 5df9d9d470ad..01cfee066837 100644</span>
<span class="p_header">--- a/arch/arm64/crypto/sha2-ce-core.S</span>
<span class="p_header">+++ b/arch/arm64/crypto/sha2-ce-core.S</span>
<span class="p_chunk">@@ -85,7 +85,7 @@</span> <span class="p_context"> ENTRY(sha2_ce_transform)</span>
 	ld1		{v12.4s-v15.4s}, [x8]
 
 	/* load state */
<span class="p_del">-	ldp		dga, dgb, [x0]</span>
<span class="p_add">+	ld1		{dgav.4s, dgbv.4s}, [x0]</span>
 
 	/* load sha256_ce_state::finalize */
 	ldr		w4, [x0, #:lo12:sha256_ce_offsetof_finalize]
<span class="p_chunk">@@ -148,6 +148,6 @@</span> <span class="p_context"> CPU_LE(	rev32		v19.16b, v19.16b	)</span>
 	b		1b
 
 	/* store new state */
<span class="p_del">-3:	stp		dga, dgb, [x0]</span>
<span class="p_add">+3:	st1		{dgav.4s, dgbv.4s}, [x0]</span>
 	ret
 ENDPROC(sha2_ce_transform)
<span class="p_header">diff --git a/arch/cris/boot/rescue/Makefile b/arch/cris/boot/rescue/Makefile</span>
<span class="p_header">index 52bd0bd1dd22..d98edbb30a18 100644</span>
<span class="p_header">--- a/arch/cris/boot/rescue/Makefile</span>
<span class="p_header">+++ b/arch/cris/boot/rescue/Makefile</span>
<span class="p_chunk">@@ -10,6 +10,9 @@</span> <span class="p_context"></span>
 
 asflags-y += $(LINUXINCLUDE)
 ccflags-y += -O2 $(LINUXINCLUDE)
<span class="p_add">+</span>
<span class="p_add">+ifdef CONFIG_ETRAX_AXISFLASHMAP</span>
<span class="p_add">+</span>
 arch-$(CONFIG_ETRAX_ARCH_V10) = v10
 arch-$(CONFIG_ETRAX_ARCH_V32) = v32
 
<span class="p_chunk">@@ -28,6 +31,11 @@</span> <span class="p_context"> $(obj)/rescue.bin: $(obj)/rescue.o FORCE</span>
 	$(call if_changed,objcopy)
 	cp -p $(obj)/rescue.bin $(objtree)
 
<span class="p_add">+else</span>
<span class="p_add">+$(obj)/rescue.bin:</span>
<span class="p_add">+</span>
<span class="p_add">+endif</span>
<span class="p_add">+</span>
 $(obj)/testrescue.bin: $(obj)/testrescue.o
 	$(OBJCOPY) $(OBJCOPYFLAGS) $(obj)/testrescue.o tr.bin
 # Pad it to 784 bytes
<span class="p_header">diff --git a/arch/mips/kvm/entry.c b/arch/mips/kvm/entry.c</span>
<span class="p_header">index 6a02b3a3fa65..e92fb190e2d6 100644</span>
<span class="p_header">--- a/arch/mips/kvm/entry.c</span>
<span class="p_header">+++ b/arch/mips/kvm/entry.c</span>
<span class="p_chunk">@@ -521,6 +521,9 @@</span> <span class="p_context"> void *kvm_mips_build_exit(void *addr)</span>
 	uasm_i_and(&amp;p, V0, V0, AT);
 	uasm_i_lui(&amp;p, AT, ST0_CU0 &gt;&gt; 16);
 	uasm_i_or(&amp;p, V0, V0, AT);
<span class="p_add">+#ifdef CONFIG_64BIT</span>
<span class="p_add">+	uasm_i_ori(&amp;p, V0, V0, ST0_SX | ST0_UX);</span>
<span class="p_add">+#endif</span>
 	uasm_i_mtc0(&amp;p, V0, C0_STATUS);
 	uasm_i_ehb(&amp;p);
 
<span class="p_chunk">@@ -643,7 +646,7 @@</span> <span class="p_context"> static void *kvm_mips_build_ret_to_guest(void *addr)</span>
 
 	/* Setup status register for running guest in UM */
 	uasm_i_ori(&amp;p, V1, V1, ST0_EXL | KSU_USER | ST0_IE);
<span class="p_del">-	UASM_i_LA(&amp;p, AT, ~(ST0_CU0 | ST0_MX));</span>
<span class="p_add">+	UASM_i_LA(&amp;p, AT, ~(ST0_CU0 | ST0_MX | ST0_SX | ST0_UX));</span>
 	uasm_i_and(&amp;p, V1, V1, AT);
 	uasm_i_mtc0(&amp;p, V1, C0_STATUS);
 	uasm_i_ehb(&amp;p);
<span class="p_header">diff --git a/arch/mips/kvm/mips.c b/arch/mips/kvm/mips.c</span>
<span class="p_header">index 06a60b19acfb..29ec9ab3fd55 100644</span>
<span class="p_header">--- a/arch/mips/kvm/mips.c</span>
<span class="p_header">+++ b/arch/mips/kvm/mips.c</span>
<span class="p_chunk">@@ -360,8 +360,8 @@</span> <span class="p_context"> struct kvm_vcpu *kvm_arch_vcpu_create(struct kvm *kvm, unsigned int id)</span>
 	dump_handler(&quot;kvm_exit&quot;, gebase + 0x2000, vcpu-&gt;arch.vcpu_run);
 
 	/* Invalidate the icache for these ranges */
<span class="p_del">-	local_flush_icache_range((unsigned long)gebase,</span>
<span class="p_del">-				(unsigned long)gebase + ALIGN(size, PAGE_SIZE));</span>
<span class="p_add">+	flush_icache_range((unsigned long)gebase,</span>
<span class="p_add">+			   (unsigned long)gebase + ALIGN(size, PAGE_SIZE));</span>
 
 	/*
 	 * Allocate comm page for guest kernel, a TLB will be reserved for
<span class="p_header">diff --git a/arch/parisc/kernel/time.c b/arch/parisc/kernel/time.c</span>
<span class="p_header">index 325f30d82b64..47ef8fdcd382 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/time.c</span>
<span class="p_header">+++ b/arch/parisc/kernel/time.c</span>
<span class="p_chunk">@@ -289,9 +289,26 @@</span> <span class="p_context"> void __init time_init(void)</span>
 
 	cr16_hz = 100 * PAGE0-&gt;mem_10msec;  /* Hz */
 
<span class="p_del">-	/* register at clocksource framework */</span>
<span class="p_del">-	clocksource_register_hz(&amp;clocksource_cr16, cr16_hz);</span>
<span class="p_del">-</span>
 	/* register as sched_clock source */
 	sched_clock_register(read_cr16_sched_clock, BITS_PER_LONG, cr16_hz);
 }
<span class="p_add">+</span>
<span class="p_add">+static int __init init_cr16_clocksource(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The cr16 interval timers are not syncronized across CPUs, so mark</span>
<span class="p_add">+	 * them unstable and lower rating on SMP systems.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (num_online_cpus() &gt; 1) {</span>
<span class="p_add">+		clocksource_cr16.flags = CLOCK_SOURCE_UNSTABLE;</span>
<span class="p_add">+		clocksource_cr16.rating = 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* register at clocksource framework */</span>
<span class="p_add">+	clocksource_register_hz(&amp;clocksource_cr16,</span>
<span class="p_add">+		100 * PAGE0-&gt;mem_10msec);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+device_initcall(init_cr16_clocksource);</span>
<span class="p_header">diff --git a/arch/parisc/mm/fault.c b/arch/parisc/mm/fault.c</span>
<span class="p_header">index 8ff9253930af..1a0b4f63f0e9 100644</span>
<span class="p_header">--- a/arch/parisc/mm/fault.c</span>
<span class="p_header">+++ b/arch/parisc/mm/fault.c</span>
<span class="p_chunk">@@ -234,7 +234,7 @@</span> <span class="p_context"> show_signal_msg(struct pt_regs *regs, unsigned long code,</span>
 	    tsk-&gt;comm, code, address);
 	print_vma_addr(KERN_CONT &quot; in &quot;, regs-&gt;iaoq[0]);
 
<span class="p_del">-	pr_cont(&quot; trap #%lu: %s%c&quot;, code, trap_name(code),</span>
<span class="p_add">+	pr_cont(&quot;\ntrap #%lu: %s%c&quot;, code, trap_name(code),</span>
 		vma ? &#39;,&#39;:&#39;\n&#39;);
 
 	if (vma)
<span class="p_header">diff --git a/arch/s390/crypto/prng.c b/arch/s390/crypto/prng.c</span>
<span class="p_header">index 9cc050f9536c..1113389d0a39 100644</span>
<span class="p_header">--- a/arch/s390/crypto/prng.c</span>
<span class="p_header">+++ b/arch/s390/crypto/prng.c</span>
<span class="p_chunk">@@ -507,8 +507,10 @@</span> <span class="p_context"> static ssize_t prng_tdes_read(struct file *file, char __user *ubuf,</span>
 		prng_data-&gt;prngws.byte_counter += n;
 		prng_data-&gt;prngws.reseed_counter += n;
 
<span class="p_del">-		if (copy_to_user(ubuf, prng_data-&gt;buf, chunk))</span>
<span class="p_del">-			return -EFAULT;</span>
<span class="p_add">+		if (copy_to_user(ubuf, prng_data-&gt;buf, chunk)) {</span>
<span class="p_add">+			ret = -EFAULT;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
 
 		nbytes -= chunk;
 		ret += chunk;
<span class="p_header">diff --git a/arch/s390/kernel/topology.c b/arch/s390/kernel/topology.c</span>
<span class="p_header">index e959c02e0cac..8705ee66c087 100644</span>
<span class="p_header">--- a/arch/s390/kernel/topology.c</span>
<span class="p_header">+++ b/arch/s390/kernel/topology.c</span>
<span class="p_chunk">@@ -448,6 +448,7 @@</span> <span class="p_context"> static int __init s390_topology_init(void)</span>
 	struct sysinfo_15_1_x *info;
 	int i;
 
<span class="p_add">+	set_sched_topology(s390_topology);</span>
 	if (!MACHINE_HAS_TOPOLOGY)
 		return 0;
 	tl_info = (struct sysinfo_15_1_x *)__get_free_page(GFP_KERNEL);
<span class="p_chunk">@@ -460,7 +461,6 @@</span> <span class="p_context"> static int __init s390_topology_init(void)</span>
 	alloc_masks(info, &amp;socket_info, 1);
 	alloc_masks(info, &amp;book_info, 2);
 	alloc_masks(info, &amp;drawer_info, 3);
<span class="p_del">-	set_sched_topology(s390_topology);</span>
 	return 0;
 }
 early_initcall(s390_topology_init);
<span class="p_header">diff --git a/arch/s390/pci/pci_dma.c b/arch/s390/pci/pci_dma.c</span>
<span class="p_header">index 6b2f72f523b9..049e3860ac54 100644</span>
<span class="p_header">--- a/arch/s390/pci/pci_dma.c</span>
<span class="p_header">+++ b/arch/s390/pci/pci_dma.c</span>
<span class="p_chunk">@@ -419,6 +419,7 @@</span> <span class="p_context"> static int __s390_dma_map_sg(struct device *dev, struct scatterlist *sg,</span>
 			     size_t size, dma_addr_t *handle,
 			     enum dma_data_direction dir)
 {
<span class="p_add">+	unsigned long nr_pages = PAGE_ALIGN(size) &gt;&gt; PAGE_SHIFT;</span>
 	struct zpci_dev *zdev = to_zpci(to_pci_dev(dev));
 	dma_addr_t dma_addr_base, dma_addr;
 	int flags = ZPCI_PTE_VALID;
<span class="p_chunk">@@ -426,8 +427,7 @@</span> <span class="p_context"> static int __s390_dma_map_sg(struct device *dev, struct scatterlist *sg,</span>
 	unsigned long pa = 0;
 	int ret;
 
<span class="p_del">-	size = PAGE_ALIGN(size);</span>
<span class="p_del">-	dma_addr_base = dma_alloc_address(dev, size &gt;&gt; PAGE_SHIFT);</span>
<span class="p_add">+	dma_addr_base = dma_alloc_address(dev, nr_pages);</span>
 	if (dma_addr_base == DMA_ERROR_CODE)
 		return -ENOMEM;
 
<span class="p_chunk">@@ -436,26 +436,27 @@</span> <span class="p_context"> static int __s390_dma_map_sg(struct device *dev, struct scatterlist *sg,</span>
 		flags |= ZPCI_TABLE_PROTECTED;
 
 	for (s = sg; dma_addr &lt; dma_addr_base + size; s = sg_next(s)) {
<span class="p_del">-		pa = page_to_phys(sg_page(s)) + s-&gt;offset;</span>
<span class="p_del">-		ret = __dma_update_trans(zdev, pa, dma_addr, s-&gt;length, flags);</span>
<span class="p_add">+		pa = page_to_phys(sg_page(s));</span>
<span class="p_add">+		ret = __dma_update_trans(zdev, pa, dma_addr,</span>
<span class="p_add">+					 s-&gt;offset + s-&gt;length, flags);</span>
 		if (ret)
 			goto unmap;
 
<span class="p_del">-		dma_addr += s-&gt;length;</span>
<span class="p_add">+		dma_addr += s-&gt;offset + s-&gt;length;</span>
 	}
 	ret = __dma_purge_tlb(zdev, dma_addr_base, size, flags);
 	if (ret)
 		goto unmap;
 
 	*handle = dma_addr_base;
<span class="p_del">-	atomic64_add(size &gt;&gt; PAGE_SHIFT, &amp;zdev-&gt;mapped_pages);</span>
<span class="p_add">+	atomic64_add(nr_pages, &amp;zdev-&gt;mapped_pages);</span>
 
 	return ret;
 
 unmap:
 	dma_update_trans(zdev, 0, dma_addr_base, dma_addr - dma_addr_base,
 			 ZPCI_PTE_INVALID);
<span class="p_del">-	dma_free_address(dev, dma_addr_base, size &gt;&gt; PAGE_SHIFT);</span>
<span class="p_add">+	dma_free_address(dev, dma_addr_base, nr_pages);</span>
 	zpci_err(&quot;map error:\n&quot;);
 	zpci_err_dma(ret, pa);
 	return ret;
<span class="p_header">diff --git a/arch/x86/include/uapi/asm/prctl.h b/arch/x86/include/uapi/asm/prctl.h</span>
<span class="p_header">index ae135de547f5..835aa51c7f6e 100644</span>
<span class="p_header">--- a/arch/x86/include/uapi/asm/prctl.h</span>
<span class="p_header">+++ b/arch/x86/include/uapi/asm/prctl.h</span>
<span class="p_chunk">@@ -6,10 +6,8 @@</span> <span class="p_context"></span>
 #define ARCH_GET_FS 0x1003
 #define ARCH_GET_GS 0x1004
 
<span class="p_del">-#ifdef CONFIG_CHECKPOINT_RESTORE</span>
<span class="p_del">-# define ARCH_MAP_VDSO_X32	0x2001</span>
<span class="p_del">-# define ARCH_MAP_VDSO_32	0x2002</span>
<span class="p_del">-# define ARCH_MAP_VDSO_64	0x2003</span>
<span class="p_del">-#endif</span>
<span class="p_add">+#define ARCH_MAP_VDSO_X32	0x2001</span>
<span class="p_add">+#define ARCH_MAP_VDSO_32	0x2002</span>
<span class="p_add">+#define ARCH_MAP_VDSO_64	0x2003</span>
 
 #endif /* _ASM_X86_PRCTL_H */
<span class="p_header">diff --git a/arch/x86/kernel/cpu/common.c b/arch/x86/kernel/cpu/common.c</span>
<span class="p_header">index c2048b44851c..dd62708c6a67 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/common.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/common.c</span>
<span class="p_chunk">@@ -667,13 +667,14 @@</span> <span class="p_context"> void get_cpu_cap(struct cpuinfo_x86 *c)</span>
 		c-&gt;x86_capability[CPUID_1_EDX] = edx;
 	}
 
<span class="p_add">+	/* Thermal and Power Management Leaf: level 0x00000006 (eax) */</span>
<span class="p_add">+	if (c-&gt;cpuid_level &gt;= 0x00000006)</span>
<span class="p_add">+		c-&gt;x86_capability[CPUID_6_EAX] = cpuid_eax(0x00000006);</span>
<span class="p_add">+</span>
 	/* Additional Intel-defined flags: level 0x00000007 */
 	if (c-&gt;cpuid_level &gt;= 0x00000007) {
 		cpuid_count(0x00000007, 0, &amp;eax, &amp;ebx, &amp;ecx, &amp;edx);
<span class="p_del">-</span>
 		c-&gt;x86_capability[CPUID_7_0_EBX] = ebx;
<span class="p_del">-</span>
<span class="p_del">-		c-&gt;x86_capability[CPUID_6_EAX] = cpuid_eax(0x00000006);</span>
 		c-&gt;x86_capability[CPUID_7_ECX] = ecx;
 	}
 
<span class="p_header">diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c</span>
<span class="p_header">index 04c5d96b1d67..f3648c978d2f 100644</span>
<span class="p_header">--- a/arch/x86/kvm/x86.c</span>
<span class="p_header">+++ b/arch/x86/kvm/x86.c</span>
<span class="p_chunk">@@ -3036,6 +3036,8 @@</span> <span class="p_context"> static void kvm_vcpu_ioctl_x86_get_vcpu_events(struct kvm_vcpu *vcpu,</span>
 	memset(&amp;events-&gt;reserved, 0, sizeof(events-&gt;reserved));
 }
 
<span class="p_add">+static void kvm_set_hflags(struct kvm_vcpu *vcpu, unsigned emul_flags);</span>
<span class="p_add">+</span>
 static int kvm_vcpu_ioctl_x86_set_vcpu_events(struct kvm_vcpu *vcpu,
 					      struct kvm_vcpu_events *events)
 {
<span class="p_chunk">@@ -3072,10 +3074,13 @@</span> <span class="p_context"> static int kvm_vcpu_ioctl_x86_set_vcpu_events(struct kvm_vcpu *vcpu,</span>
 		vcpu-&gt;arch.apic-&gt;sipi_vector = events-&gt;sipi_vector;
 
 	if (events-&gt;flags &amp; KVM_VCPUEVENT_VALID_SMM) {
<span class="p_add">+		u32 hflags = vcpu-&gt;arch.hflags;</span>
 		if (events-&gt;smi.smm)
<span class="p_del">-			vcpu-&gt;arch.hflags |= HF_SMM_MASK;</span>
<span class="p_add">+			hflags |= HF_SMM_MASK;</span>
 		else
<span class="p_del">-			vcpu-&gt;arch.hflags &amp;= ~HF_SMM_MASK;</span>
<span class="p_add">+			hflags &amp;= ~HF_SMM_MASK;</span>
<span class="p_add">+		kvm_set_hflags(vcpu, hflags);</span>
<span class="p_add">+</span>
 		vcpu-&gt;arch.smi_pending = events-&gt;smi.pending;
 		if (events-&gt;smi.smm_inside_nmi)
 			vcpu-&gt;arch.hflags |= HF_SMM_INSIDE_NMI_MASK;
<span class="p_header">diff --git a/drivers/base/power/power.h b/drivers/base/power/power.h</span>
<span class="p_header">index 50e30e7b059d..a84332aefc2d 100644</span>
<span class="p_header">--- a/drivers/base/power/power.h</span>
<span class="p_header">+++ b/drivers/base/power/power.h</span>
<span class="p_chunk">@@ -21,14 +21,22 @@</span> <span class="p_context"> extern void pm_runtime_init(struct device *dev);</span>
 extern void pm_runtime_reinit(struct device *dev);
 extern void pm_runtime_remove(struct device *dev);
 
<span class="p_add">+#define WAKE_IRQ_DEDICATED_ALLOCATED	BIT(0)</span>
<span class="p_add">+#define WAKE_IRQ_DEDICATED_MANAGED	BIT(1)</span>
<span class="p_add">+#define WAKE_IRQ_DEDICATED_MASK		(WAKE_IRQ_DEDICATED_ALLOCATED | \</span>
<span class="p_add">+					 WAKE_IRQ_DEDICATED_MANAGED)</span>
<span class="p_add">+</span>
 struct wake_irq {
 	struct device *dev;
<span class="p_add">+	unsigned int status;</span>
 	int irq;
<span class="p_del">-	bool dedicated_irq:1;</span>
 };
 
 extern void dev_pm_arm_wake_irq(struct wake_irq *wirq);
 extern void dev_pm_disarm_wake_irq(struct wake_irq *wirq);
<span class="p_add">+extern void dev_pm_enable_wake_irq_check(struct device *dev,</span>
<span class="p_add">+					 bool can_change_status);</span>
<span class="p_add">+extern void dev_pm_disable_wake_irq_check(struct device *dev);</span>
 
 #ifdef CONFIG_PM_SLEEP
 
<span class="p_chunk">@@ -104,6 +112,15 @@</span> <span class="p_context"> static inline void dev_pm_disarm_wake_irq(struct wake_irq *wirq)</span>
 {
 }
 
<span class="p_add">+static inline void dev_pm_enable_wake_irq_check(struct device *dev,</span>
<span class="p_add">+						bool can_change_status)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void dev_pm_disable_wake_irq_check(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #endif
 
 #ifdef CONFIG_PM_SLEEP
<span class="p_header">diff --git a/drivers/base/power/runtime.c b/drivers/base/power/runtime.c</span>
<span class="p_header">index 82a081ea4317..23f3b95a1158 100644</span>
<span class="p_header">--- a/drivers/base/power/runtime.c</span>
<span class="p_header">+++ b/drivers/base/power/runtime.c</span>
<span class="p_chunk">@@ -515,7 +515,7 @@</span> <span class="p_context"> static int rpm_suspend(struct device *dev, int rpmflags)</span>
 
 	callback = RPM_GET_CALLBACK(dev, runtime_suspend);
 
<span class="p_del">-	dev_pm_enable_wake_irq(dev);</span>
<span class="p_add">+	dev_pm_enable_wake_irq_check(dev, true);</span>
 	retval = rpm_callback(callback, dev);
 	if (retval)
 		goto fail;
<span class="p_chunk">@@ -554,7 +554,7 @@</span> <span class="p_context"> static int rpm_suspend(struct device *dev, int rpmflags)</span>
 	return retval;
 
  fail:
<span class="p_del">-	dev_pm_disable_wake_irq(dev);</span>
<span class="p_add">+	dev_pm_disable_wake_irq_check(dev);</span>
 	__update_runtime_status(dev, RPM_ACTIVE);
 	dev-&gt;power.deferred_resume = false;
 	wake_up_all(&amp;dev-&gt;power.wait_queue);
<span class="p_chunk">@@ -737,12 +737,12 @@</span> <span class="p_context"> static int rpm_resume(struct device *dev, int rpmflags)</span>
 
 	callback = RPM_GET_CALLBACK(dev, runtime_resume);
 
<span class="p_del">-	dev_pm_disable_wake_irq(dev);</span>
<span class="p_add">+	dev_pm_disable_wake_irq_check(dev);</span>
 	retval = rpm_callback(callback, dev);
 	if (retval) {
 		__update_runtime_status(dev, RPM_SUSPENDED);
 		pm_runtime_cancel_pending(dev);
<span class="p_del">-		dev_pm_enable_wake_irq(dev);</span>
<span class="p_add">+		dev_pm_enable_wake_irq_check(dev, false);</span>
 	} else {
  no_callback:
 		__update_runtime_status(dev, RPM_ACTIVE);
<span class="p_header">diff --git a/drivers/base/power/wakeirq.c b/drivers/base/power/wakeirq.c</span>
<span class="p_header">index 0d77cd6fd8d1..404d94c6c8bc 100644</span>
<span class="p_header">--- a/drivers/base/power/wakeirq.c</span>
<span class="p_header">+++ b/drivers/base/power/wakeirq.c</span>
<span class="p_chunk">@@ -110,8 +110,10 @@</span> <span class="p_context"> void dev_pm_clear_wake_irq(struct device *dev)</span>
 	dev-&gt;power.wakeirq = NULL;
 	spin_unlock_irqrestore(&amp;dev-&gt;power.lock, flags);
 
<span class="p_del">-	if (wirq-&gt;dedicated_irq)</span>
<span class="p_add">+	if (wirq-&gt;status &amp; WAKE_IRQ_DEDICATED_ALLOCATED) {</span>
 		free_irq(wirq-&gt;irq, wirq);
<span class="p_add">+		wirq-&gt;status &amp;= ~WAKE_IRQ_DEDICATED_MASK;</span>
<span class="p_add">+	}</span>
 	kfree(wirq);
 }
 EXPORT_SYMBOL_GPL(dev_pm_clear_wake_irq);
<span class="p_chunk">@@ -179,7 +181,6 @@</span> <span class="p_context"> int dev_pm_set_dedicated_wake_irq(struct device *dev, int irq)</span>
 
 	wirq-&gt;dev = dev;
 	wirq-&gt;irq = irq;
<span class="p_del">-	wirq-&gt;dedicated_irq = true;</span>
 	irq_set_status_flags(irq, IRQ_NOAUTOEN);
 
 	/*
<span class="p_chunk">@@ -195,6 +196,8 @@</span> <span class="p_context"> int dev_pm_set_dedicated_wake_irq(struct device *dev, int irq)</span>
 	if (err)
 		goto err_free_irq;
 
<span class="p_add">+	wirq-&gt;status = WAKE_IRQ_DEDICATED_ALLOCATED;</span>
<span class="p_add">+</span>
 	return err;
 
 err_free_irq:
<span class="p_chunk">@@ -210,9 +213,9 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(dev_pm_set_dedicated_wake_irq);</span>
  * dev_pm_enable_wake_irq - Enable device wake-up interrupt
  * @dev: Device
  *
<span class="p_del">- * Called from the bus code or the device driver for</span>
<span class="p_del">- * runtime_suspend() to enable the wake-up interrupt while</span>
<span class="p_del">- * the device is running.</span>
<span class="p_add">+ * Optionally called from the bus code or the device driver for</span>
<span class="p_add">+ * runtime_resume() to override the PM runtime core managed wake-up</span>
<span class="p_add">+ * interrupt handling to enable the wake-up interrupt.</span>
  *
  * Note that for runtime_suspend()) the wake-up interrupts
  * should be unconditionally enabled unlike for suspend()
<span class="p_chunk">@@ -222,7 +225,7 @@</span> <span class="p_context"> void dev_pm_enable_wake_irq(struct device *dev)</span>
 {
 	struct wake_irq *wirq = dev-&gt;power.wakeirq;
 
<span class="p_del">-	if (wirq &amp;&amp; wirq-&gt;dedicated_irq)</span>
<span class="p_add">+	if (wirq &amp;&amp; (wirq-&gt;status &amp; WAKE_IRQ_DEDICATED_ALLOCATED))</span>
 		enable_irq(wirq-&gt;irq);
 }
 EXPORT_SYMBOL_GPL(dev_pm_enable_wake_irq);
<span class="p_chunk">@@ -231,20 +234,73 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(dev_pm_enable_wake_irq);</span>
  * dev_pm_disable_wake_irq - Disable device wake-up interrupt
  * @dev: Device
  *
<span class="p_del">- * Called from the bus code or the device driver for</span>
<span class="p_del">- * runtime_resume() to disable the wake-up interrupt while</span>
<span class="p_del">- * the device is running.</span>
<span class="p_add">+ * Optionally called from the bus code or the device driver for</span>
<span class="p_add">+ * runtime_suspend() to override the PM runtime core managed wake-up</span>
<span class="p_add">+ * interrupt handling to disable the wake-up interrupt.</span>
  */
 void dev_pm_disable_wake_irq(struct device *dev)
 {
 	struct wake_irq *wirq = dev-&gt;power.wakeirq;
 
<span class="p_del">-	if (wirq &amp;&amp; wirq-&gt;dedicated_irq)</span>
<span class="p_add">+	if (wirq &amp;&amp; (wirq-&gt;status &amp; WAKE_IRQ_DEDICATED_ALLOCATED))</span>
 		disable_irq_nosync(wirq-&gt;irq);
 }
 EXPORT_SYMBOL_GPL(dev_pm_disable_wake_irq);
 
 /**
<span class="p_add">+ * dev_pm_enable_wake_irq_check - Checks and enables wake-up interrupt</span>
<span class="p_add">+ * @dev: Device</span>
<span class="p_add">+ * @can_change_status: Can change wake-up interrupt status</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Enables wakeirq conditionally. We need to enable wake-up interrupt</span>
<span class="p_add">+ * lazily on the first rpm_suspend(). This is needed as the consumer device</span>
<span class="p_add">+ * starts in RPM_SUSPENDED state, and the the first pm_runtime_get() would</span>
<span class="p_add">+ * otherwise try to disable already disabled wakeirq. The wake-up interrupt</span>
<span class="p_add">+ * starts disabled with IRQ_NOAUTOEN set.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Should be only called from rpm_suspend() and rpm_resume() path.</span>
<span class="p_add">+ * Caller must hold &amp;dev-&gt;power.lock to change wirq-&gt;status</span>
<span class="p_add">+ */</span>
<span class="p_add">+void dev_pm_enable_wake_irq_check(struct device *dev,</span>
<span class="p_add">+				  bool can_change_status)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct wake_irq *wirq = dev-&gt;power.wakeirq;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!wirq || !((wirq-&gt;status &amp; WAKE_IRQ_DEDICATED_MASK)))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (likely(wirq-&gt;status &amp; WAKE_IRQ_DEDICATED_MANAGED)) {</span>
<span class="p_add">+		goto enable;</span>
<span class="p_add">+	} else if (can_change_status) {</span>
<span class="p_add">+		wirq-&gt;status |= WAKE_IRQ_DEDICATED_MANAGED;</span>
<span class="p_add">+		goto enable;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return;</span>
<span class="p_add">+</span>
<span class="p_add">+enable:</span>
<span class="p_add">+	enable_irq(wirq-&gt;irq);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * dev_pm_disable_wake_irq_check - Checks and disables wake-up interrupt</span>
<span class="p_add">+ * @dev: Device</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Disables wake-up interrupt conditionally based on status.</span>
<span class="p_add">+ * Should be only called from rpm_suspend() and rpm_resume() path.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void dev_pm_disable_wake_irq_check(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct wake_irq *wirq = dev-&gt;power.wakeirq;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!wirq || !((wirq-&gt;status &amp; WAKE_IRQ_DEDICATED_MASK)))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (wirq-&gt;status &amp; WAKE_IRQ_DEDICATED_MANAGED)</span>
<span class="p_add">+		disable_irq_nosync(wirq-&gt;irq);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
  * dev_pm_arm_wake_irq - Arm device wake-up
  * @wirq: Device wake-up interrupt
  *
<span class="p_header">diff --git a/drivers/char/tpm/tpm_tis_core.c b/drivers/char/tpm/tpm_tis_core.c</span>
<span class="p_header">index e3bf31b37138..a1ce0607bf7b 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm_tis_core.c</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm_tis_core.c</span>
<span class="p_chunk">@@ -185,7 +185,12 @@</span> <span class="p_context"> static int recv_data(struct tpm_chip *chip, u8 *buf, size_t count)</span>
 				 TPM_STS_DATA_AVAIL | TPM_STS_VALID,
 				 chip-&gt;timeout_c,
 				 &amp;priv-&gt;read_queue, true) == 0) {
<span class="p_del">-		burstcnt = min_t(int, get_burstcount(chip), count - size);</span>
<span class="p_add">+		burstcnt = get_burstcount(chip);</span>
<span class="p_add">+		if (burstcnt &lt; 0) {</span>
<span class="p_add">+			dev_err(&amp;chip-&gt;dev, &quot;Unable to read burstcount\n&quot;);</span>
<span class="p_add">+			return burstcnt;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		burstcnt = min_t(int, burstcnt, count - size);</span>
 
 		rc = tpm_tis_read_bytes(priv, TPM_DATA_FIFO(priv-&gt;locality),
 					burstcnt, buf + size);
<span class="p_chunk">@@ -271,7 +276,13 @@</span> <span class="p_context"> static int tpm_tis_send_data(struct tpm_chip *chip, u8 *buf, size_t len)</span>
 	}
 
 	while (count &lt; len - 1) {
<span class="p_del">-		burstcnt = min_t(int, get_burstcount(chip), len - count - 1);</span>
<span class="p_add">+		burstcnt = get_burstcount(chip);</span>
<span class="p_add">+		if (burstcnt &lt; 0) {</span>
<span class="p_add">+			dev_err(&amp;chip-&gt;dev, &quot;Unable to read burstcount\n&quot;);</span>
<span class="p_add">+			rc = burstcnt;</span>
<span class="p_add">+			goto out_err;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		burstcnt = min_t(int, burstcnt, len - count - 1);</span>
 		rc = tpm_tis_write_bytes(priv, TPM_DATA_FIFO(priv-&gt;locality),
 					 burstcnt, buf + count);
 		if (rc &lt; 0)
<span class="p_header">diff --git a/drivers/clk/clk-wm831x.c b/drivers/clk/clk-wm831x.c</span>
<span class="p_header">index f4fdac55727c..0621fbfb4beb 100644</span>
<span class="p_header">--- a/drivers/clk/clk-wm831x.c</span>
<span class="p_header">+++ b/drivers/clk/clk-wm831x.c</span>
<span class="p_chunk">@@ -243,7 +243,7 @@</span> <span class="p_context"> static int wm831x_clkout_is_prepared(struct clk_hw *hw)</span>
 	if (ret &lt; 0) {
 		dev_err(wm831x-&gt;dev, &quot;Unable to read CLOCK_CONTROL_1: %d\n&quot;,
 			ret);
<span class="p_del">-		return true;</span>
<span class="p_add">+		return false;</span>
 	}
 
 	return (ret &amp; WM831X_CLKOUT_ENA) != 0;
<span class="p_header">diff --git a/drivers/clk/imx/clk-imx31.c b/drivers/clk/imx/clk-imx31.c</span>
<span class="p_header">index 6a964144a5b5..6a49ba2b9671 100644</span>
<span class="p_header">--- a/drivers/clk/imx/clk-imx31.c</span>
<span class="p_header">+++ b/drivers/clk/imx/clk-imx31.c</span>
<span class="p_chunk">@@ -157,10 +157,8 @@</span> <span class="p_context"> static void __init _mx31_clocks_init(unsigned long fref)</span>
 	}
 }
 
<span class="p_del">-int __init mx31_clocks_init(void)</span>
<span class="p_add">+int __init mx31_clocks_init(unsigned long fref)</span>
 {
<span class="p_del">-	u32 fref = 26000000; /* default */</span>
<span class="p_del">-</span>
 	_mx31_clocks_init(fref);
 
 	clk_register_clkdev(clk[gpt_gate], &quot;per&quot;, &quot;imx-gpt.0&quot;);
<span class="p_header">diff --git a/drivers/clk/qcom/gcc-ipq806x.c b/drivers/clk/qcom/gcc-ipq806x.c</span>
<span class="p_header">index 52a7d3959875..28eb200d0f1e 100644</span>
<span class="p_header">--- a/drivers/clk/qcom/gcc-ipq806x.c</span>
<span class="p_header">+++ b/drivers/clk/qcom/gcc-ipq806x.c</span>
<span class="p_chunk">@@ -2990,11 +2990,11 @@</span> <span class="p_context"> static int gcc_ipq806x_probe(struct platform_device *pdev)</span>
 	struct regmap *regmap;
 	int ret;
 
<span class="p_del">-	ret = qcom_cc_register_board_clk(dev, &quot;cxo_board&quot;, &quot;cxo&quot;, 19200000);</span>
<span class="p_add">+	ret = qcom_cc_register_board_clk(dev, &quot;cxo_board&quot;, &quot;cxo&quot;, 25000000);</span>
 	if (ret)
 		return ret;
 
<span class="p_del">-	ret = qcom_cc_register_board_clk(dev, &quot;pxo_board&quot;, &quot;pxo&quot;, 27000000);</span>
<span class="p_add">+	ret = qcom_cc_register_board_clk(dev, &quot;pxo_board&quot;, &quot;pxo&quot;, 25000000);</span>
 	if (ret)
 		return ret;
 
<span class="p_header">diff --git a/drivers/clk/renesas/clk-mstp.c b/drivers/clk/renesas/clk-mstp.c</span>
<span class="p_header">index 9375777776d9..b533f99550e1 100644</span>
<span class="p_header">--- a/drivers/clk/renesas/clk-mstp.c</span>
<span class="p_header">+++ b/drivers/clk/renesas/clk-mstp.c</span>
<span class="p_chunk">@@ -37,12 +37,14 @@</span> <span class="p_context"></span>
  * @smstpcr: module stop control register
  * @mstpsr: module stop status register (optional)
  * @lock: protects writes to SMSTPCR
<span class="p_add">+ * @width_8bit: registers are 8-bit, not 32-bit</span>
  */
 struct mstp_clock_group {
 	struct clk_onecell_data data;
 	void __iomem *smstpcr;
 	void __iomem *mstpsr;
 	spinlock_t lock;
<span class="p_add">+	bool width_8bit;</span>
 };
 
 /**
<span class="p_chunk">@@ -59,6 +61,18 @@</span> <span class="p_context"> struct mstp_clock {</span>
 
 #define to_mstp_clock(_hw) container_of(_hw, struct mstp_clock, hw)
 
<span class="p_add">+static inline u32 cpg_mstp_read(struct mstp_clock_group *group,</span>
<span class="p_add">+				u32 __iomem *reg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return group-&gt;width_8bit ? readb(reg) : clk_readl(reg);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void cpg_mstp_write(struct mstp_clock_group *group, u32 val,</span>
<span class="p_add">+				  u32 __iomem *reg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	group-&gt;width_8bit ? writeb(val, reg) : clk_writel(val, reg);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int cpg_mstp_clock_endisable(struct clk_hw *hw, bool enable)
 {
 	struct mstp_clock *clock = to_mstp_clock(hw);
<span class="p_chunk">@@ -70,12 +84,12 @@</span> <span class="p_context"> static int cpg_mstp_clock_endisable(struct clk_hw *hw, bool enable)</span>
 
 	spin_lock_irqsave(&amp;group-&gt;lock, flags);
 
<span class="p_del">-	value = clk_readl(group-&gt;smstpcr);</span>
<span class="p_add">+	value = cpg_mstp_read(group, group-&gt;smstpcr);</span>
 	if (enable)
 		value &amp;= ~bitmask;
 	else
 		value |= bitmask;
<span class="p_del">-	clk_writel(value, group-&gt;smstpcr);</span>
<span class="p_add">+	cpg_mstp_write(group, value, group-&gt;smstpcr);</span>
 
 	spin_unlock_irqrestore(&amp;group-&gt;lock, flags);
 
<span class="p_chunk">@@ -83,7 +97,7 @@</span> <span class="p_context"> static int cpg_mstp_clock_endisable(struct clk_hw *hw, bool enable)</span>
 		return 0;
 
 	for (i = 1000; i &gt; 0; --i) {
<span class="p_del">-		if (!(clk_readl(group-&gt;mstpsr) &amp; bitmask))</span>
<span class="p_add">+		if (!(cpg_mstp_read(group, group-&gt;mstpsr) &amp; bitmask))</span>
 			break;
 		cpu_relax();
 	}
<span class="p_chunk">@@ -114,9 +128,9 @@</span> <span class="p_context"> static int cpg_mstp_clock_is_enabled(struct clk_hw *hw)</span>
 	u32 value;
 
 	if (group-&gt;mstpsr)
<span class="p_del">-		value = clk_readl(group-&gt;mstpsr);</span>
<span class="p_add">+		value = cpg_mstp_read(group, group-&gt;mstpsr);</span>
 	else
<span class="p_del">-		value = clk_readl(group-&gt;smstpcr);</span>
<span class="p_add">+		value = cpg_mstp_read(group, group-&gt;smstpcr);</span>
 
 	return !(value &amp; BIT(clock-&gt;bit_index));
 }
<span class="p_chunk">@@ -188,6 +202,9 @@</span> <span class="p_context"> static void __init cpg_mstp_clocks_init(struct device_node *np)</span>
 		return;
 	}
 
<span class="p_add">+	if (of_device_is_compatible(np, &quot;renesas,r7s72100-mstp-clocks&quot;))</span>
<span class="p_add">+		group-&gt;width_8bit = true;</span>
<span class="p_add">+</span>
 	for (i = 0; i &lt; MSTP_MAX_CLOCKS; ++i)
 		clks[i] = ERR_PTR(-ENOENT);
 
<span class="p_header">diff --git a/drivers/clk/renesas/renesas-cpg-mssr.c b/drivers/clk/renesas/renesas-cpg-mssr.c</span>
<span class="p_header">index e1365e7491ae..25c41cd9cdfc 100644</span>
<span class="p_header">--- a/drivers/clk/renesas/renesas-cpg-mssr.c</span>
<span class="p_header">+++ b/drivers/clk/renesas/renesas-cpg-mssr.c</span>
<span class="p_chunk">@@ -33,9 +33,9 @@</span> <span class="p_context"></span>
 #include &quot;clk-div6.h&quot;
 
 #ifdef DEBUG
<span class="p_del">-#define WARN_DEBUG(x)	do { } while (0)</span>
<span class="p_del">-#else</span>
 #define WARN_DEBUG(x)	WARN_ON(x)
<span class="p_add">+#else</span>
<span class="p_add">+#define WARN_DEBUG(x)	do { } while (0)</span>
 #endif
 
 
<span class="p_header">diff --git a/drivers/clk/sunxi-ng/ccu-sun8i-a23.c b/drivers/clk/sunxi-ng/ccu-sun8i-a23.c</span>
<span class="p_header">index 2646d980087b..5c6d37bdf247 100644</span>
<span class="p_header">--- a/drivers/clk/sunxi-ng/ccu-sun8i-a23.c</span>
<span class="p_header">+++ b/drivers/clk/sunxi-ng/ccu-sun8i-a23.c</span>
<span class="p_chunk">@@ -344,10 +344,10 @@</span> <span class="p_context"> static SUNXI_CCU_MP_WITH_MUX_GATE(spi1_clk, &quot;spi1&quot;, mod0_default_parents, 0x0a4,</span>
 static const char * const i2s_parents[] = { &quot;pll-audio-8x&quot;, &quot;pll-audio-4x&quot;,
 					    &quot;pll-audio-2x&quot;, &quot;pll-audio&quot; };
 static SUNXI_CCU_MUX_WITH_GATE(i2s0_clk, &quot;i2s0&quot;, i2s_parents,
<span class="p_del">-			       0x0b0, 16, 2, BIT(31), 0);</span>
<span class="p_add">+			       0x0b0, 16, 2, BIT(31), CLK_SET_RATE_PARENT);</span>
 
 static SUNXI_CCU_MUX_WITH_GATE(i2s1_clk, &quot;i2s1&quot;, i2s_parents,
<span class="p_del">-			       0x0b4, 16, 2, BIT(31), 0);</span>
<span class="p_add">+			       0x0b4, 16, 2, BIT(31), CLK_SET_RATE_PARENT);</span>
 
 /* TODO: the parent for most of the USB clocks is not known */
 static SUNXI_CCU_GATE(usb_phy0_clk,	&quot;usb-phy0&quot;,	&quot;osc24M&quot;,
<span class="p_chunk">@@ -415,7 +415,7 @@</span> <span class="p_context"> static SUNXI_CCU_M_WITH_GATE(ve_clk, &quot;ve&quot;, &quot;pll-ve&quot;,</span>
 			     0x13c, 16, 3, BIT(31), CLK_SET_RATE_PARENT);
 
 static SUNXI_CCU_GATE(ac_dig_clk,	&quot;ac-dig&quot;,	&quot;pll-audio&quot;,
<span class="p_del">-		      0x140, BIT(31), 0);</span>
<span class="p_add">+		      0x140, BIT(31), CLK_SET_RATE_PARENT);</span>
 static SUNXI_CCU_GATE(avs_clk,		&quot;avs&quot;,		&quot;osc24M&quot;,
 		      0x144, BIT(31), 0);
 
<span class="p_header">diff --git a/drivers/clk/sunxi-ng/ccu-sun8i-h3.c b/drivers/clk/sunxi-ng/ccu-sun8i-h3.c</span>
<span class="p_header">index 4d70590f05e3..21c427d86f28 100644</span>
<span class="p_header">--- a/drivers/clk/sunxi-ng/ccu-sun8i-h3.c</span>
<span class="p_header">+++ b/drivers/clk/sunxi-ng/ccu-sun8i-h3.c</span>
<span class="p_chunk">@@ -394,16 +394,16 @@</span> <span class="p_context"> static SUNXI_CCU_MP_WITH_MUX_GATE(spi1_clk, &quot;spi1&quot;, mod0_default_parents, 0x0a4,</span>
 static const char * const i2s_parents[] = { &quot;pll-audio-8x&quot;, &quot;pll-audio-4x&quot;,
 					    &quot;pll-audio-2x&quot;, &quot;pll-audio&quot; };
 static SUNXI_CCU_MUX_WITH_GATE(i2s0_clk, &quot;i2s0&quot;, i2s_parents,
<span class="p_del">-			       0x0b0, 16, 2, BIT(31), 0);</span>
<span class="p_add">+			       0x0b0, 16, 2, BIT(31), CLK_SET_RATE_PARENT);</span>
 
 static SUNXI_CCU_MUX_WITH_GATE(i2s1_clk, &quot;i2s1&quot;, i2s_parents,
<span class="p_del">-			       0x0b4, 16, 2, BIT(31), 0);</span>
<span class="p_add">+			       0x0b4, 16, 2, BIT(31), CLK_SET_RATE_PARENT);</span>
 
 static SUNXI_CCU_MUX_WITH_GATE(i2s2_clk, &quot;i2s2&quot;, i2s_parents,
<span class="p_del">-			       0x0b8, 16, 2, BIT(31), 0);</span>
<span class="p_add">+			       0x0b8, 16, 2, BIT(31), CLK_SET_RATE_PARENT);</span>
 
 static SUNXI_CCU_M_WITH_GATE(spdif_clk, &quot;spdif&quot;, &quot;pll-audio&quot;,
<span class="p_del">-			     0x0c0, 0, 4, BIT(31), 0);</span>
<span class="p_add">+			     0x0c0, 0, 4, BIT(31), CLK_SET_RATE_PARENT);</span>
 
 static SUNXI_CCU_GATE(usb_phy0_clk,	&quot;usb-phy0&quot;,	&quot;osc24M&quot;,
 		      0x0cc, BIT(8), 0);
<span class="p_chunk">@@ -466,7 +466,7 @@</span> <span class="p_context"> static SUNXI_CCU_M_WITH_GATE(ve_clk, &quot;ve&quot;, &quot;pll-ve&quot;,</span>
 			     0x13c, 16, 3, BIT(31), 0);
 
 static SUNXI_CCU_GATE(ac_dig_clk,	&quot;ac-dig&quot;,	&quot;pll-audio&quot;,
<span class="p_del">-		      0x140, BIT(31), 0);</span>
<span class="p_add">+		      0x140, BIT(31), CLK_SET_RATE_PARENT);</span>
 static SUNXI_CCU_GATE(avs_clk,		&quot;avs&quot;,		&quot;osc24M&quot;,
 		      0x144, BIT(31), 0);
 
<span class="p_header">diff --git a/drivers/clk/ti/clk-7xx.c b/drivers/clk/ti/clk-7xx.c</span>
<span class="p_header">index bfa17d33ef3b..9fd6043314eb 100644</span>
<span class="p_header">--- a/drivers/clk/ti/clk-7xx.c</span>
<span class="p_header">+++ b/drivers/clk/ti/clk-7xx.c</span>
<span class="p_chunk">@@ -201,7 +201,6 @@</span> <span class="p_context"> static struct ti_dt_clk dra7xx_clks[] = {</span>
 	DT_CLK(NULL, &quot;atl_dpll_clk_mux&quot;, &quot;atl_dpll_clk_mux&quot;),
 	DT_CLK(NULL, &quot;atl_gfclk_mux&quot;, &quot;atl_gfclk_mux&quot;),
 	DT_CLK(NULL, &quot;dcan1_sys_clk_mux&quot;, &quot;dcan1_sys_clk_mux&quot;),
<span class="p_del">-	DT_CLK(NULL, &quot;gmac_gmii_ref_clk_div&quot;, &quot;gmac_gmii_ref_clk_div&quot;),</span>
 	DT_CLK(NULL, &quot;gmac_rft_clk_mux&quot;, &quot;gmac_rft_clk_mux&quot;),
 	DT_CLK(NULL, &quot;gpu_core_gclk_mux&quot;, &quot;gpu_core_gclk_mux&quot;),
 	DT_CLK(NULL, &quot;gpu_hyd_gclk_mux&quot;, &quot;gpu_hyd_gclk_mux&quot;),
<span class="p_header">diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c</span>
<span class="p_header">index 1ac199cd75e7..a4944e22f294 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/efi.c</span>
<span class="p_header">+++ b/drivers/firmware/efi/efi.c</span>
<span class="p_chunk">@@ -259,8 +259,10 @@</span> <span class="p_context"> static __init int efivar_ssdt_load(void)</span>
 		}
 
 		data = kmalloc(size, GFP_KERNEL);
<span class="p_del">-		if (!data)</span>
<span class="p_add">+		if (!data) {</span>
<span class="p_add">+			ret = -ENOMEM;</span>
 			goto free_entry;
<span class="p_add">+		}</span>
 
 		ret = efivar_entry_get(entry, NULL, &amp;size, data);
 		if (ret) {
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_gem_request.h b/drivers/gpu/drm/i915/i915_gem_request.h</span>
<span class="p_header">index 974bd7bcc801..59ac90025552 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_gem_request.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_gem_request.h</span>
<span class="p_chunk">@@ -344,6 +344,25 @@</span> <span class="p_context"> i915_gem_active_set(struct i915_gem_active *active,</span>
 	rcu_assign_pointer(active-&gt;request, request);
 }
 
<span class="p_add">+/**</span>
<span class="p_add">+ * i915_gem_active_set_retire_fn - updates the retirement callback</span>
<span class="p_add">+ * @active - the active tracker</span>
<span class="p_add">+ * @fn - the routine called when the request is retired</span>
<span class="p_add">+ * @mutex - struct_mutex used to guard retirements</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * i915_gem_active_set_retire_fn() updates the function pointer that</span>
<span class="p_add">+ * is called when the final request associated with the @active tracker</span>
<span class="p_add">+ * is retired.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline void</span>
<span class="p_add">+i915_gem_active_set_retire_fn(struct i915_gem_active *active,</span>
<span class="p_add">+			      i915_gem_retire_fn fn,</span>
<span class="p_add">+			      struct mutex *mutex)</span>
<span class="p_add">+{</span>
<span class="p_add">+	lockdep_assert_held(mutex);</span>
<span class="p_add">+	active-&gt;retire = fn ?: i915_gem_retire_noop;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline struct drm_i915_gem_request *
 __i915_gem_active_peek(const struct i915_gem_active *active)
 {
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_dp.c b/drivers/gpu/drm/i915/intel_dp.c</span>
<span class="p_header">index bf344d08356a..055525013d2f 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_dp.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_dp.c</span>
<span class="p_chunk">@@ -280,7 +280,8 @@</span> <span class="p_context"> intel_dp_init_panel_power_sequencer(struct drm_device *dev,</span>
 				    struct intel_dp *intel_dp);
 static void
 intel_dp_init_panel_power_sequencer_registers(struct drm_device *dev,
<span class="p_del">-					      struct intel_dp *intel_dp);</span>
<span class="p_add">+					      struct intel_dp *intel_dp,</span>
<span class="p_add">+					      bool force_disable_vdd);</span>
 static void
 intel_dp_pps_init(struct drm_device *dev, struct intel_dp *intel_dp);
 
<span class="p_chunk">@@ -442,7 +443,7 @@</span> <span class="p_context"> vlv_power_sequencer_pipe(struct intel_dp *intel_dp)</span>
 
 	/* init power sequencer on this pipe and port */
 	intel_dp_init_panel_power_sequencer(dev, intel_dp);
<span class="p_del">-	intel_dp_init_panel_power_sequencer_registers(dev, intel_dp);</span>
<span class="p_add">+	intel_dp_init_panel_power_sequencer_registers(dev, intel_dp, true);</span>
 
 	/*
 	 * Even vdd force doesn&#39;t work until we&#39;ve made
<span class="p_chunk">@@ -479,7 +480,7 @@</span> <span class="p_context"> bxt_power_sequencer_idx(struct intel_dp *intel_dp)</span>
 	 * Only the HW needs to be reprogrammed, the SW state is fixed and
 	 * has been setup during connector init.
 	 */
<span class="p_del">-	intel_dp_init_panel_power_sequencer_registers(dev, intel_dp);</span>
<span class="p_add">+	intel_dp_init_panel_power_sequencer_registers(dev, intel_dp, false);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -562,7 +563,7 @@</span> <span class="p_context"> vlv_initial_power_sequencer_setup(struct intel_dp *intel_dp)</span>
 		      port_name(port), pipe_name(intel_dp-&gt;pps_pipe));
 
 	intel_dp_init_panel_power_sequencer(dev, intel_dp);
<span class="p_del">-	intel_dp_init_panel_power_sequencer_registers(dev, intel_dp);</span>
<span class="p_add">+	intel_dp_init_panel_power_sequencer_registers(dev, intel_dp, false);</span>
 }
 
 void intel_power_sequencer_reset(struct drm_i915_private *dev_priv)
<span class="p_chunk">@@ -2924,7 +2925,7 @@</span> <span class="p_context"> static void vlv_init_panel_power_sequencer(struct intel_dp *intel_dp)</span>
 
 	/* init power sequencer on this pipe and port */
 	intel_dp_init_panel_power_sequencer(dev, intel_dp);
<span class="p_del">-	intel_dp_init_panel_power_sequencer_registers(dev, intel_dp);</span>
<span class="p_add">+	intel_dp_init_panel_power_sequencer_registers(dev, intel_dp, true);</span>
 }
 
 static void vlv_pre_enable_dp(struct intel_encoder *encoder,
<span class="p_chunk">@@ -4017,6 +4018,11 @@</span> <span class="p_context"> intel_dp_check_link_status(struct intel_dp *intel_dp)</span>
 	if (!to_intel_crtc(intel_encoder-&gt;base.crtc)-&gt;active)
 		return;
 
<span class="p_add">+	/* FIXME: we need to synchronize this sort of stuff with hardware</span>
<span class="p_add">+	 * readout. Currently fast link training doesn&#39;t work on boot-up. */</span>
<span class="p_add">+	if (!intel_dp-&gt;lane_count)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	/* if link training is requested we should perform it always */
 	if ((intel_dp-&gt;compliance_test_type == DP_TEST_LINK_TRAINING) ||
 	    (!drm_dp_channel_eq_ok(link_status, intel_dp-&gt;lane_count))) {
<span class="p_chunk">@@ -5054,7 +5060,8 @@</span> <span class="p_context"> intel_dp_init_panel_power_sequencer(struct drm_device *dev,</span>
 
 static void
 intel_dp_init_panel_power_sequencer_registers(struct drm_device *dev,
<span class="p_del">-					      struct intel_dp *intel_dp)</span>
<span class="p_add">+					      struct intel_dp *intel_dp,</span>
<span class="p_add">+					      bool force_disable_vdd)</span>
 {
 	struct drm_i915_private *dev_priv = to_i915(dev);
 	u32 pp_on, pp_off, pp_div, port_sel = 0;
<span class="p_chunk">@@ -5067,6 +5074,31 @@</span> <span class="p_context"> intel_dp_init_panel_power_sequencer_registers(struct drm_device *dev,</span>
 
 	intel_pps_get_registers(dev_priv, intel_dp, &amp;regs);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * On some VLV machines the BIOS can leave the VDD</span>
<span class="p_add">+	 * enabled even on power seqeuencers which aren&#39;t</span>
<span class="p_add">+	 * hooked up to any port. This would mess up the</span>
<span class="p_add">+	 * power domain tracking the first time we pick</span>
<span class="p_add">+	 * one of these power sequencers for use since</span>
<span class="p_add">+	 * edp_panel_vdd_on() would notice that the VDD was</span>
<span class="p_add">+	 * already on and therefore wouldn&#39;t grab the power</span>
<span class="p_add">+	 * domain reference. Disable VDD first to avoid this.</span>
<span class="p_add">+	 * This also avoids spuriously turning the VDD on as</span>
<span class="p_add">+	 * soon as the new power seqeuencer gets initialized.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (force_disable_vdd) {</span>
<span class="p_add">+		u32 pp = ironlake_get_pp_control(intel_dp);</span>
<span class="p_add">+</span>
<span class="p_add">+		WARN(pp &amp; PANEL_POWER_ON, &quot;Panel power already on\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (pp &amp; EDP_FORCE_VDD)</span>
<span class="p_add">+			DRM_DEBUG_KMS(&quot;VDD already on, disabling first\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+		pp &amp;= ~EDP_FORCE_VDD;</span>
<span class="p_add">+</span>
<span class="p_add">+		I915_WRITE(regs.pp_ctrl, pp);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	pp_on = (seq-&gt;t1_t3 &lt;&lt; PANEL_POWER_UP_DELAY_SHIFT) |
 		(seq-&gt;t8 &lt;&lt; PANEL_LIGHT_ON_DELAY_SHIFT);
 	pp_off = (seq-&gt;t9 &lt;&lt; PANEL_LIGHT_OFF_DELAY_SHIFT) |
<span class="p_chunk">@@ -5119,7 +5151,7 @@</span> <span class="p_context"> static void intel_dp_pps_init(struct drm_device *dev,</span>
 		vlv_initial_power_sequencer_setup(intel_dp);
 	} else {
 		intel_dp_init_panel_power_sequencer(dev, intel_dp);
<span class="p_del">-		intel_dp_init_panel_power_sequencer_registers(dev, intel_dp);</span>
<span class="p_add">+		intel_dp_init_panel_power_sequencer_registers(dev, intel_dp, false);</span>
 	}
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_overlay.c b/drivers/gpu/drm/i915/intel_overlay.c</span>
<span class="p_header">index a24bc8c7889f..a2655cd5a84e 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_overlay.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_overlay.c</span>
<span class="p_chunk">@@ -216,7 +216,8 @@</span> <span class="p_context"> static void intel_overlay_submit_request(struct intel_overlay *overlay,</span>
 {
 	GEM_BUG_ON(i915_gem_active_peek(&amp;overlay-&gt;last_flip,
 					&amp;overlay-&gt;i915-&gt;drm.struct_mutex));
<span class="p_del">-	overlay-&gt;last_flip.retire = retire;</span>
<span class="p_add">+	i915_gem_active_set_retire_fn(&amp;overlay-&gt;last_flip, retire,</span>
<span class="p_add">+				      &amp;overlay-&gt;i915-&gt;drm.struct_mutex);</span>
 	i915_gem_active_set(&amp;overlay-&gt;last_flip, req);
 	i915_add_request(req);
 }
<span class="p_chunk">@@ -839,8 +840,8 @@</span> <span class="p_context"> static int intel_overlay_do_put_image(struct intel_overlay *overlay,</span>
 	if (ret)
 		goto out_unpin;
 
<span class="p_del">-	i915_gem_track_fb(overlay-&gt;vma-&gt;obj, new_bo,</span>
<span class="p_del">-			  INTEL_FRONTBUFFER_OVERLAY(pipe));</span>
<span class="p_add">+	i915_gem_track_fb(overlay-&gt;vma ? overlay-&gt;vma-&gt;obj : NULL,</span>
<span class="p_add">+			  vma-&gt;obj, INTEL_FRONTBUFFER_OVERLAY(pipe));</span>
 
 	overlay-&gt;old_vma = overlay-&gt;vma;
 	overlay-&gt;vma = vma;
<span class="p_chunk">@@ -1430,6 +1431,8 @@</span> <span class="p_context"> void intel_setup_overlay(struct drm_i915_private *dev_priv)</span>
 	overlay-&gt;contrast = 75;
 	overlay-&gt;saturation = 146;
 
<span class="p_add">+	init_request_active(&amp;overlay-&gt;last_flip, NULL);</span>
<span class="p_add">+</span>
 	regs = intel_overlay_map_regs(overlay);
 	if (!regs)
 		goto out_unpin_bo;
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_pm.c b/drivers/gpu/drm/i915/intel_pm.c</span>
<span class="p_header">index db24f898853c..103cefdb9ddd 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_pm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_pm.c</span>
<span class="p_chunk">@@ -2879,6 +2879,21 @@</span> <span class="p_context"> skl_wm_plane_id(const struct intel_plane *plane)</span>
 	}
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * FIXME: We still don&#39;t have the proper code detect if we need to apply the WA,</span>
<span class="p_add">+ * so assume we&#39;ll always need it in order to avoid underruns.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static bool skl_needs_memory_bw_wa(struct intel_atomic_state *state)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct drm_i915_private *dev_priv = to_i915(state-&gt;base.dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (IS_SKYLAKE(dev_priv) || IS_BROXTON(dev_priv) ||</span>
<span class="p_add">+	    IS_KABYLAKE(dev_priv))</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static bool
 intel_has_sagv(struct drm_i915_private *dev_priv)
 {
<span class="p_chunk">@@ -2999,9 +3014,10 @@</span> <span class="p_context"> bool intel_can_enable_sagv(struct drm_atomic_state *state)</span>
 	struct drm_device *dev = state-&gt;dev;
 	struct drm_i915_private *dev_priv = to_i915(dev);
 	struct intel_atomic_state *intel_state = to_intel_atomic_state(state);
<span class="p_del">-	struct drm_crtc *crtc;</span>
<span class="p_add">+	struct intel_crtc *crtc;</span>
<span class="p_add">+	struct intel_plane *plane;</span>
 	enum pipe pipe;
<span class="p_del">-	int level, plane;</span>
<span class="p_add">+	int level, id, latency;</span>
 
 	if (!intel_has_sagv(dev_priv))
 		return false;
<span class="p_chunk">@@ -3019,27 +3035,36 @@</span> <span class="p_context"> bool intel_can_enable_sagv(struct drm_atomic_state *state)</span>
 
 	/* Since we&#39;re now guaranteed to only have one active CRTC... */
 	pipe = ffs(intel_state-&gt;active_crtcs) - 1;
<span class="p_del">-	crtc = dev_priv-&gt;pipe_to_crtc_mapping[pipe];</span>
<span class="p_add">+	crtc = to_intel_crtc(dev_priv-&gt;pipe_to_crtc_mapping[pipe]);</span>
 
<span class="p_del">-	if (crtc-&gt;state-&gt;mode.flags &amp; DRM_MODE_FLAG_INTERLACE)</span>
<span class="p_add">+	if (crtc-&gt;base.state-&gt;mode.flags &amp; DRM_MODE_FLAG_INTERLACE)</span>
 		return false;
 
<span class="p_del">-	for_each_plane(dev_priv, pipe, plane) {</span>
<span class="p_add">+	for_each_intel_plane_on_crtc(dev, crtc, plane) {</span>
<span class="p_add">+		id = skl_wm_plane_id(plane);</span>
<span class="p_add">+</span>
 		/* Skip this plane if it&#39;s not enabled */
<span class="p_del">-		if (intel_state-&gt;wm_results.plane[pipe][plane][0] == 0)</span>
<span class="p_add">+		if (intel_state-&gt;wm_results.plane[pipe][id][0] == 0)</span>
 			continue;
 
 		/* Find the highest enabled wm level for this plane */
 		for (level = ilk_wm_max_level(dev);
<span class="p_del">-		     intel_state-&gt;wm_results.plane[pipe][plane][level] == 0; --level)</span>
<span class="p_add">+		     intel_state-&gt;wm_results.plane[pipe][id][level] == 0; --level)</span>
 		     { }
 
<span class="p_add">+		latency = dev_priv-&gt;wm.skl_latency[level];</span>
<span class="p_add">+</span>
<span class="p_add">+		if (skl_needs_memory_bw_wa(intel_state) &amp;&amp;</span>
<span class="p_add">+		    plane-&gt;base.state-&gt;fb-&gt;modifier[0] ==</span>
<span class="p_add">+		    I915_FORMAT_MOD_X_TILED)</span>
<span class="p_add">+			latency += 15;</span>
<span class="p_add">+</span>
 		/*
 		 * If any of the planes on this pipe don&#39;t enable wm levels
 		 * that incur memory latencies higher then 30s we can&#39;t enable
 		 * the SAGV
 		 */
<span class="p_del">-		if (dev_priv-&gt;wm.skl_latency[level] &lt; SKL_SAGV_BLOCK_TIME)</span>
<span class="p_add">+		if (latency &lt; SKL_SAGV_BLOCK_TIME)</span>
 			return false;
 	}
 
<span class="p_chunk">@@ -3549,12 +3574,18 @@</span> <span class="p_context"> static int skl_compute_plane_wm(const struct drm_i915_private *dev_priv,</span>
 	uint32_t width = 0, height = 0;
 	uint32_t plane_pixel_rate;
 	uint32_t y_tile_minimum, y_min_scanlines;
<span class="p_add">+	struct intel_atomic_state *state =</span>
<span class="p_add">+		to_intel_atomic_state(cstate-&gt;base.state);</span>
<span class="p_add">+	bool apply_memory_bw_wa = skl_needs_memory_bw_wa(state);</span>
 
 	if (latency == 0 || !cstate-&gt;base.active || !intel_pstate-&gt;base.visible) {
 		*enabled = false;
 		return 0;
 	}
 
<span class="p_add">+	if (apply_memory_bw_wa &amp;&amp; fb-&gt;modifier[0] == I915_FORMAT_MOD_X_TILED)</span>
<span class="p_add">+		latency += 15;</span>
<span class="p_add">+</span>
 	width = drm_rect_width(&amp;intel_pstate-&gt;base.src) &gt;&gt; 16;
 	height = drm_rect_height(&amp;intel_pstate-&gt;base.src) &gt;&gt; 16;
 
<span class="p_chunk">@@ -3586,6 +3617,9 @@</span> <span class="p_context"> static int skl_compute_plane_wm(const struct drm_i915_private *dev_priv,</span>
 		y_min_scanlines = 4;
 	}
 
<span class="p_add">+	if (apply_memory_bw_wa)</span>
<span class="p_add">+		y_min_scanlines *= 2;</span>
<span class="p_add">+</span>
 	plane_bytes_per_line = width * cpp;
 	if (fb-&gt;modifier[0] == I915_FORMAT_MOD_Y_TILED ||
 	    fb-&gt;modifier[0] == I915_FORMAT_MOD_Yf_TILED) {
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_psr.c b/drivers/gpu/drm/i915/intel_psr.c</span>
<span class="p_header">index 108ba1e5d658..9b307cee3008 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_psr.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_psr.c</span>
<span class="p_chunk">@@ -825,13 +825,9 @@</span> <span class="p_context"> void intel_psr_init(struct drm_device *dev)</span>
 	dev_priv-&gt;psr_mmio_base = IS_HASWELL(dev_priv) ?
 		HSW_EDP_PSR_BASE : BDW_EDP_PSR_BASE;
 
<span class="p_del">-	/* Per platform default */</span>
<span class="p_del">-	if (i915.enable_psr == -1) {</span>
<span class="p_del">-		if (IS_HASWELL(dev) || IS_BROADWELL(dev))</span>
<span class="p_del">-			i915.enable_psr = 1;</span>
<span class="p_del">-		else</span>
<span class="p_del">-			i915.enable_psr = 0;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	/* Per platform default: all disabled. */</span>
<span class="p_add">+	if (i915.enable_psr == -1)</span>
<span class="p_add">+		i915.enable_psr = 0;</span>
 
 	/* Set link_standby x link_off defaults */
 	if (IS_HASWELL(dev) || IS_BROADWELL(dev))
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_cursor.c b/drivers/gpu/drm/radeon/radeon_cursor.c</span>
<span class="p_header">index 87a72476d313..fb16070b266e 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_cursor.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_cursor.c</span>
<span class="p_chunk">@@ -146,6 +146,9 @@</span> <span class="p_context"> static int radeon_cursor_move_locked(struct drm_crtc *crtc, int x, int y)</span>
 	int xorigin = 0, yorigin = 0;
 	int w = radeon_crtc-&gt;cursor_width;
 
<span class="p_add">+	radeon_crtc-&gt;cursor_x = x;</span>
<span class="p_add">+	radeon_crtc-&gt;cursor_y = y;</span>
<span class="p_add">+</span>
 	if (ASIC_IS_AVIVO(rdev)) {
 		/* avivo cursor are offset into the total surface */
 		x += crtc-&gt;x;
<span class="p_chunk">@@ -240,9 +243,6 @@</span> <span class="p_context"> static int radeon_cursor_move_locked(struct drm_crtc *crtc, int x, int y)</span>
 		       yorigin * 256);
 	}
 
<span class="p_del">-	radeon_crtc-&gt;cursor_x = x;</span>
<span class="p_del">-	radeon_crtc-&gt;cursor_y = y;</span>
<span class="p_del">-</span>
 	if (radeon_crtc-&gt;cursor_out_of_bounds) {
 		radeon_crtc-&gt;cursor_out_of_bounds = false;
 		if (radeon_crtc-&gt;cursor_bo)
<span class="p_header">diff --git a/drivers/hid/hid-sensor-hub.c b/drivers/hid/hid-sensor-hub.c</span>
<span class="p_header">index 60875625cbdf..8f6c35370f66 100644</span>
<span class="p_header">--- a/drivers/hid/hid-sensor-hub.c</span>
<span class="p_header">+++ b/drivers/hid/hid-sensor-hub.c</span>
<span class="p_chunk">@@ -212,7 +212,6 @@</span> <span class="p_context"> int sensor_hub_set_feature(struct hid_sensor_hub_device *hsdev, u32 report_id,</span>
 	__s32 value;
 	int ret = 0;
 
<span class="p_del">-	memset(buffer, 0, buffer_size);</span>
 	mutex_lock(&amp;data-&gt;mutex);
 	report = sensor_hub_report(report_id, hsdev-&gt;hdev, HID_FEATURE_REPORT);
 	if (!report || (field_index &gt;= report-&gt;maxfield)) {
<span class="p_chunk">@@ -256,6 +255,8 @@</span> <span class="p_context"> int sensor_hub_get_feature(struct hid_sensor_hub_device *hsdev, u32 report_id,</span>
 	int buffer_index = 0;
 	int i;
 
<span class="p_add">+	memset(buffer, 0, buffer_size);</span>
<span class="p_add">+</span>
 	mutex_lock(&amp;data-&gt;mutex);
 	report = sensor_hub_report(report_id, hsdev-&gt;hdev, HID_FEATURE_REPORT);
 	if (!report || (field_index &gt;= report-&gt;maxfield) ||
<span class="p_header">diff --git a/drivers/hwmon/amc6821.c b/drivers/hwmon/amc6821.c</span>
<span class="p_header">index 12e851a5af48..46b4e35fd555 100644</span>
<span class="p_header">--- a/drivers/hwmon/amc6821.c</span>
<span class="p_header">+++ b/drivers/hwmon/amc6821.c</span>
<span class="p_chunk">@@ -188,8 +188,8 @@</span> <span class="p_context"> static struct amc6821_data *amc6821_update_device(struct device *dev)</span>
 			!data-&gt;valid) {
 
 		for (i = 0; i &lt; TEMP_IDX_LEN; i++)
<span class="p_del">-			data-&gt;temp[i] = i2c_smbus_read_byte_data(client,</span>
<span class="p_del">-				temp_reg[i]);</span>
<span class="p_add">+			data-&gt;temp[i] = (int8_t)i2c_smbus_read_byte_data(</span>
<span class="p_add">+				client, temp_reg[i]);</span>
 
 		data-&gt;stat1 = i2c_smbus_read_byte_data(client,
 			AMC6821_REG_STAT1);
<span class="p_header">diff --git a/drivers/hwmon/ds620.c b/drivers/hwmon/ds620.c</span>
<span class="p_header">index edf550fc4eef..0043a4c02b85 100644</span>
<span class="p_header">--- a/drivers/hwmon/ds620.c</span>
<span class="p_header">+++ b/drivers/hwmon/ds620.c</span>
<span class="p_chunk">@@ -166,7 +166,7 @@</span> <span class="p_context"> static ssize_t set_temp(struct device *dev, struct device_attribute *da,</span>
 	if (res)
 		return res;
 
<span class="p_del">-	val = (val * 10 / 625) * 8;</span>
<span class="p_add">+	val = (clamp_val(val, -128000, 128000) * 10 / 625) * 8;</span>
 
 	mutex_lock(&amp;data-&gt;update_lock);
 	data-&gt;temp[attr-&gt;index] = val;
<span class="p_header">diff --git a/drivers/hwmon/g762.c b/drivers/hwmon/g762.c</span>
<span class="p_header">index b96a2a9e4df7..628be9c95ff9 100644</span>
<span class="p_header">--- a/drivers/hwmon/g762.c</span>
<span class="p_header">+++ b/drivers/hwmon/g762.c</span>
<span class="p_chunk">@@ -193,14 +193,17 @@</span> <span class="p_context"> static inline unsigned int rpm_from_cnt(u8 cnt, u32 clk_freq, u16 p,</span>
  * Convert fan RPM value from sysfs into count value for fan controller
  * register (FAN_SET_CNT).
  */
<span class="p_del">-static inline unsigned char cnt_from_rpm(u32 rpm, u32 clk_freq, u16 p,</span>
<span class="p_add">+static inline unsigned char cnt_from_rpm(unsigned long rpm, u32 clk_freq, u16 p,</span>
 					 u8 clk_div, u8 gear_mult)
 {
<span class="p_del">-	if (!rpm)         /* to stop the fan, set cnt to 255 */</span>
<span class="p_add">+	unsigned long f1 = clk_freq * 30 * gear_mult;</span>
<span class="p_add">+	unsigned long f2 = p * clk_div;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!rpm)	/* to stop the fan, set cnt to 255 */</span>
 		return 0xff;
 
<span class="p_del">-	return clamp_val(((clk_freq * 30 * gear_mult) / (rpm * p * clk_div)),</span>
<span class="p_del">-			 0, 255);</span>
<span class="p_add">+	rpm = clamp_val(rpm, f1 / (255 * f2), ULONG_MAX / f2);</span>
<span class="p_add">+	return DIV_ROUND_CLOSEST(f1, rpm * f2);</span>
 }
 
 /* helper to grab and cache data, at most one time per second */
<span class="p_header">diff --git a/drivers/hwmon/lm90.c b/drivers/hwmon/lm90.c</span>
<span class="p_header">index 322ed9272811..841f2428e84a 100644</span>
<span class="p_header">--- a/drivers/hwmon/lm90.c</span>
<span class="p_header">+++ b/drivers/hwmon/lm90.c</span>
<span class="p_chunk">@@ -1036,7 +1036,7 @@</span> <span class="p_context"> static const u8 lm90_temp_emerg_index[3] = {</span>
 };
 
 static const u8 lm90_min_alarm_bits[3] = { 5, 3, 11 };
<span class="p_del">-static const u8 lm90_max_alarm_bits[3] = { 0, 4, 12 };</span>
<span class="p_add">+static const u8 lm90_max_alarm_bits[3] = { 6, 4, 12 };</span>
 static const u8 lm90_crit_alarm_bits[3] = { 0, 1, 9 };
 static const u8 lm90_emergency_alarm_bits[3] = { 15, 13, 14 };
 static const u8 lm90_fault_bits[3] = { 0, 2, 10 };
<span class="p_header">diff --git a/drivers/hwmon/nct7802.c b/drivers/hwmon/nct7802.c</span>
<span class="p_header">index 3ce33d244cc0..12b94b094c0d 100644</span>
<span class="p_header">--- a/drivers/hwmon/nct7802.c</span>
<span class="p_header">+++ b/drivers/hwmon/nct7802.c</span>
<span class="p_chunk">@@ -259,13 +259,15 @@</span> <span class="p_context"> static int nct7802_read_fan_min(struct nct7802_data *data, u8 reg_fan_low,</span>
 		ret = 0;
 	else if (ret)
 		ret = DIV_ROUND_CLOSEST(1350000U, ret);
<span class="p_add">+	else</span>
<span class="p_add">+		ret = 1350000U;</span>
 abort:
 	mutex_unlock(&amp;data-&gt;access_lock);
 	return ret;
 }
 
 static int nct7802_write_fan_min(struct nct7802_data *data, u8 reg_fan_low,
<span class="p_del">-				 u8 reg_fan_high, unsigned int limit)</span>
<span class="p_add">+				 u8 reg_fan_high, unsigned long limit)</span>
 {
 	int err;
 
<span class="p_chunk">@@ -326,8 +328,8 @@</span> <span class="p_context"> static int nct7802_write_voltage(struct nct7802_data *data, int nr, int index,</span>
 	int shift = 8 - REG_VOLTAGE_LIMIT_MSB_SHIFT[index - 1][nr];
 	int err;
 
<span class="p_add">+	voltage = clamp_val(voltage, 0, 0x3ff * nct7802_vmul[nr]);</span>
 	voltage = DIV_ROUND_CLOSEST(voltage, nct7802_vmul[nr]);
<span class="p_del">-	voltage = clamp_val(voltage, 0, 0x3ff);</span>
 
 	mutex_lock(&amp;data-&gt;access_lock);
 	err = regmap_write(data-&gt;regmap,
<span class="p_chunk">@@ -402,7 +404,7 @@</span> <span class="p_context"> static ssize_t store_temp(struct device *dev, struct device_attribute *attr,</span>
 	if (err &lt; 0)
 		return err;
 
<span class="p_del">-	val = clamp_val(DIV_ROUND_CLOSEST(val, 1000), -128, 127);</span>
<span class="p_add">+	val = DIV_ROUND_CLOSEST(clamp_val(val, -128000, 127000), 1000);</span>
 
 	err = regmap_write(data-&gt;regmap, nr, val &amp; 0xff);
 	return err ? : count;
<span class="p_header">diff --git a/drivers/hwmon/scpi-hwmon.c b/drivers/hwmon/scpi-hwmon.c</span>
<span class="p_header">index 559a3dcd64d8..094f948f99ff 100644</span>
<span class="p_header">--- a/drivers/hwmon/scpi-hwmon.c</span>
<span class="p_header">+++ b/drivers/hwmon/scpi-hwmon.c</span>
<span class="p_chunk">@@ -251,6 +251,7 @@</span> <span class="p_context"> static const struct of_device_id scpi_of_match[] = {</span>
 	{.compatible = &quot;arm,scpi-sensors&quot;},
 	{},
 };
<span class="p_add">+MODULE_DEVICE_TABLE(of, scpi_of_match);</span>
 
 static struct platform_driver scpi_hwmon_platdrv = {
 	.driver = {
<span class="p_header">diff --git a/drivers/iio/accel/st_accel_core.c b/drivers/iio/accel/st_accel_core.c</span>
<span class="p_header">index ce69048c88e9..3a557e3181ea 100644</span>
<span class="p_header">--- a/drivers/iio/accel/st_accel_core.c</span>
<span class="p_header">+++ b/drivers/iio/accel/st_accel_core.c</span>
<span class="p_chunk">@@ -154,8 +154,8 @@</span> <span class="p_context"></span>
 #define ST_ACCEL_4_FS_MASK			0x80
 #define ST_ACCEL_4_FS_AVL_2_VAL			0X00
 #define ST_ACCEL_4_FS_AVL_6_VAL			0X01
<span class="p_del">-#define ST_ACCEL_4_FS_AVL_2_GAIN		IIO_G_TO_M_S_2(1024)</span>
<span class="p_del">-#define ST_ACCEL_4_FS_AVL_6_GAIN		IIO_G_TO_M_S_2(340)</span>
<span class="p_add">+#define ST_ACCEL_4_FS_AVL_2_GAIN		IIO_G_TO_M_S_2(1000)</span>
<span class="p_add">+#define ST_ACCEL_4_FS_AVL_6_GAIN		IIO_G_TO_M_S_2(3000)</span>
 #define ST_ACCEL_4_BDU_ADDR			0x21
 #define ST_ACCEL_4_BDU_MASK			0x40
 #define ST_ACCEL_4_DRDY_IRQ_ADDR		0x21
<span class="p_chunk">@@ -346,6 +346,14 @@</span> <span class="p_context"> static const struct st_sensor_settings st_accel_sensors_settings[] = {</span>
 			.addr = ST_ACCEL_1_BDU_ADDR,
 			.mask = ST_ACCEL_1_BDU_MASK,
 		},
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Data Alignment Setting - needs to be set to get</span>
<span class="p_add">+		 * left-justified data like all other sensors.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		.das = {</span>
<span class="p_add">+			.addr = 0x21,</span>
<span class="p_add">+			.mask = 0x01,</span>
<span class="p_add">+		},</span>
 		.drdy_irq = {
 			.addr = ST_ACCEL_1_DRDY_IRQ_ADDR,
 			.mask_int1 = ST_ACCEL_1_DRDY_IRQ_INT1_MASK,
<span class="p_header">diff --git a/drivers/iio/common/st_sensors/st_sensors_buffer.c b/drivers/iio/common/st_sensors/st_sensors_buffer.c</span>
<span class="p_header">index fe7775bb3740..df4045203a07 100644</span>
<span class="p_header">--- a/drivers/iio/common/st_sensors/st_sensors_buffer.c</span>
<span class="p_header">+++ b/drivers/iio/common/st_sensors/st_sensors_buffer.c</span>
<span class="p_chunk">@@ -30,7 +30,9 @@</span> <span class="p_context"> static int st_sensors_get_buffer_element(struct iio_dev *indio_dev, u8 *buf)</span>
 
 	for_each_set_bit(i, indio_dev-&gt;active_scan_mask, num_data_channels) {
 		const struct iio_chan_spec *channel = &amp;indio_dev-&gt;channels[i];
<span class="p_del">-		unsigned int bytes_to_read = channel-&gt;scan_type.realbits &gt;&gt; 3;</span>
<span class="p_add">+		unsigned int bytes_to_read =</span>
<span class="p_add">+			DIV_ROUND_UP(channel-&gt;scan_type.realbits +</span>
<span class="p_add">+				     channel-&gt;scan_type.shift, 8);</span>
 		unsigned int storage_bytes =
 			channel-&gt;scan_type.storagebits &gt;&gt; 3;
 
<span class="p_header">diff --git a/drivers/iio/common/st_sensors/st_sensors_core.c b/drivers/iio/common/st_sensors/st_sensors_core.c</span>
<span class="p_header">index 975a1f19f747..79c8c7cd70d5 100644</span>
<span class="p_header">--- a/drivers/iio/common/st_sensors/st_sensors_core.c</span>
<span class="p_header">+++ b/drivers/iio/common/st_sensors/st_sensors_core.c</span>
<span class="p_chunk">@@ -401,6 +401,15 @@</span> <span class="p_context"> int st_sensors_init_sensor(struct iio_dev *indio_dev,</span>
 			return err;
 	}
 
<span class="p_add">+	/* set DAS */</span>
<span class="p_add">+	if (sdata-&gt;sensor_settings-&gt;das.addr) {</span>
<span class="p_add">+		err = st_sensors_write_data_with_mask(indio_dev,</span>
<span class="p_add">+					sdata-&gt;sensor_settings-&gt;das.addr,</span>
<span class="p_add">+					sdata-&gt;sensor_settings-&gt;das.mask, 1);</span>
<span class="p_add">+		if (err &lt; 0)</span>
<span class="p_add">+			return err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (sdata-&gt;int_pin_open_drain) {
 		dev_info(&amp;indio_dev-&gt;dev,
 			 &quot;set interrupt line to open drain mode\n&quot;);
<span class="p_chunk">@@ -483,8 +492,10 @@</span> <span class="p_context"> static int st_sensors_read_axis_data(struct iio_dev *indio_dev,</span>
 	int err;
 	u8 *outdata;
 	struct st_sensor_data *sdata = iio_priv(indio_dev);
<span class="p_del">-	unsigned int byte_for_channel = ch-&gt;scan_type.realbits &gt;&gt; 3;</span>
<span class="p_add">+	unsigned int byte_for_channel;</span>
 
<span class="p_add">+	byte_for_channel = DIV_ROUND_UP(ch-&gt;scan_type.realbits +</span>
<span class="p_add">+					ch-&gt;scan_type.shift, 8);</span>
 	outdata = kmalloc(byte_for_channel, GFP_KERNEL);
 	if (!outdata)
 		return -ENOMEM;
<span class="p_header">diff --git a/drivers/iio/imu/bmi160/bmi160_core.c b/drivers/iio/imu/bmi160/bmi160_core.c</span>
<span class="p_header">index e0251b8c1a52..5fb571d03153 100644</span>
<span class="p_header">--- a/drivers/iio/imu/bmi160/bmi160_core.c</span>
<span class="p_header">+++ b/drivers/iio/imu/bmi160/bmi160_core.c</span>
<span class="p_chunk">@@ -66,10 +66,8 @@</span> <span class="p_context"></span>
 
 #define BMI160_REG_DUMMY		0x7F
 
<span class="p_del">-#define BMI160_ACCEL_PMU_MIN_USLEEP	3200</span>
<span class="p_del">-#define BMI160_ACCEL_PMU_MAX_USLEEP	3800</span>
<span class="p_del">-#define BMI160_GYRO_PMU_MIN_USLEEP	55000</span>
<span class="p_del">-#define BMI160_GYRO_PMU_MAX_USLEEP	80000</span>
<span class="p_add">+#define BMI160_ACCEL_PMU_MIN_USLEEP	3800</span>
<span class="p_add">+#define BMI160_GYRO_PMU_MIN_USLEEP	80000</span>
 #define BMI160_SOFTRESET_USLEEP		1000
 
 #define BMI160_CHANNEL(_type, _axis, _index) {			\
<span class="p_chunk">@@ -151,20 +149,9 @@</span> <span class="p_context"> static struct bmi160_regs bmi160_regs[] = {</span>
 	},
 };
 
<span class="p_del">-struct bmi160_pmu_time {</span>
<span class="p_del">-	unsigned long min;</span>
<span class="p_del">-	unsigned long max;</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-static struct bmi160_pmu_time bmi160_pmu_time[] = {</span>
<span class="p_del">-	[BMI160_ACCEL] = {</span>
<span class="p_del">-		.min = BMI160_ACCEL_PMU_MIN_USLEEP,</span>
<span class="p_del">-		.max = BMI160_ACCEL_PMU_MAX_USLEEP</span>
<span class="p_del">-	},</span>
<span class="p_del">-	[BMI160_GYRO] = {</span>
<span class="p_del">-		.min = BMI160_GYRO_PMU_MIN_USLEEP,</span>
<span class="p_del">-		.max = BMI160_GYRO_PMU_MIN_USLEEP,</span>
<span class="p_del">-	},</span>
<span class="p_add">+static unsigned long bmi160_pmu_time[] = {</span>
<span class="p_add">+	[BMI160_ACCEL] = BMI160_ACCEL_PMU_MIN_USLEEP,</span>
<span class="p_add">+	[BMI160_GYRO] = BMI160_GYRO_PMU_MIN_USLEEP,</span>
 };
 
 struct bmi160_scale {
<span class="p_chunk">@@ -289,7 +276,7 @@</span> <span class="p_context"> int bmi160_set_mode(struct bmi160_data *data, enum bmi160_sensor_type t,</span>
 	if (ret &lt; 0)
 		return ret;
 
<span class="p_del">-	usleep_range(bmi160_pmu_time[t].min, bmi160_pmu_time[t].max);</span>
<span class="p_add">+	usleep_range(bmi160_pmu_time[t], bmi160_pmu_time[t] + 1000);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/iio/light/max44000.c b/drivers/iio/light/max44000.c</span>
<span class="p_header">index 6511b20a2a29..a8ffa432bf0d 100644</span>
<span class="p_header">--- a/drivers/iio/light/max44000.c</span>
<span class="p_header">+++ b/drivers/iio/light/max44000.c</span>
<span class="p_chunk">@@ -113,7 +113,7 @@</span> <span class="p_context"> static const char max44000_int_time_avail_str[] =</span>
 	&quot;0.100 &quot;
 	&quot;0.025 &quot;
 	&quot;0.00625 &quot;
<span class="p_del">-	&quot;0.001625&quot;;</span>
<span class="p_add">+	&quot;0.0015625&quot;;</span>
 
 /* Available scales (internal to ulux) with pretty manual alignment: */
 static const int max44000_scale_avail_ulux_array[] = {
<span class="p_header">diff --git a/drivers/input/rmi4/rmi_f54.c b/drivers/input/rmi4/rmi_f54.c</span>
<span class="p_header">index cf805b960866..2e934aef3d2a 100644</span>
<span class="p_header">--- a/drivers/input/rmi4/rmi_f54.c</span>
<span class="p_header">+++ b/drivers/input/rmi4/rmi_f54.c</span>
<span class="p_chunk">@@ -200,7 +200,7 @@</span> <span class="p_context"> static int rmi_f54_request_report(struct rmi_function *fn, u8 report_type)</span>
 
 	error = rmi_write(rmi_dev, fn-&gt;fd.command_base_addr, F54_GET_REPORT);
 	if (error &lt; 0)
<span class="p_del">-		return error;</span>
<span class="p_add">+		goto unlock;</span>
 
 	init_completion(&amp;f54-&gt;cmd_done);
 
<span class="p_chunk">@@ -209,9 +209,10 @@</span> <span class="p_context"> static int rmi_f54_request_report(struct rmi_function *fn, u8 report_type)</span>
 
 	queue_delayed_work(f54-&gt;workqueue, &amp;f54-&gt;work, 0);
 
<span class="p_add">+unlock:</span>
 	mutex_unlock(&amp;f54-&gt;data_mutex);
 
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return error;</span>
 }
 
 static size_t rmi_f54_get_report_size(struct f54_data *f54)
<span class="p_header">diff --git a/drivers/iommu/amd_iommu.c b/drivers/iommu/amd_iommu.c</span>
<span class="p_header">index 754595ee11b6..11a13b5be73a 100644</span>
<span class="p_header">--- a/drivers/iommu/amd_iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/amd_iommu.c</span>
<span class="p_chunk">@@ -1021,7 +1021,7 @@</span> <span class="p_context"> static int __iommu_queue_command_sync(struct amd_iommu *iommu,</span>
 	next_tail = (tail + sizeof(*cmd)) % CMD_BUFFER_SIZE;
 	left      = (head - next_tail) % CMD_BUFFER_SIZE;
 
<span class="p_del">-	if (left &lt;= 2) {</span>
<span class="p_add">+	if (left &lt;= 0x20) {</span>
 		struct iommu_cmd sync_cmd;
 		int ret;
 
<span class="p_header">diff --git a/drivers/iommu/amd_iommu_v2.c b/drivers/iommu/amd_iommu_v2.c</span>
<span class="p_header">index 594849a3a9be..f8ed8c95b685 100644</span>
<span class="p_header">--- a/drivers/iommu/amd_iommu_v2.c</span>
<span class="p_header">+++ b/drivers/iommu/amd_iommu_v2.c</span>
<span class="p_chunk">@@ -805,8 +805,10 @@</span> <span class="p_context"> int amd_iommu_init_device(struct pci_dev *pdev, int pasids)</span>
 		goto out_free_domain;
 
 	group = iommu_group_get(&amp;pdev-&gt;dev);
<span class="p_del">-	if (!group)</span>
<span class="p_add">+	if (!group) {</span>
<span class="p_add">+		ret = -EINVAL;</span>
 		goto out_free_domain;
<span class="p_add">+	}</span>
 
 	ret = iommu_attach_group(dev_state-&gt;domain, group);
 	if (ret != 0)
<span class="p_header">diff --git a/drivers/iommu/intel-iommu.c b/drivers/iommu/intel-iommu.c</span>
<span class="p_header">index d8376c2d18b3..d82637ab09fd 100644</span>
<span class="p_header">--- a/drivers/iommu/intel-iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/intel-iommu.c</span>
<span class="p_chunk">@@ -2037,6 +2037,25 @@</span> <span class="p_context"> static int domain_context_mapping_one(struct dmar_domain *domain,</span>
 	if (context_present(context))
 		goto out_unlock;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * For kdump cases, old valid entries may be cached due to the</span>
<span class="p_add">+	 * in-flight DMA and copied pgtable, but there is no unmapping</span>
<span class="p_add">+	 * behaviour for them, thus we need an explicit cache flush for</span>
<span class="p_add">+	 * the newly-mapped device. For kdump, at this point, the device</span>
<span class="p_add">+	 * is supposed to finish reset at its driver probe stage, so no</span>
<span class="p_add">+	 * in-flight DMA will exist, and we don&#39;t need to worry anymore</span>
<span class="p_add">+	 * hereafter.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (context_copied(context)) {</span>
<span class="p_add">+		u16 did_old = context_domain_id(context);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (did_old &gt;= 0 &amp;&amp; did_old &lt; cap_ndoms(iommu-&gt;cap))</span>
<span class="p_add">+			iommu-&gt;flush.flush_context(iommu, did_old,</span>
<span class="p_add">+						   (((u16)bus) &lt;&lt; 8) | devfn,</span>
<span class="p_add">+						   DMA_CCMD_MASK_NOBIT,</span>
<span class="p_add">+						   DMA_CCMD_DEVICE_INVL);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	pgd = domain-&gt;pgd;
 
 	context_clear_entry(context);
<span class="p_chunk">@@ -5197,6 +5216,25 @@</span> <span class="p_context"> static void intel_iommu_remove_device(struct device *dev)</span>
 }
 
 #ifdef CONFIG_INTEL_IOMMU_SVM
<span class="p_add">+#define MAX_NR_PASID_BITS (20)</span>
<span class="p_add">+static inline unsigned long intel_iommu_get_pts(struct intel_iommu *iommu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Convert ecap_pss to extend context entry pts encoding, also</span>
<span class="p_add">+	 * respect the soft pasid_max value set by the iommu.</span>
<span class="p_add">+	 * - number of PASID bits = ecap_pss + 1</span>
<span class="p_add">+	 * - number of PASID table entries = 2^(pts + 5)</span>
<span class="p_add">+	 * Therefore, pts = ecap_pss - 4</span>
<span class="p_add">+	 * e.g. KBL ecap_pss = 0x13, PASID has 20 bits, pts = 15</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (ecap_pss(iommu-&gt;ecap) &lt; 5)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* pasid_max is encoded as actual number of entries not the bits */</span>
<span class="p_add">+	return find_first_bit((unsigned long *)&amp;iommu-&gt;pasid_max,</span>
<span class="p_add">+			MAX_NR_PASID_BITS) - 5;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int intel_iommu_enable_pasid(struct intel_iommu *iommu, struct intel_svm_dev *sdev)
 {
 	struct device_domain_info *info;
<span class="p_chunk">@@ -5229,7 +5267,9 @@</span> <span class="p_context"> int intel_iommu_enable_pasid(struct intel_iommu *iommu, struct intel_svm_dev *sd</span>
 
 	if (!(ctx_lo &amp; CONTEXT_PASIDE)) {
 		context[1].hi = (u64)virt_to_phys(iommu-&gt;pasid_state_table);
<span class="p_del">-		context[1].lo = (u64)virt_to_phys(iommu-&gt;pasid_table) | ecap_pss(iommu-&gt;ecap);</span>
<span class="p_add">+		context[1].lo = (u64)virt_to_phys(iommu-&gt;pasid_table) |</span>
<span class="p_add">+			intel_iommu_get_pts(iommu);</span>
<span class="p_add">+</span>
 		wmb();
 		/* CONTEXT_TT_MULTI_LEVEL and CONTEXT_TT_DEV_IOTLB are both
 		 * extended to permit requests-with-PASID if the PASIDE bit
<span class="p_header">diff --git a/drivers/irqchip/irq-bcm7038-l1.c b/drivers/irqchip/irq-bcm7038-l1.c</span>
<span class="p_header">index 353c54986211..c2662a1bfdd3 100644</span>
<span class="p_header">--- a/drivers/irqchip/irq-bcm7038-l1.c</span>
<span class="p_header">+++ b/drivers/irqchip/irq-bcm7038-l1.c</span>
<span class="p_chunk">@@ -215,6 +215,31 @@</span> <span class="p_context"> static int bcm7038_l1_set_affinity(struct irq_data *d,</span>
 	return 0;
 }
 
<span class="p_add">+static void bcm7038_l1_cpu_offline(struct irq_data *d)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct cpumask *mask = irq_data_get_affinity_mask(d);</span>
<span class="p_add">+	int cpu = smp_processor_id();</span>
<span class="p_add">+	cpumask_t new_affinity;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* This CPU was not on the affinity mask */</span>
<span class="p_add">+	if (!cpumask_test_cpu(cpu, mask))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (cpumask_weight(mask) &gt; 1) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Multiple CPU affinity, remove this CPU from the affinity</span>
<span class="p_add">+		 * mask</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		cpumask_copy(&amp;new_affinity, mask);</span>
<span class="p_add">+		cpumask_clear_cpu(cpu, &amp;new_affinity);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		/* Only CPU, put on the lowest online CPU */</span>
<span class="p_add">+		cpumask_clear(&amp;new_affinity);</span>
<span class="p_add">+		cpumask_set_cpu(cpumask_first(cpu_online_mask), &amp;new_affinity);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	irq_set_affinity_locked(d, &amp;new_affinity, false);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int __init bcm7038_l1_init_one(struct device_node *dn,
 				      unsigned int idx,
 				      struct bcm7038_l1_chip *intc)
<span class="p_chunk">@@ -266,6 +291,7 @@</span> <span class="p_context"> static struct irq_chip bcm7038_l1_irq_chip = {</span>
 	.irq_mask		= bcm7038_l1_mask,
 	.irq_unmask		= bcm7038_l1_unmask,
 	.irq_set_affinity	= bcm7038_l1_set_affinity,
<span class="p_add">+	.irq_cpu_offline	= bcm7038_l1_cpu_offline,</span>
 };
 
 static int bcm7038_l1_map(struct irq_domain *d, unsigned int virq,
<span class="p_header">diff --git a/drivers/md/md.c b/drivers/md/md.c</span>
<span class="p_header">index 2089d46b0eb8..24925f2aa235 100644</span>
<span class="p_header">--- a/drivers/md/md.c</span>
<span class="p_header">+++ b/drivers/md/md.c</span>
<span class="p_chunk">@@ -6829,7 +6829,7 @@</span> <span class="p_context"> static int md_ioctl(struct block_device *bdev, fmode_t mode,</span>
 		/* need to ensure recovery thread has run */
 		wait_event_interruptible_timeout(mddev-&gt;sb_wait,
 						 !test_bit(MD_RECOVERY_NEEDED,
<span class="p_del">-							   &amp;mddev-&gt;flags),</span>
<span class="p_add">+							   &amp;mddev-&gt;recovery),</span>
 						 msecs_to_jiffies(5000));
 	if (cmd == STOP_ARRAY || cmd == STOP_ARRAY_RO) {
 		/* Need to flush page cache, and ensure no-one else opens
<span class="p_chunk">@@ -7092,7 +7092,8 @@</span> <span class="p_context"> static int md_open(struct block_device *bdev, fmode_t mode)</span>
 
 	if (test_bit(MD_CLOSING, &amp;mddev-&gt;flags)) {
 		mutex_unlock(&amp;mddev-&gt;open_mutex);
<span class="p_del">-		return -ENODEV;</span>
<span class="p_add">+		err = -ENODEV;</span>
<span class="p_add">+		goto out;</span>
 	}
 
 	err = 0;
<span class="p_chunk">@@ -7101,6 +7102,8 @@</span> <span class="p_context"> static int md_open(struct block_device *bdev, fmode_t mode)</span>
 
 	check_disk_change(bdev);
  out:
<span class="p_add">+	if (err)</span>
<span class="p_add">+		mddev_put(mddev);</span>
 	return err;
 }
 
<span class="p_header">diff --git a/drivers/media/usb/dvb-usb/dibusb-common.c b/drivers/media/usb/dvb-usb/dibusb-common.c</span>
<span class="p_header">index de3ee2547479..8207e6900656 100644</span>
<span class="p_header">--- a/drivers/media/usb/dvb-usb/dibusb-common.c</span>
<span class="p_header">+++ b/drivers/media/usb/dvb-usb/dibusb-common.c</span>
<span class="p_chunk">@@ -382,9 +382,9 @@</span> <span class="p_context"> int dibusb_rc_query(struct dvb_usb_device *d, u32 *event, int *state)</span>
 	if (buf[0] != 0)
 		deb_info(&quot;key: %*ph\n&quot;, 5, buf);
 
<span class="p_add">+ret:</span>
 	kfree(buf);
 
<span class="p_del">-ret:</span>
 	return ret;
 }
 EXPORT_SYMBOL(dibusb_rc_query);
<span class="p_header">diff --git a/drivers/mfd/tps65217.c b/drivers/mfd/tps65217.c</span>
<span class="p_header">index 9a4d8684dd32..df2e7756927f 100644</span>
<span class="p_header">--- a/drivers/mfd/tps65217.c</span>
<span class="p_header">+++ b/drivers/mfd/tps65217.c</span>
<span class="p_chunk">@@ -424,6 +424,24 @@</span> <span class="p_context"> static int tps65217_probe(struct i2c_client *client,</span>
 	return 0;
 }
 
<span class="p_add">+static int tps65217_remove(struct i2c_client *client)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct tps65217 *tps = i2c_get_clientdata(client);</span>
<span class="p_add">+	unsigned int virq;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; ARRAY_SIZE(tps65217_irqs); i++) {</span>
<span class="p_add">+		virq = irq_find_mapping(tps-&gt;irq_domain, i);</span>
<span class="p_add">+		if (virq)</span>
<span class="p_add">+			irq_dispose_mapping(virq);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	irq_domain_remove(tps-&gt;irq_domain);</span>
<span class="p_add">+	tps-&gt;irq_domain = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static const struct i2c_device_id tps65217_id_table[] = {
 	{&quot;tps65217&quot;, TPS65217},
 	{ /* sentinel */ }
<span class="p_chunk">@@ -437,6 +455,7 @@</span> <span class="p_context"> static struct i2c_driver tps65217_driver = {</span>
 	},
 	.id_table	= tps65217_id_table,
 	.probe		= tps65217_probe,
<span class="p_add">+	.remove		= tps65217_remove,</span>
 };
 
 static int __init tps65217_init(void)
<span class="p_header">diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c</span>
<span class="p_header">index 8cac7ef9ad0d..dbe676de7a19 100644</span>
<span class="p_header">--- a/drivers/misc/mei/bus.c</span>
<span class="p_header">+++ b/drivers/misc/mei/bus.c</span>
<span class="p_chunk">@@ -408,7 +408,7 @@</span> <span class="p_context"> bool mei_cldev_enabled(struct mei_cl_device *cldev)</span>
 EXPORT_SYMBOL_GPL(mei_cldev_enabled);
 
 /**
<span class="p_del">- * mei_cldev_enable_device - enable me client device</span>
<span class="p_add">+ * mei_cldev_enable - enable me client device</span>
  *     create connection with me client
  *
  * @cldev: me client device
<span class="p_header">diff --git a/drivers/misc/mei/client.c b/drivers/misc/mei/client.c</span>
<span class="p_header">index f999a8d3c9c4..e2af61f7e3b6 100644</span>
<span class="p_header">--- a/drivers/misc/mei/client.c</span>
<span class="p_header">+++ b/drivers/misc/mei/client.c</span>
<span class="p_chunk">@@ -425,7 +425,7 @@</span> <span class="p_context"> static inline void mei_io_list_free(struct mei_cl_cb *list, struct mei_cl *cl)</span>
  *
  * @cl: host client
  * @length: size of the buffer
<span class="p_del">- * @type: operation type</span>
<span class="p_add">+ * @fop_type: operation type</span>
  * @fp: associated file pointer (might be NULL)
  *
  * Return: cb on success and NULL on failure
<span class="p_chunk">@@ -459,7 +459,7 @@</span> <span class="p_context"> struct mei_cl_cb *mei_cl_alloc_cb(struct mei_cl *cl, size_t length,</span>
  *
  * @cl: host client
  * @length: size of the buffer
<span class="p_del">- * @type: operation type</span>
<span class="p_add">+ * @fop_type: operation type</span>
  * @fp: associated file pointer (might be NULL)
  *
  * Return: cb on success and NULL on failure
<span class="p_chunk">@@ -1536,7 +1536,7 @@</span> <span class="p_context"> int mei_cl_irq_write(struct mei_cl *cl, struct mei_cl_cb *cb,</span>
 
 	rets = first_chunk ? mei_cl_tx_flow_ctrl_creds(cl) : 1;
 	if (rets &lt; 0)
<span class="p_del">-		return rets;</span>
<span class="p_add">+		goto err;</span>
 
 	if (rets == 0) {
 		cl_dbg(dev, cl, &quot;No flow control credentials: not sending.\n&quot;);
<span class="p_chunk">@@ -1570,11 +1570,8 @@</span> <span class="p_context"> int mei_cl_irq_write(struct mei_cl *cl, struct mei_cl_cb *cb,</span>
 			cb-&gt;buf.size, cb-&gt;buf_idx);
 
 	rets = mei_write_message(dev, &amp;mei_hdr, buf-&gt;data + cb-&gt;buf_idx);
<span class="p_del">-	if (rets) {</span>
<span class="p_del">-		cl-&gt;status = rets;</span>
<span class="p_del">-		list_move_tail(&amp;cb-&gt;list, &amp;cmpl_list-&gt;list);</span>
<span class="p_del">-		return rets;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (rets)</span>
<span class="p_add">+		goto err;</span>
 
 	cl-&gt;status = 0;
 	cl-&gt;writing_state = MEI_WRITING;
<span class="p_chunk">@@ -1582,14 +1579,21 @@</span> <span class="p_context"> int mei_cl_irq_write(struct mei_cl *cl, struct mei_cl_cb *cb,</span>
 	cb-&gt;completed = mei_hdr.msg_complete == 1;
 
 	if (first_chunk) {
<span class="p_del">-		if (mei_cl_tx_flow_ctrl_creds_reduce(cl))</span>
<span class="p_del">-			return -EIO;</span>
<span class="p_add">+		if (mei_cl_tx_flow_ctrl_creds_reduce(cl)) {</span>
<span class="p_add">+			rets = -EIO;</span>
<span class="p_add">+			goto err;</span>
<span class="p_add">+		}</span>
 	}
 
 	if (mei_hdr.msg_complete)
 		list_move_tail(&amp;cb-&gt;list, &amp;dev-&gt;write_waiting_list.list);
 
 	return 0;
<span class="p_add">+</span>
<span class="p_add">+err:</span>
<span class="p_add">+	cl-&gt;status = rets;</span>
<span class="p_add">+	list_move_tail(&amp;cb-&gt;list, &amp;cmpl_list-&gt;list);</span>
<span class="p_add">+	return rets;</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/mmc/card/mmc_test.c b/drivers/mmc/card/mmc_test.c</span>
<span class="p_header">index 3678220964fe..df382be62634 100644</span>
<span class="p_header">--- a/drivers/mmc/card/mmc_test.c</span>
<span class="p_header">+++ b/drivers/mmc/card/mmc_test.c</span>
<span class="p_chunk">@@ -818,7 +818,7 @@</span> <span class="p_context"> static int mmc_test_nonblock_transfer(struct mmc_test_card *test,</span>
 	struct mmc_async_req *cur_areq = &amp;test_areq[0].areq;
 	struct mmc_async_req *other_areq = &amp;test_areq[1].areq;
 	int i;
<span class="p_del">-	int ret;</span>
<span class="p_add">+	int ret = RESULT_OK;</span>
 
 	test_areq[0].test = test;
 	test_areq[1].test = test;
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath10k/core.h b/drivers/net/wireless/ath/ath10k/core.h</span>
<span class="p_header">index 521f1c55c19e..be5b527472f9 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath10k/core.h</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath10k/core.h</span>
<span class="p_chunk">@@ -557,10 +557,8 @@</span> <span class="p_context"> enum ath10k_fw_features {</span>
 	 */
 	ATH10K_FW_FEATURE_BTCOEX_PARAM = 14,
 
<span class="p_del">-	/* Older firmware with HTT delivers incorrect tx status for null func</span>
<span class="p_del">-	 * frames to driver, but this fixed in 10.2 and 10.4 firmware versions.</span>
<span class="p_del">-	 * Also this workaround results in reporting of incorrect null func</span>
<span class="p_del">-	 * status for 10.4. This flag is used to skip the workaround.</span>
<span class="p_add">+	/* Unused flag and proven to be not working, enable this if you want</span>
<span class="p_add">+	 * to experiment sending NULL func data frames in HTT TX</span>
 	 */
 	ATH10K_FW_FEATURE_SKIP_NULL_FUNC_WAR = 15,
 
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath10k/mac.c b/drivers/net/wireless/ath/ath10k/mac.c</span>
<span class="p_header">index 90eeb1c82e8b..f2e85eb22afe 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath10k/mac.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath10k/mac.c</span>
<span class="p_chunk">@@ -3255,8 +3255,6 @@</span> <span class="p_context"> ath10k_mac_tx_h_get_txmode(struct ath10k *ar,</span>
 	if (ar-&gt;htt.target_version_major &lt; 3 &amp;&amp;
 	    (ieee80211_is_nullfunc(fc) || ieee80211_is_qos_nullfunc(fc)) &amp;&amp;
 	    !test_bit(ATH10K_FW_FEATURE_HAS_WMI_MGMT_TX,
<span class="p_del">-		      ar-&gt;running_fw-&gt;fw_file.fw_features) &amp;&amp;</span>
<span class="p_del">-	    !test_bit(ATH10K_FW_FEATURE_SKIP_NULL_FUNC_WAR,</span>
 		      ar-&gt;running_fw-&gt;fw_file.fw_features))
 		return ATH10K_HW_TXRX_MGMT;
 
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath10k/spectral.c b/drivers/net/wireless/ath/ath10k/spectral.c</span>
<span class="p_header">index 7d9b0da1b010..2ffc1fe4923b 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath10k/spectral.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath10k/spectral.c</span>
<span class="p_chunk">@@ -338,7 +338,7 @@</span> <span class="p_context"> static ssize_t write_file_spec_scan_ctl(struct file *file,</span>
 		} else {
 			res = -EINVAL;
 		}
<span class="p_del">-	} else if (strncmp(&quot;background&quot;, buf, 9) == 0) {</span>
<span class="p_add">+	} else if (strncmp(&quot;background&quot;, buf, 10) == 0) {</span>
 		res = ath10k_spectral_scan_config(ar, SPECTRAL_BACKGROUND);
 	} else if (strncmp(&quot;manual&quot;, buf, 6) == 0) {
 		res = ath10k_spectral_scan_config(ar, SPECTRAL_MANUAL);
<span class="p_header">diff --git a/drivers/net/wireless/realtek/rtlwifi/base.c b/drivers/net/wireless/realtek/rtlwifi/base.c</span>
<span class="p_header">index 4ac928bf1f8e..264466f59c57 100644</span>
<span class="p_header">--- a/drivers/net/wireless/realtek/rtlwifi/base.c</span>
<span class="p_header">+++ b/drivers/net/wireless/realtek/rtlwifi/base.c</span>
<span class="p_chunk">@@ -1303,13 +1303,12 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(rtl_action_proc);</span>
 
 static void setup_arp_tx(struct rtl_priv *rtlpriv, struct rtl_ps_ctl *ppsc)
 {
<span class="p_del">-	struct ieee80211_hw *hw = rtlpriv-&gt;hw;</span>
<span class="p_del">-</span>
 	rtlpriv-&gt;ra.is_special_data = true;
 	if (rtlpriv-&gt;cfg-&gt;ops-&gt;get_btc_status())
 		rtlpriv-&gt;btcoexist.btc_ops-&gt;btc_special_packet_notify(
 					rtlpriv, 1);
<span class="p_del">-	rtl_lps_leave(hw);</span>
<span class="p_add">+	rtlpriv-&gt;enter_ps = false;</span>
<span class="p_add">+	schedule_work(&amp;rtlpriv-&gt;works.lps_change_work);</span>
 	ppsc-&gt;last_delaylps_stamp_jiffies = jiffies;
 }
 
<span class="p_chunk">@@ -1382,7 +1381,8 @@</span> <span class="p_context"> u8 rtl_is_special_data(struct ieee80211_hw *hw, struct sk_buff *skb, u8 is_tx,</span>
 
 		if (is_tx) {
 			rtlpriv-&gt;ra.is_special_data = true;
<span class="p_del">-			rtl_lps_leave(hw);</span>
<span class="p_add">+			rtlpriv-&gt;enter_ps = false;</span>
<span class="p_add">+			schedule_work(&amp;rtlpriv-&gt;works.lps_change_work);</span>
 			ppsc-&gt;last_delaylps_stamp_jiffies = jiffies;
 		}
 
<span class="p_header">diff --git a/drivers/net/wireless/realtek/rtlwifi/core.c b/drivers/net/wireless/realtek/rtlwifi/core.c</span>
<span class="p_header">index 4da4e458142c..8e7f23c11680 100644</span>
<span class="p_header">--- a/drivers/net/wireless/realtek/rtlwifi/core.c</span>
<span class="p_header">+++ b/drivers/net/wireless/realtek/rtlwifi/core.c</span>
<span class="p_chunk">@@ -1150,8 +1150,10 @@</span> <span class="p_context"> static void rtl_op_bss_info_changed(struct ieee80211_hw *hw,</span>
 		} else {
 			mstatus = RT_MEDIA_DISCONNECT;
 
<span class="p_del">-			if (mac-&gt;link_state == MAC80211_LINKED)</span>
<span class="p_del">-				rtl_lps_leave(hw);</span>
<span class="p_add">+			if (mac-&gt;link_state == MAC80211_LINKED) {</span>
<span class="p_add">+				rtlpriv-&gt;enter_ps = false;</span>
<span class="p_add">+				schedule_work(&amp;rtlpriv-&gt;works.lps_change_work);</span>
<span class="p_add">+			}</span>
 			if (ppsc-&gt;p2p_ps_info.p2p_ps_mode &gt; P2P_PS_NONE)
 				rtl_p2p_ps_cmd(hw, P2P_PS_DISABLE);
 			mac-&gt;link_state = MAC80211_NOLINK;
<span class="p_chunk">@@ -1429,7 +1431,8 @@</span> <span class="p_context"> static void rtl_op_sw_scan_start(struct ieee80211_hw *hw,</span>
 	}
 
 	if (mac-&gt;link_state == MAC80211_LINKED) {
<span class="p_del">-		rtl_lps_leave(hw);</span>
<span class="p_add">+		rtlpriv-&gt;enter_ps = false;</span>
<span class="p_add">+		schedule_work(&amp;rtlpriv-&gt;works.lps_change_work);</span>
 		mac-&gt;link_state = MAC80211_LINKED_SCANNING;
 	} else {
 		rtl_ips_nic_on(hw);
<span class="p_header">diff --git a/drivers/net/wireless/realtek/rtlwifi/pci.c b/drivers/net/wireless/realtek/rtlwifi/pci.c</span>
<span class="p_header">index 5be4fc96002d..0dfa9eac3926 100644</span>
<span class="p_header">--- a/drivers/net/wireless/realtek/rtlwifi/pci.c</span>
<span class="p_header">+++ b/drivers/net/wireless/realtek/rtlwifi/pci.c</span>
<span class="p_chunk">@@ -663,9 +663,11 @@</span> <span class="p_context"> static void _rtl_pci_tx_isr(struct ieee80211_hw *hw, int prio)</span>
 	}
 
 	if (((rtlpriv-&gt;link_info.num_rx_inperiod +
<span class="p_del">-	      rtlpriv-&gt;link_info.num_tx_inperiod) &gt; 8) ||</span>
<span class="p_del">-	      (rtlpriv-&gt;link_info.num_rx_inperiod &gt; 2))</span>
<span class="p_del">-		rtl_lps_leave(hw);</span>
<span class="p_add">+		rtlpriv-&gt;link_info.num_tx_inperiod) &gt; 8) ||</span>
<span class="p_add">+		(rtlpriv-&gt;link_info.num_rx_inperiod &gt; 2)) {</span>
<span class="p_add">+		rtlpriv-&gt;enter_ps = false;</span>
<span class="p_add">+		schedule_work(&amp;rtlpriv-&gt;works.lps_change_work);</span>
<span class="p_add">+	}</span>
 }
 
 static int _rtl_pci_init_one_rxdesc(struct ieee80211_hw *hw,
<span class="p_chunk">@@ -916,8 +918,10 @@</span> <span class="p_context"> static void _rtl_pci_rx_interrupt(struct ieee80211_hw *hw)</span>
 		}
 		if (((rtlpriv-&gt;link_info.num_rx_inperiod +
 		      rtlpriv-&gt;link_info.num_tx_inperiod) &gt; 8) ||
<span class="p_del">-		      (rtlpriv-&gt;link_info.num_rx_inperiod &gt; 2))</span>
<span class="p_del">-			rtl_lps_leave(hw);</span>
<span class="p_add">+		      (rtlpriv-&gt;link_info.num_rx_inperiod &gt; 2)) {</span>
<span class="p_add">+			rtlpriv-&gt;enter_ps = false;</span>
<span class="p_add">+			schedule_work(&amp;rtlpriv-&gt;works.lps_change_work);</span>
<span class="p_add">+		}</span>
 		skb = new_skb;
 no_new:
 		if (rtlpriv-&gt;use_new_trx_flow) {
<span class="p_header">diff --git a/drivers/net/wireless/realtek/rtlwifi/ps.c b/drivers/net/wireless/realtek/rtlwifi/ps.c</span>
<span class="p_header">index d0ffc4d508cf..18d979affc18 100644</span>
<span class="p_header">--- a/drivers/net/wireless/realtek/rtlwifi/ps.c</span>
<span class="p_header">+++ b/drivers/net/wireless/realtek/rtlwifi/ps.c</span>
<span class="p_chunk">@@ -407,8 +407,8 @@</span> <span class="p_context"> void rtl_lps_set_psmode(struct ieee80211_hw *hw, u8 rt_psmode)</span>
 	}
 }
 
<span class="p_del">-/* Interrupt safe routine to enter the leisure power save mode.*/</span>
<span class="p_del">-static void rtl_lps_enter_core(struct ieee80211_hw *hw)</span>
<span class="p_add">+/*Enter the leisure power save mode.*/</span>
<span class="p_add">+void rtl_lps_enter(struct ieee80211_hw *hw)</span>
 {
 	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));
 	struct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));
<span class="p_chunk">@@ -444,9 +444,10 @@</span> <span class="p_context"> static void rtl_lps_enter_core(struct ieee80211_hw *hw)</span>
 
 	spin_unlock_irqrestore(&amp;rtlpriv-&gt;locks.lps_lock, flag);
 }
<span class="p_add">+EXPORT_SYMBOL(rtl_lps_enter);</span>
 
<span class="p_del">-/* Interrupt safe routine to leave the leisure power save mode.*/</span>
<span class="p_del">-static void rtl_lps_leave_core(struct ieee80211_hw *hw)</span>
<span class="p_add">+/*Leave the leisure power save mode.*/</span>
<span class="p_add">+void rtl_lps_leave(struct ieee80211_hw *hw)</span>
 {
 	struct rtl_priv *rtlpriv = rtl_priv(hw);
 	struct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));
<span class="p_chunk">@@ -476,6 +477,7 @@</span> <span class="p_context"> static void rtl_lps_leave_core(struct ieee80211_hw *hw)</span>
 	}
 	spin_unlock_irqrestore(&amp;rtlpriv-&gt;locks.lps_lock, flag);
 }
<span class="p_add">+EXPORT_SYMBOL(rtl_lps_leave);</span>
 
 /* For sw LPS*/
 void rtl_swlps_beacon(struct ieee80211_hw *hw, void *data, unsigned int len)
<span class="p_chunk">@@ -668,34 +670,12 @@</span> <span class="p_context"> void rtl_lps_change_work_callback(struct work_struct *work)</span>
 	struct rtl_priv *rtlpriv = rtl_priv(hw);
 
 	if (rtlpriv-&gt;enter_ps)
<span class="p_del">-		rtl_lps_enter_core(hw);</span>
<span class="p_add">+		rtl_lps_enter(hw);</span>
 	else
<span class="p_del">-		rtl_lps_leave_core(hw);</span>
<span class="p_add">+		rtl_lps_leave(hw);</span>
 }
 EXPORT_SYMBOL_GPL(rtl_lps_change_work_callback);
 
<span class="p_del">-void rtl_lps_enter(struct ieee80211_hw *hw)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct rtl_priv *rtlpriv = rtl_priv(hw);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!in_interrupt())</span>
<span class="p_del">-		return rtl_lps_enter_core(hw);</span>
<span class="p_del">-	rtlpriv-&gt;enter_ps = true;</span>
<span class="p_del">-	schedule_work(&amp;rtlpriv-&gt;works.lps_change_work);</span>
<span class="p_del">-}</span>
<span class="p_del">-EXPORT_SYMBOL_GPL(rtl_lps_enter);</span>
<span class="p_del">-</span>
<span class="p_del">-void rtl_lps_leave(struct ieee80211_hw *hw)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct rtl_priv *rtlpriv = rtl_priv(hw);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!in_interrupt())</span>
<span class="p_del">-		return rtl_lps_leave_core(hw);</span>
<span class="p_del">-	rtlpriv-&gt;enter_ps = false;</span>
<span class="p_del">-	schedule_work(&amp;rtlpriv-&gt;works.lps_change_work);</span>
<span class="p_del">-}</span>
<span class="p_del">-EXPORT_SYMBOL_GPL(rtl_lps_leave);</span>
<span class="p_del">-</span>
 void rtl_swlps_wq_callback(void *data)
 {
 	struct rtl_works *rtlworks = container_of_dwork_rtl(data,
<span class="p_header">diff --git a/drivers/pci/host/pcie-rockchip.c b/drivers/pci/host/pcie-rockchip.c</span>
<span class="p_header">index e04f69beb42d..3452983d3569 100644</span>
<span class="p_header">--- a/drivers/pci/host/pcie-rockchip.c</span>
<span class="p_header">+++ b/drivers/pci/host/pcie-rockchip.c</span>
<span class="p_chunk">@@ -533,7 +533,7 @@</span> <span class="p_context"> static int rockchip_pcie_init_port(struct rockchip_pcie *rockchip)</span>
 
 	/* Fix the transmitted FTS count desired to exit from L0s. */
 	status = rockchip_pcie_read(rockchip, PCIE_CORE_CTRL_PLC1);
<span class="p_del">-	status = (status &amp; PCIE_CORE_CTRL_PLC1_FTS_MASK) |</span>
<span class="p_add">+	status = (status &amp; ~PCIE_CORE_CTRL_PLC1_FTS_MASK) |</span>
 		 (PCIE_CORE_CTRL_PLC1_FTS_CNT &lt;&lt; PCIE_CORE_CTRL_PLC1_FTS_SHIFT);
 	rockchip_pcie_write(rockchip, status, PCIE_CORE_CTRL_PLC1);
 
<span class="p_chunk">@@ -590,8 +590,8 @@</span> <span class="p_context"> static int rockchip_pcie_init_port(struct rockchip_pcie *rockchip)</span>
 
 	/* Check the final link width from negotiated lane counter from MGMT */
 	status = rockchip_pcie_read(rockchip, PCIE_CORE_CTRL);
<span class="p_del">-	status =  0x1 &lt;&lt; ((status &amp; PCIE_CORE_PL_CONF_LANE_MASK) &gt;&gt;</span>
<span class="p_del">-			  PCIE_CORE_PL_CONF_LANE_MASK);</span>
<span class="p_add">+	status = 0x1 &lt;&lt; ((status &amp; PCIE_CORE_PL_CONF_LANE_MASK) &gt;&gt;</span>
<span class="p_add">+			  PCIE_CORE_PL_CONF_LANE_SHIFT);</span>
 	dev_dbg(dev, &quot;current link width is x%d\n&quot;, status);
 
 	rockchip_pcie_write(rockchip, ROCKCHIP_VENDOR_ID,
<span class="p_header">diff --git a/drivers/pci/hotplug/rpadlpar_core.c b/drivers/pci/hotplug/rpadlpar_core.c</span>
<span class="p_header">index dc67f39779ec..c614ff7c3bc3 100644</span>
<span class="p_header">--- a/drivers/pci/hotplug/rpadlpar_core.c</span>
<span class="p_header">+++ b/drivers/pci/hotplug/rpadlpar_core.c</span>
<span class="p_chunk">@@ -257,8 +257,13 @@</span> <span class="p_context"> static int dlpar_add_phb(char *drc_name, struct device_node *dn)</span>
 
 static int dlpar_add_vio_slot(char *drc_name, struct device_node *dn)
 {
<span class="p_del">-	if (vio_find_node(dn))</span>
<span class="p_add">+	struct vio_dev *vio_dev;</span>
<span class="p_add">+</span>
<span class="p_add">+	vio_dev = vio_find_node(dn);</span>
<span class="p_add">+	if (vio_dev) {</span>
<span class="p_add">+		put_device(&amp;vio_dev-&gt;dev);</span>
 		return -EINVAL;
<span class="p_add">+	}</span>
 
 	if (!vio_register_device_node(dn)) {
 		printk(KERN_ERR
<span class="p_chunk">@@ -334,6 +339,9 @@</span> <span class="p_context"> static int dlpar_remove_vio_slot(char *drc_name, struct device_node *dn)</span>
 		return -EINVAL;
 
 	vio_unregister_device(vio_dev);
<span class="p_add">+</span>
<span class="p_add">+	put_device(&amp;vio_dev-&gt;dev);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/pci/msi.c b/drivers/pci/msi.c</span>
<span class="p_header">index ad70507cfb56..3455f752d5e4 100644</span>
<span class="p_header">--- a/drivers/pci/msi.c</span>
<span class="p_header">+++ b/drivers/pci/msi.c</span>
<span class="p_chunk">@@ -1294,7 +1294,8 @@</span> <span class="p_context"> const struct cpumask *pci_irq_get_affinity(struct pci_dev *dev, int nr)</span>
 	} else if (dev-&gt;msi_enabled) {
 		struct msi_desc *entry = first_pci_msi_entry(dev);
 
<span class="p_del">-		if (WARN_ON_ONCE(!entry || nr &gt;= entry-&gt;nvec_used))</span>
<span class="p_add">+		if (WARN_ON_ONCE(!entry || !entry-&gt;affinity ||</span>
<span class="p_add">+				 nr &gt;= entry-&gt;nvec_used))</span>
 			return NULL;
 
 		return &amp;entry-&gt;affinity[nr];
<span class="p_header">diff --git a/drivers/pci/quirks.c b/drivers/pci/quirks.c</span>
<span class="p_header">index c232729f5b1b..3a035e073889 100644</span>
<span class="p_header">--- a/drivers/pci/quirks.c</span>
<span class="p_header">+++ b/drivers/pci/quirks.c</span>
<span class="p_chunk">@@ -3137,8 +3137,9 @@</span> <span class="p_context"> DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x22b5, quirk_remove_d3_delay);</span>
 DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x22b7, quirk_remove_d3_delay);
 DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x2298, quirk_remove_d3_delay);
 DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x229c, quirk_remove_d3_delay);
<span class="p_add">+</span>
 /*
<span class="p_del">- * Some devices may pass our check in pci_intx_mask_supported if</span>
<span class="p_add">+ * Some devices may pass our check in pci_intx_mask_supported() if</span>
  * PCI_COMMAND_INTX_DISABLE works though they actually do not properly
  * support this feature.
  */
<span class="p_chunk">@@ -3146,53 +3147,139 @@</span> <span class="p_context"> static void quirk_broken_intx_masking(struct pci_dev *dev)</span>
 {
 	dev-&gt;broken_intx_masking = 1;
 }
<span class="p_del">-DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_CHELSIO, 0x0030,</span>
<span class="p_del">-			 quirk_broken_intx_masking);</span>
<span class="p_del">-DECLARE_PCI_FIXUP_HEADER(0x1814, 0x0601, /* Ralink RT2800 802.11n PCI */</span>
<span class="p_del">-			 quirk_broken_intx_masking);</span>
<span class="p_add">+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_CHELSIO, 0x0030,</span>
<span class="p_add">+			quirk_broken_intx_masking);</span>
<span class="p_add">+DECLARE_PCI_FIXUP_FINAL(0x1814, 0x0601, /* Ralink RT2800 802.11n PCI */</span>
<span class="p_add">+			quirk_broken_intx_masking);</span>
<span class="p_add">+</span>
 /*
  * Realtek RTL8169 PCI Gigabit Ethernet Controller (rev 10)
  * Subsystem: Realtek RTL8169/8110 Family PCI Gigabit Ethernet NIC
  *
  * RTL8110SC - Fails under PCI device assignment using DisINTx masking.
  */
<span class="p_del">-DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_REALTEK, 0x8169,</span>
<span class="p_del">-			 quirk_broken_intx_masking);</span>
<span class="p_del">-DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_MELLANOX, PCI_ANY_ID,</span>
<span class="p_del">-			 quirk_broken_intx_masking);</span>
<span class="p_add">+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_REALTEK, 0x8169,</span>
<span class="p_add">+			quirk_broken_intx_masking);</span>
 
 /*
  * Intel i40e (XL710/X710) 10/20/40GbE NICs all have broken INTx masking,
  * DisINTx can be set but the interrupt status bit is non-functional.
  */
<span class="p_del">-DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x1572,</span>
<span class="p_del">-			 quirk_broken_intx_masking);</span>
<span class="p_del">-DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x1574,</span>
<span class="p_del">-			 quirk_broken_intx_masking);</span>
<span class="p_del">-DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x1580,</span>
<span class="p_del">-			 quirk_broken_intx_masking);</span>
<span class="p_del">-DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x1581,</span>
<span class="p_del">-			 quirk_broken_intx_masking);</span>
<span class="p_del">-DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x1583,</span>
<span class="p_del">-			 quirk_broken_intx_masking);</span>
<span class="p_del">-DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x1584,</span>
<span class="p_del">-			 quirk_broken_intx_masking);</span>
<span class="p_del">-DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x1585,</span>
<span class="p_del">-			 quirk_broken_intx_masking);</span>
<span class="p_del">-DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x1586,</span>
<span class="p_del">-			 quirk_broken_intx_masking);</span>
<span class="p_del">-DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x1587,</span>
<span class="p_del">-			 quirk_broken_intx_masking);</span>
<span class="p_del">-DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x1588,</span>
<span class="p_del">-			 quirk_broken_intx_masking);</span>
<span class="p_del">-DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x1589,</span>
<span class="p_del">-			 quirk_broken_intx_masking);</span>
<span class="p_del">-DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x37d0,</span>
<span class="p_del">-			 quirk_broken_intx_masking);</span>
<span class="p_del">-DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x37d1,</span>
<span class="p_del">-			 quirk_broken_intx_masking);</span>
<span class="p_del">-DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x37d2,</span>
<span class="p_del">-			 quirk_broken_intx_masking);</span>
<span class="p_add">+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x1572,</span>
<span class="p_add">+			quirk_broken_intx_masking);</span>
<span class="p_add">+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x1574,</span>
<span class="p_add">+			quirk_broken_intx_masking);</span>
<span class="p_add">+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x1580,</span>
<span class="p_add">+			quirk_broken_intx_masking);</span>
<span class="p_add">+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x1581,</span>
<span class="p_add">+			quirk_broken_intx_masking);</span>
<span class="p_add">+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x1583,</span>
<span class="p_add">+			quirk_broken_intx_masking);</span>
<span class="p_add">+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x1584,</span>
<span class="p_add">+			quirk_broken_intx_masking);</span>
<span class="p_add">+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x1585,</span>
<span class="p_add">+			quirk_broken_intx_masking);</span>
<span class="p_add">+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x1586,</span>
<span class="p_add">+			quirk_broken_intx_masking);</span>
<span class="p_add">+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x1587,</span>
<span class="p_add">+			quirk_broken_intx_masking);</span>
<span class="p_add">+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x1588,</span>
<span class="p_add">+			quirk_broken_intx_masking);</span>
<span class="p_add">+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x1589,</span>
<span class="p_add">+			quirk_broken_intx_masking);</span>
<span class="p_add">+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x37d0,</span>
<span class="p_add">+			quirk_broken_intx_masking);</span>
<span class="p_add">+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x37d1,</span>
<span class="p_add">+			quirk_broken_intx_masking);</span>
<span class="p_add">+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x37d2,</span>
<span class="p_add">+			quirk_broken_intx_masking);</span>
<span class="p_add">+</span>
<span class="p_add">+static u16 mellanox_broken_intx_devs[] = {</span>
<span class="p_add">+	PCI_DEVICE_ID_MELLANOX_HERMON_SDR,</span>
<span class="p_add">+	PCI_DEVICE_ID_MELLANOX_HERMON_DDR,</span>
<span class="p_add">+	PCI_DEVICE_ID_MELLANOX_HERMON_QDR,</span>
<span class="p_add">+	PCI_DEVICE_ID_MELLANOX_HERMON_DDR_GEN2,</span>
<span class="p_add">+	PCI_DEVICE_ID_MELLANOX_HERMON_QDR_GEN2,</span>
<span class="p_add">+	PCI_DEVICE_ID_MELLANOX_HERMON_EN,</span>
<span class="p_add">+	PCI_DEVICE_ID_MELLANOX_HERMON_EN_GEN2,</span>
<span class="p_add">+	PCI_DEVICE_ID_MELLANOX_CONNECTX_EN,</span>
<span class="p_add">+	PCI_DEVICE_ID_MELLANOX_CONNECTX_EN_T_GEN2,</span>
<span class="p_add">+	PCI_DEVICE_ID_MELLANOX_CONNECTX_EN_GEN2,</span>
<span class="p_add">+	PCI_DEVICE_ID_MELLANOX_CONNECTX_EN_5_GEN2,</span>
<span class="p_add">+	PCI_DEVICE_ID_MELLANOX_CONNECTX2,</span>
<span class="p_add">+	PCI_DEVICE_ID_MELLANOX_CONNECTX3,</span>
<span class="p_add">+	PCI_DEVICE_ID_MELLANOX_CONNECTX3_PRO,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+#define CONNECTX_4_CURR_MAX_MINOR 99</span>
<span class="p_add">+#define CONNECTX_4_INTX_SUPPORT_MINOR 14</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Check ConnectX-4/LX FW version to see if it supports legacy interrupts.</span>
<span class="p_add">+ * If so, don&#39;t mark it as broken.</span>
<span class="p_add">+ * FW minor &gt; 99 means older FW version format and no INTx masking support.</span>
<span class="p_add">+ * FW minor &lt; 14 means new FW version format and no INTx masking support.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void mellanox_check_broken_intx_masking(struct pci_dev *pdev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	__be32 __iomem *fw_ver;</span>
<span class="p_add">+	u16 fw_major;</span>
<span class="p_add">+	u16 fw_minor;</span>
<span class="p_add">+	u16 fw_subminor;</span>
<span class="p_add">+	u32 fw_maj_min;</span>
<span class="p_add">+	u32 fw_sub_min;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; ARRAY_SIZE(mellanox_broken_intx_devs); i++) {</span>
<span class="p_add">+		if (pdev-&gt;device == mellanox_broken_intx_devs[i]) {</span>
<span class="p_add">+			pdev-&gt;broken_intx_masking = 1;</span>
<span class="p_add">+			return;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Getting here means Connect-IB cards and up. Connect-IB has no INTx</span>
<span class="p_add">+	 * support so shouldn&#39;t be checked further</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (pdev-&gt;device == PCI_DEVICE_ID_MELLANOX_CONNECTIB)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (pdev-&gt;device != PCI_DEVICE_ID_MELLANOX_CONNECTX4 &amp;&amp;</span>
<span class="p_add">+	    pdev-&gt;device != PCI_DEVICE_ID_MELLANOX_CONNECTX4_LX)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* For ConnectX-4 and ConnectX-4LX, need to check FW support */</span>
<span class="p_add">+	if (pci_enable_device_mem(pdev)) {</span>
<span class="p_add">+		dev_warn(&amp;pdev-&gt;dev, &quot;Can&#39;t enable device memory\n&quot;);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	fw_ver = ioremap(pci_resource_start(pdev, 0), 4);</span>
<span class="p_add">+	if (!fw_ver) {</span>
<span class="p_add">+		dev_warn(&amp;pdev-&gt;dev, &quot;Can&#39;t map ConnectX-4 initialization segment\n&quot;);</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Reading from resource space should be 32b aligned */</span>
<span class="p_add">+	fw_maj_min = ioread32be(fw_ver);</span>
<span class="p_add">+	fw_sub_min = ioread32be(fw_ver + 1);</span>
<span class="p_add">+	fw_major = fw_maj_min &amp; 0xffff;</span>
<span class="p_add">+	fw_minor = fw_maj_min &gt;&gt; 16;</span>
<span class="p_add">+	fw_subminor = fw_sub_min &amp; 0xffff;</span>
<span class="p_add">+	if (fw_minor &gt; CONNECTX_4_CURR_MAX_MINOR ||</span>
<span class="p_add">+	    fw_minor &lt; CONNECTX_4_INTX_SUPPORT_MINOR) {</span>
<span class="p_add">+		dev_warn(&amp;pdev-&gt;dev, &quot;ConnectX-4: FW %u.%u.%u doesn&#39;t support INTx masking, disabling. Please upgrade FW to %d.14.1100 and up for INTx support\n&quot;,</span>
<span class="p_add">+			 fw_major, fw_minor, fw_subminor, pdev-&gt;device ==</span>
<span class="p_add">+			 PCI_DEVICE_ID_MELLANOX_CONNECTX4 ? 12 : 14);</span>
<span class="p_add">+		pdev-&gt;broken_intx_masking = 1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	iounmap(fw_ver);</span>
<span class="p_add">+</span>
<span class="p_add">+out:</span>
<span class="p_add">+	pci_disable_device(pdev);</span>
<span class="p_add">+}</span>
<span class="p_add">+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_MELLANOX, PCI_ANY_ID,</span>
<span class="p_add">+			mellanox_check_broken_intx_masking);</span>
 
 static void quirk_no_bus_reset(struct pci_dev *dev)
 {
<span class="p_chunk">@@ -3255,6 +3342,25 @@</span> <span class="p_context"> DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_CACTUS_RIDGE_4C</span>
 DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_PORT_RIDGE,
 			quirk_thunderbolt_hotplug_msi);
 
<span class="p_add">+static void quirk_chelsio_extend_vpd(struct pci_dev *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pci_set_vpd_size(dev, 8192);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_CHELSIO, 0x20, quirk_chelsio_extend_vpd);</span>
<span class="p_add">+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_CHELSIO, 0x21, quirk_chelsio_extend_vpd);</span>
<span class="p_add">+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_CHELSIO, 0x22, quirk_chelsio_extend_vpd);</span>
<span class="p_add">+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_CHELSIO, 0x23, quirk_chelsio_extend_vpd);</span>
<span class="p_add">+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_CHELSIO, 0x24, quirk_chelsio_extend_vpd);</span>
<span class="p_add">+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_CHELSIO, 0x25, quirk_chelsio_extend_vpd);</span>
<span class="p_add">+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_CHELSIO, 0x26, quirk_chelsio_extend_vpd);</span>
<span class="p_add">+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_CHELSIO, 0x30, quirk_chelsio_extend_vpd);</span>
<span class="p_add">+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_CHELSIO, 0x31, quirk_chelsio_extend_vpd);</span>
<span class="p_add">+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_CHELSIO, 0x32, quirk_chelsio_extend_vpd);</span>
<span class="p_add">+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_CHELSIO, 0x35, quirk_chelsio_extend_vpd);</span>
<span class="p_add">+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_CHELSIO, 0x36, quirk_chelsio_extend_vpd);</span>
<span class="p_add">+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_CHELSIO, 0x37, quirk_chelsio_extend_vpd);</span>
<span class="p_add">+</span>
 #ifdef CONFIG_ACPI
 /*
  * Apple: Shutdown Cactus Ridge Thunderbolt controller.
<span class="p_header">diff --git a/drivers/pinctrl/pinctrl-amd.c b/drivers/pinctrl/pinctrl-amd.c</span>
<span class="p_header">index aea310a91821..c9a146948192 100644</span>
<span class="p_header">--- a/drivers/pinctrl/pinctrl-amd.c</span>
<span class="p_header">+++ b/drivers/pinctrl/pinctrl-amd.c</span>
<span class="p_chunk">@@ -382,26 +382,21 @@</span> <span class="p_context"> static int amd_gpio_irq_set_type(struct irq_data *d, unsigned int type)</span>
 {
 	int ret = 0;
 	u32 pin_reg;
<span class="p_del">-	unsigned long flags;</span>
<span class="p_del">-	bool level_trig;</span>
<span class="p_del">-	u32 active_level;</span>
<span class="p_add">+	unsigned long flags, irq_flags;</span>
 	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
 	struct amd_gpio *gpio_dev = gpiochip_get_data(gc);
 
 	spin_lock_irqsave(&amp;gpio_dev-&gt;lock, flags);
 	pin_reg = readl(gpio_dev-&gt;base + (d-&gt;hwirq)*4);
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * When level_trig is set EDGE and active_level is set HIGH in BIOS</span>
<span class="p_del">-	 * default settings, ignore incoming settings from client and use</span>
<span class="p_del">-	 * BIOS settings to configure GPIO register.</span>
<span class="p_add">+	/* Ignore the settings coming from the client and</span>
<span class="p_add">+	 * read the values from the ACPI tables</span>
<span class="p_add">+	 * while setting the trigger type</span>
 	 */
<span class="p_del">-	level_trig = !(pin_reg &amp; (LEVEL_TRIGGER &lt;&lt; LEVEL_TRIG_OFF));</span>
<span class="p_del">-	active_level = pin_reg &amp; (ACTIVE_LEVEL_MASK &lt;&lt; ACTIVE_LEVEL_OFF);</span>
 
<span class="p_del">-	if(level_trig &amp;&amp;</span>
<span class="p_del">-	   ((active_level &gt;&gt; ACTIVE_LEVEL_OFF) == ACTIVE_HIGH))</span>
<span class="p_del">-		type = IRQ_TYPE_EDGE_FALLING;</span>
<span class="p_add">+	irq_flags = irq_get_trigger_type(d-&gt;irq);</span>
<span class="p_add">+	if (irq_flags != IRQ_TYPE_NONE)</span>
<span class="p_add">+		type = irq_flags;</span>
 
 	switch (type &amp; IRQ_TYPE_SENSE_MASK) {
 	case IRQ_TYPE_EDGE_RISING:
<span class="p_header">diff --git a/drivers/platform/x86/fujitsu-laptop.c b/drivers/platform/x86/fujitsu-laptop.c</span>
<span class="p_header">index 61f39abf5dc8..82d67715ce76 100644</span>
<span class="p_header">--- a/drivers/platform/x86/fujitsu-laptop.c</span>
<span class="p_header">+++ b/drivers/platform/x86/fujitsu-laptop.c</span>
<span class="p_chunk">@@ -177,43 +177,43 @@</span> <span class="p_context"> static void acpi_fujitsu_hotkey_notify(struct acpi_device *device, u32 event);</span>
 
 #if IS_ENABLED(CONFIG_LEDS_CLASS)
 static enum led_brightness logolamp_get(struct led_classdev *cdev);
<span class="p_del">-static void logolamp_set(struct led_classdev *cdev,</span>
<span class="p_add">+static int logolamp_set(struct led_classdev *cdev,</span>
 			       enum led_brightness brightness);
 
 static struct led_classdev logolamp_led = {
  .name = &quot;fujitsu::logolamp&quot;,
  .brightness_get = logolamp_get,
<span class="p_del">- .brightness_set = logolamp_set</span>
<span class="p_add">+ .brightness_set_blocking = logolamp_set</span>
 };
 
 static enum led_brightness kblamps_get(struct led_classdev *cdev);
<span class="p_del">-static void kblamps_set(struct led_classdev *cdev,</span>
<span class="p_add">+static int kblamps_set(struct led_classdev *cdev,</span>
 			       enum led_brightness brightness);
 
 static struct led_classdev kblamps_led = {
  .name = &quot;fujitsu::kblamps&quot;,
  .brightness_get = kblamps_get,
<span class="p_del">- .brightness_set = kblamps_set</span>
<span class="p_add">+ .brightness_set_blocking = kblamps_set</span>
 };
 
 static enum led_brightness radio_led_get(struct led_classdev *cdev);
<span class="p_del">-static void radio_led_set(struct led_classdev *cdev,</span>
<span class="p_add">+static int radio_led_set(struct led_classdev *cdev,</span>
 			       enum led_brightness brightness);
 
 static struct led_classdev radio_led = {
  .name = &quot;fujitsu::radio_led&quot;,
  .brightness_get = radio_led_get,
<span class="p_del">- .brightness_set = radio_led_set</span>
<span class="p_add">+ .brightness_set_blocking = radio_led_set</span>
 };
 
 static enum led_brightness eco_led_get(struct led_classdev *cdev);
<span class="p_del">-static void eco_led_set(struct led_classdev *cdev,</span>
<span class="p_add">+static int eco_led_set(struct led_classdev *cdev,</span>
 			       enum led_brightness brightness);
 
 static struct led_classdev eco_led = {
  .name = &quot;fujitsu::eco_led&quot;,
  .brightness_get = eco_led_get,
<span class="p_del">- .brightness_set = eco_led_set</span>
<span class="p_add">+ .brightness_set_blocking = eco_led_set</span>
 };
 #endif
 
<span class="p_chunk">@@ -267,48 +267,48 @@</span> <span class="p_context"> static int call_fext_func(int cmd, int arg0, int arg1, int arg2)</span>
 #if IS_ENABLED(CONFIG_LEDS_CLASS)
 /* LED class callbacks */
 
<span class="p_del">-static void logolamp_set(struct led_classdev *cdev,</span>
<span class="p_add">+static int logolamp_set(struct led_classdev *cdev,</span>
 			       enum led_brightness brightness)
 {
 	if (brightness &gt;= LED_FULL) {
 		call_fext_func(FUNC_LEDS, 0x1, LOGOLAMP_POWERON, FUNC_LED_ON);
<span class="p_del">-		call_fext_func(FUNC_LEDS, 0x1, LOGOLAMP_ALWAYS, FUNC_LED_ON);</span>
<span class="p_add">+		return call_fext_func(FUNC_LEDS, 0x1, LOGOLAMP_ALWAYS, FUNC_LED_ON);</span>
 	} else if (brightness &gt;= LED_HALF) {
 		call_fext_func(FUNC_LEDS, 0x1, LOGOLAMP_POWERON, FUNC_LED_ON);
<span class="p_del">-		call_fext_func(FUNC_LEDS, 0x1, LOGOLAMP_ALWAYS, FUNC_LED_OFF);</span>
<span class="p_add">+		return call_fext_func(FUNC_LEDS, 0x1, LOGOLAMP_ALWAYS, FUNC_LED_OFF);</span>
 	} else {
<span class="p_del">-		call_fext_func(FUNC_LEDS, 0x1, LOGOLAMP_POWERON, FUNC_LED_OFF);</span>
<span class="p_add">+		return call_fext_func(FUNC_LEDS, 0x1, LOGOLAMP_POWERON, FUNC_LED_OFF);</span>
 	}
 }
 
<span class="p_del">-static void kblamps_set(struct led_classdev *cdev,</span>
<span class="p_add">+static int kblamps_set(struct led_classdev *cdev,</span>
 			       enum led_brightness brightness)
 {
 	if (brightness &gt;= LED_FULL)
<span class="p_del">-		call_fext_func(FUNC_LEDS, 0x1, KEYBOARD_LAMPS, FUNC_LED_ON);</span>
<span class="p_add">+		return call_fext_func(FUNC_LEDS, 0x1, KEYBOARD_LAMPS, FUNC_LED_ON);</span>
 	else
<span class="p_del">-		call_fext_func(FUNC_LEDS, 0x1, KEYBOARD_LAMPS, FUNC_LED_OFF);</span>
<span class="p_add">+		return call_fext_func(FUNC_LEDS, 0x1, KEYBOARD_LAMPS, FUNC_LED_OFF);</span>
 }
 
<span class="p_del">-static void radio_led_set(struct led_classdev *cdev,</span>
<span class="p_add">+static int radio_led_set(struct led_classdev *cdev,</span>
 				enum led_brightness brightness)
 {
 	if (brightness &gt;= LED_FULL)
<span class="p_del">-		call_fext_func(FUNC_RFKILL, 0x5, RADIO_LED_ON, RADIO_LED_ON);</span>
<span class="p_add">+		return call_fext_func(FUNC_RFKILL, 0x5, RADIO_LED_ON, RADIO_LED_ON);</span>
 	else
<span class="p_del">-		call_fext_func(FUNC_RFKILL, 0x5, RADIO_LED_ON, 0x0);</span>
<span class="p_add">+		return call_fext_func(FUNC_RFKILL, 0x5, RADIO_LED_ON, 0x0);</span>
 }
 
<span class="p_del">-static void eco_led_set(struct led_classdev *cdev,</span>
<span class="p_add">+static int eco_led_set(struct led_classdev *cdev,</span>
 				enum led_brightness brightness)
 {
 	int curr;
 
 	curr = call_fext_func(FUNC_LEDS, 0x2, ECO_LED, 0x0);
 	if (brightness &gt;= LED_FULL)
<span class="p_del">-		call_fext_func(FUNC_LEDS, 0x1, ECO_LED, curr | ECO_LED_ON);</span>
<span class="p_add">+		return call_fext_func(FUNC_LEDS, 0x1, ECO_LED, curr | ECO_LED_ON);</span>
 	else
<span class="p_del">-		call_fext_func(FUNC_LEDS, 0x1, ECO_LED, curr &amp; ~ECO_LED_ON);</span>
<span class="p_add">+		return call_fext_func(FUNC_LEDS, 0x1, ECO_LED, curr &amp; ~ECO_LED_ON);</span>
 }
 
 static enum led_brightness logolamp_get(struct led_classdev *cdev)
<span class="p_header">diff --git a/drivers/rpmsg/qcom_smd.c b/drivers/rpmsg/qcom_smd.c</span>
<span class="p_header">index 06fef2b4c814..1d4770c02e57 100644</span>
<span class="p_header">--- a/drivers/rpmsg/qcom_smd.c</span>
<span class="p_header">+++ b/drivers/rpmsg/qcom_smd.c</span>
<span class="p_chunk">@@ -739,7 +739,7 @@</span> <span class="p_context"> static int __qcom_smd_send(struct qcom_smd_channel *channel, const void *data,</span>
 
 	while (qcom_smd_get_tx_avail(channel) &lt; tlen) {
 		if (!wait) {
<span class="p_del">-			ret = -ENOMEM;</span>
<span class="p_add">+			ret = -EAGAIN;</span>
 			goto out;
 		}
 
<span class="p_header">diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c</span>
<span class="p_header">index cbf010324c18..596a75924d90 100644</span>
<span class="p_header">--- a/drivers/scsi/g_NCR5380.c</span>
<span class="p_header">+++ b/drivers/scsi/g_NCR5380.c</span>
<span class="p_chunk">@@ -170,12 +170,12 @@</span> <span class="p_context"> static int generic_NCR5380_init_one(struct scsi_host_template *tpnt,</span>
 		if (ports[i]) {
 			/* At this point we have our region reserved */
 			magic_configure(i, 0, magic); /* no IRQ yet */
<span class="p_del">-			outb(0xc0, ports[i] + 9);</span>
<span class="p_del">-			if (inb(ports[i] + 9) != 0x80) {</span>
<span class="p_add">+			base = ports[i];</span>
<span class="p_add">+			outb(0xc0, base + 9);</span>
<span class="p_add">+			if (inb(base + 9) != 0x80) {</span>
 				ret = -ENODEV;
 				goto out_release;
 			}
<span class="p_del">-			base = ports[i];</span>
 			port_idx = i;
 		} else
 			return -EINVAL;
<span class="p_header">diff --git a/drivers/scsi/mvsas/mv_94xx.c b/drivers/scsi/mvsas/mv_94xx.c</span>
<span class="p_header">index 4c57d9abce7b..7de5d8d75480 100644</span>
<span class="p_header">--- a/drivers/scsi/mvsas/mv_94xx.c</span>
<span class="p_header">+++ b/drivers/scsi/mvsas/mv_94xx.c</span>
<span class="p_chunk">@@ -668,7 +668,7 @@</span> <span class="p_context"> static void mvs_94xx_command_active(struct mvs_info *mvi, u32 slot_idx)</span>
 {
 	u32 tmp;
 	tmp = mvs_cr32(mvi, MVS_COMMAND_ACTIVE+(slot_idx &gt;&gt; 3));
<span class="p_del">-	if (tmp &amp;&amp; 1 &lt;&lt; (slot_idx % 32)) {</span>
<span class="p_add">+	if (tmp &amp; 1 &lt;&lt; (slot_idx % 32)) {</span>
 		mv_printk(&quot;command active %08X,  slot [%x].\n&quot;, tmp, slot_idx);
 		mvs_cw32(mvi, MVS_COMMAND_ACTIVE + (slot_idx &gt;&gt; 3),
 			1 &lt;&lt; (slot_idx % 32));
<span class="p_header">diff --git a/drivers/staging/iio/adc/ad7606_core.c b/drivers/staging/iio/adc/ad7606_core.c</span>
<span class="p_header">index f79ee61851f6..cbd6bc52050f 100644</span>
<span class="p_header">--- a/drivers/staging/iio/adc/ad7606_core.c</span>
<span class="p_header">+++ b/drivers/staging/iio/adc/ad7606_core.c</span>
<span class="p_chunk">@@ -189,7 +189,7 @@</span> <span class="p_context"> static ssize_t ad7606_store_oversampling_ratio(struct device *dev,</span>
 	mutex_lock(&amp;indio_dev-&gt;mlock);
 	gpio_set_value(st-&gt;pdata-&gt;gpio_os0, (ret &gt;&gt; 0) &amp; 1);
 	gpio_set_value(st-&gt;pdata-&gt;gpio_os1, (ret &gt;&gt; 1) &amp; 1);
<span class="p_del">-	gpio_set_value(st-&gt;pdata-&gt;gpio_os1, (ret &gt;&gt; 2) &amp; 1);</span>
<span class="p_add">+	gpio_set_value(st-&gt;pdata-&gt;gpio_os2, (ret &gt;&gt; 2) &amp; 1);</span>
 	st-&gt;oversampling = lval;
 	mutex_unlock(&amp;indio_dev-&gt;mlock);
 
<span class="p_header">diff --git a/drivers/staging/media/davinci_vpfe/vpfe_video.c b/drivers/staging/media/davinci_vpfe/vpfe_video.c</span>
<span class="p_header">index 8be9f854510f..89dd6b989254 100644</span>
<span class="p_header">--- a/drivers/staging/media/davinci_vpfe/vpfe_video.c</span>
<span class="p_header">+++ b/drivers/staging/media/davinci_vpfe/vpfe_video.c</span>
<span class="p_chunk">@@ -1362,7 +1362,7 @@</span> <span class="p_context"> static int vpfe_reqbufs(struct file *file, void *priv,</span>
 	ret = vb2_queue_init(q);
 	if (ret) {
 		v4l2_err(&amp;vpfe_dev-&gt;v4l2_dev, &quot;vb2_queue_init() failed\n&quot;);
<span class="p_del">-		return ret;</span>
<span class="p_add">+		goto unlock_out;</span>
 	}
 
 	fh-&gt;io_allowed = 1;
<span class="p_header">diff --git a/drivers/staging/octeon/ethernet.c b/drivers/staging/octeon/ethernet.c</span>
<span class="p_header">index d02e3e31ed29..12354440a334 100644</span>
<span class="p_header">--- a/drivers/staging/octeon/ethernet.c</span>
<span class="p_header">+++ b/drivers/staging/octeon/ethernet.c</span>
<span class="p_chunk">@@ -776,6 +776,7 @@</span> <span class="p_context"> static int cvm_oct_probe(struct platform_device *pdev)</span>
 			/* Initialize the device private structure. */
 			struct octeon_ethernet *priv = netdev_priv(dev);
 
<span class="p_add">+			SET_NETDEV_DEV(dev, &amp;pdev-&gt;dev);</span>
 			dev-&gt;netdev_ops = &amp;cvm_oct_pow_netdev_ops;
 			priv-&gt;imode = CVMX_HELPER_INTERFACE_MODE_DISABLED;
 			priv-&gt;port = CVMX_PIP_NUM_INPUT_PORTS;
<span class="p_chunk">@@ -820,6 +821,7 @@</span> <span class="p_context"> static int cvm_oct_probe(struct platform_device *pdev)</span>
 			}
 
 			/* Initialize the device private structure. */
<span class="p_add">+			SET_NETDEV_DEV(dev, &amp;pdev-&gt;dev);</span>
 			priv = netdev_priv(dev);
 			priv-&gt;netdev = dev;
 			priv-&gt;of_node = cvm_oct_node_for_port(pip, interface,
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target_tpg.c b/drivers/target/iscsi/iscsi_target_tpg.c</span>
<span class="p_header">index 0814e5894a96..205a509b0dfb 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target_tpg.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target_tpg.c</span>
<span class="p_chunk">@@ -260,7 +260,6 @@</span> <span class="p_context"> int iscsit_tpg_add_portal_group(struct iscsi_tiqn *tiqn, struct iscsi_portal_gro</span>
 		iscsi_release_param_list(tpg-&gt;param_list);
 		tpg-&gt;param_list = NULL;
 	}
<span class="p_del">-	kfree(tpg);</span>
 	return -ENOMEM;
 }
 
<span class="p_header">diff --git a/drivers/target/sbp/sbp_target.c b/drivers/target/sbp/sbp_target.c</span>
<span class="p_header">index 58bb6ed18185..6ca388eca33b 100644</span>
<span class="p_header">--- a/drivers/target/sbp/sbp_target.c</span>
<span class="p_header">+++ b/drivers/target/sbp/sbp_target.c</span>
<span class="p_chunk">@@ -928,7 +928,7 @@</span> <span class="p_context"> static struct sbp_target_request *sbp_mgt_get_req(struct sbp_session *sess,</span>
 	struct sbp_target_request *req;
 	int tag;
 
<span class="p_del">-	tag = percpu_ida_alloc(&amp;se_sess-&gt;sess_tag_pool, GFP_ATOMIC);</span>
<span class="p_add">+	tag = percpu_ida_alloc(&amp;se_sess-&gt;sess_tag_pool, TASK_RUNNING);</span>
 	if (tag &lt; 0)
 		return ERR_PTR(-ENOMEM);
 
<span class="p_header">diff --git a/drivers/usb/core/config.c b/drivers/usb/core/config.c</span>
<span class="p_header">index a2d90aca779f..1f7036c8f57b 100644</span>
<span class="p_header">--- a/drivers/usb/core/config.c</span>
<span class="p_header">+++ b/drivers/usb/core/config.c</span>
<span class="p_chunk">@@ -234,6 +234,16 @@</span> <span class="p_context"> static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,</span>
 	if (ifp-&gt;desc.bNumEndpoints &gt;= num_ep)
 		goto skip_to_next_endpoint_or_interface_descriptor;
 
<span class="p_add">+	/* Check for duplicate endpoint addresses */</span>
<span class="p_add">+	for (i = 0; i &lt; ifp-&gt;desc.bNumEndpoints; ++i) {</span>
<span class="p_add">+		if (ifp-&gt;endpoint[i].desc.bEndpointAddress ==</span>
<span class="p_add">+		    d-&gt;bEndpointAddress) {</span>
<span class="p_add">+			dev_warn(ddev, &quot;config %d interface %d altsetting %d has a duplicate endpoint with address 0x%X, skipping\n&quot;,</span>
<span class="p_add">+			    cfgno, inum, asnum, d-&gt;bEndpointAddress);</span>
<span class="p_add">+			goto skip_to_next_endpoint_or_interface_descriptor;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	endpoint = &amp;ifp-&gt;endpoint[ifp-&gt;desc.bNumEndpoints];
 	++ifp-&gt;desc.bNumEndpoints;
 
<span class="p_header">diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c</span>
<span class="p_header">index 0d81436c94bd..aef81a16e2c8 100644</span>
<span class="p_header">--- a/drivers/usb/core/hub.c</span>
<span class="p_header">+++ b/drivers/usb/core/hub.c</span>
<span class="p_chunk">@@ -101,8 +101,7 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(ehci_cf_port_reset_rwsem);</span>
 
 static void hub_release(struct kref *kref);
 static int usb_reset_and_verify_device(struct usb_device *udev);
<span class="p_del">-static void hub_usb3_port_prepare_disable(struct usb_hub *hub,</span>
<span class="p_del">-					  struct usb_port *port_dev);</span>
<span class="p_add">+static int hub_port_disable(struct usb_hub *hub, int port1, int set_state);</span>
 
 static inline char *portspeed(struct usb_hub *hub, int portstatus)
 {
<span class="p_chunk">@@ -901,34 +900,6 @@</span> <span class="p_context"> static int hub_set_port_link_state(struct usb_hub *hub, int port1,</span>
 }
 
 /*
<span class="p_del">- * USB-3 does not have a similar link state as USB-2 that will avoid negotiating</span>
<span class="p_del">- * a connection with a plugged-in cable but will signal the host when the cable</span>
<span class="p_del">- * is unplugged. Disable remote wake and set link state to U3 for USB-3 devices</span>
<span class="p_del">- */</span>
<span class="p_del">-static int hub_port_disable(struct usb_hub *hub, int port1, int set_state)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct usb_port *port_dev = hub-&gt;ports[port1 - 1];</span>
<span class="p_del">-	struct usb_device *hdev = hub-&gt;hdev;</span>
<span class="p_del">-	int ret = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!hub-&gt;error) {</span>
<span class="p_del">-		if (hub_is_superspeed(hub-&gt;hdev)) {</span>
<span class="p_del">-			hub_usb3_port_prepare_disable(hub, port_dev);</span>
<span class="p_del">-			ret = hub_set_port_link_state(hub, port_dev-&gt;portnum,</span>
<span class="p_del">-						      USB_SS_PORT_LS_U3);</span>
<span class="p_del">-		} else {</span>
<span class="p_del">-			ret = usb_clear_port_feature(hdev, port1,</span>
<span class="p_del">-					USB_PORT_FEAT_ENABLE);</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-	if (port_dev-&gt;child &amp;&amp; set_state)</span>
<span class="p_del">-		usb_set_device_state(port_dev-&gt;child, USB_STATE_NOTATTACHED);</span>
<span class="p_del">-	if (ret &amp;&amp; ret != -ENODEV)</span>
<span class="p_del">-		dev_err(&amp;port_dev-&gt;dev, &quot;cannot disable (err = %d)\n&quot;, ret);</span>
<span class="p_del">-	return ret;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
  * Disable a port and mark a logical connect-change event, so that some
  * time later hub_wq will disconnect() any existing usb_device on the port
  * and will re-enumerate if there actually is a device attached.
<span class="p_chunk">@@ -4153,6 +4124,34 @@</span> <span class="p_context"> static int hub_handle_remote_wakeup(struct usb_hub *hub, unsigned int port,</span>
 
 #endif	/* CONFIG_PM */
 
<span class="p_add">+/*</span>
<span class="p_add">+ * USB-3 does not have a similar link state as USB-2 that will avoid negotiating</span>
<span class="p_add">+ * a connection with a plugged-in cable but will signal the host when the cable</span>
<span class="p_add">+ * is unplugged. Disable remote wake and set link state to U3 for USB-3 devices</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int hub_port_disable(struct usb_hub *hub, int port1, int set_state)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct usb_port *port_dev = hub-&gt;ports[port1 - 1];</span>
<span class="p_add">+	struct usb_device *hdev = hub-&gt;hdev;</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!hub-&gt;error) {</span>
<span class="p_add">+		if (hub_is_superspeed(hub-&gt;hdev)) {</span>
<span class="p_add">+			hub_usb3_port_prepare_disable(hub, port_dev);</span>
<span class="p_add">+			ret = hub_set_port_link_state(hub, port_dev-&gt;portnum,</span>
<span class="p_add">+						      USB_SS_PORT_LS_U3);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			ret = usb_clear_port_feature(hdev, port1,</span>
<span class="p_add">+					USB_PORT_FEAT_ENABLE);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (port_dev-&gt;child &amp;&amp; set_state)</span>
<span class="p_add">+		usb_set_device_state(port_dev-&gt;child, USB_STATE_NOTATTACHED);</span>
<span class="p_add">+	if (ret &amp;&amp; ret != -ENODEV)</span>
<span class="p_add">+		dev_err(&amp;port_dev-&gt;dev, &quot;cannot disable (err = %d)\n&quot;, ret);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 
 /* USB 2.0 spec, 7.1.7.3 / fig 7-29:
  *
<span class="p_header">diff --git a/drivers/usb/dwc3/core.h b/drivers/usb/dwc3/core.h</span>
<span class="p_header">index 6b60e42626a2..884c43714456 100644</span>
<span class="p_header">--- a/drivers/usb/dwc3/core.h</span>
<span class="p_header">+++ b/drivers/usb/dwc3/core.h</span>
<span class="p_chunk">@@ -43,9 +43,7 @@</span> <span class="p_context"></span>
 #define DWC3_XHCI_RESOURCES_NUM	2
 
 #define DWC3_SCRATCHBUF_SIZE	4096	/* each buffer is assumed to be 4KiB */
<span class="p_del">-#define DWC3_EVENT_SIZE		4	/* bytes */</span>
<span class="p_del">-#define DWC3_EVENT_MAX_NUM	64	/* 2 events/endpoint */</span>
<span class="p_del">-#define DWC3_EVENT_BUFFERS_SIZE	(DWC3_EVENT_SIZE * DWC3_EVENT_MAX_NUM)</span>
<span class="p_add">+#define DWC3_EVENT_BUFFERS_SIZE	4096</span>
 #define DWC3_EVENT_TYPE_MASK	0xfe
 
 #define DWC3_EVENT_TYPE_DEV	0
<span class="p_chunk">@@ -303,9 +301,8 @@</span> <span class="p_context"></span>
 #define DWC3_DCFG_SUPERSPEED_PLUS (5 &lt;&lt; 0)  /* DWC_usb31 only */
 #define DWC3_DCFG_SUPERSPEED	(4 &lt;&lt; 0)
 #define DWC3_DCFG_HIGHSPEED	(0 &lt;&lt; 0)
<span class="p_del">-#define DWC3_DCFG_FULLSPEED2	(1 &lt;&lt; 0)</span>
<span class="p_add">+#define DWC3_DCFG_FULLSPEED	(1 &lt;&lt; 0)</span>
 #define DWC3_DCFG_LOWSPEED	(2 &lt;&lt; 0)
<span class="p_del">-#define DWC3_DCFG_FULLSPEED1	(3 &lt;&lt; 0)</span>
 
 #define DWC3_DCFG_NUMP_SHIFT	17
 #define DWC3_DCFG_NUMP(n)	(((n) &gt;&gt; DWC3_DCFG_NUMP_SHIFT) &amp; 0x1f)
<span class="p_chunk">@@ -397,9 +394,8 @@</span> <span class="p_context"></span>
 #define DWC3_DSTS_SUPERSPEED_PLUS	(5 &lt;&lt; 0) /* DWC_usb31 only */
 #define DWC3_DSTS_SUPERSPEED		(4 &lt;&lt; 0)
 #define DWC3_DSTS_HIGHSPEED		(0 &lt;&lt; 0)
<span class="p_del">-#define DWC3_DSTS_FULLSPEED2		(1 &lt;&lt; 0)</span>
<span class="p_add">+#define DWC3_DSTS_FULLSPEED		(1 &lt;&lt; 0)</span>
 #define DWC3_DSTS_LOWSPEED		(2 &lt;&lt; 0)
<span class="p_del">-#define DWC3_DSTS_FULLSPEED1		(3 &lt;&lt; 0)</span>
 
 /* Device Generic Command Register */
 #define DWC3_DGCMD_SET_LMP		0x01
<span class="p_header">diff --git a/drivers/usb/dwc3/dwc3-pci.c b/drivers/usb/dwc3/dwc3-pci.c</span>
<span class="p_header">index 6df0f5dad9a4..427291a19e6d 100644</span>
<span class="p_header">--- a/drivers/usb/dwc3/dwc3-pci.c</span>
<span class="p_header">+++ b/drivers/usb/dwc3/dwc3-pci.c</span>
<span class="p_chunk">@@ -38,6 +38,7 @@</span> <span class="p_context"></span>
 #define PCI_DEVICE_ID_INTEL_BXT_M		0x1aaa
 #define PCI_DEVICE_ID_INTEL_APL			0x5aaa
 #define PCI_DEVICE_ID_INTEL_KBP			0xa2b0
<span class="p_add">+#define PCI_DEVICE_ID_INTEL_GLK			0x31aa</span>
 
 static const struct acpi_gpio_params reset_gpios = { 0, 0, false };
 static const struct acpi_gpio_params cs_gpios = { 1, 0, false };
<span class="p_chunk">@@ -81,7 +82,7 @@</span> <span class="p_context"> static int dwc3_pci_quirks(struct pci_dev *pdev, struct platform_device *dwc3)</span>
 		int ret;
 
 		struct property_entry properties[] = {
<span class="p_del">-			PROPERTY_ENTRY_STRING(&quot;dr-mode&quot;, &quot;peripheral&quot;),</span>
<span class="p_add">+			PROPERTY_ENTRY_STRING(&quot;dr_mode&quot;, &quot;peripheral&quot;),</span>
 			{ }
 		};
 
<span class="p_chunk">@@ -229,6 +230,7 @@</span> <span class="p_context"> static const struct pci_device_id dwc3_pci_id_table[] = {</span>
 	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_BXT_M), },
 	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_APL), },
 	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_KBP), },
<span class="p_add">+	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_GLK), },</span>
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_NL_USB), },
 	{  }	/* Terminating Entry */
 };
<span class="p_header">diff --git a/drivers/usb/dwc3/ep0.c b/drivers/usb/dwc3/ep0.c</span>
<span class="p_header">index fe79d771dee4..2331469f943d 100644</span>
<span class="p_header">--- a/drivers/usb/dwc3/ep0.c</span>
<span class="p_header">+++ b/drivers/usb/dwc3/ep0.c</span>
<span class="p_chunk">@@ -55,20 +55,13 @@</span> <span class="p_context"> static const char *dwc3_ep0_state_string(enum dwc3_ep0_state state)</span>
 	}
 }
 
<span class="p_del">-static int dwc3_ep0_start_trans(struct dwc3 *dwc, u8 epnum, dma_addr_t buf_dma,</span>
<span class="p_del">-		u32 len, u32 type, bool chain)</span>
<span class="p_add">+static void dwc3_ep0_prepare_one_trb(struct dwc3 *dwc, u8 epnum,</span>
<span class="p_add">+		dma_addr_t buf_dma, u32 len, u32 type, bool chain)</span>
 {
<span class="p_del">-	struct dwc3_gadget_ep_cmd_params params;</span>
 	struct dwc3_trb			*trb;
 	struct dwc3_ep			*dep;
 
<span class="p_del">-	int				ret;</span>
<span class="p_del">-</span>
 	dep = dwc-&gt;eps[epnum];
<span class="p_del">-	if (dep-&gt;flags &amp; DWC3_EP_BUSY) {</span>
<span class="p_del">-		dwc3_trace(trace_dwc3_ep0, &quot;%s still busy&quot;, dep-&gt;name);</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	}</span>
 
 	trb = &amp;dwc-&gt;ep0_trb[dep-&gt;trb_enqueue];
 
<span class="p_chunk">@@ -89,15 +82,25 @@</span> <span class="p_context"> static int dwc3_ep0_start_trans(struct dwc3 *dwc, u8 epnum, dma_addr_t buf_dma,</span>
 		trb-&gt;ctrl |= (DWC3_TRB_CTRL_IOC
 				| DWC3_TRB_CTRL_LST);
 
<span class="p_del">-	if (chain)</span>
<span class="p_add">+	trace_dwc3_prepare_trb(dep, trb);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int dwc3_ep0_start_trans(struct dwc3 *dwc, u8 epnum)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct dwc3_gadget_ep_cmd_params params;</span>
<span class="p_add">+	struct dwc3_ep			*dep;</span>
<span class="p_add">+	int				ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	dep = dwc-&gt;eps[epnum];</span>
<span class="p_add">+	if (dep-&gt;flags &amp; DWC3_EP_BUSY) {</span>
<span class="p_add">+		dwc3_trace(trace_dwc3_ep0, &quot;%s still busy&quot;, dep-&gt;name);</span>
 		return 0;
<span class="p_add">+	}</span>
 
 	memset(&amp;params, 0, sizeof(params));
 	params.param0 = upper_32_bits(dwc-&gt;ep0_trb_addr);
 	params.param1 = lower_32_bits(dwc-&gt;ep0_trb_addr);
 
<span class="p_del">-	trace_dwc3_prepare_trb(dep, trb);</span>
<span class="p_del">-</span>
 	ret = dwc3_send_gadget_ep_cmd(dep, DWC3_DEPCMD_STARTTRANSFER, &amp;params);
 	if (ret &lt; 0) {
 		dwc3_trace(trace_dwc3_ep0, &quot;%s STARTTRANSFER failed&quot;,
<span class="p_chunk">@@ -308,8 +311,9 @@</span> <span class="p_context"> void dwc3_ep0_out_start(struct dwc3 *dwc)</span>
 {
 	int				ret;
 
<span class="p_del">-	ret = dwc3_ep0_start_trans(dwc, 0, dwc-&gt;ctrl_req_addr, 8,</span>
<span class="p_add">+	dwc3_ep0_prepare_one_trb(dwc, 0, dwc-&gt;ctrl_req_addr, 8,</span>
 			DWC3_TRBCTL_CONTROL_SETUP, false);
<span class="p_add">+	ret = dwc3_ep0_start_trans(dwc, 0);</span>
 	WARN_ON(ret &lt; 0);
 }
 
<span class="p_chunk">@@ -880,9 +884,9 @@</span> <span class="p_context"> static void dwc3_ep0_complete_data(struct dwc3 *dwc,</span>
 
 			dwc-&gt;ep0_next_event = DWC3_EP0_COMPLETE;
 
<span class="p_del">-			ret = dwc3_ep0_start_trans(dwc, epnum,</span>
<span class="p_del">-					dwc-&gt;ctrl_req_addr, 0,</span>
<span class="p_del">-					DWC3_TRBCTL_CONTROL_DATA, false);</span>
<span class="p_add">+			dwc3_ep0_prepare_one_trb(dwc, epnum, dwc-&gt;ctrl_req_addr,</span>
<span class="p_add">+					0, DWC3_TRBCTL_CONTROL_DATA, false);</span>
<span class="p_add">+			ret = dwc3_ep0_start_trans(dwc, epnum);</span>
 			WARN_ON(ret &lt; 0);
 		}
 	}
<span class="p_chunk">@@ -966,9 +970,10 @@</span> <span class="p_context"> static void __dwc3_ep0_do_control_data(struct dwc3 *dwc,</span>
 	req-&gt;direction = !!dep-&gt;number;
 
 	if (req-&gt;request.length == 0) {
<span class="p_del">-		ret = dwc3_ep0_start_trans(dwc, dep-&gt;number,</span>
<span class="p_add">+		dwc3_ep0_prepare_one_trb(dwc, dep-&gt;number,</span>
 				dwc-&gt;ctrl_req_addr, 0,
 				DWC3_TRBCTL_CONTROL_DATA, false);
<span class="p_add">+		ret = dwc3_ep0_start_trans(dwc, dep-&gt;number);</span>
 	} else if (!IS_ALIGNED(req-&gt;request.length, dep-&gt;endpoint.maxpacket)
 			&amp;&amp; (dep-&gt;number == 0)) {
 		u32	transfer_size = 0;
<span class="p_chunk">@@ -986,7 +991,7 @@</span> <span class="p_context"> static void __dwc3_ep0_do_control_data(struct dwc3 *dwc,</span>
 		if (req-&gt;request.length &gt; DWC3_EP0_BOUNCE_SIZE) {
 			transfer_size = ALIGN(req-&gt;request.length - maxpacket,
 					      maxpacket);
<span class="p_del">-			ret = dwc3_ep0_start_trans(dwc, dep-&gt;number,</span>
<span class="p_add">+			dwc3_ep0_prepare_one_trb(dwc, dep-&gt;number,</span>
 						   req-&gt;request.dma,
 						   transfer_size,
 						   DWC3_TRBCTL_CONTROL_DATA,
<span class="p_chunk">@@ -998,9 +1003,10 @@</span> <span class="p_context"> static void __dwc3_ep0_do_control_data(struct dwc3 *dwc,</span>
 
 		dwc-&gt;ep0_bounced = true;
 
<span class="p_del">-		ret = dwc3_ep0_start_trans(dwc, dep-&gt;number,</span>
<span class="p_add">+		dwc3_ep0_prepare_one_trb(dwc, dep-&gt;number,</span>
 				dwc-&gt;ep0_bounce_addr, transfer_size,
 				DWC3_TRBCTL_CONTROL_DATA, false);
<span class="p_add">+		ret = dwc3_ep0_start_trans(dwc, dep-&gt;number);</span>
 	} else {
 		ret = usb_gadget_map_request(&amp;dwc-&gt;gadget, &amp;req-&gt;request,
 				dep-&gt;number);
<span class="p_chunk">@@ -1009,9 +1015,10 @@</span> <span class="p_context"> static void __dwc3_ep0_do_control_data(struct dwc3 *dwc,</span>
 			return;
 		}
 
<span class="p_del">-		ret = dwc3_ep0_start_trans(dwc, dep-&gt;number, req-&gt;request.dma,</span>
<span class="p_add">+		dwc3_ep0_prepare_one_trb(dwc, dep-&gt;number, req-&gt;request.dma,</span>
 				req-&gt;request.length, DWC3_TRBCTL_CONTROL_DATA,
 				false);
<span class="p_add">+		ret = dwc3_ep0_start_trans(dwc, dep-&gt;number);</span>
 	}
 
 	WARN_ON(ret &lt; 0);
<span class="p_chunk">@@ -1025,8 +1032,9 @@</span> <span class="p_context"> static int dwc3_ep0_start_control_status(struct dwc3_ep *dep)</span>
 	type = dwc-&gt;three_stage_setup ? DWC3_TRBCTL_CONTROL_STATUS3
 		: DWC3_TRBCTL_CONTROL_STATUS2;
 
<span class="p_del">-	return dwc3_ep0_start_trans(dwc, dep-&gt;number,</span>
<span class="p_add">+	dwc3_ep0_prepare_one_trb(dwc, dep-&gt;number,</span>
 			dwc-&gt;ctrl_req_addr, 0, type, false);
<span class="p_add">+	return dwc3_ep0_start_trans(dwc, dep-&gt;number);</span>
 }
 
 static void __dwc3_ep0_do_control_status(struct dwc3 *dwc, struct dwc3_ep *dep)
<span class="p_header">diff --git a/drivers/usb/dwc3/gadget.c b/drivers/usb/dwc3/gadget.c</span>
<span class="p_header">index b3687e223e00..d2b860ebfe13 100644</span>
<span class="p_header">--- a/drivers/usb/dwc3/gadget.c</span>
<span class="p_header">+++ b/drivers/usb/dwc3/gadget.c</span>
<span class="p_chunk">@@ -182,11 +182,11 @@</span> <span class="p_context"> void dwc3_gadget_giveback(struct dwc3_ep *dep, struct dwc3_request *req,</span>
 	if (req-&gt;request.status == -EINPROGRESS)
 		req-&gt;request.status = status;
 
<span class="p_del">-	if (dwc-&gt;ep0_bounced &amp;&amp; dep-&gt;number == 0)</span>
<span class="p_add">+	if (dwc-&gt;ep0_bounced &amp;&amp; dep-&gt;number &lt;= 1)</span>
 		dwc-&gt;ep0_bounced = false;
<span class="p_del">-	else</span>
<span class="p_del">-		usb_gadget_unmap_request(&amp;dwc-&gt;gadget, &amp;req-&gt;request,</span>
<span class="p_del">-				req-&gt;direction);</span>
<span class="p_add">+</span>
<span class="p_add">+	usb_gadget_unmap_request(&amp;dwc-&gt;gadget, &amp;req-&gt;request,</span>
<span class="p_add">+			req-&gt;direction);</span>
 
 	trace_dwc3_gadget_giveback(req);
 
<span class="p_chunk">@@ -1606,7 +1606,7 @@</span> <span class="p_context"> static int __dwc3_gadget_start(struct dwc3 *dwc)</span>
 			reg |= DWC3_DCFG_LOWSPEED;
 			break;
 		case USB_SPEED_FULL:
<span class="p_del">-			reg |= DWC3_DCFG_FULLSPEED1;</span>
<span class="p_add">+			reg |= DWC3_DCFG_FULLSPEED;</span>
 			break;
 		case USB_SPEED_HIGH:
 			reg |= DWC3_DCFG_HIGHSPEED;
<span class="p_chunk">@@ -2465,8 +2465,7 @@</span> <span class="p_context"> static void dwc3_gadget_conndone_interrupt(struct dwc3 *dwc)</span>
 		dwc-&gt;gadget.ep0-&gt;maxpacket = 64;
 		dwc-&gt;gadget.speed = USB_SPEED_HIGH;
 		break;
<span class="p_del">-	case DWC3_DSTS_FULLSPEED2:</span>
<span class="p_del">-	case DWC3_DSTS_FULLSPEED1:</span>
<span class="p_add">+	case DWC3_DSTS_FULLSPEED:</span>
 		dwc3_gadget_ep0_desc.wMaxPacketSize = cpu_to_le16(64);
 		dwc-&gt;gadget.ep0-&gt;maxpacket = 64;
 		dwc-&gt;gadget.speed = USB_SPEED_FULL;
<span class="p_header">diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c</span>
<span class="p_header">index e38b21087d26..c3c5b87b35b3 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/composite.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/composite.c</span>
<span class="p_chunk">@@ -205,7 +205,7 @@</span> <span class="p_context"> int config_ep_by_speed(struct usb_gadget *g,</span>
 
 	if (g-&gt;speed == USB_SPEED_HIGH &amp;&amp; (usb_endpoint_xfer_isoc(_ep-&gt;desc) ||
 				usb_endpoint_xfer_int(_ep-&gt;desc)))
<span class="p_del">-		_ep-&gt;mult = usb_endpoint_maxp(_ep-&gt;desc) &amp; 0x7ff;</span>
<span class="p_add">+		_ep-&gt;mult = ((usb_endpoint_maxp(_ep-&gt;desc) &amp; 0x1800) &gt;&gt; 11) + 1;</span>
 
 	if (!want_comp_desc)
 		return 0;
<span class="p_chunk">@@ -1694,9 +1694,7 @@</span> <span class="p_context"> composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)</span>
 		value = min(w_length, (u16) 1);
 		break;
 
<span class="p_del">-	/* function drivers must handle get/set altsetting; if there&#39;s</span>
<span class="p_del">-	 * no get() method, we know only altsetting zero works.</span>
<span class="p_del">-	 */</span>
<span class="p_add">+	/* function drivers must handle get/set altsetting */</span>
 	case USB_REQ_SET_INTERFACE:
 		if (ctrl-&gt;bRequestType != USB_RECIP_INTERFACE)
 			goto unknown;
<span class="p_chunk">@@ -1705,7 +1703,13 @@</span> <span class="p_context"> composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)</span>
 		f = cdev-&gt;config-&gt;interface[intf];
 		if (!f)
 			break;
<span class="p_del">-		if (w_value &amp;&amp; !f-&gt;set_alt)</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * If there&#39;s no get_alt() method, we know only altsetting zero</span>
<span class="p_add">+		 * works. There is no need to check if set_alt() is not NULL</span>
<span class="p_add">+		 * as we check this in usb_add_function().</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (w_value &amp;&amp; !f-&gt;get_alt)</span>
 			break;
 		value = f-&gt;set_alt(f, w_index, w_value);
 		if (value == USB_GADGET_DELAYED_STATUS) {
<span class="p_header">diff --git a/drivers/usb/gadget/function/f_tcm.c b/drivers/usb/gadget/function/f_tcm.c</span>
<span class="p_header">index 197f73386fac..d2351139342f 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/function/f_tcm.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/function/f_tcm.c</span>
<span class="p_chunk">@@ -1073,7 +1073,7 @@</span> <span class="p_context"> static struct usbg_cmd *usbg_get_cmd(struct f_uas *fu,</span>
 	struct usbg_cmd *cmd;
 	int tag;
 
<span class="p_del">-	tag = percpu_ida_alloc(&amp;se_sess-&gt;sess_tag_pool, GFP_ATOMIC);</span>
<span class="p_add">+	tag = percpu_ida_alloc(&amp;se_sess-&gt;sess_tag_pool, TASK_RUNNING);</span>
 	if (tag &lt; 0)
 		return ERR_PTR(-ENOMEM);
 
<span class="p_header">diff --git a/drivers/usb/gadget/legacy/inode.c b/drivers/usb/gadget/legacy/inode.c</span>
<span class="p_header">index bd82dd12deff..1468d8f085a3 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/legacy/inode.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/legacy/inode.c</span>
<span class="p_chunk">@@ -1126,7 +1126,7 @@</span> <span class="p_context"> ep0_write (struct file *fd, const char __user *buf, size_t len, loff_t *ptr)</span>
 	/* data and/or status stage for control request */
 	} else if (dev-&gt;state == STATE_DEV_SETUP) {
 
<span class="p_del">-		/* IN DATA+STATUS caller makes len &lt;= wLength */</span>
<span class="p_add">+		len = min_t(size_t, len, dev-&gt;setup_wLength);</span>
 		if (dev-&gt;setup_in) {
 			retval = setup_req (dev-&gt;gadget-&gt;ep0, dev-&gt;req, len);
 			if (retval == 0) {
<span class="p_chunk">@@ -1734,10 +1734,12 @@</span> <span class="p_context"> static struct usb_gadget_driver gadgetfs_driver = {</span>
  * such as configuration notifications.
  */
 
<span class="p_del">-static int is_valid_config (struct usb_config_descriptor *config)</span>
<span class="p_add">+static int is_valid_config(struct usb_config_descriptor *config,</span>
<span class="p_add">+		unsigned int total)</span>
 {
 	return config-&gt;bDescriptorType == USB_DT_CONFIG
 		&amp;&amp; config-&gt;bLength == USB_DT_CONFIG_SIZE
<span class="p_add">+		&amp;&amp; total &gt;= USB_DT_CONFIG_SIZE</span>
 		&amp;&amp; config-&gt;bConfigurationValue != 0
 		&amp;&amp; (config-&gt;bmAttributes &amp; USB_CONFIG_ATT_ONE) != 0
 		&amp;&amp; (config-&gt;bmAttributes &amp; USB_CONFIG_ATT_WAKEUP) == 0;
<span class="p_chunk">@@ -1762,7 +1764,8 @@</span> <span class="p_context"> dev_config (struct file *fd, const char __user *buf, size_t len, loff_t *ptr)</span>
 	}
 	spin_unlock_irq(&amp;dev-&gt;lock);
 
<span class="p_del">-	if (len &lt; (USB_DT_CONFIG_SIZE + USB_DT_DEVICE_SIZE + 4))</span>
<span class="p_add">+	if ((len &lt; (USB_DT_CONFIG_SIZE + USB_DT_DEVICE_SIZE + 4)) ||</span>
<span class="p_add">+	    (len &gt; PAGE_SIZE * 4))</span>
 		return -EINVAL;
 
 	/* we might need to change message format someday */
<span class="p_chunk">@@ -1786,7 +1789,8 @@</span> <span class="p_context"> dev_config (struct file *fd, const char __user *buf, size_t len, loff_t *ptr)</span>
 	/* full or low speed config */
 	dev-&gt;config = (void *) kbuf;
 	total = le16_to_cpu(dev-&gt;config-&gt;wTotalLength);
<span class="p_del">-	if (!is_valid_config (dev-&gt;config) || total &gt;= length)</span>
<span class="p_add">+	if (!is_valid_config(dev-&gt;config, total) ||</span>
<span class="p_add">+			total &gt; length - USB_DT_DEVICE_SIZE)</span>
 		goto fail;
 	kbuf += total;
 	length -= total;
<span class="p_chunk">@@ -1795,10 +1799,13 @@</span> <span class="p_context"> dev_config (struct file *fd, const char __user *buf, size_t len, loff_t *ptr)</span>
 	if (kbuf [1] == USB_DT_CONFIG) {
 		dev-&gt;hs_config = (void *) kbuf;
 		total = le16_to_cpu(dev-&gt;hs_config-&gt;wTotalLength);
<span class="p_del">-		if (!is_valid_config (dev-&gt;hs_config) || total &gt;= length)</span>
<span class="p_add">+		if (!is_valid_config(dev-&gt;hs_config, total) ||</span>
<span class="p_add">+				total &gt; length - USB_DT_DEVICE_SIZE)</span>
 			goto fail;
 		kbuf += total;
 		length -= total;
<span class="p_add">+	} else {</span>
<span class="p_add">+		dev-&gt;hs_config = NULL;</span>
 	}
 
 	/* could support multiple configs, using another encoding! */
<span class="p_header">diff --git a/drivers/usb/gadget/udc/core.c b/drivers/usb/gadget/udc/core.c</span>
<span class="p_header">index 9483489080f6..0402177f93cd 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/udc/core.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/udc/core.c</span>
<span class="p_chunk">@@ -1317,7 +1317,11 @@</span> <span class="p_context"> int usb_gadget_probe_driver(struct usb_gadget_driver *driver)</span>
 			if (!ret)
 				break;
 		}
<span class="p_del">-		if (!ret &amp;&amp; !udc-&gt;driver)</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			ret = -ENODEV;</span>
<span class="p_add">+		else if (udc-&gt;driver)</span>
<span class="p_add">+			ret = -EBUSY;</span>
<span class="p_add">+		else</span>
 			goto found;
 	} else {
 		list_for_each_entry(udc, &amp;udc_list, list) {
<span class="p_header">diff --git a/drivers/usb/gadget/udc/dummy_hcd.c b/drivers/usb/gadget/udc/dummy_hcd.c</span>
<span class="p_header">index 77d07904f932..a81d9ab861dc 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/udc/dummy_hcd.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/udc/dummy_hcd.c</span>
<span class="p_chunk">@@ -330,7 +330,7 @@</span> <span class="p_context"> static void nuke(struct dummy *dum, struct dummy_ep *ep)</span>
 /* caller must hold lock */
 static void stop_activity(struct dummy *dum)
 {
<span class="p_del">-	struct dummy_ep	*ep;</span>
<span class="p_add">+	int i;</span>
 
 	/* prevent any more requests */
 	dum-&gt;address = 0;
<span class="p_chunk">@@ -338,8 +338,8 @@</span> <span class="p_context"> static void stop_activity(struct dummy *dum)</span>
 	/* The timer is left running so that outstanding URBs can fail */
 
 	/* nuke any pending requests first, so driver i/o is quiesced */
<span class="p_del">-	list_for_each_entry(ep, &amp;dum-&gt;gadget.ep_list, ep.ep_list)</span>
<span class="p_del">-		nuke(dum, ep);</span>
<span class="p_add">+	for (i = 0; i &lt; DUMMY_ENDPOINTS; ++i)</span>
<span class="p_add">+		nuke(dum, &amp;dum-&gt;ep[i]);</span>
 
 	/* driver now does any non-usb quiescing necessary */
 }
<span class="p_header">diff --git a/drivers/usb/host/xhci-mem.c b/drivers/usb/host/xhci-mem.c</span>
<span class="p_header">index 6afe32381209..7064892ff4a6 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-mem.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-mem.c</span>
<span class="p_chunk">@@ -979,6 +979,40 @@</span> <span class="p_context"> void xhci_free_virt_device(struct xhci_hcd *xhci, int slot_id)</span>
 	xhci-&gt;devs[slot_id] = NULL;
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Free a virt_device structure.</span>
<span class="p_add">+ * If the virt_device added a tt_info (a hub) and has children pointing to</span>
<span class="p_add">+ * that tt_info, then free the child first. Recursive.</span>
<span class="p_add">+ * We can&#39;t rely on udev at this point to find child-parent relationships.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void xhci_free_virt_devices_depth_first(struct xhci_hcd *xhci, int slot_id)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct xhci_virt_device *vdev;</span>
<span class="p_add">+	struct list_head *tt_list_head;</span>
<span class="p_add">+	struct xhci_tt_bw_info *tt_info, *next;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	vdev = xhci-&gt;devs[slot_id];</span>
<span class="p_add">+	if (!vdev)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	tt_list_head = &amp;(xhci-&gt;rh_bw[vdev-&gt;real_port - 1].tts);</span>
<span class="p_add">+	list_for_each_entry_safe(tt_info, next, tt_list_head, tt_list) {</span>
<span class="p_add">+		/* is this a hub device that added a tt_info to the tts list */</span>
<span class="p_add">+		if (tt_info-&gt;slot_id == slot_id) {</span>
<span class="p_add">+			/* are any devices using this tt_info? */</span>
<span class="p_add">+			for (i = 1; i &lt; HCS_MAX_SLOTS(xhci-&gt;hcs_params1); i++) {</span>
<span class="p_add">+				vdev = xhci-&gt;devs[i];</span>
<span class="p_add">+				if (vdev &amp;&amp; (vdev-&gt;tt_info == tt_info))</span>
<span class="p_add">+					xhci_free_virt_devices_depth_first(</span>
<span class="p_add">+						xhci, i);</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	/* we are now at a leaf device */</span>
<span class="p_add">+	xhci_free_virt_device(xhci, slot_id);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int xhci_alloc_virt_device(struct xhci_hcd *xhci, int slot_id,
 		struct usb_device *udev, gfp_t flags)
 {
<span class="p_chunk">@@ -1796,7 +1830,7 @@</span> <span class="p_context"> void xhci_mem_cleanup(struct xhci_hcd *xhci)</span>
 	int size;
 	int i, j, num_ports;
 
<span class="p_del">-	del_timer_sync(&amp;xhci-&gt;cmd_timer);</span>
<span class="p_add">+	cancel_delayed_work_sync(&amp;xhci-&gt;cmd_timer);</span>
 
 	/* Free the Event Ring Segment Table and the actual Event Ring */
 	size = sizeof(struct xhci_erst_entry)*(xhci-&gt;erst.num_entries);
<span class="p_chunk">@@ -1829,8 +1863,8 @@</span> <span class="p_context"> void xhci_mem_cleanup(struct xhci_hcd *xhci)</span>
 		}
 	}
 
<span class="p_del">-	for (i = 1; i &lt; MAX_HC_SLOTS; ++i)</span>
<span class="p_del">-		xhci_free_virt_device(xhci, i);</span>
<span class="p_add">+	for (i = HCS_MAX_SLOTS(xhci-&gt;hcs_params1); i &gt; 0; i--)</span>
<span class="p_add">+		xhci_free_virt_devices_depth_first(xhci, i);</span>
 
 	dma_pool_destroy(xhci-&gt;segment_pool);
 	xhci-&gt;segment_pool = NULL;
<span class="p_chunk">@@ -2343,9 +2377,9 @@</span> <span class="p_context"> int xhci_mem_init(struct xhci_hcd *xhci, gfp_t flags)</span>
 
 	INIT_LIST_HEAD(&amp;xhci-&gt;cmd_list);
 
<span class="p_del">-	/* init command timeout timer */</span>
<span class="p_del">-	setup_timer(&amp;xhci-&gt;cmd_timer, xhci_handle_command_timeout,</span>
<span class="p_del">-		    (unsigned long)xhci);</span>
<span class="p_add">+	/* init command timeout work */</span>
<span class="p_add">+	INIT_DELAYED_WORK(&amp;xhci-&gt;cmd_timer, xhci_handle_command_timeout);</span>
<span class="p_add">+	init_completion(&amp;xhci-&gt;cmd_ring_stop_completion);</span>
 
 	page_size = readl(&amp;xhci-&gt;op_regs-&gt;page_size);
 	xhci_dbg_trace(xhci, trace_xhci_dbg_init,
<span class="p_chunk">@@ -2384,7 +2418,7 @@</span> <span class="p_context"> int xhci_mem_init(struct xhci_hcd *xhci, gfp_t flags)</span>
 	 * &quot;physically contiguous and 64-byte (cache line) aligned&quot;.
 	 */
 	xhci-&gt;dcbaa = dma_alloc_coherent(dev, sizeof(*xhci-&gt;dcbaa), &amp;dma,
<span class="p_del">-			GFP_KERNEL);</span>
<span class="p_add">+			flags);</span>
 	if (!xhci-&gt;dcbaa)
 		goto fail;
 	memset(xhci-&gt;dcbaa, 0, sizeof *(xhci-&gt;dcbaa));
<span class="p_chunk">@@ -2480,7 +2514,7 @@</span> <span class="p_context"> int xhci_mem_init(struct xhci_hcd *xhci, gfp_t flags)</span>
 
 	xhci-&gt;erst.entries = dma_alloc_coherent(dev,
 			sizeof(struct xhci_erst_entry) * ERST_NUM_SEGS, &amp;dma,
<span class="p_del">-			GFP_KERNEL);</span>
<span class="p_add">+			flags);</span>
 	if (!xhci-&gt;erst.entries)
 		goto fail;
 	xhci_dbg_trace(xhci, trace_xhci_dbg_init,
<span class="p_header">diff --git a/drivers/usb/host/xhci-mtk.c b/drivers/usb/host/xhci-mtk.c</span>
<span class="p_header">index 79959f17c38c..f2365a47fa4a 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-mtk.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-mtk.c</span>
<span class="p_chunk">@@ -560,8 +560,10 @@</span> <span class="p_context"> static int xhci_mtk_probe(struct platform_device *pdev)</span>
 		goto disable_ldos;
 
 	irq = platform_get_irq(pdev, 0);
<span class="p_del">-	if (irq &lt; 0)</span>
<span class="p_add">+	if (irq &lt; 0) {</span>
<span class="p_add">+		ret = irq;</span>
 		goto disable_clk;
<span class="p_add">+	}</span>
 
 	/* Initialize dma_mask and coherent_dma_mask to 32-bits */
 	ret = dma_set_coherent_mask(dev, DMA_BIT_MASK(32));
<span class="p_header">diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">index e96ae80d107e..954abfd5014d 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-pci.c</span>
<span class="p_chunk">@@ -165,7 +165,8 @@</span> <span class="p_context"> static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)</span>
 		 pdev-&gt;device == PCI_DEVICE_ID_INTEL_SUNRISEPOINT_H_XHCI ||
 		 pdev-&gt;device == PCI_DEVICE_ID_INTEL_CHERRYVIEW_XHCI ||
 		 pdev-&gt;device == PCI_DEVICE_ID_INTEL_BROXTON_M_XHCI ||
<span class="p_del">-		 pdev-&gt;device == PCI_DEVICE_ID_INTEL_BROXTON_B_XHCI)) {</span>
<span class="p_add">+		 pdev-&gt;device == PCI_DEVICE_ID_INTEL_BROXTON_B_XHCI ||</span>
<span class="p_add">+		 pdev-&gt;device == PCI_DEVICE_ID_INTEL_APL_XHCI)) {</span>
 		xhci-&gt;quirks |= XHCI_PME_STUCK_QUIRK;
 	}
 	if (pdev-&gt;vendor == PCI_VENDOR_ID_INTEL &amp;&amp;
<span class="p_header">diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">index 797137e26549..771a6da9caea 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-ring.c</span>
<span class="p_chunk">@@ -260,23 +260,76 @@</span> <span class="p_context"> void xhci_ring_cmd_db(struct xhci_hcd *xhci)</span>
 	readl(&amp;xhci-&gt;dba-&gt;doorbell[0]);
 }
 
<span class="p_del">-static int xhci_abort_cmd_ring(struct xhci_hcd *xhci)</span>
<span class="p_add">+static bool xhci_mod_cmd_timer(struct xhci_hcd *xhci, unsigned long delay)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return mod_delayed_work(system_wq, &amp;xhci-&gt;cmd_timer, delay);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct xhci_command *xhci_next_queued_cmd(struct xhci_hcd *xhci)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return list_first_entry_or_null(&amp;xhci-&gt;cmd_list, struct xhci_command,</span>
<span class="p_add">+					cmd_list);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Turn all commands on command ring with status set to &quot;aborted&quot; to no-op trbs.</span>
<span class="p_add">+ * If there are other commands waiting then restart the ring and kick the timer.</span>
<span class="p_add">+ * This must be called with command ring stopped and xhci-&gt;lock held.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void xhci_handle_stopped_cmd_ring(struct xhci_hcd *xhci,</span>
<span class="p_add">+					 struct xhci_command *cur_cmd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct xhci_command *i_cmd;</span>
<span class="p_add">+	u32 cycle_state;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Turn all aborted commands in list to no-ops, then restart */</span>
<span class="p_add">+	list_for_each_entry(i_cmd, &amp;xhci-&gt;cmd_list, cmd_list) {</span>
<span class="p_add">+</span>
<span class="p_add">+		if (i_cmd-&gt;status != COMP_CMD_ABORT)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		i_cmd-&gt;status = COMP_CMD_STOP;</span>
<span class="p_add">+</span>
<span class="p_add">+		xhci_dbg(xhci, &quot;Turn aborted command %p to no-op\n&quot;,</span>
<span class="p_add">+			 i_cmd-&gt;command_trb);</span>
<span class="p_add">+		/* get cycle state from the original cmd trb */</span>
<span class="p_add">+		cycle_state = le32_to_cpu(</span>
<span class="p_add">+			i_cmd-&gt;command_trb-&gt;generic.field[3]) &amp;	TRB_CYCLE;</span>
<span class="p_add">+		/* modify the command trb to no-op command */</span>
<span class="p_add">+		i_cmd-&gt;command_trb-&gt;generic.field[0] = 0;</span>
<span class="p_add">+		i_cmd-&gt;command_trb-&gt;generic.field[1] = 0;</span>
<span class="p_add">+		i_cmd-&gt;command_trb-&gt;generic.field[2] = 0;</span>
<span class="p_add">+		i_cmd-&gt;command_trb-&gt;generic.field[3] = cpu_to_le32(</span>
<span class="p_add">+			TRB_TYPE(TRB_CMD_NOOP) | cycle_state);</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * caller waiting for completion is called when command</span>
<span class="p_add">+		 *  completion event is received for these no-op commands</span>
<span class="p_add">+		 */</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	xhci-&gt;cmd_ring_state = CMD_RING_STATE_RUNNING;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* ring command ring doorbell to restart the command ring */</span>
<span class="p_add">+	if ((xhci-&gt;cmd_ring-&gt;dequeue != xhci-&gt;cmd_ring-&gt;enqueue) &amp;&amp;</span>
<span class="p_add">+	    !(xhci-&gt;xhc_state &amp; XHCI_STATE_DYING)) {</span>
<span class="p_add">+		xhci-&gt;current_cmd = cur_cmd;</span>
<span class="p_add">+		xhci_mod_cmd_timer(xhci, XHCI_CMD_DEFAULT_TIMEOUT);</span>
<span class="p_add">+		xhci_ring_cmd_db(xhci);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Must be called with xhci-&gt;lock held, releases and aquires lock back */</span>
<span class="p_add">+static int xhci_abort_cmd_ring(struct xhci_hcd *xhci, unsigned long flags)</span>
 {
 	u64 temp_64;
 	int ret;
 
 	xhci_dbg(xhci, &quot;Abort command ring\n&quot;);
 
<span class="p_del">-	temp_64 = xhci_read_64(xhci, &amp;xhci-&gt;op_regs-&gt;cmd_ring);</span>
<span class="p_del">-	xhci-&gt;cmd_ring_state = CMD_RING_STATE_ABORTED;</span>
<span class="p_add">+	reinit_completion(&amp;xhci-&gt;cmd_ring_stop_completion);</span>
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Writing the CMD_RING_ABORT bit should cause a cmd completion event,</span>
<span class="p_del">-	 * however on some host hw the CMD_RING_RUNNING bit is correctly cleared</span>
<span class="p_del">-	 * but the completion event in never sent. Use the cmd timeout timer to</span>
<span class="p_del">-	 * handle those cases. Use twice the time to cover the bit polling retry</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	mod_timer(&amp;xhci-&gt;cmd_timer, jiffies + (2 * XHCI_CMD_DEFAULT_TIMEOUT));</span>
<span class="p_add">+	temp_64 = xhci_read_64(xhci, &amp;xhci-&gt;op_regs-&gt;cmd_ring);</span>
 	xhci_write_64(xhci, temp_64 | CMD_RING_ABORT,
 			&amp;xhci-&gt;op_regs-&gt;cmd_ring);
 
<span class="p_chunk">@@ -296,16 +349,30 @@</span> <span class="p_context"> static int xhci_abort_cmd_ring(struct xhci_hcd *xhci)</span>
 		udelay(1000);
 		ret = xhci_handshake(&amp;xhci-&gt;op_regs-&gt;cmd_ring,
 				     CMD_RING_RUNNING, 0, 3 * 1000 * 1000);
<span class="p_del">-		if (ret == 0)</span>
<span class="p_del">-			return 0;</span>
<span class="p_del">-</span>
<span class="p_del">-		xhci_err(xhci, &quot;Stopped the command ring failed, &quot;</span>
<span class="p_del">-				&quot;maybe the host is dead\n&quot;);</span>
<span class="p_del">-		del_timer(&amp;xhci-&gt;cmd_timer);</span>
<span class="p_del">-		xhci-&gt;xhc_state |= XHCI_STATE_DYING;</span>
<span class="p_del">-		xhci_quiesce(xhci);</span>
<span class="p_del">-		xhci_halt(xhci);</span>
<span class="p_del">-		return -ESHUTDOWN;</span>
<span class="p_add">+		if (ret &lt; 0) {</span>
<span class="p_add">+			xhci_err(xhci, &quot;Stopped the command ring failed, &quot;</span>
<span class="p_add">+				 &quot;maybe the host is dead\n&quot;);</span>
<span class="p_add">+			xhci-&gt;xhc_state |= XHCI_STATE_DYING;</span>
<span class="p_add">+			xhci_quiesce(xhci);</span>
<span class="p_add">+			xhci_halt(xhci);</span>
<span class="p_add">+			return -ESHUTDOWN;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Writing the CMD_RING_ABORT bit should cause a cmd completion event,</span>
<span class="p_add">+	 * however on some host hw the CMD_RING_RUNNING bit is correctly cleared</span>
<span class="p_add">+	 * but the completion event in never sent. Wait 2 secs (arbitrary</span>
<span class="p_add">+	 * number) to handle those cases after negation of CMD_RING_RUNNING.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;xhci-&gt;lock, flags);</span>
<span class="p_add">+	ret = wait_for_completion_timeout(&amp;xhci-&gt;cmd_ring_stop_completion,</span>
<span class="p_add">+					  msecs_to_jiffies(2000));</span>
<span class="p_add">+	spin_lock_irqsave(&amp;xhci-&gt;lock, flags);</span>
<span class="p_add">+	if (!ret) {</span>
<span class="p_add">+		xhci_dbg(xhci, &quot;No stop event for abort, ring start fail?\n&quot;);</span>
<span class="p_add">+		xhci_cleanup_command_queue(xhci);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		xhci_handle_stopped_cmd_ring(xhci, xhci_next_queued_cmd(xhci));</span>
 	}
 
 	return 0;
<span class="p_chunk">@@ -1211,101 +1278,62 @@</span> <span class="p_context"> void xhci_cleanup_command_queue(struct xhci_hcd *xhci)</span>
 		xhci_complete_del_and_free_cmd(cur_cmd, COMP_CMD_ABORT);
 }
 
<span class="p_del">-/*</span>
<span class="p_del">- * Turn all commands on command ring with status set to &quot;aborted&quot; to no-op trbs.</span>
<span class="p_del">- * If there are other commands waiting then restart the ring and kick the timer.</span>
<span class="p_del">- * This must be called with command ring stopped and xhci-&gt;lock held.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void xhci_handle_stopped_cmd_ring(struct xhci_hcd *xhci,</span>
<span class="p_del">-					 struct xhci_command *cur_cmd)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct xhci_command *i_cmd, *tmp_cmd;</span>
<span class="p_del">-	u32 cycle_state;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Turn all aborted commands in list to no-ops, then restart */</span>
<span class="p_del">-	list_for_each_entry_safe(i_cmd, tmp_cmd, &amp;xhci-&gt;cmd_list,</span>
<span class="p_del">-				 cmd_list) {</span>
<span class="p_del">-</span>
<span class="p_del">-		if (i_cmd-&gt;status != COMP_CMD_ABORT)</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-</span>
<span class="p_del">-		i_cmd-&gt;status = COMP_CMD_STOP;</span>
<span class="p_del">-</span>
<span class="p_del">-		xhci_dbg(xhci, &quot;Turn aborted command %p to no-op\n&quot;,</span>
<span class="p_del">-			 i_cmd-&gt;command_trb);</span>
<span class="p_del">-		/* get cycle state from the original cmd trb */</span>
<span class="p_del">-		cycle_state = le32_to_cpu(</span>
<span class="p_del">-			i_cmd-&gt;command_trb-&gt;generic.field[3]) &amp;	TRB_CYCLE;</span>
<span class="p_del">-		/* modify the command trb to no-op command */</span>
<span class="p_del">-		i_cmd-&gt;command_trb-&gt;generic.field[0] = 0;</span>
<span class="p_del">-		i_cmd-&gt;command_trb-&gt;generic.field[1] = 0;</span>
<span class="p_del">-		i_cmd-&gt;command_trb-&gt;generic.field[2] = 0;</span>
<span class="p_del">-		i_cmd-&gt;command_trb-&gt;generic.field[3] = cpu_to_le32(</span>
<span class="p_del">-			TRB_TYPE(TRB_CMD_NOOP) | cycle_state);</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * caller waiting for completion is called when command</span>
<span class="p_del">-		 *  completion event is received for these no-op commands</span>
<span class="p_del">-		 */</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	xhci-&gt;cmd_ring_state = CMD_RING_STATE_RUNNING;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* ring command ring doorbell to restart the command ring */</span>
<span class="p_del">-	if ((xhci-&gt;cmd_ring-&gt;dequeue != xhci-&gt;cmd_ring-&gt;enqueue) &amp;&amp;</span>
<span class="p_del">-	    !(xhci-&gt;xhc_state &amp; XHCI_STATE_DYING)) {</span>
<span class="p_del">-		xhci-&gt;current_cmd = cur_cmd;</span>
<span class="p_del">-		mod_timer(&amp;xhci-&gt;cmd_timer, jiffies + XHCI_CMD_DEFAULT_TIMEOUT);</span>
<span class="p_del">-		xhci_ring_cmd_db(xhci);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-void xhci_handle_command_timeout(unsigned long data)</span>
<span class="p_add">+void xhci_handle_command_timeout(struct work_struct *work)</span>
 {
 	struct xhci_hcd *xhci;
 	int ret;
 	unsigned long flags;
 	u64 hw_ring_state;
<span class="p_del">-	bool second_timeout = false;</span>
<span class="p_del">-	xhci = (struct xhci_hcd *) data;</span>
 
<span class="p_del">-	/* mark this command to be cancelled */</span>
<span class="p_add">+	xhci = container_of(to_delayed_work(work), struct xhci_hcd, cmd_timer);</span>
<span class="p_add">+</span>
 	spin_lock_irqsave(&amp;xhci-&gt;lock, flags);
<span class="p_del">-	if (xhci-&gt;current_cmd) {</span>
<span class="p_del">-		if (xhci-&gt;current_cmd-&gt;status == COMP_CMD_ABORT)</span>
<span class="p_del">-			second_timeout = true;</span>
<span class="p_del">-		xhci-&gt;current_cmd-&gt;status = COMP_CMD_ABORT;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If timeout work is pending, or current_cmd is NULL, it means we</span>
<span class="p_add">+	 * raced with command completion. Command is handled so just return.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!xhci-&gt;current_cmd || delayed_work_pending(&amp;xhci-&gt;cmd_timer)) {</span>
<span class="p_add">+		spin_unlock_irqrestore(&amp;xhci-&gt;lock, flags);</span>
<span class="p_add">+		return;</span>
 	}
<span class="p_add">+	/* mark this command to be cancelled */</span>
<span class="p_add">+	xhci-&gt;current_cmd-&gt;status = COMP_CMD_ABORT;</span>
 
 	/* Make sure command ring is running before aborting it */
 	hw_ring_state = xhci_read_64(xhci, &amp;xhci-&gt;op_regs-&gt;cmd_ring);
 	if ((xhci-&gt;cmd_ring_state &amp; CMD_RING_STATE_RUNNING) &amp;&amp;
 	    (hw_ring_state &amp; CMD_RING_RUNNING))  {
<span class="p_del">-		spin_unlock_irqrestore(&amp;xhci-&gt;lock, flags);</span>
<span class="p_add">+		/* Prevent new doorbell, and start command abort */</span>
<span class="p_add">+		xhci-&gt;cmd_ring_state = CMD_RING_STATE_ABORTED;</span>
 		xhci_dbg(xhci, &quot;Command timeout\n&quot;);
<span class="p_del">-		ret = xhci_abort_cmd_ring(xhci);</span>
<span class="p_add">+		ret = xhci_abort_cmd_ring(xhci, flags);</span>
 		if (unlikely(ret == -ESHUTDOWN)) {
 			xhci_err(xhci, &quot;Abort command ring failed\n&quot;);
 			xhci_cleanup_command_queue(xhci);
<span class="p_add">+			spin_unlock_irqrestore(&amp;xhci-&gt;lock, flags);</span>
 			usb_hc_died(xhci_to_hcd(xhci)-&gt;primary_hcd);
 			xhci_dbg(xhci, &quot;xHCI host controller is dead.\n&quot;);
<span class="p_add">+</span>
<span class="p_add">+			return;</span>
 		}
<span class="p_del">-		return;</span>
<span class="p_add">+</span>
<span class="p_add">+		goto time_out_completed;</span>
 	}
 
<span class="p_del">-	/* command ring failed to restart, or host removed. Bail out */</span>
<span class="p_del">-	if (second_timeout || xhci-&gt;xhc_state &amp; XHCI_STATE_REMOVING) {</span>
<span class="p_del">-		spin_unlock_irqrestore(&amp;xhci-&gt;lock, flags);</span>
<span class="p_del">-		xhci_dbg(xhci, &quot;command timed out twice, ring start fail?\n&quot;);</span>
<span class="p_add">+	/* host removed. Bail out */</span>
<span class="p_add">+	if (xhci-&gt;xhc_state &amp; XHCI_STATE_REMOVING) {</span>
<span class="p_add">+		xhci_dbg(xhci, &quot;host removed, ring start fail?\n&quot;);</span>
 		xhci_cleanup_command_queue(xhci);
<span class="p_del">-		return;</span>
<span class="p_add">+</span>
<span class="p_add">+		goto time_out_completed;</span>
 	}
 
 	/* command timeout on stopped ring, ring can&#39;t be aborted */
 	xhci_dbg(xhci, &quot;Command timeout on stopped ring\n&quot;);
 	xhci_handle_stopped_cmd_ring(xhci, xhci-&gt;current_cmd);
<span class="p_add">+</span>
<span class="p_add">+time_out_completed:</span>
 	spin_unlock_irqrestore(&amp;xhci-&gt;lock, flags);
 	return;
 }
<span class="p_chunk">@@ -1338,7 +1366,7 @@</span> <span class="p_context"> static void handle_cmd_completion(struct xhci_hcd *xhci,</span>
 
 	cmd = list_entry(xhci-&gt;cmd_list.next, struct xhci_command, cmd_list);
 
<span class="p_del">-	del_timer(&amp;xhci-&gt;cmd_timer);</span>
<span class="p_add">+	cancel_delayed_work(&amp;xhci-&gt;cmd_timer);</span>
 
 	trace_xhci_cmd_completion(cmd_trb, (struct xhci_generic_trb *) event);
 
<span class="p_chunk">@@ -1346,7 +1374,7 @@</span> <span class="p_context"> static void handle_cmd_completion(struct xhci_hcd *xhci,</span>
 
 	/* If CMD ring stopped we own the trbs between enqueue and dequeue */
 	if (cmd_comp_code == COMP_CMD_STOP) {
<span class="p_del">-		xhci_handle_stopped_cmd_ring(xhci, cmd);</span>
<span class="p_add">+		complete_all(&amp;xhci-&gt;cmd_ring_stop_completion);</span>
 		return;
 	}
 
<span class="p_chunk">@@ -1364,8 +1392,11 @@</span> <span class="p_context"> static void handle_cmd_completion(struct xhci_hcd *xhci,</span>
 	 */
 	if (cmd_comp_code == COMP_CMD_ABORT) {
 		xhci-&gt;cmd_ring_state = CMD_RING_STATE_STOPPED;
<span class="p_del">-		if (cmd-&gt;status == COMP_CMD_ABORT)</span>
<span class="p_add">+		if (cmd-&gt;status == COMP_CMD_ABORT) {</span>
<span class="p_add">+			if (xhci-&gt;current_cmd == cmd)</span>
<span class="p_add">+				xhci-&gt;current_cmd = NULL;</span>
 			goto event_handled;
<span class="p_add">+		}</span>
 	}
 
 	cmd_type = TRB_FIELD_TO_TYPE(le32_to_cpu(cmd_trb-&gt;generic.field[3]));
<span class="p_chunk">@@ -1426,7 +1457,9 @@</span> <span class="p_context"> static void handle_cmd_completion(struct xhci_hcd *xhci,</span>
 	if (cmd-&gt;cmd_list.next != &amp;xhci-&gt;cmd_list) {
 		xhci-&gt;current_cmd = list_entry(cmd-&gt;cmd_list.next,
 					       struct xhci_command, cmd_list);
<span class="p_del">-		mod_timer(&amp;xhci-&gt;cmd_timer, jiffies + XHCI_CMD_DEFAULT_TIMEOUT);</span>
<span class="p_add">+		xhci_mod_cmd_timer(xhci, XHCI_CMD_DEFAULT_TIMEOUT);</span>
<span class="p_add">+	} else if (xhci-&gt;current_cmd == cmd) {</span>
<span class="p_add">+		xhci-&gt;current_cmd = NULL;</span>
 	}
 
 event_handled:
<span class="p_chunk">@@ -3920,9 +3953,9 @@</span> <span class="p_context"> static int queue_command(struct xhci_hcd *xhci, struct xhci_command *cmd,</span>
 
 	/* if there are no other commands queued we start the timeout timer */
 	if (xhci-&gt;cmd_list.next == &amp;cmd-&gt;cmd_list &amp;&amp;
<span class="p_del">-	    !timer_pending(&amp;xhci-&gt;cmd_timer)) {</span>
<span class="p_add">+	    !delayed_work_pending(&amp;xhci-&gt;cmd_timer)) {</span>
 		xhci-&gt;current_cmd = cmd;
<span class="p_del">-		mod_timer(&amp;xhci-&gt;cmd_timer, jiffies + XHCI_CMD_DEFAULT_TIMEOUT);</span>
<span class="p_add">+		xhci_mod_cmd_timer(xhci, XHCI_CMD_DEFAULT_TIMEOUT);</span>
 	}
 
 	queue_trb(xhci, xhci-&gt;cmd_ring, false, field1, field2, field3,
<span class="p_header">diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c</span>
<span class="p_header">index 1a4ca02729c2..ad0624386950 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci.c</span>
<span class="p_chunk">@@ -3783,8 +3783,10 @@</span> <span class="p_context"> static int xhci_setup_device(struct usb_hcd *hcd, struct usb_device *udev,</span>
 
 	mutex_lock(&amp;xhci-&gt;mutex);
 
<span class="p_del">-	if (xhci-&gt;xhc_state)	/* dying, removing or halted */</span>
<span class="p_add">+	if (xhci-&gt;xhc_state) {	/* dying, removing or halted */</span>
<span class="p_add">+		ret = -ESHUTDOWN;</span>
 		goto out;
<span class="p_add">+	}</span>
 
 	if (!udev-&gt;slot_id) {
 		xhci_dbg_trace(xhci, trace_xhci_dbg_address,
<span class="p_header">diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h</span>
<span class="p_header">index f945380035d0..c525722aa934 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci.h</span>
<span class="p_header">+++ b/drivers/usb/host/xhci.h</span>
<span class="p_chunk">@@ -1571,7 +1571,8 @@</span> <span class="p_context"> struct xhci_hcd {</span>
 #define CMD_RING_STATE_STOPPED         (1 &lt;&lt; 2)
 	struct list_head        cmd_list;
 	unsigned int		cmd_ring_reserved_trbs;
<span class="p_del">-	struct timer_list	cmd_timer;</span>
<span class="p_add">+	struct delayed_work	cmd_timer;</span>
<span class="p_add">+	struct completion	cmd_ring_stop_completion;</span>
 	struct xhci_command	*current_cmd;
 	struct xhci_ring	*event_ring;
 	struct xhci_erst	erst;
<span class="p_chunk">@@ -1941,7 +1942,7 @@</span> <span class="p_context"> void xhci_queue_config_ep_quirk(struct xhci_hcd *xhci,</span>
 		unsigned int slot_id, unsigned int ep_index,
 		struct xhci_dequeue_state *deq_state);
 void xhci_stop_endpoint_command_watchdog(unsigned long arg);
<span class="p_del">-void xhci_handle_command_timeout(unsigned long data);</span>
<span class="p_add">+void xhci_handle_command_timeout(struct work_struct *work);</span>
 
 void xhci_ring_ep_doorbell(struct xhci_hcd *xhci, unsigned int slot_id,
 		unsigned int ep_index, unsigned int stream_id);
<span class="p_header">diff --git a/drivers/usb/musb/blackfin.c b/drivers/usb/musb/blackfin.c</span>
<span class="p_header">index 310238c6b5cd..896798071817 100644</span>
<span class="p_header">--- a/drivers/usb/musb/blackfin.c</span>
<span class="p_header">+++ b/drivers/usb/musb/blackfin.c</span>
<span class="p_chunk">@@ -469,6 +469,7 @@</span> <span class="p_context"> static const struct musb_platform_ops bfin_ops = {</span>
 	.init		= bfin_musb_init,
 	.exit		= bfin_musb_exit,
 
<span class="p_add">+	.fifo_offset	= bfin_fifo_offset,</span>
 	.readb		= bfin_readb,
 	.writeb		= bfin_writeb,
 	.readw		= bfin_readw,
<span class="p_header">diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h</span>
<span class="p_header">index 91817d77d59c..47331dbdde29 100644</span>
<span class="p_header">--- a/drivers/usb/musb/musb_core.h</span>
<span class="p_header">+++ b/drivers/usb/musb/musb_core.h</span>
<span class="p_chunk">@@ -216,6 +216,7 @@</span> <span class="p_context"> struct musb_platform_ops {</span>
 	void	(*pre_root_reset_end)(struct musb *musb);
 	void	(*post_root_reset_end)(struct musb *musb);
 	int	(*phy_callback)(enum musb_vbus_id_status status);
<span class="p_add">+	void	(*clear_ep_rxintr)(struct musb *musb, int epnum);</span>
 };
 
 /*
<span class="p_chunk">@@ -626,4 +627,10 @@</span> <span class="p_context"> static inline void musb_platform_post_root_reset_end(struct musb *musb)</span>
 		musb-&gt;ops-&gt;post_root_reset_end(musb);
 }
 
<span class="p_add">+static inline void musb_platform_clear_ep_rxintr(struct musb *musb, int epnum)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (musb-&gt;ops-&gt;clear_ep_rxintr)</span>
<span class="p_add">+		musb-&gt;ops-&gt;clear_ep_rxintr(musb, epnum);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #endif	/* __MUSB_CORE_H__ */
<span class="p_header">diff --git a/drivers/usb/musb/musb_dsps.c b/drivers/usb/musb/musb_dsps.c</span>
<span class="p_header">index feae1561b9ab..9f125e179acd 100644</span>
<span class="p_header">--- a/drivers/usb/musb/musb_dsps.c</span>
<span class="p_header">+++ b/drivers/usb/musb/musb_dsps.c</span>
<span class="p_chunk">@@ -267,6 +267,17 @@</span> <span class="p_context"> static void otg_timer(unsigned long _musb)</span>
 	pm_runtime_put_autosuspend(dev);
 }
 
<span class="p_add">+void dsps_musb_clear_ep_rxintr(struct musb *musb, int epnum)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 epintr;</span>
<span class="p_add">+	struct dsps_glue *glue = dev_get_drvdata(musb-&gt;controller-&gt;parent);</span>
<span class="p_add">+	const struct dsps_musb_wrapper *wrp = glue-&gt;wrp;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* musb-&gt;lock might already been held */</span>
<span class="p_add">+	epintr = (1 &lt;&lt; epnum) &lt;&lt; wrp-&gt;rxep_shift;</span>
<span class="p_add">+	musb_writel(musb-&gt;ctrl_base, wrp-&gt;epintr_status, epintr);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static irqreturn_t dsps_interrupt(int irq, void *hci)
 {
 	struct musb  *musb = hci;
<span class="p_chunk">@@ -622,6 +633,7 @@</span> <span class="p_context"> static struct musb_platform_ops dsps_ops = {</span>
 
 	.set_mode	= dsps_musb_set_mode,
 	.recover	= dsps_musb_recover,
<span class="p_add">+	.clear_ep_rxintr = dsps_musb_clear_ep_rxintr,</span>
 };
 
 static u64 musb_dmamask = DMA_BIT_MASK(32);
<span class="p_header">diff --git a/drivers/usb/musb/musb_host.c b/drivers/usb/musb/musb_host.c</span>
<span class="p_header">index 53bc4ceefe89..806451418cfe 100644</span>
<span class="p_header">--- a/drivers/usb/musb/musb_host.c</span>
<span class="p_header">+++ b/drivers/usb/musb/musb_host.c</span>
<span class="p_chunk">@@ -2374,12 +2374,11 @@</span> <span class="p_context"> static int musb_cleanup_urb(struct urb *urb, struct musb_qh *qh)</span>
 	int			is_in = usb_pipein(urb-&gt;pipe);
 	int			status = 0;
 	u16			csr;
<span class="p_add">+	struct dma_channel	*dma = NULL;</span>
 
 	musb_ep_select(regs, hw_end);
 
 	if (is_dma_capable()) {
<span class="p_del">-		struct dma_channel	*dma;</span>
<span class="p_del">-</span>
 		dma = is_in ? ep-&gt;rx_channel : ep-&gt;tx_channel;
 		if (dma) {
 			status = ep-&gt;musb-&gt;dma_controller-&gt;channel_abort(dma);
<span class="p_chunk">@@ -2395,10 +2394,9 @@</span> <span class="p_context"> static int musb_cleanup_urb(struct urb *urb, struct musb_qh *qh)</span>
 		/* giveback saves bulk toggle */
 		csr = musb_h_flush_rxfifo(ep, 0);
 
<span class="p_del">-		/* REVISIT we still get an irq; should likely clear the</span>
<span class="p_del">-		 * endpoint&#39;s irq status here to avoid bogus irqs.</span>
<span class="p_del">-		 * clearing that status is platform-specific...</span>
<span class="p_del">-		 */</span>
<span class="p_add">+		/* clear the endpoint&#39;s irq status here to avoid bogus irqs */</span>
<span class="p_add">+		if (is_dma_capable() &amp;&amp; dma)</span>
<span class="p_add">+			musb_platform_clear_ep_rxintr(musb, ep-&gt;epnum);</span>
 	} else if (ep-&gt;epnum) {
 		musb_h_tx_flush_fifo(ep);
 		csr = musb_readw(epio, MUSB_TXCSR);
<span class="p_header">diff --git a/drivers/usb/musb/musbhsdma.h b/drivers/usb/musb/musbhsdma.h</span>
<span class="p_header">index f7b13fd25257..a3dcbd55e436 100644</span>
<span class="p_header">--- a/drivers/usb/musb/musbhsdma.h</span>
<span class="p_header">+++ b/drivers/usb/musb/musbhsdma.h</span>
<span class="p_chunk">@@ -157,5 +157,5 @@</span> <span class="p_context"> struct musb_dma_controller {</span>
 	void __iomem			*base;
 	u8				channel_count;
 	u8				used_channels;
<span class="p_del">-	u8				irq;</span>
<span class="p_add">+	int				irq;</span>
 };
<span class="p_header">diff --git a/drivers/usb/phy/phy-am335x-control.c b/drivers/usb/phy/phy-am335x-control.c</span>
<span class="p_header">index 42a1afe36a90..5f5f19813fde 100644</span>
<span class="p_header">--- a/drivers/usb/phy/phy-am335x-control.c</span>
<span class="p_header">+++ b/drivers/usb/phy/phy-am335x-control.c</span>
<span class="p_chunk">@@ -134,10 +134,12 @@</span> <span class="p_context"> struct phy_control *am335x_get_phy_control(struct device *dev)</span>
 		return NULL;
 
 	dev = bus_find_device(&amp;platform_bus_type, NULL, node, match);
<span class="p_add">+	of_node_put(node);</span>
 	if (!dev)
 		return NULL;
 
 	ctrl_usb = dev_get_drvdata(dev);
<span class="p_add">+	put_device(dev);</span>
 	if (!ctrl_usb)
 		return NULL;
 	return &amp;ctrl_usb-&gt;phy_ctrl;
<span class="p_header">diff --git a/drivers/usb/serial/cyberjack.c b/drivers/usb/serial/cyberjack.c</span>
<span class="p_header">index 5f17a3b9916d..80260b08398b 100644</span>
<span class="p_header">--- a/drivers/usb/serial/cyberjack.c</span>
<span class="p_header">+++ b/drivers/usb/serial/cyberjack.c</span>
<span class="p_chunk">@@ -50,6 +50,7 @@</span> <span class="p_context"></span>
 #define CYBERJACK_PRODUCT_ID	0x0100
 
 /* Function prototypes */
<span class="p_add">+static int cyberjack_attach(struct usb_serial *serial);</span>
 static int cyberjack_port_probe(struct usb_serial_port *port);
 static int cyberjack_port_remove(struct usb_serial_port *port);
 static int  cyberjack_open(struct tty_struct *tty,
<span class="p_chunk">@@ -77,6 +78,7 @@</span> <span class="p_context"> static struct usb_serial_driver cyberjack_device = {</span>
 	.description =		&quot;Reiner SCT Cyberjack USB card reader&quot;,
 	.id_table =		id_table,
 	.num_ports =		1,
<span class="p_add">+	.attach =		cyberjack_attach,</span>
 	.port_probe =		cyberjack_port_probe,
 	.port_remove =		cyberjack_port_remove,
 	.open =			cyberjack_open,
<span class="p_chunk">@@ -100,6 +102,14 @@</span> <span class="p_context"> struct cyberjack_private {</span>
 	short		wrsent;		/* Data already sent */
 };
 
<span class="p_add">+static int cyberjack_attach(struct usb_serial *serial)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (serial-&gt;num_bulk_out &lt; serial-&gt;num_ports)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int cyberjack_port_probe(struct usb_serial_port *port)
 {
 	struct cyberjack_private *priv;
<span class="p_header">diff --git a/drivers/usb/serial/garmin_gps.c b/drivers/usb/serial/garmin_gps.c</span>
<span class="p_header">index 97cabf803c2f..b2f2e87aed94 100644</span>
<span class="p_header">--- a/drivers/usb/serial/garmin_gps.c</span>
<span class="p_header">+++ b/drivers/usb/serial/garmin_gps.c</span>
<span class="p_chunk">@@ -1043,6 +1043,7 @@</span> <span class="p_context"> static int garmin_write_bulk(struct usb_serial_port *port,</span>
 		   &quot;%s - usb_submit_urb(write bulk) failed with status = %d\n&quot;,
 				__func__, status);
 		count = status;
<span class="p_add">+		kfree(buffer);</span>
 	}
 
 	/* we are done with this urb, so let the host driver
<span class="p_header">diff --git a/drivers/usb/serial/io_edgeport.c b/drivers/usb/serial/io_edgeport.c</span>
<span class="p_header">index 11c05ce2f35f..36dfe9972b17 100644</span>
<span class="p_header">--- a/drivers/usb/serial/io_edgeport.c</span>
<span class="p_header">+++ b/drivers/usb/serial/io_edgeport.c</span>
<span class="p_chunk">@@ -2754,6 +2754,11 @@</span> <span class="p_context"> static int edge_startup(struct usb_serial *serial)</span>
 					EDGE_COMPATIBILITY_MASK1,
 					EDGE_COMPATIBILITY_MASK2 };
 
<span class="p_add">+	if (serial-&gt;num_bulk_in &lt; 1 || serial-&gt;num_interrupt_in &lt; 1) {</span>
<span class="p_add">+		dev_err(&amp;serial-&gt;interface-&gt;dev, &quot;missing endpoints\n&quot;);</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	dev = serial-&gt;dev;
 
 	/* create our private serial structure */
<span class="p_header">diff --git a/drivers/usb/serial/io_ti.c b/drivers/usb/serial/io_ti.c</span>
<span class="p_header">index fce82fd79f77..c02808a30436 100644</span>
<span class="p_header">--- a/drivers/usb/serial/io_ti.c</span>
<span class="p_header">+++ b/drivers/usb/serial/io_ti.c</span>
<span class="p_chunk">@@ -1499,8 +1499,7 @@</span> <span class="p_context"> static int do_boot_mode(struct edgeport_serial *serial,</span>
 
 		dev_dbg(dev, &quot;%s - Download successful -- Device rebooting...\n&quot;, __func__);
 
<span class="p_del">-		/* return an error on purpose */</span>
<span class="p_del">-		return -ENODEV;</span>
<span class="p_add">+		return 1;</span>
 	}
 
 stayinbootmode:
<span class="p_chunk">@@ -1508,7 +1507,7 @@</span> <span class="p_context"> static int do_boot_mode(struct edgeport_serial *serial,</span>
 	dev_dbg(dev, &quot;%s - STAYING IN BOOT MODE\n&quot;, __func__);
 	serial-&gt;product_info.TiMode = TI_MODE_BOOT;
 
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return 1;</span>
 }
 
 static int ti_do_config(struct edgeport_port *port, int feature, int on)
<span class="p_chunk">@@ -2549,6 +2548,13 @@</span> <span class="p_context"> static int edge_startup(struct usb_serial *serial)</span>
 	int status;
 	u16 product_id;
 
<span class="p_add">+	/* Make sure we have the required endpoints when in download mode. */</span>
<span class="p_add">+	if (serial-&gt;interface-&gt;cur_altsetting-&gt;desc.bNumEndpoints &gt; 1) {</span>
<span class="p_add">+		if (serial-&gt;num_bulk_in &lt; serial-&gt;num_ports ||</span>
<span class="p_add">+				serial-&gt;num_bulk_out &lt; serial-&gt;num_ports)</span>
<span class="p_add">+			return -ENODEV;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* create our private serial structure */
 	edge_serial = kzalloc(sizeof(struct edgeport_serial), GFP_KERNEL);
 	if (!edge_serial)
<span class="p_chunk">@@ -2556,14 +2562,18 @@</span> <span class="p_context"> static int edge_startup(struct usb_serial *serial)</span>
 
 	mutex_init(&amp;edge_serial-&gt;es_lock);
 	edge_serial-&gt;serial = serial;
<span class="p_add">+	INIT_DELAYED_WORK(&amp;edge_serial-&gt;heartbeat_work, edge_heartbeat_work);</span>
 	usb_set_serial_data(serial, edge_serial);
 
 	status = download_fw(edge_serial);
<span class="p_del">-	if (status) {</span>
<span class="p_add">+	if (status &lt; 0) {</span>
 		kfree(edge_serial);
 		return status;
 	}
 
<span class="p_add">+	if (status &gt; 0)</span>
<span class="p_add">+		return 1;	/* bind but do not register any ports */</span>
<span class="p_add">+</span>
 	product_id = le16_to_cpu(
 			edge_serial-&gt;serial-&gt;dev-&gt;descriptor.idProduct);
 
<span class="p_chunk">@@ -2575,7 +2585,6 @@</span> <span class="p_context"> static int edge_startup(struct usb_serial *serial)</span>
 		}
 	}
 
<span class="p_del">-	INIT_DELAYED_WORK(&amp;edge_serial-&gt;heartbeat_work, edge_heartbeat_work);</span>
 	edge_heartbeat_schedule(edge_serial);
 
 	return 0;
<span class="p_chunk">@@ -2583,6 +2592,9 @@</span> <span class="p_context"> static int edge_startup(struct usb_serial *serial)</span>
 
 static void edge_disconnect(struct usb_serial *serial)
 {
<span class="p_add">+	struct edgeport_serial *edge_serial = usb_get_serial_data(serial);</span>
<span class="p_add">+</span>
<span class="p_add">+	cancel_delayed_work_sync(&amp;edge_serial-&gt;heartbeat_work);</span>
 }
 
 static void edge_release(struct usb_serial *serial)
<span class="p_header">diff --git a/drivers/usb/serial/iuu_phoenix.c b/drivers/usb/serial/iuu_phoenix.c</span>
<span class="p_header">index 344b4eea4bd5..d57fb5199218 100644</span>
<span class="p_header">--- a/drivers/usb/serial/iuu_phoenix.c</span>
<span class="p_header">+++ b/drivers/usb/serial/iuu_phoenix.c</span>
<span class="p_chunk">@@ -68,6 +68,16 @@</span> <span class="p_context"> struct iuu_private {</span>
 	u32 clk;
 };
 
<span class="p_add">+static int iuu_attach(struct usb_serial *serial)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned char num_ports = serial-&gt;num_ports;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (serial-&gt;num_bulk_in &lt; num_ports || serial-&gt;num_bulk_out &lt; num_ports)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int iuu_port_probe(struct usb_serial_port *port)
 {
 	struct iuu_private *priv;
<span class="p_chunk">@@ -1196,6 +1206,7 @@</span> <span class="p_context"> static struct usb_serial_driver iuu_device = {</span>
 	.tiocmset = iuu_tiocmset,
 	.set_termios = iuu_set_termios,
 	.init_termios = iuu_init_termios,
<span class="p_add">+	.attach = iuu_attach,</span>
 	.port_probe = iuu_port_probe,
 	.port_remove = iuu_port_remove,
 };
<span class="p_header">diff --git a/drivers/usb/serial/keyspan_pda.c b/drivers/usb/serial/keyspan_pda.c</span>
<span class="p_header">index e49ad0c63ad8..83523fcf6fb9 100644</span>
<span class="p_header">--- a/drivers/usb/serial/keyspan_pda.c</span>
<span class="p_header">+++ b/drivers/usb/serial/keyspan_pda.c</span>
<span class="p_chunk">@@ -699,6 +699,19 @@</span> <span class="p_context"> MODULE_FIRMWARE(&quot;keyspan_pda/keyspan_pda.fw&quot;);</span>
 MODULE_FIRMWARE(&quot;keyspan_pda/xircom_pgs.fw&quot;);
 #endif
 
<span class="p_add">+static int keyspan_pda_attach(struct usb_serial *serial)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned char num_ports = serial-&gt;num_ports;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (serial-&gt;num_bulk_out &lt; num_ports ||</span>
<span class="p_add">+			serial-&gt;num_interrupt_in &lt; num_ports) {</span>
<span class="p_add">+		dev_err(&amp;serial-&gt;interface-&gt;dev, &quot;missing endpoints\n&quot;);</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int keyspan_pda_port_probe(struct usb_serial_port *port)
 {
 
<span class="p_chunk">@@ -776,6 +789,7 @@</span> <span class="p_context"> static struct usb_serial_driver keyspan_pda_device = {</span>
 	.break_ctl =		keyspan_pda_break_ctl,
 	.tiocmget =		keyspan_pda_tiocmget,
 	.tiocmset =		keyspan_pda_tiocmset,
<span class="p_add">+	.attach =		keyspan_pda_attach,</span>
 	.port_probe =		keyspan_pda_port_probe,
 	.port_remove =		keyspan_pda_port_remove,
 };
<span class="p_header">diff --git a/drivers/usb/serial/kl5kusb105.c b/drivers/usb/serial/kl5kusb105.c</span>
<span class="p_header">index 6f29bfadbe33..0ee190fc1bf8 100644</span>
<span class="p_header">--- a/drivers/usb/serial/kl5kusb105.c</span>
<span class="p_header">+++ b/drivers/usb/serial/kl5kusb105.c</span>
<span class="p_chunk">@@ -311,6 +311,7 @@</span> <span class="p_context"> static int  klsi_105_open(struct tty_struct *tty, struct usb_serial_port *port)</span>
 	if (rc &lt; 0) {
 		dev_err(&amp;port-&gt;dev, &quot;Enabling read failed (error = %d)\n&quot;, rc);
 		retval = rc;
<span class="p_add">+		goto err_generic_close;</span>
 	} else
 		dev_dbg(&amp;port-&gt;dev, &quot;%s - enabled reading\n&quot;, __func__);
 
<span class="p_chunk">@@ -337,6 +338,7 @@</span> <span class="p_context"> static int  klsi_105_open(struct tty_struct *tty, struct usb_serial_port *port)</span>
 			     0, /* index */
 			     NULL, 0,
 			     KLSI_TIMEOUT);
<span class="p_add">+err_generic_close:</span>
 	usb_serial_generic_close(port);
 err_free_cfg:
 	kfree(cfg);
<span class="p_header">diff --git a/drivers/usb/serial/kobil_sct.c b/drivers/usb/serial/kobil_sct.c</span>
<span class="p_header">index 2363654cafc9..813035f51fe7 100644</span>
<span class="p_header">--- a/drivers/usb/serial/kobil_sct.c</span>
<span class="p_header">+++ b/drivers/usb/serial/kobil_sct.c</span>
<span class="p_chunk">@@ -51,6 +51,7 @@</span> <span class="p_context"></span>
 
 
 /* Function prototypes */
<span class="p_add">+static int kobil_attach(struct usb_serial *serial);</span>
 static int kobil_port_probe(struct usb_serial_port *probe);
 static int kobil_port_remove(struct usb_serial_port *probe);
 static int  kobil_open(struct tty_struct *tty, struct usb_serial_port *port);
<span class="p_chunk">@@ -86,6 +87,7 @@</span> <span class="p_context"> static struct usb_serial_driver kobil_device = {</span>
 	.description =		&quot;KOBIL USB smart card terminal&quot;,
 	.id_table =		id_table,
 	.num_ports =		1,
<span class="p_add">+	.attach =		kobil_attach,</span>
 	.port_probe =		kobil_port_probe,
 	.port_remove =		kobil_port_remove,
 	.ioctl =		kobil_ioctl,
<span class="p_chunk">@@ -113,6 +115,16 @@</span> <span class="p_context"> struct kobil_private {</span>
 };
 
 
<span class="p_add">+static int kobil_attach(struct usb_serial *serial)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (serial-&gt;num_interrupt_out &lt; serial-&gt;num_ports) {</span>
<span class="p_add">+		dev_err(&amp;serial-&gt;interface-&gt;dev, &quot;missing interrupt-out endpoint\n&quot;);</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int kobil_port_probe(struct usb_serial_port *port)
 {
 	struct usb_serial *serial = port-&gt;serial;
<span class="p_header">diff --git a/drivers/usb/serial/mos7720.c b/drivers/usb/serial/mos7720.c</span>
<span class="p_header">index de9992b492b0..136ff5e1b7c1 100644</span>
<span class="p_header">--- a/drivers/usb/serial/mos7720.c</span>
<span class="p_header">+++ b/drivers/usb/serial/mos7720.c</span>
<span class="p_chunk">@@ -65,8 +65,6 @@</span> <span class="p_context"> struct moschip_port {</span>
 	struct urb		*write_urb_pool[NUM_URBS];
 };
 
<span class="p_del">-static struct usb_serial_driver moschip7720_2port_driver;</span>
<span class="p_del">-</span>
 #define USB_VENDOR_ID_MOSCHIP		0x9710
 #define MOSCHIP_DEVICE_ID_7720		0x7720
 #define MOSCHIP_DEVICE_ID_7715		0x7715
<span class="p_chunk">@@ -970,25 +968,6 @@</span> <span class="p_context"> static void mos7720_bulk_out_data_callback(struct urb *urb)</span>
 		tty_port_tty_wakeup(&amp;mos7720_port-&gt;port-&gt;port);
 }
 
<span class="p_del">-/*</span>
<span class="p_del">- * mos77xx_probe</span>
<span class="p_del">- *	this function installs the appropriate read interrupt endpoint callback</span>
<span class="p_del">- *	depending on whether the device is a 7720 or 7715, thus avoiding costly</span>
<span class="p_del">- *	run-time checks in the high-frequency callback routine itself.</span>
<span class="p_del">- */</span>
<span class="p_del">-static int mos77xx_probe(struct usb_serial *serial,</span>
<span class="p_del">-			 const struct usb_device_id *id)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (id-&gt;idProduct == MOSCHIP_DEVICE_ID_7715)</span>
<span class="p_del">-		moschip7720_2port_driver.read_int_callback =</span>
<span class="p_del">-			mos7715_interrupt_callback;</span>
<span class="p_del">-	else</span>
<span class="p_del">-		moschip7720_2port_driver.read_int_callback =</span>
<span class="p_del">-			mos7720_interrupt_callback;</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static int mos77xx_calc_num_ports(struct usb_serial *serial)
 {
 	u16 product = le16_to_cpu(serial-&gt;dev-&gt;descriptor.idProduct);
<span class="p_chunk">@@ -1920,6 +1899,11 @@</span> <span class="p_context"> static int mos7720_startup(struct usb_serial *serial)</span>
 	u16 product;
 	int ret_val;
 
<span class="p_add">+	if (serial-&gt;num_bulk_in &lt; 2 || serial-&gt;num_bulk_out &lt; 2) {</span>
<span class="p_add">+		dev_err(&amp;serial-&gt;interface-&gt;dev, &quot;missing bulk endpoints\n&quot;);</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	product = le16_to_cpu(serial-&gt;dev-&gt;descriptor.idProduct);
 	dev = serial-&gt;dev;
 
<span class="p_chunk">@@ -1944,19 +1928,18 @@</span> <span class="p_context"> static int mos7720_startup(struct usb_serial *serial)</span>
 			tmp-&gt;interrupt_in_endpointAddress;
 		serial-&gt;port[1]-&gt;interrupt_in_urb = NULL;
 		serial-&gt;port[1]-&gt;interrupt_in_buffer = NULL;
<span class="p_add">+</span>
<span class="p_add">+		if (serial-&gt;port[0]-&gt;interrupt_in_urb) {</span>
<span class="p_add">+			struct urb *urb = serial-&gt;port[0]-&gt;interrupt_in_urb;</span>
<span class="p_add">+</span>
<span class="p_add">+			urb-&gt;complete = mos7715_interrupt_callback;</span>
<span class="p_add">+		}</span>
 	}
 
 	/* setting configuration feature to one */
 	usb_control_msg(serial-&gt;dev, usb_sndctrlpipe(serial-&gt;dev, 0),
 			(__u8)0x03, 0x00, 0x01, 0x00, NULL, 0x00, 5000);
 
<span class="p_del">-	/* start the interrupt urb */</span>
<span class="p_del">-	ret_val = usb_submit_urb(serial-&gt;port[0]-&gt;interrupt_in_urb, GFP_KERNEL);</span>
<span class="p_del">-	if (ret_val)</span>
<span class="p_del">-		dev_err(&amp;dev-&gt;dev,</span>
<span class="p_del">-			&quot;%s - Error %d submitting control urb\n&quot;,</span>
<span class="p_del">-			__func__, ret_val);</span>
<span class="p_del">-</span>
 #ifdef CONFIG_USB_SERIAL_MOS7715_PARPORT
 	if (product == MOSCHIP_DEVICE_ID_7715) {
 		ret_val = mos7715_parport_init(serial);
<span class="p_chunk">@@ -1964,6 +1947,13 @@</span> <span class="p_context"> static int mos7720_startup(struct usb_serial *serial)</span>
 			return ret_val;
 	}
 #endif
<span class="p_add">+	/* start the interrupt urb */</span>
<span class="p_add">+	ret_val = usb_submit_urb(serial-&gt;port[0]-&gt;interrupt_in_urb, GFP_KERNEL);</span>
<span class="p_add">+	if (ret_val) {</span>
<span class="p_add">+		dev_err(&amp;dev-&gt;dev, &quot;failed to submit interrupt urb: %d\n&quot;,</span>
<span class="p_add">+			ret_val);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* LSR For Port 1 */
 	read_mos_reg(serial, 0, MOS7720_LSR, &amp;data);
 	dev_dbg(&amp;dev-&gt;dev, &quot;LSR:%x\n&quot;, data);
<span class="p_chunk">@@ -1973,6 +1963,8 @@</span> <span class="p_context"> static int mos7720_startup(struct usb_serial *serial)</span>
 
 static void mos7720_release(struct usb_serial *serial)
 {
<span class="p_add">+	usb_kill_urb(serial-&gt;port[0]-&gt;interrupt_in_urb);</span>
<span class="p_add">+</span>
 #ifdef CONFIG_USB_SERIAL_MOS7715_PARPORT
 	/* close the parallel port */
 
<span class="p_chunk">@@ -2056,7 +2048,6 @@</span> <span class="p_context"> static struct usb_serial_driver moschip7720_2port_driver = {</span>
 	.close			= mos7720_close,
 	.throttle		= mos7720_throttle,
 	.unthrottle		= mos7720_unthrottle,
<span class="p_del">-	.probe			= mos77xx_probe,</span>
 	.attach			= mos7720_startup,
 	.release		= mos7720_release,
 	.port_probe		= mos7720_port_probe,
<span class="p_chunk">@@ -2070,7 +2061,7 @@</span> <span class="p_context"> static struct usb_serial_driver moschip7720_2port_driver = {</span>
 	.chars_in_buffer	= mos7720_chars_in_buffer,
 	.break_ctl		= mos7720_break,
 	.read_bulk_callback	= mos7720_bulk_in_callback,
<span class="p_del">-	.read_int_callback	= NULL  /* dynamically assigned in probe() */</span>
<span class="p_add">+	.read_int_callback	= mos7720_interrupt_callback,</span>
 };
 
 static struct usb_serial_driver * const serial_drivers[] = {
<span class="p_header">diff --git a/drivers/usb/serial/mos7840.c b/drivers/usb/serial/mos7840.c</span>
<span class="p_header">index 57426d703a09..4f9af47e6a29 100644</span>
<span class="p_header">--- a/drivers/usb/serial/mos7840.c</span>
<span class="p_header">+++ b/drivers/usb/serial/mos7840.c</span>
<span class="p_chunk">@@ -2116,6 +2116,17 @@</span> <span class="p_context"> static int mos7840_calc_num_ports(struct usb_serial *serial)</span>
 	return mos7840_num_ports;
 }
 
<span class="p_add">+static int mos7840_attach(struct usb_serial *serial)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (serial-&gt;num_bulk_in &lt; serial-&gt;num_ports ||</span>
<span class="p_add">+			serial-&gt;num_bulk_out &lt; serial-&gt;num_ports) {</span>
<span class="p_add">+		dev_err(&amp;serial-&gt;interface-&gt;dev, &quot;missing endpoints\n&quot;);</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int mos7840_port_probe(struct usb_serial_port *port)
 {
 	struct usb_serial *serial = port-&gt;serial;
<span class="p_chunk">@@ -2391,6 +2402,7 @@</span> <span class="p_context"> static struct usb_serial_driver moschip7840_4port_device = {</span>
 	.tiocmset = mos7840_tiocmset,
 	.tiocmiwait = usb_serial_generic_tiocmiwait,
 	.get_icount = usb_serial_generic_get_icount,
<span class="p_add">+	.attach = mos7840_attach,</span>
 	.port_probe = mos7840_port_probe,
 	.port_remove = mos7840_port_remove,
 	.read_bulk_callback = mos7840_bulk_in_callback,
<span class="p_header">diff --git a/drivers/usb/serial/omninet.c b/drivers/usb/serial/omninet.c</span>
<span class="p_header">index f6c6900bccf0..a180b17d2432 100644</span>
<span class="p_header">--- a/drivers/usb/serial/omninet.c</span>
<span class="p_header">+++ b/drivers/usb/serial/omninet.c</span>
<span class="p_chunk">@@ -38,6 +38,7 @@</span> <span class="p_context"> static int  omninet_write(struct tty_struct *tty, struct usb_serial_port *port,</span>
 				const unsigned char *buf, int count);
 static int  omninet_write_room(struct tty_struct *tty);
 static void omninet_disconnect(struct usb_serial *serial);
<span class="p_add">+static int omninet_attach(struct usb_serial *serial);</span>
 static int omninet_port_probe(struct usb_serial_port *port);
 static int omninet_port_remove(struct usb_serial_port *port);
 
<span class="p_chunk">@@ -56,6 +57,7 @@</span> <span class="p_context"> static struct usb_serial_driver zyxel_omninet_device = {</span>
 	.description =		&quot;ZyXEL - omni.net lcd plus usb&quot;,
 	.id_table =		id_table,
 	.num_ports =		1,
<span class="p_add">+	.attach =		omninet_attach,</span>
 	.port_probe =		omninet_port_probe,
 	.port_remove =		omninet_port_remove,
 	.open =			omninet_open,
<span class="p_chunk">@@ -104,6 +106,17 @@</span> <span class="p_context"> struct omninet_data {</span>
 	__u8	od_outseq;	/* Sequence number for bulk_out URBs */
 };
 
<span class="p_add">+static int omninet_attach(struct usb_serial *serial)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* The second bulk-out endpoint is used for writing. */</span>
<span class="p_add">+	if (serial-&gt;num_bulk_out &lt; 2) {</span>
<span class="p_add">+		dev_err(&amp;serial-&gt;interface-&gt;dev, &quot;missing endpoints\n&quot;);</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int omninet_port_probe(struct usb_serial_port *port)
 {
 	struct omninet_data *od;
<span class="p_header">diff --git a/drivers/usb/serial/oti6858.c b/drivers/usb/serial/oti6858.c</span>
<span class="p_header">index a4b88bc038b6..b8bf52bf7a94 100644</span>
<span class="p_header">--- a/drivers/usb/serial/oti6858.c</span>
<span class="p_header">+++ b/drivers/usb/serial/oti6858.c</span>
<span class="p_chunk">@@ -134,6 +134,7 @@</span> <span class="p_context"> static int oti6858_chars_in_buffer(struct tty_struct *tty);</span>
 static int oti6858_tiocmget(struct tty_struct *tty);
 static int oti6858_tiocmset(struct tty_struct *tty,
 				unsigned int set, unsigned int clear);
<span class="p_add">+static int oti6858_attach(struct usb_serial *serial);</span>
 static int oti6858_port_probe(struct usb_serial_port *port);
 static int oti6858_port_remove(struct usb_serial_port *port);
 
<span class="p_chunk">@@ -158,6 +159,7 @@</span> <span class="p_context"> static struct usb_serial_driver oti6858_device = {</span>
 	.write_bulk_callback =	oti6858_write_bulk_callback,
 	.write_room =		oti6858_write_room,
 	.chars_in_buffer =	oti6858_chars_in_buffer,
<span class="p_add">+	.attach =		oti6858_attach,</span>
 	.port_probe =		oti6858_port_probe,
 	.port_remove =		oti6858_port_remove,
 };
<span class="p_chunk">@@ -324,6 +326,20 @@</span> <span class="p_context"> static void send_data(struct work_struct *work)</span>
 	usb_serial_port_softint(port);
 }
 
<span class="p_add">+static int oti6858_attach(struct usb_serial *serial)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned char num_ports = serial-&gt;num_ports;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (serial-&gt;num_bulk_in &lt; num_ports ||</span>
<span class="p_add">+			serial-&gt;num_bulk_out &lt; num_ports ||</span>
<span class="p_add">+			serial-&gt;num_interrupt_in &lt; num_ports) {</span>
<span class="p_add">+		dev_err(&amp;serial-&gt;interface-&gt;dev, &quot;missing endpoints\n&quot;);</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int oti6858_port_probe(struct usb_serial_port *port)
 {
 	struct oti6858_private *priv;
<span class="p_header">diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c</span>
<span class="p_header">index ae682e4eeaef..46fca6b75846 100644</span>
<span class="p_header">--- a/drivers/usb/serial/pl2303.c</span>
<span class="p_header">+++ b/drivers/usb/serial/pl2303.c</span>
<span class="p_chunk">@@ -220,9 +220,17 @@</span> <span class="p_context"> static int pl2303_probe(struct usb_serial *serial,</span>
 static int pl2303_startup(struct usb_serial *serial)
 {
 	struct pl2303_serial_private *spriv;
<span class="p_add">+	unsigned char num_ports = serial-&gt;num_ports;</span>
 	enum pl2303_type type = TYPE_01;
 	unsigned char *buf;
 
<span class="p_add">+	if (serial-&gt;num_bulk_in &lt; num_ports ||</span>
<span class="p_add">+			serial-&gt;num_bulk_out &lt; num_ports ||</span>
<span class="p_add">+			serial-&gt;num_interrupt_in &lt; num_ports) {</span>
<span class="p_add">+		dev_err(&amp;serial-&gt;interface-&gt;dev, &quot;missing endpoints\n&quot;);</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	spriv = kzalloc(sizeof(*spriv), GFP_KERNEL);
 	if (!spriv)
 		return -ENOMEM;
<span class="p_header">diff --git a/drivers/usb/serial/quatech2.c b/drivers/usb/serial/quatech2.c</span>
<span class="p_header">index 85acb50a7ee2..bd1a1307e0f0 100644</span>
<span class="p_header">--- a/drivers/usb/serial/quatech2.c</span>
<span class="p_header">+++ b/drivers/usb/serial/quatech2.c</span>
<span class="p_chunk">@@ -408,16 +408,12 @@</span> <span class="p_context"> static void qt2_close(struct usb_serial_port *port)</span>
 {
 	struct usb_serial *serial;
 	struct qt2_port_private *port_priv;
<span class="p_del">-	unsigned long flags;</span>
 	int i;
 
 	serial = port-&gt;serial;
 	port_priv = usb_get_serial_port_data(port);
 
<span class="p_del">-	spin_lock_irqsave(&amp;port_priv-&gt;urb_lock, flags);</span>
 	usb_kill_urb(port_priv-&gt;write_urb);
<span class="p_del">-	port_priv-&gt;urb_in_use = false;</span>
<span class="p_del">-	spin_unlock_irqrestore(&amp;port_priv-&gt;urb_lock, flags);</span>
 
 	/* flush the port transmit buffer */
 	i = usb_control_msg(serial-&gt;dev,
<span class="p_header">diff --git a/drivers/usb/serial/spcp8x5.c b/drivers/usb/serial/spcp8x5.c</span>
<span class="p_header">index ef0dbf0703c5..475e6c31b266 100644</span>
<span class="p_header">--- a/drivers/usb/serial/spcp8x5.c</span>
<span class="p_header">+++ b/drivers/usb/serial/spcp8x5.c</span>
<span class="p_chunk">@@ -154,6 +154,19 @@</span> <span class="p_context"> static int spcp8x5_probe(struct usb_serial *serial,</span>
 	return 0;
 }
 
<span class="p_add">+static int spcp8x5_attach(struct usb_serial *serial)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned char num_ports = serial-&gt;num_ports;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (serial-&gt;num_bulk_in &lt; num_ports ||</span>
<span class="p_add">+			serial-&gt;num_bulk_out &lt; num_ports) {</span>
<span class="p_add">+		dev_err(&amp;serial-&gt;interface-&gt;dev, &quot;missing endpoints\n&quot;);</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int spcp8x5_port_probe(struct usb_serial_port *port)
 {
 	const struct usb_device_id *id = usb_get_serial_data(port-&gt;serial);
<span class="p_chunk">@@ -477,6 +490,7 @@</span> <span class="p_context"> static struct usb_serial_driver spcp8x5_device = {</span>
 	.tiocmget		= spcp8x5_tiocmget,
 	.tiocmset		= spcp8x5_tiocmset,
 	.probe			= spcp8x5_probe,
<span class="p_add">+	.attach			= spcp8x5_attach,</span>
 	.port_probe		= spcp8x5_port_probe,
 	.port_remove		= spcp8x5_port_remove,
 };
<span class="p_header">diff --git a/drivers/usb/serial/ti_usb_3410_5052.c b/drivers/usb/serial/ti_usb_3410_5052.c</span>
<span class="p_header">index a8b9bdba314f..bdbddbc8bd4d 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ti_usb_3410_5052.c</span>
<span class="p_header">+++ b/drivers/usb/serial/ti_usb_3410_5052.c</span>
<span class="p_chunk">@@ -579,6 +579,13 @@</span> <span class="p_context"> static int ti_startup(struct usb_serial *serial)</span>
 		goto free_tdev;
 	}
 
<span class="p_add">+	if (serial-&gt;num_bulk_in &lt; serial-&gt;num_ports ||</span>
<span class="p_add">+			serial-&gt;num_bulk_out &lt; serial-&gt;num_ports) {</span>
<span class="p_add">+		dev_err(&amp;serial-&gt;interface-&gt;dev, &quot;missing endpoints\n&quot;);</span>
<span class="p_add">+		status = -ENODEV;</span>
<span class="p_add">+		goto free_tdev;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return 0;
 
 free_tdev:
<span class="p_header">diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h</span>
<span class="p_header">index af3c7eecff91..16cc18369111 100644</span>
<span class="p_header">--- a/drivers/usb/storage/unusual_devs.h</span>
<span class="p_header">+++ b/drivers/usb/storage/unusual_devs.h</span>
<span class="p_chunk">@@ -2109,6 +2109,13 @@</span> <span class="p_context"> UNUSUAL_DEV(  0x152d, 0x2566, 0x0114, 0x0114,</span>
 		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
 		US_FL_BROKEN_FUA ),
 
<span class="p_add">+/* Reported-by George Cherian &lt;george.cherian@cavium.com&gt; */</span>
<span class="p_add">+UNUSUAL_DEV(0x152d, 0x9561, 0x0000, 0x9999,</span>
<span class="p_add">+		&quot;JMicron&quot;,</span>
<span class="p_add">+		&quot;JMS56x&quot;,</span>
<span class="p_add">+		USB_SC_DEVICE, USB_PR_DEVICE, NULL,</span>
<span class="p_add">+		US_FL_NO_REPORT_OPCODES),</span>
<span class="p_add">+</span>
 /*
  * Entrega Technologies U1-SC25 (later Xircom PortGear PGSCSI)
  * and Mac USB Dock USB-SCSI */
<span class="p_header">diff --git a/fs/crypto/policy.c b/fs/crypto/policy.c</span>
<span class="p_header">index 6865663aac69..abc18847b98d 100644</span>
<span class="p_header">--- a/fs/crypto/policy.c</span>
<span class="p_header">+++ b/fs/crypto/policy.c</span>
<span class="p_chunk">@@ -171,6 +171,11 @@</span> <span class="p_context"> int fscrypt_has_permitted_context(struct inode *parent, struct inode *child)</span>
 		BUG_ON(1);
 	}
 
<span class="p_add">+	/* No restrictions on file types which are never encrypted */</span>
<span class="p_add">+	if (!S_ISREG(child-&gt;i_mode) &amp;&amp; !S_ISDIR(child-&gt;i_mode) &amp;&amp;</span>
<span class="p_add">+	    !S_ISLNK(child-&gt;i_mode))</span>
<span class="p_add">+		return 1;</span>
<span class="p_add">+</span>
 	/* no restrictions if the parent directory is not encrypted */
 	if (!parent-&gt;i_sb-&gt;s_cop-&gt;is_encrypted(parent))
 		return 1;
<span class="p_header">diff --git a/fs/f2fs/data.c b/fs/f2fs/data.c</span>
<span class="p_header">index 9ae194fd2fdb..14db4b712021 100644</span>
<span class="p_header">--- a/fs/f2fs/data.c</span>
<span class="p_header">+++ b/fs/f2fs/data.c</span>
<span class="p_chunk">@@ -716,7 +716,7 @@</span> <span class="p_context"> int f2fs_map_blocks(struct inode *inode, struct f2fs_map_blocks *map,</span>
 	}
 
 	prealloc = 0;
<span class="p_del">-	ofs_in_node = dn.ofs_in_node;</span>
<span class="p_add">+	last_ofs_in_node = ofs_in_node = dn.ofs_in_node;</span>
 	end_offset = ADDRS_PER_PAGE(dn.node_page, inode);
 
 next_block:
<span class="p_header">diff --git a/fs/f2fs/debug.c b/fs/f2fs/debug.c</span>
<span class="p_header">index 1c35e80732e0..687998e9557c 100644</span>
<span class="p_header">--- a/fs/f2fs/debug.c</span>
<span class="p_header">+++ b/fs/f2fs/debug.c</span>
<span class="p_chunk">@@ -310,17 +310,17 @@</span> <span class="p_context"> static int stat_show(struct seq_file *s, void *v)</span>
 		seq_printf(s, &quot;  - Inner Struct Count: tree: %d(%d), node: %d\n&quot;,
 				si-&gt;ext_tree, si-&gt;zombie_tree, si-&gt;ext_node);
 		seq_puts(s, &quot;\nBalancing F2FS Async:\n&quot;);
<span class="p_del">-		seq_printf(s, &quot;  - inmem: %4lld, wb_bios: %4d\n&quot;,</span>
<span class="p_add">+		seq_printf(s, &quot;  - inmem: %4d, wb_bios: %4d\n&quot;,</span>
 			   si-&gt;inmem_pages, si-&gt;wb_bios);
<span class="p_del">-		seq_printf(s, &quot;  - nodes: %4lld in %4d\n&quot;,</span>
<span class="p_add">+		seq_printf(s, &quot;  - nodes: %4d in %4d\n&quot;,</span>
 			   si-&gt;ndirty_node, si-&gt;node_pages);
<span class="p_del">-		seq_printf(s, &quot;  - dents: %4lld in dirs:%4d (%4d)\n&quot;,</span>
<span class="p_add">+		seq_printf(s, &quot;  - dents: %4d in dirs:%4d (%4d)\n&quot;,</span>
 			   si-&gt;ndirty_dent, si-&gt;ndirty_dirs, si-&gt;ndirty_all);
<span class="p_del">-		seq_printf(s, &quot;  - datas: %4lld in files:%4d\n&quot;,</span>
<span class="p_add">+		seq_printf(s, &quot;  - datas: %4d in files:%4d\n&quot;,</span>
 			   si-&gt;ndirty_data, si-&gt;ndirty_files);
<span class="p_del">-		seq_printf(s, &quot;  - meta: %4lld in %4d\n&quot;,</span>
<span class="p_add">+		seq_printf(s, &quot;  - meta: %4d in %4d\n&quot;,</span>
 			   si-&gt;ndirty_meta, si-&gt;meta_pages);
<span class="p_del">-		seq_printf(s, &quot;  - imeta: %4lld\n&quot;,</span>
<span class="p_add">+		seq_printf(s, &quot;  - imeta: %4d\n&quot;,</span>
 			   si-&gt;ndirty_imeta);
 		seq_printf(s, &quot;  - NATs: %9d/%9d\n  - SITs: %9d/%9d\n&quot;,
 			   si-&gt;dirty_nats, si-&gt;nats, si-&gt;dirty_sits, si-&gt;sits);
<span class="p_header">diff --git a/fs/f2fs/f2fs.h b/fs/f2fs/f2fs.h</span>
<span class="p_header">index 6dd03115789b..506af456412f 100644</span>
<span class="p_header">--- a/fs/f2fs/f2fs.h</span>
<span class="p_header">+++ b/fs/f2fs/f2fs.h</span>
<span class="p_chunk">@@ -819,7 +819,7 @@</span> <span class="p_context"> struct f2fs_sb_info {</span>
 	atomic_t nr_wb_bios;			/* # of writeback bios */
 
 	/* # of pages, see count_type */
<span class="p_del">-	struct percpu_counter nr_pages[NR_COUNT_TYPE];</span>
<span class="p_add">+	atomic_t nr_pages[NR_COUNT_TYPE];</span>
 	/* # of allocated blocks */
 	struct percpu_counter alloc_valid_block_count;
 
<span class="p_chunk">@@ -1233,7 +1233,7 @@</span> <span class="p_context"> static inline void dec_valid_block_count(struct f2fs_sb_info *sbi,</span>
 
 static inline void inc_page_count(struct f2fs_sb_info *sbi, int count_type)
 {
<span class="p_del">-	percpu_counter_inc(&amp;sbi-&gt;nr_pages[count_type]);</span>
<span class="p_add">+	atomic_inc(&amp;sbi-&gt;nr_pages[count_type]);</span>
 
 	if (count_type == F2FS_DIRTY_DATA || count_type == F2FS_INMEM_PAGES)
 		return;
<span class="p_chunk">@@ -1250,7 +1250,7 @@</span> <span class="p_context"> static inline void inode_inc_dirty_pages(struct inode *inode)</span>
 
 static inline void dec_page_count(struct f2fs_sb_info *sbi, int count_type)
 {
<span class="p_del">-	percpu_counter_dec(&amp;sbi-&gt;nr_pages[count_type]);</span>
<span class="p_add">+	atomic_dec(&amp;sbi-&gt;nr_pages[count_type]);</span>
 }
 
 static inline void inode_dec_dirty_pages(struct inode *inode)
<span class="p_chunk">@@ -1266,7 +1266,7 @@</span> <span class="p_context"> static inline void inode_dec_dirty_pages(struct inode *inode)</span>
 
 static inline s64 get_pages(struct f2fs_sb_info *sbi, int count_type)
 {
<span class="p_del">-	return percpu_counter_sum_positive(&amp;sbi-&gt;nr_pages[count_type]);</span>
<span class="p_add">+	return atomic_read(&amp;sbi-&gt;nr_pages[count_type]);</span>
 }
 
 static inline int get_dirty_pages(struct inode *inode)
<span class="p_chunk">@@ -2187,8 +2187,8 @@</span> <span class="p_context"> struct f2fs_stat_info {</span>
 	unsigned long long hit_largest, hit_cached, hit_rbtree;
 	unsigned long long hit_total, total_ext;
 	int ext_tree, zombie_tree, ext_node;
<span class="p_del">-	s64 ndirty_node, ndirty_dent, ndirty_meta, ndirty_data, ndirty_imeta;</span>
<span class="p_del">-	s64 inmem_pages;</span>
<span class="p_add">+	int ndirty_node, ndirty_dent, ndirty_meta, ndirty_data, ndirty_imeta;</span>
<span class="p_add">+	int inmem_pages;</span>
 	unsigned int ndirty_dirs, ndirty_files, ndirty_all;
 	int nats, dirty_nats, sits, dirty_sits, fnids;
 	int total_count, utilization;
<span class="p_header">diff --git a/fs/f2fs/super.c b/fs/f2fs/super.c</span>
<span class="p_header">index 8021d35df7b0..013c6a541d6b 100644</span>
<span class="p_header">--- a/fs/f2fs/super.c</span>
<span class="p_header">+++ b/fs/f2fs/super.c</span>
<span class="p_chunk">@@ -688,10 +688,6 @@</span> <span class="p_context"> static void f2fs_destroy_inode(struct inode *inode)</span>
 
 static void destroy_percpu_info(struct f2fs_sb_info *sbi)
 {
<span class="p_del">-	int i;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; i &lt; NR_COUNT_TYPE; i++)</span>
<span class="p_del">-		percpu_counter_destroy(&amp;sbi-&gt;nr_pages[i]);</span>
 	percpu_counter_destroy(&amp;sbi-&gt;alloc_valid_block_count);
 	percpu_counter_destroy(&amp;sbi-&gt;total_valid_inode_count);
 }
<span class="p_chunk">@@ -1442,6 +1438,7 @@</span> <span class="p_context"> int sanity_check_ckpt(struct f2fs_sb_info *sbi)</span>
 static void init_sb_info(struct f2fs_sb_info *sbi)
 {
 	struct f2fs_super_block *raw_super = sbi-&gt;raw_super;
<span class="p_add">+	int i;</span>
 
 	sbi-&gt;log_sectors_per_block =
 		le32_to_cpu(raw_super-&gt;log_sectors_per_block);
<span class="p_chunk">@@ -1466,6 +1463,9 @@</span> <span class="p_context"> static void init_sb_info(struct f2fs_sb_info *sbi)</span>
 	sbi-&gt;interval_time[REQ_TIME] = DEF_IDLE_INTERVAL;
 	clear_sbi_flag(sbi, SBI_NEED_FSCK);
 
<span class="p_add">+	for (i = 0; i &lt; NR_COUNT_TYPE; i++)</span>
<span class="p_add">+		atomic_set(&amp;sbi-&gt;nr_pages[i], 0);</span>
<span class="p_add">+</span>
 	INIT_LIST_HEAD(&amp;sbi-&gt;s_list);
 	mutex_init(&amp;sbi-&gt;umount_mutex);
 	mutex_init(&amp;sbi-&gt;wio_mutex[NODE]);
<span class="p_chunk">@@ -1481,13 +1481,7 @@</span> <span class="p_context"> static void init_sb_info(struct f2fs_sb_info *sbi)</span>
 
 static int init_percpu_info(struct f2fs_sb_info *sbi)
 {
<span class="p_del">-	int i, err;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; i &lt; NR_COUNT_TYPE; i++) {</span>
<span class="p_del">-		err = percpu_counter_init(&amp;sbi-&gt;nr_pages[i], 0, GFP_KERNEL);</span>
<span class="p_del">-		if (err)</span>
<span class="p_del">-			return err;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	int err;</span>
 
 	err = percpu_counter_init(&amp;sbi-&gt;alloc_valid_block_count, 0, GFP_KERNEL);
 	if (err)
<span class="p_header">diff --git a/fs/xfs/libxfs/xfs_ag_resv.c b/fs/xfs/libxfs/xfs_ag_resv.c</span>
<span class="p_header">index e5ebc3770460..d346d42c54d1 100644</span>
<span class="p_header">--- a/fs/xfs/libxfs/xfs_ag_resv.c</span>
<span class="p_header">+++ b/fs/xfs/libxfs/xfs_ag_resv.c</span>
<span class="p_chunk">@@ -256,6 +256,9 @@</span> <span class="p_context"> xfs_ag_resv_init(</span>
 			goto out;
 	}
 
<span class="p_add">+	ASSERT(xfs_perag_resv(pag, XFS_AG_RESV_METADATA)-&gt;ar_reserved +</span>
<span class="p_add">+	       xfs_perag_resv(pag, XFS_AG_RESV_AGFL)-&gt;ar_reserved &lt;=</span>
<span class="p_add">+	       pag-&gt;pagf_freeblks + pag-&gt;pagf_flcount);</span>
 out:
 	return error;
 }
<span class="p_header">diff --git a/fs/xfs/libxfs/xfs_alloc.c b/fs/xfs/libxfs/xfs_alloc.c</span>
<span class="p_header">index effb64cf714f..5050056a0b06 100644</span>
<span class="p_header">--- a/fs/xfs/libxfs/xfs_alloc.c</span>
<span class="p_header">+++ b/fs/xfs/libxfs/xfs_alloc.c</span>
<span class="p_chunk">@@ -2455,12 +2455,15 @@</span> <span class="p_context"> xfs_agf_verify(</span>
 	      be32_to_cpu(agf-&gt;agf_flcount) &lt;= XFS_AGFL_SIZE(mp)))
 		return false;
 
<span class="p_del">-	if (be32_to_cpu(agf-&gt;agf_levels[XFS_BTNUM_BNO]) &gt; XFS_BTREE_MAXLEVELS ||</span>
<span class="p_add">+	if (be32_to_cpu(agf-&gt;agf_levels[XFS_BTNUM_BNO]) &lt; 1 ||</span>
<span class="p_add">+	    be32_to_cpu(agf-&gt;agf_levels[XFS_BTNUM_CNT]) &lt; 1 ||</span>
<span class="p_add">+	    be32_to_cpu(agf-&gt;agf_levels[XFS_BTNUM_BNO]) &gt; XFS_BTREE_MAXLEVELS ||</span>
 	    be32_to_cpu(agf-&gt;agf_levels[XFS_BTNUM_CNT]) &gt; XFS_BTREE_MAXLEVELS)
 		return false;
 
 	if (xfs_sb_version_hasrmapbt(&amp;mp-&gt;m_sb) &amp;&amp;
<span class="p_del">-	    be32_to_cpu(agf-&gt;agf_levels[XFS_BTNUM_RMAP]) &gt; XFS_BTREE_MAXLEVELS)</span>
<span class="p_add">+	    (be32_to_cpu(agf-&gt;agf_levels[XFS_BTNUM_RMAP]) &lt; 1 ||</span>
<span class="p_add">+	     be32_to_cpu(agf-&gt;agf_levels[XFS_BTNUM_RMAP]) &gt; XFS_BTREE_MAXLEVELS))</span>
 		return false;
 
 	/*
<span class="p_chunk">@@ -2477,7 +2480,8 @@</span> <span class="p_context"> xfs_agf_verify(</span>
 		return false;
 
 	if (xfs_sb_version_hasreflink(&amp;mp-&gt;m_sb) &amp;&amp;
<span class="p_del">-	    be32_to_cpu(agf-&gt;agf_refcount_level) &gt; XFS_BTREE_MAXLEVELS)</span>
<span class="p_add">+	    (be32_to_cpu(agf-&gt;agf_refcount_level) &lt; 1 ||</span>
<span class="p_add">+	     be32_to_cpu(agf-&gt;agf_refcount_level) &gt; XFS_BTREE_MAXLEVELS))</span>
 		return false;
 
 	return true;;
<span class="p_header">diff --git a/fs/xfs/libxfs/xfs_alloc_btree.c b/fs/xfs/libxfs/xfs_alloc_btree.c</span>
<span class="p_header">index 5ba2dac5e67c..c06ec77a9418 100644</span>
<span class="p_header">--- a/fs/xfs/libxfs/xfs_alloc_btree.c</span>
<span class="p_header">+++ b/fs/xfs/libxfs/xfs_alloc_btree.c</span>
<span class="p_chunk">@@ -421,7 +421,7 @@</span> <span class="p_context"> xfs_allocbt_init_cursor(</span>
 
 	ASSERT(btnum == XFS_BTNUM_BNO || btnum == XFS_BTNUM_CNT);
 
<span class="p_del">-	cur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_SLEEP);</span>
<span class="p_add">+	cur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_NOFS);</span>
 
 	cur-&gt;bc_tp = tp;
 	cur-&gt;bc_mp = mp;
<span class="p_header">diff --git a/fs/xfs/libxfs/xfs_attr_leaf.c b/fs/xfs/libxfs/xfs_attr_leaf.c</span>
<span class="p_header">index 8ea91f363093..2852521fc8ec 100644</span>
<span class="p_header">--- a/fs/xfs/libxfs/xfs_attr_leaf.c</span>
<span class="p_header">+++ b/fs/xfs/libxfs/xfs_attr_leaf.c</span>
<span class="p_chunk">@@ -253,6 +253,7 @@</span> <span class="p_context"> xfs_attr3_leaf_verify(</span>
 {
 	struct xfs_mount	*mp = bp-&gt;b_target-&gt;bt_mount;
 	struct xfs_attr_leafblock *leaf = bp-&gt;b_addr;
<span class="p_add">+	struct xfs_perag *pag = bp-&gt;b_pag;</span>
 	struct xfs_attr3_icleaf_hdr ichdr;
 
 	xfs_attr3_leaf_hdr_from_disk(mp-&gt;m_attr_geo, &amp;ichdr, leaf);
<span class="p_chunk">@@ -273,7 +274,12 @@</span> <span class="p_context"> xfs_attr3_leaf_verify(</span>
 		if (ichdr.magic != XFS_ATTR_LEAF_MAGIC)
 			return false;
 	}
<span class="p_del">-	if (ichdr.count == 0)</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * In recovery there is a transient state where count == 0 is valid</span>
<span class="p_add">+	 * because we may have transitioned an empty shortform attr to a leaf</span>
<span class="p_add">+	 * if the attr didn&#39;t fit in shortform.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (pag &amp;&amp; pag-&gt;pagf_init &amp;&amp; ichdr.count == 0)</span>
 		return false;
 
 	/* XXX: need to range check rest of attr header values */
<span class="p_header">diff --git a/fs/xfs/libxfs/xfs_bmap.c b/fs/xfs/libxfs/xfs_bmap.c</span>
<span class="p_header">index c6eb21940783..89d727b659fc 100644</span>
<span class="p_header">--- a/fs/xfs/libxfs/xfs_bmap.c</span>
<span class="p_header">+++ b/fs/xfs/libxfs/xfs_bmap.c</span>
<span class="p_chunk">@@ -49,6 +49,8 @@</span> <span class="p_context"></span>
 #include &quot;xfs_rmap.h&quot;
 #include &quot;xfs_ag_resv.h&quot;
 #include &quot;xfs_refcount.h&quot;
<span class="p_add">+#include &quot;xfs_rmap_btree.h&quot;</span>
<span class="p_add">+#include &quot;xfs_icache.h&quot;</span>
 
 
 kmem_zone_t		*xfs_bmap_free_item_zone;
<span class="p_chunk">@@ -190,8 +192,12 @@</span> <span class="p_context"> xfs_bmap_worst_indlen(</span>
 	int		maxrecs;	/* maximum record count at this level */
 	xfs_mount_t	*mp;		/* mount structure */
 	xfs_filblks_t	rval;		/* return value */
<span class="p_add">+	xfs_filblks_t   orig_len;</span>
 
 	mp = ip-&gt;i_mount;
<span class="p_add">+</span>
<span class="p_add">+	/* Calculate the worst-case size of the bmbt. */</span>
<span class="p_add">+	orig_len = len;</span>
 	maxrecs = mp-&gt;m_bmap_dmxr[0];
 	for (level = 0, rval = 0;
 	     level &lt; XFS_BM_MAXLEVELS(mp, XFS_DATA_FORK);
<span class="p_chunk">@@ -199,12 +205,20 @@</span> <span class="p_context"> xfs_bmap_worst_indlen(</span>
 		len += maxrecs - 1;
 		do_div(len, maxrecs);
 		rval += len;
<span class="p_del">-		if (len == 1)</span>
<span class="p_del">-			return rval + XFS_BM_MAXLEVELS(mp, XFS_DATA_FORK) -</span>
<span class="p_add">+		if (len == 1) {</span>
<span class="p_add">+			rval += XFS_BM_MAXLEVELS(mp, XFS_DATA_FORK) -</span>
 				level - 1;
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
 		if (level == 0)
 			maxrecs = mp-&gt;m_bmap_dmxr[1];
 	}
<span class="p_add">+</span>
<span class="p_add">+	/* Calculate the worst-case size of the rmapbt. */</span>
<span class="p_add">+	if (xfs_sb_version_hasrmapbt(&amp;mp-&gt;m_sb))</span>
<span class="p_add">+		rval += 1 + xfs_rmapbt_calc_size(mp, orig_len) +</span>
<span class="p_add">+				mp-&gt;m_rmap_maxlevels;</span>
<span class="p_add">+</span>
 	return rval;
 }
 
<span class="p_chunk">@@ -504,7 +518,7 @@</span> <span class="p_context"> void</span>
 xfs_bmap_trace_exlist(
 	xfs_inode_t	*ip,		/* incore inode pointer */
 	xfs_extnum_t	cnt,		/* count of entries in the list */
<span class="p_del">-	int		whichfork,	/* data or attr fork */</span>
<span class="p_add">+	int		whichfork,	/* data or attr or cow fork */</span>
 	unsigned long	caller_ip)
 {
 	xfs_extnum_t	idx;		/* extent record index */
<span class="p_chunk">@@ -513,11 +527,13 @@</span> <span class="p_context"> xfs_bmap_trace_exlist(</span>
 
 	if (whichfork == XFS_ATTR_FORK)
 		state |= BMAP_ATTRFORK;
<span class="p_add">+	else if (whichfork == XFS_COW_FORK)</span>
<span class="p_add">+		state |= BMAP_COWFORK;</span>
 
 	ifp = XFS_IFORK_PTR(ip, whichfork);
<span class="p_del">-	ASSERT(cnt == (ifp-&gt;if_bytes / (uint)sizeof(xfs_bmbt_rec_t)));</span>
<span class="p_add">+	ASSERT(cnt == xfs_iext_count(ifp));</span>
 	for (idx = 0; idx &lt; cnt; idx++)
<span class="p_del">-		trace_xfs_extlist(ip, idx, whichfork, caller_ip);</span>
<span class="p_add">+		trace_xfs_extlist(ip, idx, state, caller_ip);</span>
 }
 
 /*
<span class="p_chunk">@@ -811,7 +827,7 @@</span> <span class="p_context"> xfs_bmap_extents_to_btree(</span>
 				XFS_BTREE_LONG_PTRS);
 
 	arp = XFS_BMBT_REC_ADDR(mp, ablock, 1);
<span class="p_del">-	nextents = ifp-&gt;if_bytes / (uint)sizeof(xfs_bmbt_rec_t);</span>
<span class="p_add">+	nextents =  xfs_iext_count(ifp);</span>
 	for (cnt = i = 0; i &lt; nextents; i++) {
 		ep = xfs_iext_get_ext(ifp, i);
 		if (!isnullstartblock(xfs_bmbt_get_startblock(ep))) {
<span class="p_chunk">@@ -1137,6 +1153,10 @@</span> <span class="p_context"> xfs_bmap_add_attrfork(</span>
 		goto trans_cancel;
 	if (XFS_IFORK_Q(ip))
 		goto trans_cancel;
<span class="p_add">+	if (ip-&gt;i_d.di_anextents != 0) {</span>
<span class="p_add">+		error = -EFSCORRUPTED;</span>
<span class="p_add">+		goto trans_cancel;</span>
<span class="p_add">+	}</span>
 	if (ip-&gt;i_d.di_aformat != XFS_DINODE_FMT_EXTENTS) {
 		/*
 		 * For inodes coming from pre-6.2 filesystems.
<span class="p_chunk">@@ -1144,7 +1164,6 @@</span> <span class="p_context"> xfs_bmap_add_attrfork(</span>
 		ASSERT(ip-&gt;i_d.di_aformat == 0);
 		ip-&gt;i_d.di_aformat = XFS_DINODE_FMT_EXTENTS;
 	}
<span class="p_del">-	ASSERT(ip-&gt;i_d.di_anextents == 0);</span>
 
 	xfs_trans_ijoin(tp, ip, 0);
 	xfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);
<span class="p_chunk">@@ -1296,7 +1315,7 @@</span> <span class="p_context"> xfs_bmap_read_extents(</span>
 	/*
 	 * Here with bp and block set to the leftmost leaf node in the tree.
 	 */
<span class="p_del">-	room = ifp-&gt;if_bytes / (uint)sizeof(xfs_bmbt_rec_t);</span>
<span class="p_add">+	room = xfs_iext_count(ifp);</span>
 	i = 0;
 	/*
 	 * Loop over all leaf nodes.  Copy information to the extent records.
<span class="p_chunk">@@ -1361,8 +1380,9 @@</span> <span class="p_context"> xfs_bmap_read_extents(</span>
 			return error;
 		block = XFS_BUF_TO_BLOCK(bp);
 	}
<span class="p_del">-	ASSERT(i == (ifp-&gt;if_bytes / (uint)sizeof(xfs_bmbt_rec_t)));</span>
<span class="p_del">-	ASSERT(i == XFS_IFORK_NEXTENTS(ip, whichfork));</span>
<span class="p_add">+	if (i != XFS_IFORK_NEXTENTS(ip, whichfork))</span>
<span class="p_add">+		return -EFSCORRUPTED;</span>
<span class="p_add">+	ASSERT(i == xfs_iext_count(ifp));</span>
 	XFS_BMAP_TRACE_EXLIST(ip, i, whichfork);
 	return 0;
 error0:
<span class="p_chunk">@@ -1404,7 +1424,7 @@</span> <span class="p_context"> xfs_bmap_search_multi_extents(</span>
 	if (lastx &gt; 0) {
 		xfs_bmbt_get_all(xfs_iext_get_ext(ifp, lastx - 1), prevp);
 	}
<span class="p_del">-	if (lastx &lt; (ifp-&gt;if_bytes / (uint)sizeof(xfs_bmbt_rec_t))) {</span>
<span class="p_add">+	if (lastx &lt; xfs_iext_count(ifp)) {</span>
 		xfs_bmbt_get_all(ep, gotp);
 		*eofp = 0;
 	} else {
<span class="p_chunk">@@ -1497,7 +1517,7 @@</span> <span class="p_context"> xfs_bmap_first_unused(</span>
 	    (error = xfs_iread_extents(tp, ip, whichfork)))
 		return error;
 	lowest = *first_unused;
<span class="p_del">-	nextents = ifp-&gt;if_bytes / (uint)sizeof(xfs_bmbt_rec_t);</span>
<span class="p_add">+	nextents = xfs_iext_count(ifp);</span>
 	for (idx = 0, lastaddr = 0, max = lowest; idx &lt; nextents; idx++) {
 		xfs_bmbt_rec_host_t *ep = xfs_iext_get_ext(ifp, idx);
 		off = xfs_bmbt_get_startoff(ep);
<span class="p_chunk">@@ -1582,7 +1602,7 @@</span> <span class="p_context"> xfs_bmap_last_extent(</span>
 			return error;
 	}
 
<span class="p_del">-	nextents = ifp-&gt;if_bytes / sizeof(xfs_bmbt_rec_t);</span>
<span class="p_add">+	nextents = xfs_iext_count(ifp);</span>
 	if (nextents == 0) {
 		*is_empty = 1;
 		return 0;
<span class="p_chunk">@@ -1735,7 +1755,7 @@</span> <span class="p_context"> xfs_bmap_add_extent_delay_real(</span>
 						&amp;bma-&gt;ip-&gt;i_d.di_nextents);
 
 	ASSERT(bma-&gt;idx &gt;= 0);
<span class="p_del">-	ASSERT(bma-&gt;idx &lt;= ifp-&gt;if_bytes / sizeof(struct xfs_bmbt_rec));</span>
<span class="p_add">+	ASSERT(bma-&gt;idx &lt;= xfs_iext_count(ifp));</span>
 	ASSERT(!isnullstartblock(new-&gt;br_startblock));
 	ASSERT(!bma-&gt;cur ||
 	       (bma-&gt;cur-&gt;bc_private.b.flags &amp; XFS_BTCUR_BPRV_WASDEL));
<span class="p_chunk">@@ -1794,7 +1814,7 @@</span> <span class="p_context"> xfs_bmap_add_extent_delay_real(</span>
 	 * Don&#39;t set contiguous if the combined extent would be too large.
 	 * Also check for all-three-contiguous being too large.
 	 */
<span class="p_del">-	if (bma-&gt;idx &lt; ifp-&gt;if_bytes / (uint)sizeof(xfs_bmbt_rec_t) - 1) {</span>
<span class="p_add">+	if (bma-&gt;idx &lt; xfs_iext_count(ifp) - 1) {</span>
 		state |= BMAP_RIGHT_VALID;
 		xfs_bmbt_get_all(xfs_iext_get_ext(ifp, bma-&gt;idx + 1), &amp;RIGHT);
 
<span class="p_chunk">@@ -2300,7 +2320,7 @@</span> <span class="p_context"> xfs_bmap_add_extent_unwritten_real(</span>
 	ifp = XFS_IFORK_PTR(ip, XFS_DATA_FORK);
 
 	ASSERT(*idx &gt;= 0);
<span class="p_del">-	ASSERT(*idx &lt;= ifp-&gt;if_bytes / sizeof(struct xfs_bmbt_rec));</span>
<span class="p_add">+	ASSERT(*idx &lt;= xfs_iext_count(ifp));</span>
 	ASSERT(!isnullstartblock(new-&gt;br_startblock));
 
 	XFS_STATS_INC(mp, xs_add_exlist);
<span class="p_chunk">@@ -2356,7 +2376,7 @@</span> <span class="p_context"> xfs_bmap_add_extent_unwritten_real(</span>
 	 * Don&#39;t set contiguous if the combined extent would be too large.
 	 * Also check for all-three-contiguous being too large.
 	 */
<span class="p_del">-	if (*idx &lt; ip-&gt;i_df.if_bytes / (uint)sizeof(xfs_bmbt_rec_t) - 1) {</span>
<span class="p_add">+	if (*idx &lt; xfs_iext_count(&amp;ip-&gt;i_df) - 1) {</span>
 		state |= BMAP_RIGHT_VALID;
 		xfs_bmbt_get_all(xfs_iext_get_ext(ifp, *idx + 1), &amp;RIGHT);
 		if (isnullstartblock(RIGHT.br_startblock))
<span class="p_chunk">@@ -2836,7 +2856,7 @@</span> <span class="p_context"> xfs_bmap_add_extent_hole_delay(</span>
 	 * Check and set flags if the current (right) segment exists.
 	 * If it doesn&#39;t exist, we&#39;re converting the hole at end-of-file.
 	 */
<span class="p_del">-	if (*idx &lt; ifp-&gt;if_bytes / (uint)sizeof(xfs_bmbt_rec_t)) {</span>
<span class="p_add">+	if (*idx &lt; xfs_iext_count(ifp)) {</span>
 		state |= BMAP_RIGHT_VALID;
 		xfs_bmbt_get_all(xfs_iext_get_ext(ifp, *idx), &amp;right);
 
<span class="p_chunk">@@ -2966,7 +2986,7 @@</span> <span class="p_context"> xfs_bmap_add_extent_hole_real(</span>
 	ifp = XFS_IFORK_PTR(bma-&gt;ip, whichfork);
 
 	ASSERT(bma-&gt;idx &gt;= 0);
<span class="p_del">-	ASSERT(bma-&gt;idx &lt;= ifp-&gt;if_bytes / sizeof(struct xfs_bmbt_rec));</span>
<span class="p_add">+	ASSERT(bma-&gt;idx &lt;= xfs_iext_count(ifp));</span>
 	ASSERT(!isnullstartblock(new-&gt;br_startblock));
 	ASSERT(!bma-&gt;cur ||
 	       !(bma-&gt;cur-&gt;bc_private.b.flags &amp; XFS_BTCUR_BPRV_WASDEL));
<span class="p_chunk">@@ -2992,7 +3012,7 @@</span> <span class="p_context"> xfs_bmap_add_extent_hole_real(</span>
 	 * Check and set flags if this segment has a current value.
 	 * Not true if we&#39;re inserting into the &quot;hole&quot; at eof.
 	 */
<span class="p_del">-	if (bma-&gt;idx &lt; ifp-&gt;if_bytes / (uint)sizeof(xfs_bmbt_rec_t)) {</span>
<span class="p_add">+	if (bma-&gt;idx &lt; xfs_iext_count(ifp)) {</span>
 		state |= BMAP_RIGHT_VALID;
 		xfs_bmbt_get_all(xfs_iext_get_ext(ifp, bma-&gt;idx), &amp;right);
 		if (isnullstartblock(right.br_startblock))
<span class="p_chunk">@@ -4221,7 +4241,7 @@</span> <span class="p_context"> xfs_bmapi_read(</span>
 			break;
 
 		/* Else go on to the next record. */
<span class="p_del">-		if (++lastx &lt; ifp-&gt;if_bytes / sizeof(xfs_bmbt_rec_t))</span>
<span class="p_add">+		if (++lastx &lt; xfs_iext_count(ifp))</span>
 			xfs_bmbt_get_all(xfs_iext_get_ext(ifp, lastx), &amp;got);
 		else
 			eof = 1;
<span class="p_chunk">@@ -4234,10 +4254,10 @@</span> <span class="p_context"> int</span>
 xfs_bmapi_reserve_delalloc(
 	struct xfs_inode	*ip,
 	int			whichfork,
<span class="p_del">-	xfs_fileoff_t		aoff,</span>
<span class="p_add">+	xfs_fileoff_t		off,</span>
 	xfs_filblks_t		len,
<span class="p_add">+	xfs_filblks_t		prealloc,</span>
 	struct xfs_bmbt_irec	*got,
<span class="p_del">-	struct xfs_bmbt_irec	*prev,</span>
 	xfs_extnum_t		*lastx,
 	int			eof)
 {
<span class="p_chunk">@@ -4248,10 +4268,17 @@</span> <span class="p_context"> xfs_bmapi_reserve_delalloc(</span>
 	char			rt = XFS_IS_REALTIME_INODE(ip);
 	xfs_extlen_t		extsz;
 	int			error;
<span class="p_add">+	xfs_fileoff_t		aoff = off;</span>
 
<span class="p_del">-	alen = XFS_FILBLKS_MIN(len, MAXEXTLEN);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Cap the alloc length. Keep track of prealloc so we know whether to</span>
<span class="p_add">+	 * tag the inode before we return.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	alen = XFS_FILBLKS_MIN(len + prealloc, MAXEXTLEN);</span>
 	if (!eof)
 		alen = XFS_FILBLKS_MIN(alen, got-&gt;br_startoff - aoff);
<span class="p_add">+	if (prealloc &amp;&amp; alen &gt;= len)</span>
<span class="p_add">+		prealloc = alen - len;</span>
 
 	/* Figure out the extent size, adjust alen */
 	if (whichfork == XFS_COW_FORK)
<span class="p_chunk">@@ -4259,7 +4286,12 @@</span> <span class="p_context"> xfs_bmapi_reserve_delalloc(</span>
 	else
 		extsz = xfs_get_extsz_hint(ip);
 	if (extsz) {
<span class="p_del">-		error = xfs_bmap_extsize_align(mp, got, prev, extsz, rt, eof,</span>
<span class="p_add">+		struct xfs_bmbt_irec	prev;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!xfs_iext_get_extent(ifp, *lastx - 1, &amp;prev))</span>
<span class="p_add">+			prev.br_startoff = NULLFILEOFF;</span>
<span class="p_add">+</span>
<span class="p_add">+		error = xfs_bmap_extsize_align(mp, got, &amp;prev, extsz, rt, eof,</span>
 					       1, 0, &amp;aoff, &amp;alen);
 		ASSERT(!error);
 	}
<span class="p_chunk">@@ -4312,6 +4344,16 @@</span> <span class="p_context"> xfs_bmapi_reserve_delalloc(</span>
 	 */
 	xfs_bmbt_get_all(xfs_iext_get_ext(ifp, *lastx), got);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Tag the inode if blocks were preallocated. Note that COW fork</span>
<span class="p_add">+	 * preallocation can occur at the start or end of the extent, even when</span>
<span class="p_add">+	 * prealloc == 0, so we must also check the aligned offset and length.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (whichfork == XFS_DATA_FORK &amp;&amp; prealloc)</span>
<span class="p_add">+		xfs_inode_set_eofblocks_tag(ip);</span>
<span class="p_add">+	if (whichfork == XFS_COW_FORK &amp;&amp; (prealloc || aoff &lt; off || alen &gt; len))</span>
<span class="p_add">+		xfs_inode_set_cowblocks_tag(ip);</span>
<span class="p_add">+</span>
 	ASSERT(got-&gt;br_startoff &lt;= aoff);
 	ASSERT(got-&gt;br_startoff + got-&gt;br_blockcount &gt;= aoff + alen);
 	ASSERT(isnullstartblock(got-&gt;br_startblock));
<span class="p_chunk">@@ -4733,7 +4775,7 @@</span> <span class="p_context"> xfs_bmapi_write(</span>
 
 		/* Else go on to the next record. */
 		bma.prev = bma.got;
<span class="p_del">-		if (++bma.idx &lt; ifp-&gt;if_bytes / sizeof(xfs_bmbt_rec_t)) {</span>
<span class="p_add">+		if (++bma.idx &lt; xfs_iext_count(ifp)) {</span>
 			xfs_bmbt_get_all(xfs_iext_get_ext(ifp, bma.idx),
 					 &amp;bma.got);
 		} else
<span class="p_chunk">@@ -4885,7 +4927,7 @@</span> <span class="p_context"> xfs_bmap_del_extent_delay(</span>
 	da_new = 0;
 
 	ASSERT(*idx &gt;= 0);
<span class="p_del">-	ASSERT(*idx &lt; ifp-&gt;if_bytes / sizeof(struct xfs_bmbt_rec));</span>
<span class="p_add">+	ASSERT(*idx &lt;= xfs_iext_count(ifp));</span>
 	ASSERT(del-&gt;br_blockcount &gt; 0);
 	ASSERT(got-&gt;br_startoff &lt;= del-&gt;br_startoff);
 	ASSERT(got_endoff &gt;= del_endoff);
<span class="p_chunk">@@ -4902,8 +4944,11 @@</span> <span class="p_context"> xfs_bmap_del_extent_delay(</span>
 	 * sb counters as we might have to borrow some blocks for the
 	 * indirect block accounting.
 	 */
<span class="p_del">-	xfs_trans_reserve_quota_nblks(NULL, ip, -((long)del-&gt;br_blockcount), 0,</span>
<span class="p_add">+	error = xfs_trans_reserve_quota_nblks(NULL, ip,</span>
<span class="p_add">+			-((long)del-&gt;br_blockcount), 0,</span>
 			isrt ? XFS_QMOPT_RES_RTBLKS : XFS_QMOPT_RES_REGBLKS);
<span class="p_add">+	if (error)</span>
<span class="p_add">+		return error;</span>
 	ip-&gt;i_delayed_blks -= del-&gt;br_blockcount;
 
 	if (whichfork == XFS_COW_FORK)
<span class="p_chunk">@@ -5013,7 +5058,7 @@</span> <span class="p_context"> xfs_bmap_del_extent_cow(</span>
 	got_endoff = got-&gt;br_startoff + got-&gt;br_blockcount;
 
 	ASSERT(*idx &gt;= 0);
<span class="p_del">-	ASSERT(*idx &lt; ifp-&gt;if_bytes / sizeof(struct xfs_bmbt_rec));</span>
<span class="p_add">+	ASSERT(*idx &lt;= xfs_iext_count(ifp));</span>
 	ASSERT(del-&gt;br_blockcount &gt; 0);
 	ASSERT(got-&gt;br_startoff &lt;= del-&gt;br_startoff);
 	ASSERT(got_endoff &gt;= del_endoff);
<span class="p_chunk">@@ -5119,8 +5164,7 @@</span> <span class="p_context"> xfs_bmap_del_extent(</span>
 		state |= BMAP_COWFORK;
 
 	ifp = XFS_IFORK_PTR(ip, whichfork);
<span class="p_del">-	ASSERT((*idx &gt;= 0) &amp;&amp; (*idx &lt; ifp-&gt;if_bytes /</span>
<span class="p_del">-		(uint)sizeof(xfs_bmbt_rec_t)));</span>
<span class="p_add">+	ASSERT((*idx &gt;= 0) &amp;&amp; (*idx &lt; xfs_iext_count(ifp)));</span>
 	ASSERT(del-&gt;br_blockcount &gt; 0);
 	ep = xfs_iext_get_ext(ifp, *idx);
 	xfs_bmbt_get_all(ep, &amp;got);
<span class="p_chunk">@@ -5445,7 +5489,6 @@</span> <span class="p_context"> __xfs_bunmapi(</span>
 	int			logflags;	/* transaction logging flags */
 	xfs_extlen_t		mod;		/* rt extent offset */
 	xfs_mount_t		*mp;		/* mount structure */
<span class="p_del">-	xfs_extnum_t		nextents;	/* number of file extents */</span>
 	xfs_bmbt_irec_t		prev;		/* previous extent record */
 	xfs_fileoff_t		start;		/* first file offset deleted */
 	int			tmp_logflags;	/* partial logging flags */
<span class="p_chunk">@@ -5477,8 +5520,7 @@</span> <span class="p_context"> __xfs_bunmapi(</span>
 	if (!(ifp-&gt;if_flags &amp; XFS_IFEXTENTS) &amp;&amp;
 	    (error = xfs_iread_extents(tp, ip, whichfork)))
 		return error;
<span class="p_del">-	nextents = ifp-&gt;if_bytes / (uint)sizeof(xfs_bmbt_rec_t);</span>
<span class="p_del">-	if (nextents == 0) {</span>
<span class="p_add">+	if (xfs_iext_count(ifp) == 0) {</span>
 		*rlen = 0;
 		return 0;
 	}
<span class="p_chunk">@@ -5963,7 +6005,7 @@</span> <span class="p_context"> xfs_bmse_shift_one(</span>
 
 	mp = ip-&gt;i_mount;
 	ifp = XFS_IFORK_PTR(ip, whichfork);
<span class="p_del">-	total_extents = ifp-&gt;if_bytes / sizeof(xfs_bmbt_rec_t);</span>
<span class="p_add">+	total_extents = xfs_iext_count(ifp);</span>
 
 	xfs_bmbt_get_all(gotp, &amp;got);
 
<span class="p_chunk">@@ -6140,7 +6182,7 @@</span> <span class="p_context"> xfs_bmap_shift_extents(</span>
 	 * are collapsing out, so we cannot use the count of real extents here.
 	 * Instead we have to calculate it from the incore fork.
 	 */
<span class="p_del">-	total_extents = ifp-&gt;if_bytes / sizeof(xfs_bmbt_rec_t);</span>
<span class="p_add">+	total_extents = xfs_iext_count(ifp);</span>
 	if (total_extents == 0) {
 		*done = 1;
 		goto del_cursor;
<span class="p_chunk">@@ -6200,7 +6242,7 @@</span> <span class="p_context"> xfs_bmap_shift_extents(</span>
 		 * count can change. Update the total and grade the next record.
 		 */
 		if (direction == SHIFT_LEFT) {
<span class="p_del">-			total_extents = ifp-&gt;if_bytes / sizeof(xfs_bmbt_rec_t);</span>
<span class="p_add">+			total_extents = xfs_iext_count(ifp);</span>
 			stop_extent = total_extents;
 		}
 
<span class="p_header">diff --git a/fs/xfs/libxfs/xfs_bmap.h b/fs/xfs/libxfs/xfs_bmap.h</span>
<span class="p_header">index 7cae6ec27fa6..d6d175a4fdec 100644</span>
<span class="p_header">--- a/fs/xfs/libxfs/xfs_bmap.h</span>
<span class="p_header">+++ b/fs/xfs/libxfs/xfs_bmap.h</span>
<span class="p_chunk">@@ -242,9 +242,8 @@</span> <span class="p_context"> struct xfs_bmbt_rec_host *</span>
 		int fork, int *eofp, xfs_extnum_t *lastxp,
 		struct xfs_bmbt_irec *gotp, struct xfs_bmbt_irec *prevp);
 int	xfs_bmapi_reserve_delalloc(struct xfs_inode *ip, int whichfork,
<span class="p_del">-		xfs_fileoff_t aoff, xfs_filblks_t len,</span>
<span class="p_del">-		struct xfs_bmbt_irec *got, struct xfs_bmbt_irec *prev,</span>
<span class="p_del">-		xfs_extnum_t *lastx, int eof);</span>
<span class="p_add">+		xfs_fileoff_t off, xfs_filblks_t len, xfs_filblks_t prealloc,</span>
<span class="p_add">+		struct xfs_bmbt_irec *got, xfs_extnum_t *lastx, int eof);</span>
 
 enum xfs_bmap_intent_type {
 	XFS_BMAP_MAP = 1,
<span class="p_header">diff --git a/fs/xfs/libxfs/xfs_bmap_btree.c b/fs/xfs/libxfs/xfs_bmap_btree.c</span>
<span class="p_header">index 8007d2ba9aef..049fa597ae91 100644</span>
<span class="p_header">--- a/fs/xfs/libxfs/xfs_bmap_btree.c</span>
<span class="p_header">+++ b/fs/xfs/libxfs/xfs_bmap_btree.c</span>
<span class="p_chunk">@@ -796,7 +796,7 @@</span> <span class="p_context"> xfs_bmbt_init_cursor(</span>
 	struct xfs_btree_cur	*cur;
 	ASSERT(whichfork != XFS_COW_FORK);
 
<span class="p_del">-	cur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_SLEEP);</span>
<span class="p_add">+	cur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_NOFS);</span>
 
 	cur-&gt;bc_tp = tp;
 	cur-&gt;bc_mp = mp;
<span class="p_header">diff --git a/fs/xfs/libxfs/xfs_btree.c b/fs/xfs/libxfs/xfs_btree.c</span>
<span class="p_header">index 0e80993c8a59..21e6a6ab6b9a 100644</span>
<span class="p_header">--- a/fs/xfs/libxfs/xfs_btree.c</span>
<span class="p_header">+++ b/fs/xfs/libxfs/xfs_btree.c</span>
<span class="p_chunk">@@ -1769,8 +1769,28 @@</span> <span class="p_context"> xfs_btree_lookup_get_block(</span>
 	if (error)
 		return error;
 
<span class="p_add">+	/* Check the inode owner since the verifiers don&#39;t. */</span>
<span class="p_add">+	if (xfs_sb_version_hascrc(&amp;cur-&gt;bc_mp-&gt;m_sb) &amp;&amp;</span>
<span class="p_add">+	    (cur-&gt;bc_flags &amp; XFS_BTREE_LONG_PTRS) &amp;&amp;</span>
<span class="p_add">+	    be64_to_cpu((*blkp)-&gt;bb_u.l.bb_owner) !=</span>
<span class="p_add">+			cur-&gt;bc_private.b.ip-&gt;i_ino)</span>
<span class="p_add">+		goto out_bad;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Did we get the level we were looking for? */</span>
<span class="p_add">+	if (be16_to_cpu((*blkp)-&gt;bb_level) != level)</span>
<span class="p_add">+		goto out_bad;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Check that internal nodes have at least one record. */</span>
<span class="p_add">+	if (level != 0 &amp;&amp; be16_to_cpu((*blkp)-&gt;bb_numrecs) == 0)</span>
<span class="p_add">+		goto out_bad;</span>
<span class="p_add">+</span>
 	xfs_btree_setbuf(cur, level, bp);
 	return 0;
<span class="p_add">+</span>
<span class="p_add">+out_bad:</span>
<span class="p_add">+	*blkp = NULL;</span>
<span class="p_add">+	xfs_trans_brelse(cur-&gt;bc_tp, bp);</span>
<span class="p_add">+	return -EFSCORRUPTED;</span>
 }
 
 /*
<span class="p_header">diff --git a/fs/xfs/libxfs/xfs_dir2_data.c b/fs/xfs/libxfs/xfs_dir2_data.c</span>
<span class="p_header">index 725fc7841fde..e526f5a5f0be 100644</span>
<span class="p_header">--- a/fs/xfs/libxfs/xfs_dir2_data.c</span>
<span class="p_header">+++ b/fs/xfs/libxfs/xfs_dir2_data.c</span>
<span class="p_chunk">@@ -329,7 +329,7 @@</span> <span class="p_context"> xfs_dir3_data_read(</span>
 
 	err = xfs_da_read_buf(tp, dp, bno, mapped_bno, bpp,
 				XFS_DATA_FORK, &amp;xfs_dir3_data_buf_ops);
<span class="p_del">-	if (!err &amp;&amp; tp)</span>
<span class="p_add">+	if (!err &amp;&amp; tp &amp;&amp; *bpp)</span>
 		xfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_DIR_DATA_BUF);
 	return err;
 }
<span class="p_header">diff --git a/fs/xfs/libxfs/xfs_ialloc.c b/fs/xfs/libxfs/xfs_ialloc.c</span>
<span class="p_header">index 51b4e0de1fdc..d45c03779dae 100644</span>
<span class="p_header">--- a/fs/xfs/libxfs/xfs_ialloc.c</span>
<span class="p_header">+++ b/fs/xfs/libxfs/xfs_ialloc.c</span>
<span class="p_chunk">@@ -2450,8 +2450,6 @@</span> <span class="p_context"> xfs_ialloc_log_agi(</span>
 	ASSERT(agi-&gt;agi_magicnum == cpu_to_be32(XFS_AGI_MAGIC));
 #endif
 
<span class="p_del">-	xfs_trans_buf_set_type(tp, bp, XFS_BLFT_AGI_BUF);</span>
<span class="p_del">-</span>
 	/*
 	 * Compute byte offsets for the first and last fields in the first
 	 * region and log the agi buffer. This only logs up through
<span class="p_chunk">@@ -2512,8 +2510,15 @@</span> <span class="p_context"> xfs_agi_verify(</span>
 	if (!XFS_AGI_GOOD_VERSION(be32_to_cpu(agi-&gt;agi_versionnum)))
 		return false;
 
<span class="p_del">-	if (be32_to_cpu(agi-&gt;agi_level) &gt; XFS_BTREE_MAXLEVELS)</span>
<span class="p_add">+	if (be32_to_cpu(agi-&gt;agi_level) &lt; 1 ||</span>
<span class="p_add">+	    be32_to_cpu(agi-&gt;agi_level) &gt; XFS_BTREE_MAXLEVELS)</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (xfs_sb_version_hasfinobt(&amp;mp-&gt;m_sb) &amp;&amp;</span>
<span class="p_add">+	    (be32_to_cpu(agi-&gt;agi_free_level) &lt; 1 ||</span>
<span class="p_add">+	     be32_to_cpu(agi-&gt;agi_free_level) &gt; XFS_BTREE_MAXLEVELS))</span>
 		return false;
<span class="p_add">+</span>
 	/*
 	 * during growfs operations, the perag is not fully initialised,
 	 * so we can&#39;t use it for any useful checking. growfs ensures we can&#39;t
<span class="p_chunk">@@ -2592,6 +2597,8 @@</span> <span class="p_context"> xfs_read_agi(</span>
 			XFS_FSS_TO_BB(mp, 1), 0, bpp, &amp;xfs_agi_buf_ops);
 	if (error)
 		return error;
<span class="p_add">+	if (tp)</span>
<span class="p_add">+		xfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_AGI_BUF);</span>
 
 	xfs_buf_set_ref(*bpp, XFS_AGI_REF);
 	return 0;
<span class="p_header">diff --git a/fs/xfs/libxfs/xfs_ialloc_btree.c b/fs/xfs/libxfs/xfs_ialloc_btree.c</span>
<span class="p_header">index eab68ae2e011..6c6b95947e71 100644</span>
<span class="p_header">--- a/fs/xfs/libxfs/xfs_ialloc_btree.c</span>
<span class="p_header">+++ b/fs/xfs/libxfs/xfs_ialloc_btree.c</span>
<span class="p_chunk">@@ -357,7 +357,7 @@</span> <span class="p_context"> xfs_inobt_init_cursor(</span>
 	struct xfs_agi		*agi = XFS_BUF_TO_AGI(agbp);
 	struct xfs_btree_cur	*cur;
 
<span class="p_del">-	cur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_SLEEP);</span>
<span class="p_add">+	cur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_NOFS);</span>
 
 	cur-&gt;bc_tp = tp;
 	cur-&gt;bc_mp = mp;
<span class="p_header">diff --git a/fs/xfs/libxfs/xfs_inode_buf.c b/fs/xfs/libxfs/xfs_inode_buf.c</span>
<span class="p_header">index 134424fac434..c906e50515f0 100644</span>
<span class="p_header">--- a/fs/xfs/libxfs/xfs_inode_buf.c</span>
<span class="p_header">+++ b/fs/xfs/libxfs/xfs_inode_buf.c</span>
<span class="p_chunk">@@ -392,6 +392,14 @@</span> <span class="p_context"> xfs_dinode_verify(</span>
 	if (dip-&gt;di_magic != cpu_to_be16(XFS_DINODE_MAGIC))
 		return false;
 
<span class="p_add">+	/* don&#39;t allow invalid i_size */</span>
<span class="p_add">+	if (be64_to_cpu(dip-&gt;di_size) &amp; (1ULL &lt;&lt; 63))</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* No zero-length symlinks. */</span>
<span class="p_add">+	if (S_ISLNK(be16_to_cpu(dip-&gt;di_mode)) &amp;&amp; dip-&gt;di_size == 0)</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
 	/* only version 3 or greater inodes are extensively verified here */
 	if (dip-&gt;di_version &lt; 3)
 		return true;
<span class="p_header">diff --git a/fs/xfs/libxfs/xfs_inode_fork.c b/fs/xfs/libxfs/xfs_inode_fork.c</span>
<span class="p_header">index 5dd56d3dbb3a..222e103356c6 100644</span>
<span class="p_header">--- a/fs/xfs/libxfs/xfs_inode_fork.c</span>
<span class="p_header">+++ b/fs/xfs/libxfs/xfs_inode_fork.c</span>
<span class="p_chunk">@@ -775,6 +775,13 @@</span> <span class="p_context"> xfs_idestroy_fork(</span>
 	}
 }
 
<span class="p_add">+/* Count number of incore extents based on if_bytes */</span>
<span class="p_add">+xfs_extnum_t</span>
<span class="p_add">+xfs_iext_count(struct xfs_ifork *ifp)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return ifp-&gt;if_bytes / (uint)sizeof(xfs_bmbt_rec_t);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * Convert in-core extents to on-disk form
  *
<span class="p_chunk">@@ -803,7 +810,7 @@</span> <span class="p_context"> xfs_iextents_copy(</span>
 	ASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL|XFS_ILOCK_SHARED));
 	ASSERT(ifp-&gt;if_bytes &gt; 0);
 
<span class="p_del">-	nrecs = ifp-&gt;if_bytes / (uint)sizeof(xfs_bmbt_rec_t);</span>
<span class="p_add">+	nrecs = xfs_iext_count(ifp);</span>
 	XFS_BMAP_TRACE_EXLIST(ip, nrecs, whichfork);
 	ASSERT(nrecs &gt; 0);
 
<span class="p_chunk">@@ -941,7 +948,7 @@</span> <span class="p_context"> xfs_iext_get_ext(</span>
 	xfs_extnum_t	idx)		/* index of target extent */
 {
 	ASSERT(idx &gt;= 0);
<span class="p_del">-	ASSERT(idx &lt; ifp-&gt;if_bytes / sizeof(xfs_bmbt_rec_t));</span>
<span class="p_add">+	ASSERT(idx &lt; xfs_iext_count(ifp));</span>
 
 	if ((ifp-&gt;if_flags &amp; XFS_IFEXTIREC) &amp;&amp; (idx == 0)) {
 		return ifp-&gt;if_u1.if_ext_irec-&gt;er_extbuf;
<span class="p_chunk">@@ -1017,7 +1024,7 @@</span> <span class="p_context"> xfs_iext_add(</span>
 	int		new_size;	/* size of extents after adding */
 	xfs_extnum_t	nextents;	/* number of extents in file */
 
<span class="p_del">-	nextents = ifp-&gt;if_bytes / (uint)sizeof(xfs_bmbt_rec_t);</span>
<span class="p_add">+	nextents = xfs_iext_count(ifp);</span>
 	ASSERT((idx &gt;= 0) &amp;&amp; (idx &lt;= nextents));
 	byte_diff = ext_diff * sizeof(xfs_bmbt_rec_t);
 	new_size = ifp-&gt;if_bytes + byte_diff;
<span class="p_chunk">@@ -1241,7 +1248,7 @@</span> <span class="p_context"> xfs_iext_remove(</span>
 	trace_xfs_iext_remove(ip, idx, state, _RET_IP_);
 
 	ASSERT(ext_diff &gt; 0);
<span class="p_del">-	nextents = ifp-&gt;if_bytes / (uint)sizeof(xfs_bmbt_rec_t);</span>
<span class="p_add">+	nextents = xfs_iext_count(ifp);</span>
 	new_size = (nextents - ext_diff) * sizeof(xfs_bmbt_rec_t);
 
 	if (new_size == 0) {
<span class="p_chunk">@@ -1270,7 +1277,7 @@</span> <span class="p_context"> xfs_iext_remove_inline(</span>
 
 	ASSERT(!(ifp-&gt;if_flags &amp; XFS_IFEXTIREC));
 	ASSERT(idx &lt; XFS_INLINE_EXTS);
<span class="p_del">-	nextents = ifp-&gt;if_bytes / (uint)sizeof(xfs_bmbt_rec_t);</span>
<span class="p_add">+	nextents = xfs_iext_count(ifp);</span>
 	ASSERT(((nextents - ext_diff) &gt; 0) &amp;&amp;
 		(nextents - ext_diff) &lt; XFS_INLINE_EXTS);
 
<span class="p_chunk">@@ -1309,7 +1316,7 @@</span> <span class="p_context"> xfs_iext_remove_direct(</span>
 	ASSERT(!(ifp-&gt;if_flags &amp; XFS_IFEXTIREC));
 	new_size = ifp-&gt;if_bytes -
 		(ext_diff * sizeof(xfs_bmbt_rec_t));
<span class="p_del">-	nextents = ifp-&gt;if_bytes / (uint)sizeof(xfs_bmbt_rec_t);</span>
<span class="p_add">+	nextents = xfs_iext_count(ifp);</span>
 
 	if (new_size == 0) {
 		xfs_iext_destroy(ifp);
<span class="p_chunk">@@ -1546,7 +1553,7 @@</span> <span class="p_context"> xfs_iext_indirect_to_direct(</span>
 	int		size;		/* size of file extents */
 
 	ASSERT(ifp-&gt;if_flags &amp; XFS_IFEXTIREC);
<span class="p_del">-	nextents = ifp-&gt;if_bytes / (uint)sizeof(xfs_bmbt_rec_t);</span>
<span class="p_add">+	nextents = xfs_iext_count(ifp);</span>
 	ASSERT(nextents &lt;= XFS_LINEAR_EXTS);
 	size = nextents * sizeof(xfs_bmbt_rec_t);
 
<span class="p_chunk">@@ -1620,7 +1627,7 @@</span> <span class="p_context"> xfs_iext_bno_to_ext(</span>
 	xfs_extnum_t	nextents;	/* number of file extents */
 	xfs_fileoff_t	startoff = 0;	/* start offset of extent */
 
<span class="p_del">-	nextents = ifp-&gt;if_bytes / (uint)sizeof(xfs_bmbt_rec_t);</span>
<span class="p_add">+	nextents = xfs_iext_count(ifp);</span>
 	if (nextents == 0) {
 		*idxp = 0;
 		return NULL;
<span class="p_chunk">@@ -1733,8 +1740,8 @@</span> <span class="p_context"> xfs_iext_idx_to_irec(</span>
 
 	ASSERT(ifp-&gt;if_flags &amp; XFS_IFEXTIREC);
 	ASSERT(page_idx &gt;= 0);
<span class="p_del">-	ASSERT(page_idx &lt;= ifp-&gt;if_bytes / sizeof(xfs_bmbt_rec_t));</span>
<span class="p_del">-	ASSERT(page_idx &lt; ifp-&gt;if_bytes / sizeof(xfs_bmbt_rec_t) || realloc);</span>
<span class="p_add">+	ASSERT(page_idx &lt;= xfs_iext_count(ifp));</span>
<span class="p_add">+	ASSERT(page_idx &lt; xfs_iext_count(ifp) || realloc);</span>
 
 	nlists = ifp-&gt;if_real_bytes / XFS_IEXT_BUFSZ;
 	erp_idx = 0;
<span class="p_chunk">@@ -1782,7 +1789,7 @@</span> <span class="p_context"> xfs_iext_irec_init(</span>
 	xfs_extnum_t	nextents;	/* number of extents in file */
 
 	ASSERT(!(ifp-&gt;if_flags &amp; XFS_IFEXTIREC));
<span class="p_del">-	nextents = ifp-&gt;if_bytes / (uint)sizeof(xfs_bmbt_rec_t);</span>
<span class="p_add">+	nextents = xfs_iext_count(ifp);</span>
 	ASSERT(nextents &lt;= XFS_LINEAR_EXTS);
 
 	erp = kmem_alloc(sizeof(xfs_ext_irec_t), KM_NOFS);
<span class="p_chunk">@@ -1906,7 +1913,7 @@</span> <span class="p_context"> xfs_iext_irec_compact(</span>
 
 	ASSERT(ifp-&gt;if_flags &amp; XFS_IFEXTIREC);
 	nlists = ifp-&gt;if_real_bytes / XFS_IEXT_BUFSZ;
<span class="p_del">-	nextents = ifp-&gt;if_bytes / (uint)sizeof(xfs_bmbt_rec_t);</span>
<span class="p_add">+	nextents = xfs_iext_count(ifp);</span>
 
 	if (nextents == 0) {
 		xfs_iext_destroy(ifp);
<span class="p_chunk">@@ -1996,3 +2003,49 @@</span> <span class="p_context"> xfs_ifork_init_cow(</span>
 	ip-&gt;i_cformat = XFS_DINODE_FMT_EXTENTS;
 	ip-&gt;i_cnextents = 0;
 }
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Lookup the extent covering bno.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * If there is an extent covering bno return the extent index, and store the</span>
<span class="p_add">+ * expanded extent structure in *gotp, and the extent index in *idx.</span>
<span class="p_add">+ * If there is no extent covering bno, but there is an extent after it (e.g.</span>
<span class="p_add">+ * it lies in a hole) return that extent in *gotp and its index in *idx</span>
<span class="p_add">+ * instead.</span>
<span class="p_add">+ * If bno is beyond the last extent return false, and return the index after</span>
<span class="p_add">+ * the last valid index in *idxp.</span>
<span class="p_add">+ */</span>
<span class="p_add">+bool</span>
<span class="p_add">+xfs_iext_lookup_extent(</span>
<span class="p_add">+	struct xfs_inode	*ip,</span>
<span class="p_add">+	struct xfs_ifork	*ifp,</span>
<span class="p_add">+	xfs_fileoff_t		bno,</span>
<span class="p_add">+	xfs_extnum_t		*idxp,</span>
<span class="p_add">+	struct xfs_bmbt_irec	*gotp)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct xfs_bmbt_rec_host *ep;</span>
<span class="p_add">+</span>
<span class="p_add">+	XFS_STATS_INC(ip-&gt;i_mount, xs_look_exlist);</span>
<span class="p_add">+</span>
<span class="p_add">+	ep = xfs_iext_bno_to_ext(ifp, bno, idxp);</span>
<span class="p_add">+	if (!ep)</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+	xfs_bmbt_get_all(ep, gotp);</span>
<span class="p_add">+	return true;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Return true if there is an extent at index idx, and return the expanded</span>
<span class="p_add">+ * extent structure at idx in that case.  Else return false.</span>
<span class="p_add">+ */</span>
<span class="p_add">+bool</span>
<span class="p_add">+xfs_iext_get_extent(</span>
<span class="p_add">+	struct xfs_ifork	*ifp,</span>
<span class="p_add">+	xfs_extnum_t		idx,</span>
<span class="p_add">+	struct xfs_bmbt_irec	*gotp)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (idx &lt; 0 || idx &gt;= xfs_iext_count(ifp))</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+	xfs_bmbt_get_all(xfs_iext_get_ext(ifp, idx), gotp);</span>
<span class="p_add">+	return true;</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/fs/xfs/libxfs/xfs_inode_fork.h b/fs/xfs/libxfs/xfs_inode_fork.h</span>
<span class="p_header">index c9476f50e32d..7fb8365326d1 100644</span>
<span class="p_header">--- a/fs/xfs/libxfs/xfs_inode_fork.h</span>
<span class="p_header">+++ b/fs/xfs/libxfs/xfs_inode_fork.h</span>
<span class="p_chunk">@@ -152,6 +152,7 @@</span> <span class="p_context"> void		xfs_init_local_fork(struct xfs_inode *, int, const void *, int);</span>
 
 struct xfs_bmbt_rec_host *
 		xfs_iext_get_ext(struct xfs_ifork *, xfs_extnum_t);
<span class="p_add">+xfs_extnum_t	xfs_iext_count(struct xfs_ifork *);</span>
 void		xfs_iext_insert(struct xfs_inode *, xfs_extnum_t, xfs_extnum_t,
 				struct xfs_bmbt_irec *, int);
 void		xfs_iext_add(struct xfs_ifork *, xfs_extnum_t, int);
<span class="p_chunk">@@ -181,6 +182,12 @@</span> <span class="p_context"> void		xfs_iext_irec_compact_pages(struct xfs_ifork *);</span>
 void		xfs_iext_irec_compact_full(struct xfs_ifork *);
 void		xfs_iext_irec_update_extoffs(struct xfs_ifork *, int, int);
 
<span class="p_add">+bool		xfs_iext_lookup_extent(struct xfs_inode *ip,</span>
<span class="p_add">+			struct xfs_ifork *ifp, xfs_fileoff_t bno,</span>
<span class="p_add">+			xfs_extnum_t *idxp, struct xfs_bmbt_irec *gotp);</span>
<span class="p_add">+bool		xfs_iext_get_extent(struct xfs_ifork *ifp, xfs_extnum_t idx,</span>
<span class="p_add">+			struct xfs_bmbt_irec *gotp);</span>
<span class="p_add">+</span>
 extern struct kmem_zone	*xfs_ifork_zone;
 
 extern void xfs_ifork_init_cow(struct xfs_inode *ip);
<span class="p_header">diff --git a/fs/xfs/libxfs/xfs_refcount_btree.c b/fs/xfs/libxfs/xfs_refcount_btree.c</span>
<span class="p_header">index 453bb2757ec2..2ba216966002 100644</span>
<span class="p_header">--- a/fs/xfs/libxfs/xfs_refcount_btree.c</span>
<span class="p_header">+++ b/fs/xfs/libxfs/xfs_refcount_btree.c</span>
<span class="p_chunk">@@ -408,13 +408,14 @@</span> <span class="p_context"> xfs_refcountbt_calc_size(</span>
  */
 xfs_extlen_t
 xfs_refcountbt_max_size(
<span class="p_del">-	struct xfs_mount	*mp)</span>
<span class="p_add">+	struct xfs_mount	*mp,</span>
<span class="p_add">+	xfs_agblock_t		agblocks)</span>
 {
 	/* Bail out if we&#39;re uninitialized, which can happen in mkfs. */
 	if (mp-&gt;m_refc_mxr[0] == 0)
 		return 0;
 
<span class="p_del">-	return xfs_refcountbt_calc_size(mp, mp-&gt;m_sb.sb_agblocks);</span>
<span class="p_add">+	return xfs_refcountbt_calc_size(mp, agblocks);</span>
 }
 
 /*
<span class="p_chunk">@@ -429,22 +430,24 @@</span> <span class="p_context"> xfs_refcountbt_calc_reserves(</span>
 {
 	struct xfs_buf		*agbp;
 	struct xfs_agf		*agf;
<span class="p_add">+	xfs_agblock_t		agblocks;</span>
 	xfs_extlen_t		tree_len;
 	int			error;
 
 	if (!xfs_sb_version_hasreflink(&amp;mp-&gt;m_sb))
 		return 0;
 
<span class="p_del">-	*ask += xfs_refcountbt_max_size(mp);</span>
 
 	error = xfs_alloc_read_agf(mp, NULL, agno, 0, &amp;agbp);
 	if (error)
 		return error;
 
 	agf = XFS_BUF_TO_AGF(agbp);
<span class="p_add">+	agblocks = be32_to_cpu(agf-&gt;agf_length);</span>
 	tree_len = be32_to_cpu(agf-&gt;agf_refcount_blocks);
 	xfs_buf_relse(agbp);
 
<span class="p_add">+	*ask += xfs_refcountbt_max_size(mp, agblocks);</span>
 	*used += tree_len;
 
 	return error;
<span class="p_header">diff --git a/fs/xfs/libxfs/xfs_refcount_btree.h b/fs/xfs/libxfs/xfs_refcount_btree.h</span>
<span class="p_header">index 3be7768bd51a..9db008b955b7 100644</span>
<span class="p_header">--- a/fs/xfs/libxfs/xfs_refcount_btree.h</span>
<span class="p_header">+++ b/fs/xfs/libxfs/xfs_refcount_btree.h</span>
<span class="p_chunk">@@ -66,7 +66,8 @@</span> <span class="p_context"> extern void xfs_refcountbt_compute_maxlevels(struct xfs_mount *mp);</span>
 
 extern xfs_extlen_t xfs_refcountbt_calc_size(struct xfs_mount *mp,
 		unsigned long long len);
<span class="p_del">-extern xfs_extlen_t xfs_refcountbt_max_size(struct xfs_mount *mp);</span>
<span class="p_add">+extern xfs_extlen_t xfs_refcountbt_max_size(struct xfs_mount *mp,</span>
<span class="p_add">+		xfs_agblock_t agblocks);</span>
 
 extern int xfs_refcountbt_calc_reserves(struct xfs_mount *mp,
 		xfs_agnumber_t agno, xfs_extlen_t *ask, xfs_extlen_t *used);
<span class="p_header">diff --git a/fs/xfs/libxfs/xfs_rmap_btree.c b/fs/xfs/libxfs/xfs_rmap_btree.c</span>
<span class="p_header">index 83e672ff7577..33a28efc3085 100644</span>
<span class="p_header">--- a/fs/xfs/libxfs/xfs_rmap_btree.c</span>
<span class="p_header">+++ b/fs/xfs/libxfs/xfs_rmap_btree.c</span>
<span class="p_chunk">@@ -549,13 +549,14 @@</span> <span class="p_context"> xfs_rmapbt_calc_size(</span>
  */
 xfs_extlen_t
 xfs_rmapbt_max_size(
<span class="p_del">-	struct xfs_mount	*mp)</span>
<span class="p_add">+	struct xfs_mount	*mp,</span>
<span class="p_add">+	xfs_agblock_t		agblocks)</span>
 {
 	/* Bail out if we&#39;re uninitialized, which can happen in mkfs. */
 	if (mp-&gt;m_rmap_mxr[0] == 0)
 		return 0;
 
<span class="p_del">-	return xfs_rmapbt_calc_size(mp, mp-&gt;m_sb.sb_agblocks);</span>
<span class="p_add">+	return xfs_rmapbt_calc_size(mp, agblocks);</span>
 }
 
 /*
<span class="p_chunk">@@ -570,25 +571,24 @@</span> <span class="p_context"> xfs_rmapbt_calc_reserves(</span>
 {
 	struct xfs_buf		*agbp;
 	struct xfs_agf		*agf;
<span class="p_del">-	xfs_extlen_t		pool_len;</span>
<span class="p_add">+	xfs_agblock_t		agblocks;</span>
 	xfs_extlen_t		tree_len;
 	int			error;
 
 	if (!xfs_sb_version_hasrmapbt(&amp;mp-&gt;m_sb))
 		return 0;
 
<span class="p_del">-	/* Reserve 1% of the AG or enough for 1 block per record. */</span>
<span class="p_del">-	pool_len = max(mp-&gt;m_sb.sb_agblocks / 100, xfs_rmapbt_max_size(mp));</span>
<span class="p_del">-	*ask += pool_len;</span>
<span class="p_del">-</span>
 	error = xfs_alloc_read_agf(mp, NULL, agno, 0, &amp;agbp);
 	if (error)
 		return error;
 
 	agf = XFS_BUF_TO_AGF(agbp);
<span class="p_add">+	agblocks = be32_to_cpu(agf-&gt;agf_length);</span>
 	tree_len = be32_to_cpu(agf-&gt;agf_rmap_blocks);
 	xfs_buf_relse(agbp);
 
<span class="p_add">+	/* Reserve 1% of the AG or enough for 1 block per record. */</span>
<span class="p_add">+	*ask += max(agblocks / 100, xfs_rmapbt_max_size(mp, agblocks));</span>
 	*used += tree_len;
 
 	return error;
<span class="p_header">diff --git a/fs/xfs/libxfs/xfs_rmap_btree.h b/fs/xfs/libxfs/xfs_rmap_btree.h</span>
<span class="p_header">index 2a9ac472fb15..19c08e933049 100644</span>
<span class="p_header">--- a/fs/xfs/libxfs/xfs_rmap_btree.h</span>
<span class="p_header">+++ b/fs/xfs/libxfs/xfs_rmap_btree.h</span>
<span class="p_chunk">@@ -60,7 +60,8 @@</span> <span class="p_context"> extern void xfs_rmapbt_compute_maxlevels(struct xfs_mount *mp);</span>
 
 extern xfs_extlen_t xfs_rmapbt_calc_size(struct xfs_mount *mp,
 		unsigned long long len);
<span class="p_del">-extern xfs_extlen_t xfs_rmapbt_max_size(struct xfs_mount *mp);</span>
<span class="p_add">+extern xfs_extlen_t xfs_rmapbt_max_size(struct xfs_mount *mp,</span>
<span class="p_add">+		xfs_agblock_t agblocks);</span>
 
 extern int xfs_rmapbt_calc_reserves(struct xfs_mount *mp,
 		xfs_agnumber_t agno, xfs_extlen_t *ask, xfs_extlen_t *used);
<span class="p_header">diff --git a/fs/xfs/libxfs/xfs_sb.c b/fs/xfs/libxfs/xfs_sb.c</span>
<span class="p_header">index a70aec910626..2580262e4ea0 100644</span>
<span class="p_header">--- a/fs/xfs/libxfs/xfs_sb.c</span>
<span class="p_header">+++ b/fs/xfs/libxfs/xfs_sb.c</span>
<span class="p_chunk">@@ -262,6 +262,12 @@</span> <span class="p_context"> xfs_mount_validate_sb(</span>
 		return -EFSCORRUPTED;
 	}
 
<span class="p_add">+	if (xfs_sb_version_hascrc(&amp;mp-&gt;m_sb) &amp;&amp;</span>
<span class="p_add">+	    sbp-&gt;sb_blocksize &lt; XFS_MIN_CRC_BLOCKSIZE) {</span>
<span class="p_add">+		xfs_notice(mp, &quot;v5 SB sanity check failed&quot;);</span>
<span class="p_add">+		return -EFSCORRUPTED;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/*
 	 * Until this is fixed only page-sized or smaller data blocks work.
 	 */
<span class="p_chunk">@@ -338,13 +344,16 @@</span> <span class="p_context"> xfs_sb_quota_from_disk(struct xfs_sb *sbp)</span>
 					XFS_PQUOTA_CHKD : XFS_GQUOTA_CHKD;
 	sbp-&gt;sb_qflags &amp;= ~(XFS_OQUOTA_ENFD | XFS_OQUOTA_CHKD);
 
<span class="p_del">-	if (sbp-&gt;sb_qflags &amp; XFS_PQUOTA_ACCT)  {</span>
<span class="p_add">+	if (sbp-&gt;sb_qflags &amp; XFS_PQUOTA_ACCT &amp;&amp;</span>
<span class="p_add">+	    sbp-&gt;sb_gquotino != NULLFSINO)  {</span>
 		/*
 		 * In older version of superblock, on-disk superblock only
 		 * has sb_gquotino, and in-core superblock has both sb_gquotino
 		 * and sb_pquotino. But, only one of them is supported at any
 		 * point of time. So, if PQUOTA is set in disk superblock,
<span class="p_del">-		 * copy over sb_gquotino to sb_pquotino.</span>
<span class="p_add">+		 * copy over sb_gquotino to sb_pquotino.  The NULLFSINO test</span>
<span class="p_add">+		 * above is to make sure we don&#39;t do this twice and wipe them</span>
<span class="p_add">+		 * both out!</span>
 		 */
 		sbp-&gt;sb_pquotino = sbp-&gt;sb_gquotino;
 		sbp-&gt;sb_gquotino = NULLFSINO;
<span class="p_header">diff --git a/fs/xfs/libxfs/xfs_types.h b/fs/xfs/libxfs/xfs_types.h</span>
<span class="p_header">index 8d74870468c2..cf044c0f4d41 100644</span>
<span class="p_header">--- a/fs/xfs/libxfs/xfs_types.h</span>
<span class="p_header">+++ b/fs/xfs/libxfs/xfs_types.h</span>
<span class="p_chunk">@@ -75,11 +75,14 @@</span> <span class="p_context"> typedef __int64_t	xfs_sfiloff_t;	/* signed block number in a file */</span>
  * Minimum and maximum blocksize and sectorsize.
  * The blocksize upper limit is pretty much arbitrary.
  * The sectorsize upper limit is due to sizeof(sb_sectsize).
<span class="p_add">+ * CRC enable filesystems use 512 byte inodes, meaning 512 byte block sizes</span>
<span class="p_add">+ * cannot be used.</span>
  */
 #define XFS_MIN_BLOCKSIZE_LOG	9	/* i.e. 512 bytes */
 #define XFS_MAX_BLOCKSIZE_LOG	16	/* i.e. 65536 bytes */
 #define XFS_MIN_BLOCKSIZE	(1 &lt;&lt; XFS_MIN_BLOCKSIZE_LOG)
 #define XFS_MAX_BLOCKSIZE	(1 &lt;&lt; XFS_MAX_BLOCKSIZE_LOG)
<span class="p_add">+#define XFS_MIN_CRC_BLOCKSIZE	(1 &lt;&lt; (XFS_MIN_BLOCKSIZE_LOG + 1))</span>
 #define XFS_MIN_SECTORSIZE_LOG	9	/* i.e. 512 bytes */
 #define XFS_MAX_SECTORSIZE_LOG	15	/* i.e. 32768 bytes */
 #define XFS_MIN_SECTORSIZE	(1 &lt;&lt; XFS_MIN_SECTORSIZE_LOG)
<span class="p_header">diff --git a/fs/xfs/xfs_aops.c b/fs/xfs/xfs_aops.c</span>
<span class="p_header">index 3e57a56cf829..2693ba84ec25 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_aops.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_aops.c</span>
<span class="p_chunk">@@ -1361,6 +1361,26 @@</span> <span class="p_context"> __xfs_get_blocks(</span>
 	if (error)
 		goto out_unlock;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The only time we can ever safely find delalloc blocks on direct I/O</span>
<span class="p_add">+	 * is a dio write to post-eof speculative preallocation. All other</span>
<span class="p_add">+	 * scenarios are indicative of a problem or misuse (such as mixing</span>
<span class="p_add">+	 * direct and mapped I/O).</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * The file may be unmapped by the time we get here so we cannot</span>
<span class="p_add">+	 * reliably fail the I/O based on mapping. Instead, fail the I/O if this</span>
<span class="p_add">+	 * is a read or a write within eof. Otherwise, carry on but warn as a</span>
<span class="p_add">+	 * precuation if the file happens to be mapped.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (direct &amp;&amp; imap.br_startblock == DELAYSTARTBLOCK) {</span>
<span class="p_add">+		if (!create || offset &lt; i_size_read(VFS_I(ip))) {</span>
<span class="p_add">+			WARN_ON_ONCE(1);</span>
<span class="p_add">+			error = -EIO;</span>
<span class="p_add">+			goto out_unlock;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		WARN_ON_ONCE(mapping_mapped(VFS_I(ip)-&gt;i_mapping));</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* for DAX, we convert unwritten extents directly */
 	if (create &amp;&amp;
 	    (!nimaps ||
<span class="p_chunk">@@ -1450,8 +1470,6 @@</span> <span class="p_context"> __xfs_get_blocks(</span>
 	     (new || ISUNWRITTEN(&amp;imap))))
 		set_buffer_new(bh_result);
 
<span class="p_del">-	BUG_ON(direct &amp;&amp; imap.br_startblock == DELAYSTARTBLOCK);</span>
<span class="p_del">-</span>
 	return 0;
 
 out_unlock:
<span class="p_header">diff --git a/fs/xfs/xfs_bmap_util.c b/fs/xfs/xfs_bmap_util.c</span>
<span class="p_header">index 47074e0c33f3..0670a8bd5818 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_bmap_util.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_bmap_util.c</span>
<span class="p_chunk">@@ -359,9 +359,7 @@</span> <span class="p_context"> xfs_bmap_count_blocks(</span>
 	mp = ip-&gt;i_mount;
 	ifp = XFS_IFORK_PTR(ip, whichfork);
 	if ( XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS ) {
<span class="p_del">-		xfs_bmap_count_leaves(ifp, 0,</span>
<span class="p_del">-			ifp-&gt;if_bytes / (uint)sizeof(xfs_bmbt_rec_t),</span>
<span class="p_del">-			count);</span>
<span class="p_add">+		xfs_bmap_count_leaves(ifp, 0, xfs_iext_count(ifp), count);</span>
 		return 0;
 	}
 
<span class="p_chunk">@@ -426,7 +424,7 @@</span> <span class="p_context"> xfs_getbmapx_fix_eof_hole(</span>
 		ifp = XFS_IFORK_PTR(ip, whichfork);
 		if (!moretocome &amp;&amp;
 		    xfs_iext_bno_to_ext(ifp, fileblock, &amp;lastx) &amp;&amp;
<span class="p_del">-		   (lastx == (ifp-&gt;if_bytes / (uint)sizeof(xfs_bmbt_rec_t))-1))</span>
<span class="p_add">+		   (lastx == xfs_iext_count(ifp) - 1))</span>
 			out-&gt;bmv_oflags |= BMV_OF_LAST;
 	}
 
<span class="p_chunk">@@ -1878,15 +1876,13 @@</span> <span class="p_context"> xfs_swap_extent_forks(</span>
 
 	switch (ip-&gt;i_d.di_format) {
 	case XFS_DINODE_FMT_EXTENTS:
<span class="p_del">-		/* If the extents fit in the inode, fix the</span>
<span class="p_del">-		 * pointer.  Otherwise it&#39;s already NULL or</span>
<span class="p_del">-		 * pointing to the extent.</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * If the extents fit in the inode, fix the pointer.  Otherwise</span>
<span class="p_add">+		 * it&#39;s already NULL or pointing to the extent.</span>
 		 */
<span class="p_del">-		nextents = ip-&gt;i_df.if_bytes / (uint)sizeof(xfs_bmbt_rec_t);</span>
<span class="p_del">-		if (nextents &lt;= XFS_INLINE_EXTS) {</span>
<span class="p_del">-			ifp-&gt;if_u1.if_extents =</span>
<span class="p_del">-				ifp-&gt;if_u2.if_inline_ext;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		nextents = xfs_iext_count(&amp;ip-&gt;i_df);</span>
<span class="p_add">+		if (nextents &lt;= XFS_INLINE_EXTS)</span>
<span class="p_add">+			ifp-&gt;if_u1.if_extents = ifp-&gt;if_u2.if_inline_ext;</span>
 		(*src_log_flags) |= XFS_ILOG_DEXT;
 		break;
 	case XFS_DINODE_FMT_BTREE:
<span class="p_chunk">@@ -1898,15 +1894,13 @@</span> <span class="p_context"> xfs_swap_extent_forks(</span>
 
 	switch (tip-&gt;i_d.di_format) {
 	case XFS_DINODE_FMT_EXTENTS:
<span class="p_del">-		/* If the extents fit in the inode, fix the</span>
<span class="p_del">-		 * pointer.  Otherwise it&#39;s already NULL or</span>
<span class="p_del">-		 * pointing to the extent.</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * If the extents fit in the inode, fix the pointer.  Otherwise</span>
<span class="p_add">+		 * it&#39;s already NULL or pointing to the extent.</span>
 		 */
<span class="p_del">-		nextents = tip-&gt;i_df.if_bytes / (uint)sizeof(xfs_bmbt_rec_t);</span>
<span class="p_del">-		if (nextents &lt;= XFS_INLINE_EXTS) {</span>
<span class="p_del">-			tifp-&gt;if_u1.if_extents =</span>
<span class="p_del">-				tifp-&gt;if_u2.if_inline_ext;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		nextents = xfs_iext_count(&amp;tip-&gt;i_df);</span>
<span class="p_add">+		if (nextents &lt;= XFS_INLINE_EXTS)</span>
<span class="p_add">+			tifp-&gt;if_u1.if_extents = tifp-&gt;if_u2.if_inline_ext;</span>
 		(*target_log_flags) |= XFS_ILOG_DEXT;
 		break;
 	case XFS_DINODE_FMT_BTREE:
<span class="p_header">diff --git a/fs/xfs/xfs_file.c b/fs/xfs/xfs_file.c</span>
<span class="p_header">index 6e4f7f900fea..9a5d64b5f35a 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_file.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_file.c</span>
<span class="p_chunk">@@ -939,7 +939,6 @@</span> <span class="p_context"> xfs_file_clone_range(</span>
 				     len, false);
 }
 
<span class="p_del">-#define XFS_MAX_DEDUPE_LEN	(16 * 1024 * 1024)</span>
 STATIC ssize_t
 xfs_file_dedupe_range(
 	struct file	*src_file,
<span class="p_chunk">@@ -950,14 +949,6 @@</span> <span class="p_context"> xfs_file_dedupe_range(</span>
 {
 	int		error;
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Limit the total length we will dedupe for each operation.</span>
<span class="p_del">-	 * This is intended to bound the total time spent in this</span>
<span class="p_del">-	 * ioctl to something sane.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (len &gt; XFS_MAX_DEDUPE_LEN)</span>
<span class="p_del">-		len = XFS_MAX_DEDUPE_LEN;</span>
<span class="p_del">-</span>
 	error = xfs_reflink_remap_range(src_file, loff, dst_file, dst_loff,
 				     len, true);
 	if (error)
<span class="p_header">diff --git a/fs/xfs/xfs_fsops.c b/fs/xfs/xfs_fsops.c</span>
<span class="p_header">index 93d12fa2670d..242e8091296d 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_fsops.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_fsops.c</span>
<span class="p_chunk">@@ -631,6 +631,20 @@</span> <span class="p_context"> xfs_growfs_data_private(</span>
 	xfs_set_low_space_thresholds(mp);
 	mp-&gt;m_alloc_set_aside = xfs_alloc_set_aside(mp);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If we expanded the last AG, free the per-AG reservation</span>
<span class="p_add">+	 * so we can reinitialize it with the new size.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (new) {</span>
<span class="p_add">+		struct xfs_perag	*pag;</span>
<span class="p_add">+</span>
<span class="p_add">+		pag = xfs_perag_get(mp, agno);</span>
<span class="p_add">+		error = xfs_ag_resv_free(pag);</span>
<span class="p_add">+		xfs_perag_put(pag);</span>
<span class="p_add">+		if (error)</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* Reserve AG metadata blocks. */
 	error = xfs_fs_reserve_ag_blocks(mp);
 	if (error &amp;&amp; error != -ENOSPC)
<span class="p_header">diff --git a/fs/xfs/xfs_icache.c b/fs/xfs/xfs_icache.c</span>
<span class="p_header">index f295049db681..29cc9886a3cb 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_icache.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_icache.c</span>
<span class="p_chunk">@@ -123,7 +123,6 @@</span> <span class="p_context"> __xfs_inode_free(</span>
 {
 	/* asserts to verify all state is correct here */
 	ASSERT(atomic_read(&amp;ip-&gt;i_pincount) == 0);
<span class="p_del">-	ASSERT(!xfs_isiflocked(ip));</span>
 	XFS_STATS_DEC(ip-&gt;i_mount, vn_active);
 
 	call_rcu(&amp;VFS_I(ip)-&gt;i_rcu, xfs_inode_free_callback);
<span class="p_chunk">@@ -133,6 +132,8 @@</span> <span class="p_context"> void</span>
 xfs_inode_free(
 	struct xfs_inode	*ip)
 {
<span class="p_add">+	ASSERT(!xfs_isiflocked(ip));</span>
<span class="p_add">+</span>
 	/*
 	 * Because we use RCU freeing we need to ensure the inode always
 	 * appears to be reclaimed with an invalid inode number when in the
<span class="p_chunk">@@ -981,6 +982,7 @@</span> <span class="p_context"> xfs_reclaim_inode(</span>
 
 	if (XFS_FORCED_SHUTDOWN(ip-&gt;i_mount)) {
 		xfs_iunpin_wait(ip);
<span class="p_add">+		/* xfs_iflush_abort() drops the flush lock */</span>
 		xfs_iflush_abort(ip, false);
 		goto reclaim;
 	}
<span class="p_chunk">@@ -989,10 +991,10 @@</span> <span class="p_context"> xfs_reclaim_inode(</span>
 			goto out_ifunlock;
 		xfs_iunpin_wait(ip);
 	}
<span class="p_del">-	if (xfs_iflags_test(ip, XFS_ISTALE))</span>
<span class="p_del">-		goto reclaim;</span>
<span class="p_del">-	if (xfs_inode_clean(ip))</span>
<span class="p_add">+	if (xfs_iflags_test(ip, XFS_ISTALE) || xfs_inode_clean(ip)) {</span>
<span class="p_add">+		xfs_ifunlock(ip);</span>
 		goto reclaim;
<span class="p_add">+	}</span>
 
 	/*
 	 * Never flush out dirty data during non-blocking reclaim, as it would
<span class="p_chunk">@@ -1030,25 +1032,24 @@</span> <span class="p_context"> xfs_reclaim_inode(</span>
 		xfs_buf_relse(bp);
 	}
 
<span class="p_del">-	xfs_iflock(ip);</span>
 reclaim:
<span class="p_add">+	ASSERT(!xfs_isiflocked(ip));</span>
<span class="p_add">+</span>
 	/*
 	 * Because we use RCU freeing we need to ensure the inode always appears
 	 * to be reclaimed with an invalid inode number when in the free state.
<span class="p_del">-	 * We do this as early as possible under the ILOCK and flush lock so</span>
<span class="p_del">-	 * that xfs_iflush_cluster() can be guaranteed to detect races with us</span>
<span class="p_del">-	 * here. By doing this, we guarantee that once xfs_iflush_cluster has</span>
<span class="p_del">-	 * locked both the XFS_ILOCK and the flush lock that it will see either</span>
<span class="p_del">-	 * a valid, flushable inode that will serialise correctly against the</span>
<span class="p_del">-	 * locks below, or it will see a clean (and invalid) inode that it can</span>
<span class="p_del">-	 * skip.</span>
<span class="p_add">+	 * We do this as early as possible under the ILOCK so that</span>
<span class="p_add">+	 * xfs_iflush_cluster() can be guaranteed to detect races with us here.</span>
<span class="p_add">+	 * By doing this, we guarantee that once xfs_iflush_cluster has locked</span>
<span class="p_add">+	 * XFS_ILOCK that it will see either a valid, flushable inode that will</span>
<span class="p_add">+	 * serialise correctly, or it will see a clean (and invalid) inode that</span>
<span class="p_add">+	 * it can skip.</span>
 	 */
 	spin_lock(&amp;ip-&gt;i_flags_lock);
 	ip-&gt;i_flags = XFS_IRECLAIM;
 	ip-&gt;i_ino = 0;
 	spin_unlock(&amp;ip-&gt;i_flags_lock);
 
<span class="p_del">-	xfs_ifunlock(ip);</span>
 	xfs_iunlock(ip, XFS_ILOCK_EXCL);
 
 	XFS_STATS_INC(ip-&gt;i_mount, xs_ig_reclaims);
<span class="p_chunk">@@ -1580,10 +1581,15 @@</span> <span class="p_context"> xfs_inode_free_cowblocks(</span>
 	struct xfs_eofblocks *eofb = args;
 	bool need_iolock = true;
 	int match;
<span class="p_add">+	struct xfs_ifork	*ifp = XFS_IFORK_PTR(ip, XFS_COW_FORK);</span>
 
 	ASSERT(!eofb || (eofb &amp;&amp; eofb-&gt;eof_scan_owner != 0));
 
<span class="p_del">-	if (!xfs_reflink_has_real_cow_blocks(ip)) {</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Just clear the tag if we have an empty cow fork or none at all. It&#39;s</span>
<span class="p_add">+	 * possible the inode was fully unshared since it was originally tagged.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!xfs_is_reflink_inode(ip) || !ifp-&gt;if_bytes) {</span>
 		trace_xfs_inode_free_cowblocks_invalid(ip);
 		xfs_inode_clear_cowblocks_tag(ip);
 		return 0;
<span class="p_chunk">@@ -1593,7 +1599,8 @@</span> <span class="p_context"> xfs_inode_free_cowblocks(</span>
 	 * If the mapping is dirty or under writeback we cannot touch the
 	 * CoW fork.  Leave it alone if we&#39;re in the midst of a directio.
 	 */
<span class="p_del">-	if (mapping_tagged(VFS_I(ip)-&gt;i_mapping, PAGECACHE_TAG_DIRTY) ||</span>
<span class="p_add">+	if ((VFS_I(ip)-&gt;i_state &amp; I_DIRTY_PAGES) ||</span>
<span class="p_add">+	    mapping_tagged(VFS_I(ip)-&gt;i_mapping, PAGECACHE_TAG_DIRTY) ||</span>
 	    mapping_tagged(VFS_I(ip)-&gt;i_mapping, PAGECACHE_TAG_WRITEBACK) ||
 	    atomic_read(&amp;VFS_I(ip)-&gt;i_dio_count))
 		return 0;
<span class="p_header">diff --git a/fs/xfs/xfs_inode.c b/fs/xfs/xfs_inode.c</span>
<span class="p_header">index 4e560e6a12c1..512ff13ed66a 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_inode.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_inode.c</span>
<span class="p_chunk">@@ -2041,7 +2041,6 @@</span> <span class="p_context"> xfs_iunlink(</span>
 	agi-&gt;agi_unlinked[bucket_index] = cpu_to_be32(agino);
 	offset = offsetof(xfs_agi_t, agi_unlinked) +
 		(sizeof(xfs_agino_t) * bucket_index);
<span class="p_del">-	xfs_trans_buf_set_type(tp, agibp, XFS_BLFT_AGI_BUF);</span>
 	xfs_trans_log_buf(tp, agibp, offset,
 			  (offset + sizeof(xfs_agino_t) - 1));
 	return 0;
<span class="p_chunk">@@ -2133,7 +2132,6 @@</span> <span class="p_context"> xfs_iunlink_remove(</span>
 		agi-&gt;agi_unlinked[bucket_index] = cpu_to_be32(next_agino);
 		offset = offsetof(xfs_agi_t, agi_unlinked) +
 			(sizeof(xfs_agino_t) * bucket_index);
<span class="p_del">-		xfs_trans_buf_set_type(tp, agibp, XFS_BLFT_AGI_BUF);</span>
 		xfs_trans_log_buf(tp, agibp, offset,
 				  (offset + sizeof(xfs_agino_t) - 1));
 	} else {
<span class="p_header">diff --git a/fs/xfs/xfs_inode.h b/fs/xfs/xfs_inode.h</span>
<span class="p_header">index f14c1de2549d..71e8a81c91a3 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_inode.h</span>
<span class="p_header">+++ b/fs/xfs/xfs_inode.h</span>
<span class="p_chunk">@@ -246,6 +246,11 @@</span> <span class="p_context"> static inline bool xfs_is_reflink_inode(struct xfs_inode *ip)</span>
  * Synchronize processes attempting to flush the in-core inode back to disk.
  */
 
<span class="p_add">+static inline int xfs_isiflocked(struct xfs_inode *ip)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return xfs_iflags_test(ip, XFS_IFLOCK);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 extern void __xfs_iflock(struct xfs_inode *ip);
 
 static inline int xfs_iflock_nowait(struct xfs_inode *ip)
<span class="p_chunk">@@ -261,16 +266,12 @@</span> <span class="p_context"> static inline void xfs_iflock(struct xfs_inode *ip)</span>
 
 static inline void xfs_ifunlock(struct xfs_inode *ip)
 {
<span class="p_add">+	ASSERT(xfs_isiflocked(ip));</span>
 	xfs_iflags_clear(ip, XFS_IFLOCK);
 	smp_mb();
 	wake_up_bit(&amp;ip-&gt;i_flags, __XFS_IFLOCK_BIT);
 }
 
<span class="p_del">-static inline int xfs_isiflocked(struct xfs_inode *ip)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return xfs_iflags_test(ip, XFS_IFLOCK);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /*
  * Flags for inode locking.
  * Bit ranges:	1&lt;&lt;1  - 1&lt;&lt;16-1 -- iolock/ilock modes (bitfield)
<span class="p_header">diff --git a/fs/xfs/xfs_inode_item.c b/fs/xfs/xfs_inode_item.c</span>
<span class="p_header">index 9610e9c00952..d90e7811ccdd 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_inode_item.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_inode_item.c</span>
<span class="p_chunk">@@ -164,7 +164,7 @@</span> <span class="p_context"> xfs_inode_item_format_data_fork(</span>
 			struct xfs_bmbt_rec *p;
 
 			ASSERT(ip-&gt;i_df.if_u1.if_extents != NULL);
<span class="p_del">-			ASSERT(ip-&gt;i_df.if_bytes / sizeof(xfs_bmbt_rec_t) &gt; 0);</span>
<span class="p_add">+			ASSERT(xfs_iext_count(&amp;ip-&gt;i_df) &gt; 0);</span>
 
 			p = xlog_prepare_iovec(lv, vecp, XLOG_REG_TYPE_IEXT);
 			data_bytes = xfs_iextents_copy(ip, p, XFS_DATA_FORK);
<span class="p_chunk">@@ -261,7 +261,7 @@</span> <span class="p_context"> xfs_inode_item_format_attr_fork(</span>
 		    ip-&gt;i_afp-&gt;if_bytes &gt; 0) {
 			struct xfs_bmbt_rec *p;
 
<span class="p_del">-			ASSERT(ip-&gt;i_afp-&gt;if_bytes / sizeof(xfs_bmbt_rec_t) ==</span>
<span class="p_add">+			ASSERT(xfs_iext_count(ip-&gt;i_afp) ==</span>
 				ip-&gt;i_d.di_anextents);
 			ASSERT(ip-&gt;i_afp-&gt;if_u1.if_extents != NULL);
 
<span class="p_header">diff --git a/fs/xfs/xfs_ioctl.c b/fs/xfs/xfs_ioctl.c</span>
<span class="p_header">index c245bed3249b..a39197501a7c 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_ioctl.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_ioctl.c</span>
<span class="p_chunk">@@ -910,16 +910,14 @@</span> <span class="p_context"> xfs_ioc_fsgetxattr(</span>
 	if (attr) {
 		if (ip-&gt;i_afp) {
 			if (ip-&gt;i_afp-&gt;if_flags &amp; XFS_IFEXTENTS)
<span class="p_del">-				fa.fsx_nextents = ip-&gt;i_afp-&gt;if_bytes /</span>
<span class="p_del">-							sizeof(xfs_bmbt_rec_t);</span>
<span class="p_add">+				fa.fsx_nextents = xfs_iext_count(ip-&gt;i_afp);</span>
 			else
 				fa.fsx_nextents = ip-&gt;i_d.di_anextents;
 		} else
 			fa.fsx_nextents = 0;
 	} else {
 		if (ip-&gt;i_df.if_flags &amp; XFS_IFEXTENTS)
<span class="p_del">-			fa.fsx_nextents = ip-&gt;i_df.if_bytes /</span>
<span class="p_del">-						sizeof(xfs_bmbt_rec_t);</span>
<span class="p_add">+			fa.fsx_nextents = xfs_iext_count(&amp;ip-&gt;i_df);</span>
 		else
 			fa.fsx_nextents = ip-&gt;i_d.di_nextents;
 	}
<span class="p_header">diff --git a/fs/xfs/xfs_iomap.c b/fs/xfs/xfs_iomap.c</span>
<span class="p_header">index 436e109bb01e..15a83813b708 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_iomap.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_iomap.c</span>
<span class="p_chunk">@@ -395,11 +395,12 @@</span> <span class="p_context"> xfs_iomap_prealloc_size(</span>
 	struct xfs_inode	*ip,
 	loff_t			offset,
 	loff_t			count,
<span class="p_del">-	xfs_extnum_t		idx,</span>
<span class="p_del">-	struct xfs_bmbt_irec	*prev)</span>
<span class="p_add">+	xfs_extnum_t		idx)</span>
 {
 	struct xfs_mount	*mp = ip-&gt;i_mount;
<span class="p_add">+	struct xfs_ifork	*ifp = XFS_IFORK_PTR(ip, XFS_DATA_FORK);</span>
 	xfs_fileoff_t		offset_fsb = XFS_B_TO_FSBT(mp, offset);
<span class="p_add">+	struct xfs_bmbt_irec	prev;</span>
 	int			shift = 0;
 	int64_t			freesp;
 	xfs_fsblock_t		qblocks;
<span class="p_chunk">@@ -419,8 +420,8 @@</span> <span class="p_context"> xfs_iomap_prealloc_size(</span>
 	 */
 	if ((mp-&gt;m_flags &amp; XFS_MOUNT_DFLT_IOSIZE) ||
 	    XFS_ISIZE(ip) &lt; XFS_FSB_TO_B(mp, mp-&gt;m_dalign) ||
<span class="p_del">-	    idx == 0 ||</span>
<span class="p_del">-	    prev-&gt;br_startoff + prev-&gt;br_blockcount &lt; offset_fsb)</span>
<span class="p_add">+	    !xfs_iext_get_extent(ifp, idx - 1, &amp;prev) ||</span>
<span class="p_add">+	    prev.br_startoff + prev.br_blockcount &lt; offset_fsb)</span>
 		return mp-&gt;m_writeio_blocks;
 
 	/*
<span class="p_chunk">@@ -439,8 +440,8 @@</span> <span class="p_context"> xfs_iomap_prealloc_size(</span>
 	 * always extends to MAXEXTLEN rather than falling short due to things
 	 * like stripe unit/width alignment of real extents.
 	 */
<span class="p_del">-	if (prev-&gt;br_blockcount &lt;= (MAXEXTLEN &gt;&gt; 1))</span>
<span class="p_del">-		alloc_blocks = prev-&gt;br_blockcount &lt;&lt; 1;</span>
<span class="p_add">+	if (prev.br_blockcount &lt;= (MAXEXTLEN &gt;&gt; 1))</span>
<span class="p_add">+		alloc_blocks = prev.br_blockcount &lt;&lt; 1;</span>
 	else
 		alloc_blocks = XFS_B_TO_FSB(mp, offset);
 	if (!alloc_blocks)
<span class="p_chunk">@@ -535,11 +536,11 @@</span> <span class="p_context"> xfs_file_iomap_begin_delay(</span>
 	xfs_fileoff_t		offset_fsb = XFS_B_TO_FSBT(mp, offset);
 	xfs_fileoff_t		maxbytes_fsb =
 		XFS_B_TO_FSB(mp, mp-&gt;m_super-&gt;s_maxbytes);
<span class="p_del">-	xfs_fileoff_t		end_fsb, orig_end_fsb;</span>
<span class="p_add">+	xfs_fileoff_t		end_fsb;</span>
 	int			error = 0, eof = 0;
 	struct xfs_bmbt_irec	got;
<span class="p_del">-	struct xfs_bmbt_irec	prev;</span>
 	xfs_extnum_t		idx;
<span class="p_add">+	xfs_fsblock_t		prealloc_blocks = 0;</span>
 
 	ASSERT(!XFS_IS_REALTIME_INODE(ip));
 	ASSERT(!xfs_get_extsz_hint(ip));
<span class="p_chunk">@@ -563,8 +564,7 @@</span> <span class="p_context"> xfs_file_iomap_begin_delay(</span>
 			goto out_unlock;
 	}
 
<span class="p_del">-	xfs_bmap_search_extents(ip, offset_fsb, XFS_DATA_FORK, &amp;eof, &amp;idx,</span>
<span class="p_del">-			&amp;got, &amp;prev);</span>
<span class="p_add">+	eof = !xfs_iext_lookup_extent(ip, ifp, offset_fsb, &amp;idx, &amp;got);</span>
 	if (!eof &amp;&amp; got.br_startoff &lt;= offset_fsb) {
 		if (xfs_is_reflink_inode(ip)) {
 			bool		shared;
<span class="p_chunk">@@ -595,35 +595,32 @@</span> <span class="p_context"> xfs_file_iomap_begin_delay(</span>
 	 * the lower level functions are updated.
 	 */
 	count = min_t(loff_t, count, 1024 * PAGE_SIZE);
<span class="p_del">-	end_fsb = orig_end_fsb =</span>
<span class="p_del">-		min(XFS_B_TO_FSB(mp, offset + count), maxbytes_fsb);</span>
<span class="p_add">+	end_fsb = min(XFS_B_TO_FSB(mp, offset + count), maxbytes_fsb);</span>
 
 	if (eof) {
<span class="p_del">-		xfs_fsblock_t	prealloc_blocks;</span>
<span class="p_del">-</span>
<span class="p_del">-		prealloc_blocks =</span>
<span class="p_del">-			xfs_iomap_prealloc_size(ip, offset, count, idx, &amp;prev);</span>
<span class="p_add">+		prealloc_blocks = xfs_iomap_prealloc_size(ip, offset, count, idx);</span>
 		if (prealloc_blocks) {
 			xfs_extlen_t	align;
 			xfs_off_t	end_offset;
<span class="p_add">+			xfs_fileoff_t	p_end_fsb;</span>
 
 			end_offset = XFS_WRITEIO_ALIGN(mp, offset + count - 1);
<span class="p_del">-			end_fsb = XFS_B_TO_FSBT(mp, end_offset) +</span>
<span class="p_del">-				prealloc_blocks;</span>
<span class="p_add">+			p_end_fsb = XFS_B_TO_FSBT(mp, end_offset) +</span>
<span class="p_add">+					prealloc_blocks;</span>
 
 			align = xfs_eof_alignment(ip, 0);
 			if (align)
<span class="p_del">-				end_fsb = roundup_64(end_fsb, align);</span>
<span class="p_add">+				p_end_fsb = roundup_64(p_end_fsb, align);</span>
 
<span class="p_del">-			end_fsb = min(end_fsb, maxbytes_fsb);</span>
<span class="p_del">-			ASSERT(end_fsb &gt; offset_fsb);</span>
<span class="p_add">+			p_end_fsb = min(p_end_fsb, maxbytes_fsb);</span>
<span class="p_add">+			ASSERT(p_end_fsb &gt; offset_fsb);</span>
<span class="p_add">+			prealloc_blocks = p_end_fsb - end_fsb;</span>
 		}
 	}
 
 retry:
 	error = xfs_bmapi_reserve_delalloc(ip, XFS_DATA_FORK, offset_fsb,
<span class="p_del">-			end_fsb - offset_fsb, &amp;got,</span>
<span class="p_del">-			&amp;prev, &amp;idx, eof);</span>
<span class="p_add">+			end_fsb - offset_fsb, prealloc_blocks, &amp;got, &amp;idx, eof);</span>
 	switch (error) {
 	case 0:
 		break;
<span class="p_chunk">@@ -631,8 +628,8 @@</span> <span class="p_context"> xfs_file_iomap_begin_delay(</span>
 	case -EDQUOT:
 		/* retry without any preallocation */
 		trace_xfs_delalloc_enospc(ip, offset, count);
<span class="p_del">-		if (end_fsb != orig_end_fsb) {</span>
<span class="p_del">-			end_fsb = orig_end_fsb;</span>
<span class="p_add">+		if (prealloc_blocks) {</span>
<span class="p_add">+			prealloc_blocks = 0;</span>
 			goto retry;
 		}
 		/*FALLTHRU*/
<span class="p_chunk">@@ -640,13 +637,6 @@</span> <span class="p_context"> xfs_file_iomap_begin_delay(</span>
 		goto out_unlock;
 	}
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Tag the inode as speculatively preallocated so we can reclaim this</span>
<span class="p_del">-	 * space on demand, if necessary.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (end_fsb != orig_end_fsb)</span>
<span class="p_del">-		xfs_inode_set_eofblocks_tag(ip);</span>
<span class="p_del">-</span>
 	trace_xfs_iomap_alloc(ip, offset, count, 0, &amp;got);
 done:
 	if (isnullstartblock(got.br_startblock))
<span class="p_header">diff --git a/fs/xfs/xfs_log_recover.c b/fs/xfs/xfs_log_recover.c</span>
<span class="p_header">index 2d91f5ab7538..9b3d7c76915d 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_log_recover.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_log_recover.c</span>
<span class="p_chunk">@@ -4929,7 +4929,6 @@</span> <span class="p_context"> xlog_recover_clear_agi_bucket(</span>
 	agi-&gt;agi_unlinked[bucket] = cpu_to_be32(NULLAGINO);
 	offset = offsetof(xfs_agi_t, agi_unlinked) +
 		 (sizeof(xfs_agino_t) * bucket);
<span class="p_del">-	xfs_trans_buf_set_type(tp, agibp, XFS_BLFT_AGI_BUF);</span>
 	xfs_trans_log_buf(tp, agibp, offset,
 			  (offset + sizeof(xfs_agino_t) - 1));
 
<span class="p_header">diff --git a/fs/xfs/xfs_qm.c b/fs/xfs/xfs_qm.c</span>
<span class="p_header">index a60d9e2739d1..45e50ea90769 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_qm.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_qm.c</span>
<span class="p_chunk">@@ -1135,7 +1135,7 @@</span> <span class="p_context"> xfs_qm_get_rtblks(</span>
 			return error;
 	}
 	rtblks = 0;
<span class="p_del">-	nextents = ifp-&gt;if_bytes / (uint)sizeof(xfs_bmbt_rec_t);</span>
<span class="p_add">+	nextents = xfs_iext_count(ifp);</span>
 	for (idx = 0; idx &lt; nextents; idx++)
 		rtblks += xfs_bmbt_get_blockcount(xfs_iext_get_ext(ifp, idx));
 	*O_rtblks = (xfs_qcnt_t)rtblks;
<span class="p_header">diff --git a/fs/xfs/xfs_refcount_item.c b/fs/xfs/xfs_refcount_item.c</span>
<span class="p_header">index fe86a668a57e..6e4c7446c3d4 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_refcount_item.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_refcount_item.c</span>
<span class="p_chunk">@@ -526,13 +526,14 @@</span> <span class="p_context"> xfs_cui_recover(</span>
 	xfs_refcount_finish_one_cleanup(tp, rcur, error);
 	error = xfs_defer_finish(&amp;tp, &amp;dfops, NULL);
 	if (error)
<span class="p_del">-		goto abort_error;</span>
<span class="p_add">+		goto abort_defer;</span>
 	set_bit(XFS_CUI_RECOVERED, &amp;cuip-&gt;cui_flags);
 	error = xfs_trans_commit(tp);
 	return error;
 
 abort_error:
 	xfs_refcount_finish_one_cleanup(tp, rcur, error);
<span class="p_add">+abort_defer:</span>
 	xfs_defer_cancel(&amp;dfops);
 	xfs_trans_cancel(tp);
 	return error;
<span class="p_header">diff --git a/fs/xfs/xfs_reflink.c b/fs/xfs/xfs_reflink.c</span>
<span class="p_header">index a279b4e7f5fe..4d3f74e3c5e1 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_reflink.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_reflink.c</span>
<span class="p_chunk">@@ -243,12 +243,11 @@</span> <span class="p_context"> xfs_reflink_reserve_cow(</span>
 	struct xfs_bmbt_irec	*imap,
 	bool			*shared)
 {
<span class="p_del">-	struct xfs_bmbt_irec	got, prev;</span>
<span class="p_del">-	xfs_fileoff_t		end_fsb, orig_end_fsb;</span>
<span class="p_del">-	int			eof = 0, error = 0;</span>
<span class="p_del">-	bool			trimmed;</span>
<span class="p_add">+	struct xfs_ifork	*ifp = XFS_IFORK_PTR(ip, XFS_COW_FORK);</span>
<span class="p_add">+	struct xfs_bmbt_irec	got;</span>
<span class="p_add">+	int			error = 0;</span>
<span class="p_add">+	bool			eof = false, trimmed;</span>
 	xfs_extnum_t		idx;
<span class="p_del">-	xfs_extlen_t		align;</span>
 
 	/*
 	 * Search the COW fork extent list first.  This serves two purposes:
<span class="p_chunk">@@ -258,8 +257,9 @@</span> <span class="p_context"> xfs_reflink_reserve_cow(</span>
 	 * extent list is generally faster than going out to the shared extent
 	 * tree.
 	 */
<span class="p_del">-	xfs_bmap_search_extents(ip, imap-&gt;br_startoff, XFS_COW_FORK, &amp;eof, &amp;idx,</span>
<span class="p_del">-			&amp;got, &amp;prev);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!xfs_iext_lookup_extent(ip, ifp, imap-&gt;br_startoff, &amp;idx, &amp;got))</span>
<span class="p_add">+		eof = true;</span>
 	if (!eof &amp;&amp; got.br_startoff &lt;= imap-&gt;br_startoff) {
 		trace_xfs_reflink_cow_found(ip, imap);
 		xfs_trim_extent(imap, got.br_startoff, got.br_blockcount);
<span class="p_chunk">@@ -285,33 +285,12 @@</span> <span class="p_context"> xfs_reflink_reserve_cow(</span>
 	if (error)
 		return error;
 
<span class="p_del">-	end_fsb = orig_end_fsb = imap-&gt;br_startoff + imap-&gt;br_blockcount;</span>
<span class="p_del">-</span>
<span class="p_del">-	align = xfs_eof_alignment(ip, xfs_get_cowextsz_hint(ip));</span>
<span class="p_del">-	if (align)</span>
<span class="p_del">-		end_fsb = roundup_64(end_fsb, align);</span>
<span class="p_del">-</span>
<span class="p_del">-retry:</span>
 	error = xfs_bmapi_reserve_delalloc(ip, XFS_COW_FORK, imap-&gt;br_startoff,
<span class="p_del">-			end_fsb - imap-&gt;br_startoff, &amp;got, &amp;prev, &amp;idx, eof);</span>
<span class="p_del">-	switch (error) {</span>
<span class="p_del">-	case 0:</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	case -ENOSPC:</span>
<span class="p_del">-	case -EDQUOT:</span>
<span class="p_del">-		/* retry without any preallocation */</span>
<span class="p_add">+			imap-&gt;br_blockcount, 0, &amp;got, &amp;idx, eof);</span>
<span class="p_add">+	if (error == -ENOSPC || error == -EDQUOT)</span>
 		trace_xfs_reflink_cow_enospc(ip, imap);
<span class="p_del">-		if (end_fsb != orig_end_fsb) {</span>
<span class="p_del">-			end_fsb = orig_end_fsb;</span>
<span class="p_del">-			goto retry;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		/*FALLTHRU*/</span>
<span class="p_del">-	default:</span>
<span class="p_add">+	if (error)</span>
 		return error;
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (end_fsb != orig_end_fsb)</span>
<span class="p_del">-		xfs_inode_set_cowblocks_tag(ip);</span>
 
 	trace_xfs_reflink_cow_alloc(ip, &amp;got);
 	return 0;
<span class="p_chunk">@@ -486,7 +465,7 @@</span> <span class="p_context"> xfs_reflink_trim_irec_to_next_cow(</span>
 	/* This is the extent before; try sliding up one. */
 	if (irec.br_startoff &lt; offset_fsb) {
 		idx++;
<span class="p_del">-		if (idx &gt;= ifp-&gt;if_bytes / sizeof(xfs_bmbt_rec_t))</span>
<span class="p_add">+		if (idx &gt;= xfs_iext_count(ifp))</span>
 			return 0;
 		gotp = xfs_iext_get_ext(ifp, idx);
 		xfs_bmbt_get_all(gotp, &amp;irec);
<span class="p_chunk">@@ -566,7 +545,7 @@</span> <span class="p_context"> xfs_reflink_cancel_cow_blocks(</span>
 			xfs_bmap_del_extent_cow(ip, &amp;idx, &amp;got, &amp;del);
 		}
 
<span class="p_del">-		if (++idx &gt;= ifp-&gt;if_bytes / sizeof(struct xfs_bmbt_rec))</span>
<span class="p_add">+		if (++idx &gt;= xfs_iext_count(ifp))</span>
 			break;
 		xfs_bmbt_get_all(xfs_iext_get_ext(ifp, idx), &amp;got);
 	}
<span class="p_chunk">@@ -1345,8 +1324,14 @@</span> <span class="p_context"> xfs_reflink_remap_range(</span>
 		goto out_unlock;
 	}
 
<span class="p_del">-	if (len == 0)</span>
<span class="p_add">+	/* Zero length dedupe exits immediately; reflink goes to EOF. */</span>
<span class="p_add">+	if (len == 0) {</span>
<span class="p_add">+		if (is_dedupe) {</span>
<span class="p_add">+			ret = 0;</span>
<span class="p_add">+			goto out_unlock;</span>
<span class="p_add">+		}</span>
 		len = isize - pos_in;
<span class="p_add">+	}</span>
 
 	/* Ensure offsets don&#39;t wrap and the input is inside i_size */
 	if (pos_in + len &lt; pos_in || pos_out + len &lt; pos_out ||
<span class="p_chunk">@@ -1697,37 +1682,3 @@</span> <span class="p_context"> xfs_reflink_unshare(</span>
 	trace_xfs_reflink_unshare_error(ip, error, _RET_IP_);
 	return error;
 }
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Does this inode have any real CoW reservations?</span>
<span class="p_del">- */</span>
<span class="p_del">-bool</span>
<span class="p_del">-xfs_reflink_has_real_cow_blocks(</span>
<span class="p_del">-	struct xfs_inode		*ip)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct xfs_bmbt_irec		irec;</span>
<span class="p_del">-	struct xfs_ifork		*ifp;</span>
<span class="p_del">-	struct xfs_bmbt_rec_host	*gotp;</span>
<span class="p_del">-	xfs_extnum_t			idx;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!xfs_is_reflink_inode(ip))</span>
<span class="p_del">-		return false;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Go find the old extent in the CoW fork. */</span>
<span class="p_del">-	ifp = XFS_IFORK_PTR(ip, XFS_COW_FORK);</span>
<span class="p_del">-	gotp = xfs_iext_bno_to_ext(ifp, 0, &amp;idx);</span>
<span class="p_del">-	while (gotp) {</span>
<span class="p_del">-		xfs_bmbt_get_all(gotp, &amp;irec);</span>
<span class="p_del">-</span>
<span class="p_del">-		if (!isnullstartblock(irec.br_startblock))</span>
<span class="p_del">-			return true;</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Roll on... */</span>
<span class="p_del">-		idx++;</span>
<span class="p_del">-		if (idx &gt;= ifp-&gt;if_bytes / sizeof(xfs_bmbt_rec_t))</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		gotp = xfs_iext_get_ext(ifp, idx);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	return false;</span>
<span class="p_del">-}</span>
<span class="p_header">diff --git a/fs/xfs/xfs_reflink.h b/fs/xfs/xfs_reflink.h</span>
<span class="p_header">index fad11607c9ad..97ea9b487884 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_reflink.h</span>
<span class="p_header">+++ b/fs/xfs/xfs_reflink.h</span>
<span class="p_chunk">@@ -50,6 +50,4 @@</span> <span class="p_context"> extern int xfs_reflink_clear_inode_flag(struct xfs_inode *ip,</span>
 extern int xfs_reflink_unshare(struct xfs_inode *ip, xfs_off_t offset,
 		xfs_off_t len);
 
<span class="p_del">-extern bool xfs_reflink_has_real_cow_blocks(struct xfs_inode *ip);</span>
<span class="p_del">-</span>
 #endif /* __XFS_REFLINK_H */
<span class="p_header">diff --git a/fs/xfs/xfs_sysfs.c b/fs/xfs/xfs_sysfs.c</span>
<span class="p_header">index 276d3023d60f..de6195e38910 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_sysfs.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_sysfs.c</span>
<span class="p_chunk">@@ -396,7 +396,7 @@</span> <span class="p_context"> max_retries_show(</span>
 	int		retries;
 	struct xfs_error_cfg *cfg = to_error_cfg(kobject);
 
<span class="p_del">-	if (cfg-&gt;retry_timeout == XFS_ERR_RETRY_FOREVER)</span>
<span class="p_add">+	if (cfg-&gt;max_retries == XFS_ERR_RETRY_FOREVER)</span>
 		retries = -1;
 	else
 		retries = cfg-&gt;max_retries;
<span class="p_chunk">@@ -422,7 +422,7 @@</span> <span class="p_context"> max_retries_store(</span>
 		return -EINVAL;
 
 	if (val == -1)
<span class="p_del">-		cfg-&gt;retry_timeout = XFS_ERR_RETRY_FOREVER;</span>
<span class="p_add">+		cfg-&gt;max_retries = XFS_ERR_RETRY_FOREVER;</span>
 	else
 		cfg-&gt;max_retries = val;
 	return count;
<span class="p_header">diff --git a/include/asm-generic/asm-prototypes.h b/include/asm-generic/asm-prototypes.h</span>
<span class="p_header">index df13637e4017..939869c772b1 100644</span>
<span class="p_header">--- a/include/asm-generic/asm-prototypes.h</span>
<span class="p_header">+++ b/include/asm-generic/asm-prototypes.h</span>
<span class="p_chunk">@@ -1,7 +1,13 @@</span> <span class="p_context"></span>
 #include &lt;linux/bitops.h&gt;
<span class="p_add">+#undef __memset</span>
 extern void *__memset(void *, int, __kernel_size_t);
<span class="p_add">+#undef __memcpy</span>
 extern void *__memcpy(void *, const void *, __kernel_size_t);
<span class="p_add">+#undef __memmove</span>
 extern void *__memmove(void *, const void *, __kernel_size_t);
<span class="p_add">+#undef memset</span>
 extern void *memset(void *, int, __kernel_size_t);
<span class="p_add">+#undef memcpy</span>
 extern void *memcpy(void *, const void *, __kernel_size_t);
<span class="p_add">+#undef memmove</span>
 extern void *memmove(void *, const void *, __kernel_size_t);
<span class="p_header">diff --git a/include/linux/cpuhotplug.h b/include/linux/cpuhotplug.h</span>
<span class="p_header">index afe641c02dca..ba1cad7b97cf 100644</span>
<span class="p_header">--- a/include/linux/cpuhotplug.h</span>
<span class="p_header">+++ b/include/linux/cpuhotplug.h</span>
<span class="p_chunk">@@ -80,7 +80,6 @@</span> <span class="p_context"> enum cpuhp_state {</span>
 	CPUHP_AP_ARM_L2X0_STARTING,
 	CPUHP_AP_ARM_ARCH_TIMER_STARTING,
 	CPUHP_AP_ARM_GLOBAL_TIMER_STARTING,
<span class="p_del">-	CPUHP_AP_DUMMY_TIMER_STARTING,</span>
 	CPUHP_AP_JCORE_TIMER_STARTING,
 	CPUHP_AP_EXYNOS4_MCT_TIMER_STARTING,
 	CPUHP_AP_ARM_TWD_STARTING,
<span class="p_chunk">@@ -94,6 +93,8 @@</span> <span class="p_context"> enum cpuhp_state {</span>
 	CPUHP_AP_KVM_ARM_VGIC_INIT_STARTING,
 	CPUHP_AP_KVM_ARM_VGIC_STARTING,
 	CPUHP_AP_KVM_ARM_TIMER_STARTING,
<span class="p_add">+	/* Must be the last timer callback */</span>
<span class="p_add">+	CPUHP_AP_DUMMY_TIMER_STARTING,</span>
 	CPUHP_AP_ARM_XEN_STARTING,
 	CPUHP_AP_ARM_CORESIGHT_STARTING,
 	CPUHP_AP_ARM_CORESIGHT4_STARTING,
<span class="p_header">diff --git a/include/linux/debugfs.h b/include/linux/debugfs.h</span>
<span class="p_header">index 4d3f0d1aec73..1b413a9aab81 100644</span>
<span class="p_header">--- a/include/linux/debugfs.h</span>
<span class="p_header">+++ b/include/linux/debugfs.h</span>
<span class="p_chunk">@@ -62,6 +62,21 @@</span> <span class="p_context"> static inline const struct file_operations *debugfs_real_fops(struct file *filp)</span>
 	return filp-&gt;f_path.dentry-&gt;d_fsdata;
 }
 
<span class="p_add">+#define DEFINE_DEBUGFS_ATTRIBUTE(__fops, __get, __set, __fmt)		\</span>
<span class="p_add">+static int __fops ## _open(struct inode *inode, struct file *file)	\</span>
<span class="p_add">+{									\</span>
<span class="p_add">+	__simple_attr_check_format(__fmt, 0ull);			\</span>
<span class="p_add">+	return simple_attr_open(inode, file, __get, __set, __fmt);	\</span>
<span class="p_add">+}									\</span>
<span class="p_add">+static const struct file_operations __fops = {				\</span>
<span class="p_add">+	.owner	 = THIS_MODULE,						\</span>
<span class="p_add">+	.open	 = __fops ## _open,					\</span>
<span class="p_add">+	.release = simple_attr_release,					\</span>
<span class="p_add">+	.read	 = debugfs_attr_read,					\</span>
<span class="p_add">+	.write	 = debugfs_attr_write,					\</span>
<span class="p_add">+	.llseek  = generic_file_llseek,					\</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #if defined(CONFIG_DEBUG_FS)
 
 struct dentry *debugfs_create_file(const char *name, umode_t mode,
<span class="p_chunk">@@ -99,21 +114,6 @@</span> <span class="p_context"> ssize_t debugfs_attr_read(struct file *file, char __user *buf,</span>
 ssize_t debugfs_attr_write(struct file *file, const char __user *buf,
 			size_t len, loff_t *ppos);
 
<span class="p_del">-#define DEFINE_DEBUGFS_ATTRIBUTE(__fops, __get, __set, __fmt)		\</span>
<span class="p_del">-static int __fops ## _open(struct inode *inode, struct file *file)	\</span>
<span class="p_del">-{									\</span>
<span class="p_del">-	__simple_attr_check_format(__fmt, 0ull);			\</span>
<span class="p_del">-	return simple_attr_open(inode, file, __get, __set, __fmt);	\</span>
<span class="p_del">-}									\</span>
<span class="p_del">-static const struct file_operations __fops = {				\</span>
<span class="p_del">-	.owner	 = THIS_MODULE,					\</span>
<span class="p_del">-	.open	 = __fops ## _open,					\</span>
<span class="p_del">-	.release = simple_attr_release,				\</span>
<span class="p_del">-	.read	 = debugfs_attr_read,					\</span>
<span class="p_del">-	.write	 = debugfs_attr_write,					\</span>
<span class="p_del">-	.llseek  = generic_file_llseek,				\</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 struct dentry *debugfs_rename(struct dentry *old_dir, struct dentry *old_dentry,
                 struct dentry *new_dir, const char *new_name);
 
<span class="p_chunk">@@ -233,8 +233,18 @@</span> <span class="p_context"> static inline void debugfs_use_file_finish(int srcu_idx)</span>
 	__releases(&amp;debugfs_srcu)
 { }
 
<span class="p_del">-#define DEFINE_DEBUGFS_ATTRIBUTE(__fops, __get, __set, __fmt)	\</span>
<span class="p_del">-	static const struct file_operations __fops = { 0 }</span>
<span class="p_add">+static inline ssize_t debugfs_attr_read(struct file *file, char __user *buf,</span>
<span class="p_add">+					size_t len, loff_t *ppos)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return -ENODEV;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline ssize_t debugfs_attr_write(struct file *file,</span>
<span class="p_add">+					const char __user *buf,</span>
<span class="p_add">+					size_t len, loff_t *ppos)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return -ENODEV;</span>
<span class="p_add">+}</span>
 
 static inline struct dentry *debugfs_rename(struct dentry *old_dir, struct dentry *old_dentry,
                 struct dentry *new_dir, char *new_name)
<span class="p_header">diff --git a/include/linux/iio/common/st_sensors.h b/include/linux/iio/common/st_sensors.h</span>
<span class="p_header">index 228bd44efa4c..497f2b3a5a62 100644</span>
<span class="p_header">--- a/include/linux/iio/common/st_sensors.h</span>
<span class="p_header">+++ b/include/linux/iio/common/st_sensors.h</span>
<span class="p_chunk">@@ -116,6 +116,16 @@</span> <span class="p_context"> struct st_sensor_bdu {</span>
 };
 
 /**
<span class="p_add">+ * struct st_sensor_das - ST sensor device data alignment selection</span>
<span class="p_add">+ * @addr: address of the register.</span>
<span class="p_add">+ * @mask: mask to write the das flag for left alignment.</span>
<span class="p_add">+ */</span>
<span class="p_add">+struct st_sensor_das {</span>
<span class="p_add">+	u8 addr;</span>
<span class="p_add">+	u8 mask;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
  * struct st_sensor_data_ready_irq - ST sensor device data-ready interrupt
  * @addr: address of the register.
  * @mask_int1: mask to enable/disable IRQ on INT1 pin.
<span class="p_chunk">@@ -185,6 +195,7 @@</span> <span class="p_context"> struct st_sensor_transfer_function {</span>
  * @enable_axis: Enable one or more axis of the sensor.
  * @fs: Full scale register and full scale list available.
  * @bdu: Block data update register.
<span class="p_add">+ * @das: Data Alignment Selection register.</span>
  * @drdy_irq: Data ready register of the sensor.
  * @multi_read_bit: Use or not particular bit for [I2C/SPI] multi-read.
  * @bootime: samples to discard when sensor passing from power-down to power-up.
<span class="p_chunk">@@ -200,6 +211,7 @@</span> <span class="p_context"> struct st_sensor_settings {</span>
 	struct st_sensor_axis enable_axis;
 	struct st_sensor_fullscale fs;
 	struct st_sensor_bdu bdu;
<span class="p_add">+	struct st_sensor_das das;</span>
 	struct st_sensor_data_ready_irq drdy_irq;
 	bool multi_read_bit;
 	unsigned int bootime;
<span class="p_header">diff --git a/include/linux/pci_ids.h b/include/linux/pci_ids.h</span>
<span class="p_header">index c58752fe16c4..f020ab4079d3 100644</span>
<span class="p_header">--- a/include/linux/pci_ids.h</span>
<span class="p_header">+++ b/include/linux/pci_ids.h</span>
<span class="p_chunk">@@ -2256,12 +2256,29 @@</span> <span class="p_context"></span>
 #define PCI_DEVICE_ID_ZOLTRIX_2BD0	0x2bd0
 
 #define PCI_VENDOR_ID_MELLANOX		0x15b3
<span class="p_del">-#define PCI_DEVICE_ID_MELLANOX_TAVOR	0x5a44</span>
<span class="p_add">+#define PCI_DEVICE_ID_MELLANOX_CONNECTX3	0x1003</span>
<span class="p_add">+#define PCI_DEVICE_ID_MELLANOX_CONNECTX3_PRO	0x1007</span>
<span class="p_add">+#define PCI_DEVICE_ID_MELLANOX_CONNECTIB	0x1011</span>
<span class="p_add">+#define PCI_DEVICE_ID_MELLANOX_CONNECTX4	0x1013</span>
<span class="p_add">+#define PCI_DEVICE_ID_MELLANOX_CONNECTX4_LX	0x1015</span>
<span class="p_add">+#define PCI_DEVICE_ID_MELLANOX_TAVOR		0x5a44</span>
 #define PCI_DEVICE_ID_MELLANOX_TAVOR_BRIDGE	0x5a46
<span class="p_del">-#define PCI_DEVICE_ID_MELLANOX_ARBEL_COMPAT 0x6278</span>
<span class="p_del">-#define PCI_DEVICE_ID_MELLANOX_ARBEL	0x6282</span>
<span class="p_del">-#define PCI_DEVICE_ID_MELLANOX_SINAI_OLD 0x5e8c</span>
<span class="p_del">-#define PCI_DEVICE_ID_MELLANOX_SINAI	0x6274</span>
<span class="p_add">+#define PCI_DEVICE_ID_MELLANOX_SINAI_OLD	0x5e8c</span>
<span class="p_add">+#define PCI_DEVICE_ID_MELLANOX_SINAI		0x6274</span>
<span class="p_add">+#define PCI_DEVICE_ID_MELLANOX_ARBEL_COMPAT	0x6278</span>
<span class="p_add">+#define PCI_DEVICE_ID_MELLANOX_ARBEL		0x6282</span>
<span class="p_add">+#define PCI_DEVICE_ID_MELLANOX_HERMON_SDR	0x6340</span>
<span class="p_add">+#define PCI_DEVICE_ID_MELLANOX_HERMON_DDR	0x634a</span>
<span class="p_add">+#define PCI_DEVICE_ID_MELLANOX_HERMON_QDR	0x6354</span>
<span class="p_add">+#define PCI_DEVICE_ID_MELLANOX_HERMON_EN	0x6368</span>
<span class="p_add">+#define PCI_DEVICE_ID_MELLANOX_CONNECTX_EN	0x6372</span>
<span class="p_add">+#define PCI_DEVICE_ID_MELLANOX_HERMON_DDR_GEN2	0x6732</span>
<span class="p_add">+#define PCI_DEVICE_ID_MELLANOX_HERMON_QDR_GEN2	0x673c</span>
<span class="p_add">+#define PCI_DEVICE_ID_MELLANOX_CONNECTX_EN_5_GEN2 0x6746</span>
<span class="p_add">+#define PCI_DEVICE_ID_MELLANOX_HERMON_EN_GEN2	0x6750</span>
<span class="p_add">+#define PCI_DEVICE_ID_MELLANOX_CONNECTX_EN_T_GEN2 0x675a</span>
<span class="p_add">+#define PCI_DEVICE_ID_MELLANOX_CONNECTX_EN_GEN2	0x6764</span>
<span class="p_add">+#define PCI_DEVICE_ID_MELLANOX_CONNECTX2	0x676e</span>
 
 #define PCI_VENDOR_ID_DFI		0x15bd
 
<span class="p_header">diff --git a/include/linux/usb/gadget.h b/include/linux/usb/gadget.h</span>
<span class="p_header">index 8e81f9eb95e4..e4516e9ded0f 100644</span>
<span class="p_header">--- a/include/linux/usb/gadget.h</span>
<span class="p_header">+++ b/include/linux/usb/gadget.h</span>
<span class="p_chunk">@@ -429,7 +429,9 @@</span> <span class="p_context"> static inline struct usb_gadget *dev_to_usb_gadget(struct device *dev)</span>
  */
 static inline size_t usb_ep_align(struct usb_ep *ep, size_t len)
 {
<span class="p_del">-	return round_up(len, (size_t)le16_to_cpu(ep-&gt;desc-&gt;wMaxPacketSize));</span>
<span class="p_add">+	int max_packet_size = (size_t)usb_endpoint_maxp(ep-&gt;desc) &amp; 0x7ff;</span>
<span class="p_add">+</span>
<span class="p_add">+	return round_up(len, max_packet_size);</span>
 }
 
 /**
<span class="p_header">diff --git a/include/uapi/linux/nl80211.h b/include/uapi/linux/nl80211.h</span>
<span class="p_header">index 56368e9b4622..d3cbe48b286d 100644</span>
<span class="p_header">--- a/include/uapi/linux/nl80211.h</span>
<span class="p_header">+++ b/include/uapi/linux/nl80211.h</span>
<span class="p_chunk">@@ -323,7 +323,7 @@</span> <span class="p_context"></span>
  * @NL80211_CMD_GET_SCAN: get scan results
  * @NL80211_CMD_TRIGGER_SCAN: trigger a new scan with the given parameters
  *	%NL80211_ATTR_TX_NO_CCK_RATE is used to decide whether to send the
<span class="p_del">- *	probe requests at CCK rate or not. %NL80211_ATTR_MAC can be used to</span>
<span class="p_add">+ *	probe requests at CCK rate or not. %NL80211_ATTR_BSSID can be used to</span>
  *	specify a BSSID to scan for; if not included, the wildcard BSSID will
  *	be used.
  * @NL80211_CMD_NEW_SCAN_RESULTS: scan notification (as a reply to
<span class="p_chunk">@@ -1937,6 +1937,9 @@</span> <span class="p_context"> enum nl80211_commands {</span>
  * @NL80211_ATTR_NAN_MATCH: used to report a match. This is a nested attribute.
  *	See &amp;enum nl80211_nan_match_attributes.
  *
<span class="p_add">+ * @NL80211_ATTR_BSSID: The BSSID of the AP. Note that %NL80211_ATTR_MAC is also</span>
<span class="p_add">+ *	used in various commands/events for specifying the BSSID.</span>
<span class="p_add">+ *</span>
  * @NUM_NL80211_ATTR: total number of nl80211_attrs available
  * @NL80211_ATTR_MAX: highest attribute number currently defined
  * @__NL80211_ATTR_AFTER_LAST: internal use
<span class="p_chunk">@@ -2336,6 +2339,8 @@</span> <span class="p_context"> enum nl80211_attrs {</span>
 	NL80211_ATTR_NAN_FUNC,
 	NL80211_ATTR_NAN_MATCH,
 
<span class="p_add">+	NL80211_ATTR_BSSID,</span>
<span class="p_add">+</span>
 	/* add attributes here, update the policy in nl80211.c */
 
 	__NL80211_ATTR_AFTER_LAST,
<span class="p_header">diff --git a/kernel/irq/affinity.c b/kernel/irq/affinity.c</span>
<span class="p_header">index 17f51d63da56..668f51b861f7 100644</span>
<span class="p_header">--- a/kernel/irq/affinity.c</span>
<span class="p_header">+++ b/kernel/irq/affinity.c</span>
<span class="p_chunk">@@ -37,10 +37,10 @@</span> <span class="p_context"> static void irq_spread_init_one(struct cpumask *irqmsk, struct cpumask *nmsk,</span>
 
 static int get_nodes_in_cpumask(const struct cpumask *mask, nodemask_t *nodemsk)
 {
<span class="p_del">-	int n, nodes;</span>
<span class="p_add">+	int n, nodes = 0;</span>
 
 	/* Calculate the number of nodes in the supplied affinity mask */
<span class="p_del">-	for (n = 0, nodes = 0; n &lt; num_online_nodes(); n++) {</span>
<span class="p_add">+	for_each_online_node(n) {</span>
 		if (cpumask_intersects(mask, cpumask_of_node(n))) {
 			node_set(n, *nodemsk);
 			nodes++;
<span class="p_chunk">@@ -81,7 +81,7 @@</span> <span class="p_context"> struct cpumask *irq_create_affinity_masks(const struct cpumask *affinity,</span>
 	nodes = get_nodes_in_cpumask(affinity, &amp;nodemsk);
 
 	/*
<span class="p_del">-	 * If the number of nodes in the mask is less than or equal the</span>
<span class="p_add">+	 * If the number of nodes in the mask is greater than or equal the</span>
 	 * number of vectors we just spread the vectors across the nodes.
 	 */
 	if (nvec &lt;= nodes) {
<span class="p_header">diff --git a/kernel/relay.c b/kernel/relay.c</span>
<span class="p_header">index da79a109dbeb..8f18d314a96a 100644</span>
<span class="p_header">--- a/kernel/relay.c</span>
<span class="p_header">+++ b/kernel/relay.c</span>
<span class="p_chunk">@@ -809,11 +809,11 @@</span> <span class="p_context"> void relay_subbufs_consumed(struct rchan *chan,</span>
 {
 	struct rchan_buf *buf;
 
<span class="p_del">-	if (!chan)</span>
<span class="p_add">+	if (!chan || cpu &gt;= NR_CPUS)</span>
 		return;
 
 	buf = *per_cpu_ptr(chan-&gt;buf, cpu);
<span class="p_del">-	if (cpu &gt;= NR_CPUS || !buf || subbufs_consumed &gt; chan-&gt;n_subbufs)</span>
<span class="p_add">+	if (!buf || subbufs_consumed &gt; chan-&gt;n_subbufs)</span>
 		return;
 
 	if (subbufs_consumed &gt; buf-&gt;subbufs_produced - buf-&gt;subbufs_consumed)
<span class="p_header">diff --git a/kernel/time/tick-broadcast.c b/kernel/time/tick-broadcast.c</span>
<span class="p_header">index f6aae7977824..d2a20e83ebae 100644</span>
<span class="p_header">--- a/kernel/time/tick-broadcast.c</span>
<span class="p_header">+++ b/kernel/time/tick-broadcast.c</span>
<span class="p_chunk">@@ -871,6 +871,9 @@</span> <span class="p_context"> void tick_broadcast_setup_oneshot(struct clock_event_device *bc)</span>
 {
 	int cpu = smp_processor_id();
 
<span class="p_add">+	if (!bc)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	/* Set it up only once ! */
 	if (bc-&gt;event_handler != tick_handle_oneshot_broadcast) {
 		int was_periodic = clockevent_state_periodic(bc);
<span class="p_header">diff --git a/mm/compaction.c b/mm/compaction.c</span>
<span class="p_header">index 0409a4ad6ea1..70e6bec46dc2 100644</span>
<span class="p_header">--- a/mm/compaction.c</span>
<span class="p_header">+++ b/mm/compaction.c</span>
<span class="p_chunk">@@ -634,22 +634,6 @@</span> <span class="p_context"> isolate_freepages_range(struct compact_control *cc,</span>
 	return pfn;
 }
 
<span class="p_del">-/* Update the number of anon and file isolated pages in the zone */</span>
<span class="p_del">-static void acct_isolated(struct zone *zone, struct compact_control *cc)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct page *page;</span>
<span class="p_del">-	unsigned int count[2] = { 0, };</span>
<span class="p_del">-</span>
<span class="p_del">-	if (list_empty(&amp;cc-&gt;migratepages))</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	list_for_each_entry(page, &amp;cc-&gt;migratepages, lru)</span>
<span class="p_del">-		count[!!page_is_file_cache(page)]++;</span>
<span class="p_del">-</span>
<span class="p_del">-	mod_node_page_state(zone-&gt;zone_pgdat, NR_ISOLATED_ANON, count[0]);</span>
<span class="p_del">-	mod_node_page_state(zone-&gt;zone_pgdat, NR_ISOLATED_FILE, count[1]);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /* Similar to reclaim, but different enough that they don&#39;t share logic */
 static bool too_many_isolated(struct zone *zone)
 {
<span class="p_chunk">@@ -866,6 +850,8 @@</span> <span class="p_context"> isolate_migratepages_block(struct compact_control *cc, unsigned long low_pfn,</span>
 
 		/* Successfully isolated */
 		del_page_from_lru_list(page, lruvec, page_lru(page));
<span class="p_add">+		inc_node_page_state(page,</span>
<span class="p_add">+				NR_ISOLATED_ANON + page_is_file_cache(page));</span>
 
 isolate_success:
 		list_add(&amp;page-&gt;lru, &amp;cc-&gt;migratepages);
<span class="p_chunk">@@ -902,7 +888,6 @@</span> <span class="p_context"> isolate_migratepages_block(struct compact_control *cc, unsigned long low_pfn,</span>
 				spin_unlock_irqrestore(zone_lru_lock(zone), flags);
 				locked = false;
 			}
<span class="p_del">-			acct_isolated(zone, cc);</span>
 			putback_movable_pages(&amp;cc-&gt;migratepages);
 			cc-&gt;nr_migratepages = 0;
 			cc-&gt;last_migrated_pfn = 0;
<span class="p_chunk">@@ -988,7 +973,6 @@</span> <span class="p_context"> isolate_migratepages_range(struct compact_control *cc, unsigned long start_pfn,</span>
 		if (cc-&gt;nr_migratepages == COMPACT_CLUSTER_MAX)
 			break;
 	}
<span class="p_del">-	acct_isolated(cc-&gt;zone, cc);</span>
 
 	return pfn;
 }
<span class="p_chunk">@@ -1258,10 +1242,8 @@</span> <span class="p_context"> static isolate_migrate_t isolate_migratepages(struct zone *zone,</span>
 		low_pfn = isolate_migratepages_block(cc, low_pfn,
 						block_end_pfn, isolate_mode);
 
<span class="p_del">-		if (!low_pfn || cc-&gt;contended) {</span>
<span class="p_del">-			acct_isolated(zone, cc);</span>
<span class="p_add">+		if (!low_pfn || cc-&gt;contended)</span>
 			return ISOLATE_ABORT;
<span class="p_del">-		}</span>
 
 		/*
 		 * Either we isolated something and proceed with migration. Or
<span class="p_chunk">@@ -1271,7 +1253,6 @@</span> <span class="p_context"> static isolate_migrate_t isolate_migratepages(struct zone *zone,</span>
 		break;
 	}
 
<span class="p_del">-	acct_isolated(zone, cc);</span>
 	/* Record where migration scanner will be restarted. */
 	cc-&gt;migrate_pfn = low_pfn;
 
<span class="p_header">diff --git a/mm/hugetlb.c b/mm/hugetlb.c</span>
<span class="p_header">index 418bf01a50ed..23aec01836aa 100644</span>
<span class="p_header">--- a/mm/hugetlb.c</span>
<span class="p_header">+++ b/mm/hugetlb.c</span>
<span class="p_chunk">@@ -3450,15 +3450,17 @@</span> <span class="p_context"> static void unmap_ref_private(struct mm_struct *mm, struct vm_area_struct *vma,</span>
  * Keep the pte_same checks anyway to make transition from the mutex easier.
  */
 static int hugetlb_cow(struct mm_struct *mm, struct vm_area_struct *vma,
<span class="p_del">-			unsigned long address, pte_t *ptep, pte_t pte,</span>
<span class="p_del">-			struct page *pagecache_page, spinlock_t *ptl)</span>
<span class="p_add">+		       unsigned long address, pte_t *ptep,</span>
<span class="p_add">+		       struct page *pagecache_page, spinlock_t *ptl)</span>
 {
<span class="p_add">+	pte_t pte;</span>
 	struct hstate *h = hstate_vma(vma);
 	struct page *old_page, *new_page;
 	int ret = 0, outside_reserve = 0;
 	unsigned long mmun_start;	/* For mmu_notifiers */
 	unsigned long mmun_end;		/* For mmu_notifiers */
 
<span class="p_add">+	pte = huge_ptep_get(ptep);</span>
 	old_page = pte_page(pte);
 
 retry_avoidcopy:
<span class="p_chunk">@@ -3733,7 +3735,7 @@</span> <span class="p_context"> static int hugetlb_no_page(struct mm_struct *mm, struct vm_area_struct *vma,</span>
 	hugetlb_count_add(pages_per_huge_page(h), mm);
 	if ((flags &amp; FAULT_FLAG_WRITE) &amp;&amp; !(vma-&gt;vm_flags &amp; VM_SHARED)) {
 		/* Optimization, do the COW without a second fault */
<span class="p_del">-		ret = hugetlb_cow(mm, vma, address, ptep, new_pte, page, ptl);</span>
<span class="p_add">+		ret = hugetlb_cow(mm, vma, address, ptep, page, ptl);</span>
 	}
 
 	spin_unlock(ptl);
<span class="p_chunk">@@ -3888,8 +3890,8 @@</span> <span class="p_context"> int hugetlb_fault(struct mm_struct *mm, struct vm_area_struct *vma,</span>
 
 	if (flags &amp; FAULT_FLAG_WRITE) {
 		if (!huge_pte_write(entry)) {
<span class="p_del">-			ret = hugetlb_cow(mm, vma, address, ptep, entry,</span>
<span class="p_del">-					pagecache_page, ptl);</span>
<span class="p_add">+			ret = hugetlb_cow(mm, vma, address, ptep,</span>
<span class="p_add">+					  pagecache_page, ptl);</span>
 			goto out_put_page;
 		}
 		entry = huge_pte_mkdirty(entry);
<span class="p_header">diff --git a/mm/khugepaged.c b/mm/khugepaged.c</span>
<span class="p_header">index 87e1a7ca3846..5d7c006373d3 100644</span>
<span class="p_header">--- a/mm/khugepaged.c</span>
<span class="p_header">+++ b/mm/khugepaged.c</span>
<span class="p_chunk">@@ -1403,6 +1403,9 @@</span> <span class="p_context"> static void collapse_shmem(struct mm_struct *mm,</span>
 
 		spin_lock_irq(&amp;mapping-&gt;tree_lock);
 
<span class="p_add">+		slot = radix_tree_lookup_slot(&amp;mapping-&gt;page_tree, index);</span>
<span class="p_add">+		VM_BUG_ON_PAGE(page != radix_tree_deref_slot_protected(slot,</span>
<span class="p_add">+					&amp;mapping-&gt;tree_lock), page);</span>
 		VM_BUG_ON_PAGE(page_mapped(page), page);
 
 		/*
<span class="p_chunk">@@ -1426,6 +1429,7 @@</span> <span class="p_context"> static void collapse_shmem(struct mm_struct *mm,</span>
 		radix_tree_replace_slot(slot,
 				new_page + (index % HPAGE_PMD_NR));
 
<span class="p_add">+		slot = radix_tree_iter_next(&amp;iter);</span>
 		index++;
 		continue;
 out_lru:
<span class="p_chunk">@@ -1521,9 +1525,11 @@</span> <span class="p_context"> static void collapse_shmem(struct mm_struct *mm,</span>
 			if (!page || iter.index &lt; page-&gt;index) {
 				if (!nr_none)
 					break;
<span class="p_del">-				/* Put holes back where they were */</span>
<span class="p_del">-				radix_tree_replace_slot(slot, NULL);</span>
 				nr_none--;
<span class="p_add">+				/* Put holes back where they were */</span>
<span class="p_add">+				radix_tree_delete(&amp;mapping-&gt;page_tree,</span>
<span class="p_add">+						  iter.index);</span>
<span class="p_add">+				slot = radix_tree_iter_next(&amp;iter);</span>
 				continue;
 			}
 
<span class="p_chunk">@@ -1537,6 +1543,7 @@</span> <span class="p_context"> static void collapse_shmem(struct mm_struct *mm,</span>
 			putback_lru_page(page);
 			unlock_page(page);
 			spin_lock_irq(&amp;mapping-&gt;tree_lock);
<span class="p_add">+			slot = radix_tree_iter_next(&amp;iter);</span>
 		}
 		VM_BUG_ON(nr_none);
 		spin_unlock_irq(&amp;mapping-&gt;tree_lock);
<span class="p_header">diff --git a/mm/migrate.c b/mm/migrate.c</span>
<span class="p_header">index 99250aee1ac1..66ce6b490b13 100644</span>
<span class="p_header">--- a/mm/migrate.c</span>
<span class="p_header">+++ b/mm/migrate.c</span>
<span class="p_chunk">@@ -168,8 +168,6 @@</span> <span class="p_context"> void putback_movable_pages(struct list_head *l)</span>
 			continue;
 		}
 		list_del(&amp;page-&gt;lru);
<span class="p_del">-		dec_node_page_state(page, NR_ISOLATED_ANON +</span>
<span class="p_del">-				page_is_file_cache(page));</span>
 		/*
 		 * We isolated non-lru movable page so here we can use
 		 * __PageMovable because LRU page&#39;s mapping cannot have
<span class="p_chunk">@@ -186,6 +184,8 @@</span> <span class="p_context"> void putback_movable_pages(struct list_head *l)</span>
 			put_page(page);
 		} else {
 			putback_lru_page(page);
<span class="p_add">+			dec_node_page_state(page, NR_ISOLATED_ANON +</span>
<span class="p_add">+					page_is_file_cache(page));</span>
 		}
 	}
 }
<span class="p_chunk">@@ -1121,8 +1121,15 @@</span> <span class="p_context"> static ICE_noinline int unmap_and_move(new_page_t get_new_page,</span>
 		 * restored.
 		 */
 		list_del(&amp;page-&gt;lru);
<span class="p_del">-		dec_node_page_state(page, NR_ISOLATED_ANON +</span>
<span class="p_del">-				page_is_file_cache(page));</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Compaction can migrate also non-LRU pages which are</span>
<span class="p_add">+		 * not accounted to NR_ISOLATED_*. They can be recognized</span>
<span class="p_add">+		 * as __PageMovable</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (likely(!__PageMovable(page)))</span>
<span class="p_add">+			dec_node_page_state(page, NR_ISOLATED_ANON +</span>
<span class="p_add">+					page_is_file_cache(page));</span>
 	}
 
 	/*
<span class="p_header">diff --git a/net/mac80211/agg-rx.c b/net/mac80211/agg-rx.c</span>
<span class="p_header">index f6749dced021..3b5fd4188f2a 100644</span>
<span class="p_header">--- a/net/mac80211/agg-rx.c</span>
<span class="p_header">+++ b/net/mac80211/agg-rx.c</span>
<span class="p_chunk">@@ -315,11 +315,7 @@</span> <span class="p_context"> void __ieee80211_start_rx_ba_session(struct sta_info *sta,</span>
 	mutex_lock(&amp;sta-&gt;ampdu_mlme.mtx);
 
 	if (test_bit(tid, sta-&gt;ampdu_mlme.agg_session_valid)) {
<span class="p_del">-		tid_agg_rx = rcu_dereference_protected(</span>
<span class="p_del">-				sta-&gt;ampdu_mlme.tid_rx[tid],</span>
<span class="p_del">-				lockdep_is_held(&amp;sta-&gt;ampdu_mlme.mtx));</span>
<span class="p_del">-</span>
<span class="p_del">-		if (tid_agg_rx-&gt;dialog_token == dialog_token) {</span>
<span class="p_add">+		if (sta-&gt;ampdu_mlme.tid_rx_token[tid] == dialog_token) {</span>
 			ht_dbg_ratelimited(sta-&gt;sdata,
 					   &quot;updated AddBA Req from %pM on tid %u\n&quot;,
 					   sta-&gt;sta.addr, tid);
<span class="p_chunk">@@ -396,7 +392,6 @@</span> <span class="p_context"> void __ieee80211_start_rx_ba_session(struct sta_info *sta,</span>
 	}
 
 	/* update data */
<span class="p_del">-	tid_agg_rx-&gt;dialog_token = dialog_token;</span>
 	tid_agg_rx-&gt;ssn = start_seq_num;
 	tid_agg_rx-&gt;head_seq_num = start_seq_num;
 	tid_agg_rx-&gt;buf_size = buf_size;
<span class="p_chunk">@@ -418,6 +413,7 @@</span> <span class="p_context"> void __ieee80211_start_rx_ba_session(struct sta_info *sta,</span>
 	if (status == WLAN_STATUS_SUCCESS) {
 		__set_bit(tid, sta-&gt;ampdu_mlme.agg_session_valid);
 		__clear_bit(tid, sta-&gt;ampdu_mlme.unexpected_agg);
<span class="p_add">+		sta-&gt;ampdu_mlme.tid_rx_token[tid] = dialog_token;</span>
 	}
 	mutex_unlock(&amp;sta-&gt;ampdu_mlme.mtx);
 
<span class="p_header">diff --git a/net/mac80211/debugfs_sta.c b/net/mac80211/debugfs_sta.c</span>
<span class="p_header">index a2fcdb47a0e6..14ec63a02669 100644</span>
<span class="p_header">--- a/net/mac80211/debugfs_sta.c</span>
<span class="p_header">+++ b/net/mac80211/debugfs_sta.c</span>
<span class="p_chunk">@@ -205,7 +205,7 @@</span> <span class="p_context"> static ssize_t sta_agg_status_read(struct file *file, char __user *userbuf,</span>
 		p += scnprintf(p, sizeof(buf) + buf - p, &quot;%02d&quot;, i);
 		p += scnprintf(p, sizeof(buf) + buf - p, &quot;\t\t%x&quot;, !!tid_rx);
 		p += scnprintf(p, sizeof(buf) + buf - p, &quot;\t%#.2x&quot;,
<span class="p_del">-				tid_rx ? tid_rx-&gt;dialog_token : 0);</span>
<span class="p_add">+				tid_rx ? sta-&gt;ampdu_mlme.tid_rx_token[i] : 0);</span>
 		p += scnprintf(p, sizeof(buf) + buf - p, &quot;\t%#.3x&quot;,
 				tid_rx ? tid_rx-&gt;ssn : 0);
 
<span class="p_header">diff --git a/net/mac80211/sta_info.h b/net/mac80211/sta_info.h</span>
<span class="p_header">index ed5fcb984a01..dd06ef0b8861 100644</span>
<span class="p_header">--- a/net/mac80211/sta_info.h</span>
<span class="p_header">+++ b/net/mac80211/sta_info.h</span>
<span class="p_chunk">@@ -184,7 +184,6 @@</span> <span class="p_context"> struct tid_ampdu_tx {</span>
  * @ssn: Starting Sequence Number expected to be aggregated.
  * @buf_size: buffer size for incoming A-MPDUs
  * @timeout: reset timer value (in TUs).
<span class="p_del">- * @dialog_token: dialog token for aggregation session</span>
  * @rcu_head: RCU head used for freeing this struct
  * @reorder_lock: serializes access to reorder buffer, see below.
  * @auto_seq: used for offloaded BA sessions to automatically pick head_seq_and
<span class="p_chunk">@@ -213,7 +212,6 @@</span> <span class="p_context"> struct tid_ampdu_rx {</span>
 	u16 ssn;
 	u16 buf_size;
 	u16 timeout;
<span class="p_del">-	u8 dialog_token;</span>
 	bool auto_seq;
 	bool removed;
 };
<span class="p_chunk">@@ -225,6 +223,7 @@</span> <span class="p_context"> struct tid_ampdu_rx {</span>
  *	to tid_tx[idx], which are protected by the sta spinlock)
  *	tid_start_tx is also protected by sta-&gt;lock.
  * @tid_rx: aggregation info for Rx per TID -- RCU protected
<span class="p_add">+ * @tid_rx_token: dialog tokens for valid aggregation sessions</span>
  * @tid_rx_timer_expired: bitmap indicating on which TIDs the
  *	RX timer expired until the work for it runs
  * @tid_rx_stop_requested:  bitmap indicating which BA sessions per TID the
<span class="p_chunk">@@ -243,6 +242,7 @@</span> <span class="p_context"> struct sta_ampdu_mlme {</span>
 	struct mutex mtx;
 	/* rx */
 	struct tid_ampdu_rx __rcu *tid_rx[IEEE80211_NUM_TIDS];
<span class="p_add">+	u8 tid_rx_token[IEEE80211_NUM_TIDS];</span>
 	unsigned long tid_rx_timer_expired[BITS_TO_LONGS(IEEE80211_NUM_TIDS)];
 	unsigned long tid_rx_stop_requested[BITS_TO_LONGS(IEEE80211_NUM_TIDS)];
 	unsigned long agg_session_valid[BITS_TO_LONGS(IEEE80211_NUM_TIDS)];
<span class="p_header">diff --git a/net/mac80211/tx.c b/net/mac80211/tx.c</span>
<span class="p_header">index bd5f4be89435..dd190ff3daea 100644</span>
<span class="p_header">--- a/net/mac80211/tx.c</span>
<span class="p_header">+++ b/net/mac80211/tx.c</span>
<span class="p_chunk">@@ -3262,7 +3262,7 @@</span> <span class="p_context"> static bool ieee80211_xmit_fast(struct ieee80211_sub_if_data *sdata,</span>
 	int extra_head = fast_tx-&gt;hdr_len - (ETH_HLEN - 2);
 	int hw_headroom = sdata-&gt;local-&gt;hw.extra_tx_headroom;
 	struct ethhdr eth;
<span class="p_del">-	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);</span>
<span class="p_add">+	struct ieee80211_tx_info *info;</span>
 	struct ieee80211_hdr *hdr = (void *)fast_tx-&gt;hdr;
 	struct ieee80211_tx_data tx;
 	ieee80211_tx_result r;
<span class="p_chunk">@@ -3326,6 +3326,7 @@</span> <span class="p_context"> static bool ieee80211_xmit_fast(struct ieee80211_sub_if_data *sdata,</span>
 	memcpy(skb-&gt;data + fast_tx-&gt;da_offs, eth.h_dest, ETH_ALEN);
 	memcpy(skb-&gt;data + fast_tx-&gt;sa_offs, eth.h_source, ETH_ALEN);
 
<span class="p_add">+	info = IEEE80211_SKB_CB(skb);</span>
 	memset(info, 0, sizeof(*info));
 	info-&gt;band = fast_tx-&gt;band;
 	info-&gt;control.vif = &amp;sdata-&gt;vif;
<span class="p_header">diff --git a/net/wireless/nl80211.c b/net/wireless/nl80211.c</span>
<span class="p_header">index c510810f0b7c..a2dd6edaae37 100644</span>
<span class="p_header">--- a/net/wireless/nl80211.c</span>
<span class="p_header">+++ b/net/wireless/nl80211.c</span>
<span class="p_chunk">@@ -414,6 +414,7 @@</span> <span class="p_context"> static const struct nla_policy nl80211_policy[NUM_NL80211_ATTR] = {</span>
 	[NL80211_ATTR_NAN_MASTER_PREF] = { .type = NLA_U8 },
 	[NL80211_ATTR_NAN_DUAL] = { .type = NLA_U8 },
 	[NL80211_ATTR_NAN_FUNC] = { .type = NLA_NESTED },
<span class="p_add">+	[NL80211_ATTR_BSSID] = { .len = ETH_ALEN },</span>
 };
 
 /* policy for the key attributes */
<span class="p_chunk">@@ -6677,7 +6678,20 @@</span> <span class="p_context"> static int nl80211_trigger_scan(struct sk_buff *skb, struct genl_info *info)</span>
 	request-&gt;no_cck =
 		nla_get_flag(info-&gt;attrs[NL80211_ATTR_TX_NO_CCK_RATE]);
 
<span class="p_del">-	if (info-&gt;attrs[NL80211_ATTR_MAC])</span>
<span class="p_add">+	/* Initial implementation used NL80211_ATTR_MAC to set the specific</span>
<span class="p_add">+	 * BSSID to scan for. This was problematic because that same attribute</span>
<span class="p_add">+	 * was already used for another purpose (local random MAC address). The</span>
<span class="p_add">+	 * NL80211_ATTR_BSSID attribute was added to fix this. For backwards</span>
<span class="p_add">+	 * compatibility with older userspace components, also use the</span>
<span class="p_add">+	 * NL80211_ATTR_MAC value here if it can be determined to be used for</span>
<span class="p_add">+	 * the specific BSSID use case instead of the random MAC address</span>
<span class="p_add">+	 * (NL80211_ATTR_SCAN_FLAGS is used to enable random MAC address use).</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (info-&gt;attrs[NL80211_ATTR_BSSID])</span>
<span class="p_add">+		memcpy(request-&gt;bssid,</span>
<span class="p_add">+		       nla_data(info-&gt;attrs[NL80211_ATTR_BSSID]), ETH_ALEN);</span>
<span class="p_add">+	else if (!(request-&gt;flags &amp; NL80211_SCAN_FLAG_RANDOM_ADDR) &amp;&amp;</span>
<span class="p_add">+		 info-&gt;attrs[NL80211_ATTR_MAC])</span>
 		memcpy(request-&gt;bssid, nla_data(info-&gt;attrs[NL80211_ATTR_MAC]),
 		       ETH_ALEN);
 	else
<span class="p_header">diff --git a/scripts/gcc-plugins/gcc-common.h b/scripts/gcc-plugins/gcc-common.h</span>
<span class="p_header">index 950fd2e64bb7..12262c0cc691 100644</span>
<span class="p_header">--- a/scripts/gcc-plugins/gcc-common.h</span>
<span class="p_header">+++ b/scripts/gcc-plugins/gcc-common.h</span>
<span class="p_chunk">@@ -39,6 +39,9 @@</span> <span class="p_context"></span>
 #include &quot;hash-map.h&quot;
 #endif
 
<span class="p_add">+#if BUILDING_GCC_VERSION &gt;= 7000</span>
<span class="p_add">+#include &quot;memmodel.h&quot;</span>
<span class="p_add">+#endif</span>
 #include &quot;emit-rtl.h&quot;
 #include &quot;debug.h&quot;
 #include &quot;target.h&quot;
<span class="p_chunk">@@ -91,6 +94,9 @@</span> <span class="p_context"></span>
 #include &quot;tree-ssa-alias.h&quot;
 #include &quot;tree-ssa.h&quot;
 #include &quot;stringpool.h&quot;
<span class="p_add">+#if BUILDING_GCC_VERSION &gt;= 7000</span>
<span class="p_add">+#include &quot;tree-vrp.h&quot;</span>
<span class="p_add">+#endif</span>
 #include &quot;tree-ssanames.h&quot;
 #include &quot;print-tree.h&quot;
 #include &quot;tree-eh.h&quot;
<span class="p_chunk">@@ -287,6 +293,22 @@</span> <span class="p_context"> static inline struct cgraph_node *cgraph_next_function_with_gimple_body(struct c</span>
 	return NULL;
 }
 
<span class="p_add">+static inline bool cgraph_for_node_and_aliases(cgraph_node_ptr node, bool (*callback)(cgraph_node_ptr, void *), void *data, bool include_overwritable)</span>
<span class="p_add">+{</span>
<span class="p_add">+	cgraph_node_ptr alias;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (callback(node, data))</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (alias = node-&gt;same_body; alias; alias = alias-&gt;next) {</span>
<span class="p_add">+		if (include_overwritable || cgraph_function_body_availability(alias) &gt; AVAIL_OVERWRITABLE)</span>
<span class="p_add">+			if (cgraph_for_node_and_aliases(alias, callback, data, include_overwritable))</span>
<span class="p_add">+				return true;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #define FOR_EACH_FUNCTION_WITH_GIMPLE_BODY(node) \
 	for ((node) = cgraph_first_function_with_gimple_body(); (node); \
 		(node) = cgraph_next_function_with_gimple_body(node))
<span class="p_chunk">@@ -399,6 +421,7 @@</span> <span class="p_context"> typedef union gimple_statement_d gassign;</span>
 typedef union gimple_statement_d gcall;
 typedef union gimple_statement_d gcond;
 typedef union gimple_statement_d gdebug;
<span class="p_add">+typedef union gimple_statement_d ggoto;</span>
 typedef union gimple_statement_d gphi;
 typedef union gimple_statement_d greturn;
 
<span class="p_chunk">@@ -452,6 +475,16 @@</span> <span class="p_context"> static inline const gdebug *as_a_const_gdebug(const_gimple stmt)</span>
 	return stmt;
 }
 
<span class="p_add">+static inline ggoto *as_a_ggoto(gimple stmt)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return stmt;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline const ggoto *as_a_const_ggoto(const_gimple stmt)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return stmt;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline gphi *as_a_gphi(gimple stmt)
 {
 	return stmt;
<span class="p_chunk">@@ -496,6 +529,14 @@</span> <span class="p_context"> static inline const greturn *as_a_const_greturn(const_gimple stmt)</span>
 
 typedef struct rtx_def rtx_insn;
 
<span class="p_add">+static inline const char *get_decl_section_name(const_tree decl)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (DECL_SECTION_NAME(decl) == NULL_TREE)</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	return TREE_STRING_POINTER(DECL_SECTION_NAME(decl));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline void set_decl_section_name(tree node, const char *value)
 {
 	if (value)
<span class="p_chunk">@@ -511,6 +552,7 @@</span> <span class="p_context"> typedef struct gimple_statement_base gassign;</span>
 typedef struct gimple_statement_call gcall;
 typedef struct gimple_statement_base gcond;
 typedef struct gimple_statement_base gdebug;
<span class="p_add">+typedef struct gimple_statement_base ggoto;</span>
 typedef struct gimple_statement_phi gphi;
 typedef struct gimple_statement_base greturn;
 
<span class="p_chunk">@@ -564,6 +606,16 @@</span> <span class="p_context"> static inline const gdebug *as_a_const_gdebug(const_gimple stmt)</span>
 	return stmt;
 }
 
<span class="p_add">+static inline ggoto *as_a_ggoto(gimple stmt)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return stmt;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline const ggoto *as_a_const_ggoto(const_gimple stmt)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return stmt;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline gphi *as_a_gphi(gimple stmt)
 {
 	return as_a&lt;gphi&gt;(stmt);
<span class="p_chunk">@@ -611,6 +663,11 @@</span> <span class="p_context"> inline bool is_a_helper&lt;const gassign *&gt;::test(const_gimple gs)</span>
 
 #define INSN_DELETED_P(insn) (insn)-&gt;deleted()
 
<span class="p_add">+static inline const char *get_decl_section_name(const_tree decl)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return DECL_SECTION_NAME(decl);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* symtab/cgraph related */
 #define debug_cgraph_node(node) (node)-&gt;debug()
 #define cgraph_get_node(decl) cgraph_node::get(decl)
<span class="p_chunk">@@ -619,6 +676,7 @@</span> <span class="p_context"> inline bool is_a_helper&lt;const gassign *&gt;::test(const_gimple gs)</span>
 #define cgraph_n_nodes symtab-&gt;cgraph_count
 #define cgraph_max_uid symtab-&gt;cgraph_max_uid
 #define varpool_get_node(decl) varpool_node::get(decl)
<span class="p_add">+#define dump_varpool_node(file, node) (node)-&gt;dump(file)</span>
 
 #define cgraph_create_edge(caller, callee, call_stmt, count, freq, nest) \
 	(caller)-&gt;create_edge((callee), (call_stmt), (count), (freq))
<span class="p_chunk">@@ -674,6 +732,11 @@</span> <span class="p_context"> static inline cgraph_node_ptr cgraph_alias_target(cgraph_node_ptr node)</span>
 	return node-&gt;get_alias_target();
 }
 
<span class="p_add">+static inline bool cgraph_for_node_and_aliases(cgraph_node_ptr node, bool (*callback)(cgraph_node_ptr, void *), void *data, bool include_overwritable)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return node-&gt;call_for_symbol_thunks_and_aliases(callback, data, include_overwritable);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline struct cgraph_node_hook_list *cgraph_add_function_insertion_hook(cgraph_node_hook hook, void *data)
 {
 	return symtab-&gt;add_cgraph_insertion_hook(hook, data);
<span class="p_chunk">@@ -731,6 +794,13 @@</span> <span class="p_context"> static inline gimple gimple_build_assign_with_ops(enum tree_code subcode, tree l</span>
 
 template &lt;&gt;
 template &lt;&gt;
<span class="p_add">+inline bool is_a_helper&lt;const ggoto *&gt;::test(const_gimple gs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return gs-&gt;code == GIMPLE_GOTO;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+template &lt;&gt;</span>
<span class="p_add">+template &lt;&gt;</span>
 inline bool is_a_helper&lt;const greturn *&gt;::test(const_gimple gs)
 {
 	return gs-&gt;code == GIMPLE_RETURN;
<span class="p_chunk">@@ -766,6 +836,16 @@</span> <span class="p_context"> static inline const gcall *as_a_const_gcall(const_gimple stmt)</span>
 	return as_a&lt;const gcall *&gt;(stmt);
 }
 
<span class="p_add">+static inline ggoto *as_a_ggoto(gimple stmt)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return as_a&lt;ggoto *&gt;(stmt);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline const ggoto *as_a_const_ggoto(const_gimple stmt)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return as_a&lt;const ggoto *&gt;(stmt);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline gphi *as_a_gphi(gimple stmt)
 {
 	return as_a&lt;gphi *&gt;(stmt);
<span class="p_chunk">@@ -828,4 +908,9 @@</span> <span class="p_context"> static inline void debug_gimple_stmt(const_gimple s)</span>
 #define debug_gimple_stmt(s) debug_gimple_stmt(CONST_CAST_GIMPLE(s))
 #endif
 
<span class="p_add">+#if BUILDING_GCC_VERSION &gt;= 7000</span>
<span class="p_add">+#define get_inner_reference(exp, pbitsize, pbitpos, poffset, pmode, punsignedp, preversep, pvolatilep, keep_aligning)	\</span>
<span class="p_add">+	get_inner_reference(exp, pbitsize, pbitpos, poffset, pmode, punsignedp, preversep, pvolatilep)</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 #endif
<span class="p_header">diff --git a/security/integrity/ima/ima_fs.c b/security/integrity/ima/ima_fs.c</span>
<span class="p_header">index c07a3844ea0a..3df46906492d 100644</span>
<span class="p_header">--- a/security/integrity/ima/ima_fs.c</span>
<span class="p_header">+++ b/security/integrity/ima/ima_fs.c</span>
<span class="p_chunk">@@ -401,7 +401,7 @@</span> <span class="p_context"> static int ima_release_policy(struct inode *inode, struct file *file)</span>
 	const char *cause = valid_policy ? &quot;completed&quot; : &quot;failed&quot;;
 
 	if ((file-&gt;f_flags &amp; O_ACCMODE) == O_RDONLY)
<span class="p_del">-		return 0;</span>
<span class="p_add">+		return seq_release(inode, file);</span>
 
 	if (valid_policy &amp;&amp; ima_check_policy() &lt; 0) {
 		cause = &quot;failed&quot;;
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index 3f75d1b83bf2..758ac86a1d3a 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -2230,6 +2230,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc882_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x1043, 0x1971, &quot;Asus W2JC&quot;, ALC882_FIXUP_ASUS_W2JC),
 	SND_PCI_QUIRK(0x1043, 0x835f, &quot;Asus Eee 1601&quot;, ALC888_FIXUP_EEE1601),
 	SND_PCI_QUIRK(0x1043, 0x84bc, &quot;ASUS ET2700&quot;, ALC887_FIXUP_ASUS_BASS),
<span class="p_add">+	SND_PCI_QUIRK(0x1043, 0x8691, &quot;ASUS ROG Ranger VIII&quot;, ALC882_FIXUP_GPIO3),</span>
 	SND_PCI_QUIRK(0x104d, 0x9047, &quot;Sony Vaio TT&quot;, ALC889_FIXUP_VAIO_TT),
 	SND_PCI_QUIRK(0x104d, 0x905a, &quot;Sony Vaio Z&quot;, ALC882_FIXUP_NO_PRIMARY_HP),
 	SND_PCI_QUIRK(0x104d, 0x9043, &quot;Sony Vaio VGC-LN51JGB&quot;, ALC882_FIXUP_NO_PRIMARY_HP),
<span class="p_chunk">@@ -6943,6 +6944,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc662_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x1043, 0x15a7, &quot;ASUS UX51VZH&quot;, ALC662_FIXUP_BASS_16),
 	SND_PCI_QUIRK(0x1043, 0x177d, &quot;ASUS N551&quot;, ALC668_FIXUP_ASUS_Nx51),
 	SND_PCI_QUIRK(0x1043, 0x17bd, &quot;ASUS N751&quot;, ALC668_FIXUP_ASUS_Nx51),
<span class="p_add">+	SND_PCI_QUIRK(0x1043, 0x1963, &quot;ASUS X71SL&quot;, ALC662_FIXUP_ASUS_MODE8),</span>
 	SND_PCI_QUIRK(0x1043, 0x1b73, &quot;ASUS N55SF&quot;, ALC662_FIXUP_BASS_16),
 	SND_PCI_QUIRK(0x1043, 0x1bf3, &quot;ASUS N76VZ&quot;, ALC662_FIXUP_BASS_MODE4_CHMAP),
 	SND_PCI_QUIRK(0x1043, 0x8469, &quot;ASUS mobo&quot;, ALC662_FIXUP_NO_JACK_DETECT),
<span class="p_header">diff --git a/sound/soc/intel/boards/cht_bsw_rt5645.c b/sound/soc/intel/boards/cht_bsw_rt5645.c</span>
<span class="p_header">index 56056ed7fcfd..16c94c45ce50 100644</span>
<span class="p_header">--- a/sound/soc/intel/boards/cht_bsw_rt5645.c</span>
<span class="p_header">+++ b/sound/soc/intel/boards/cht_bsw_rt5645.c</span>
<span class="p_chunk">@@ -44,6 +44,7 @@</span> <span class="p_context"> struct cht_acpi_card {</span>
 struct cht_mc_private {
 	struct snd_soc_jack jack;
 	struct cht_acpi_card *acpi_card;
<span class="p_add">+	char codec_name[16];</span>
 };
 
 static inline struct snd_soc_dai *cht_get_codec_dai(struct snd_soc_card *card)
<span class="p_chunk">@@ -354,7 +355,6 @@</span> <span class="p_context"> static int snd_cht_mc_probe(struct platform_device *pdev)</span>
 	int i;
 	struct cht_mc_private *drv;
 	struct snd_soc_card *card = snd_soc_cards[0].soc_card;
<span class="p_del">-	char codec_name[16];</span>
 	struct sst_acpi_mach *mach;
 	const char *i2c_name = NULL;
 	int dai_index = 0;
<span class="p_chunk">@@ -374,12 +374,12 @@</span> <span class="p_context"> static int snd_cht_mc_probe(struct platform_device *pdev)</span>
 	}
 	card-&gt;dev = &amp;pdev-&gt;dev;
 	mach = card-&gt;dev-&gt;platform_data;
<span class="p_del">-	sprintf(codec_name, &quot;i2c-%s:00&quot;, drv-&gt;acpi_card-&gt;codec_id);</span>
<span class="p_add">+	sprintf(drv-&gt;codec_name, &quot;i2c-%s:00&quot;, drv-&gt;acpi_card-&gt;codec_id);</span>
 
 	/* set correct codec name */
 	for (i = 0; i &lt; ARRAY_SIZE(cht_dailink); i++)
 		if (!strcmp(card-&gt;dai_link[i].codec_name, &quot;i2c-10EC5645:00&quot;)) {
<span class="p_del">-			card-&gt;dai_link[i].codec_name = kstrdup(codec_name, GFP_KERNEL);</span>
<span class="p_add">+			card-&gt;dai_link[i].codec_name = drv-&gt;codec_name;</span>
 			dai_index = i;
 		}
 
<span class="p_header">diff --git a/sound/soc/intel/skylake/skl-sst-utils.c b/sound/soc/intel/skylake/skl-sst-utils.c</span>
<span class="p_header">index 8dc03039b311..ea162fbf68e5 100644</span>
<span class="p_header">--- a/sound/soc/intel/skylake/skl-sst-utils.c</span>
<span class="p_header">+++ b/sound/soc/intel/skylake/skl-sst-utils.c</span>
<span class="p_chunk">@@ -179,7 +179,7 @@</span> <span class="p_context"> static inline int skl_getid_32(struct uuid_module *module, u64 *val,</span>
 		index = ffz(mask_val);
 		pvt_id = index + word1_mask + word2_mask;
 		if (pvt_id &lt;= (max_inst - 1)) {
<span class="p_del">-			*val |= 1 &lt;&lt; (index + word1_mask);</span>
<span class="p_add">+			*val |= 1ULL &lt;&lt; (index + word1_mask);</span>
 			return pvt_id;
 		}
 	}
<span class="p_header">diff --git a/sound/soc/qcom/lpass-platform.c b/sound/soc/qcom/lpass-platform.c</span>
<span class="p_header">index b392e51de94d..420d200f9a05 100644</span>
<span class="p_header">--- a/sound/soc/qcom/lpass-platform.c</span>
<span class="p_header">+++ b/sound/soc/qcom/lpass-platform.c</span>
<span class="p_chunk">@@ -78,6 +78,9 @@</span> <span class="p_context"> static int lpass_platform_pcmops_open(struct snd_pcm_substream *substream)</span>
 	dma_ch = 0;
 	if (v-&gt;alloc_dma_channel)
 		dma_ch = v-&gt;alloc_dma_channel(drvdata, dir);
<span class="p_add">+	else</span>
<span class="p_add">+		dma_ch = 0;</span>
<span class="p_add">+</span>
 	if (dma_ch &lt; 0)
 		return dma_ch;
 
<span class="p_header">diff --git a/sound/soc/samsung/i2s.c b/sound/soc/samsung/i2s.c</span>
<span class="p_header">index 7825bff45ae3..85324e61cbd5 100644</span>
<span class="p_header">--- a/sound/soc/samsung/i2s.c</span>
<span class="p_header">+++ b/sound/soc/samsung/i2s.c</span>
<span class="p_chunk">@@ -1029,12 +1029,13 @@</span> <span class="p_context"> static int samsung_i2s_dai_probe(struct snd_soc_dai *dai)</span>
 static int samsung_i2s_dai_remove(struct snd_soc_dai *dai)
 {
 	struct i2s_dai *i2s = snd_soc_dai_get_drvdata(dai);
<span class="p_add">+	unsigned long flags;</span>
 
 	if (!is_secondary(i2s)) {
 		if (i2s-&gt;quirks &amp; QUIRK_NEED_RSTCLR) {
<span class="p_del">-			spin_lock(i2s-&gt;lock);</span>
<span class="p_add">+			spin_lock_irqsave(i2s-&gt;lock, flags);</span>
 			writel(0, i2s-&gt;addr + I2SCON);
<span class="p_del">-			spin_unlock(i2s-&gt;lock);</span>
<span class="p_add">+			spin_unlock_irqrestore(i2s-&gt;lock, flags);</span>
 		}
 	}
 
<span class="p_header">diff --git a/sound/usb/card.c b/sound/usb/card.c</span>
<span class="p_header">index 2ddc034673a8..f36cb068dad3 100644</span>
<span class="p_header">--- a/sound/usb/card.c</span>
<span class="p_header">+++ b/sound/usb/card.c</span>
<span class="p_chunk">@@ -206,7 +206,6 @@</span> <span class="p_context"> static int snd_usb_create_stream(struct snd_usb_audio *chip, int ctrlif, int int</span>
 	if (! snd_usb_parse_audio_interface(chip, interface)) {
 		usb_set_interface(dev, interface, 0); /* reset the current interface */
 		usb_driver_claim_interface(&amp;usb_audio_driver, iface, (void *)-1L);
<span class="p_del">-		return -EINVAL;</span>
 	}
 
 	return 0;
<span class="p_header">diff --git a/sound/usb/endpoint.c b/sound/usb/endpoint.c</span>
<span class="p_header">index c470251cea4b..c5251aaad844 100644</span>
<span class="p_header">--- a/sound/usb/endpoint.c</span>
<span class="p_header">+++ b/sound/usb/endpoint.c</span>
<span class="p_chunk">@@ -534,6 +534,11 @@</span> <span class="p_context"> static int wait_clear_urbs(struct snd_usb_endpoint *ep)</span>
 			alive, ep-&gt;ep_num);
 	clear_bit(EP_FLAG_STOPPING, &amp;ep-&gt;flags);
 
<span class="p_add">+	ep-&gt;data_subs = NULL;</span>
<span class="p_add">+	ep-&gt;sync_slave = NULL;</span>
<span class="p_add">+	ep-&gt;retire_data_urb = NULL;</span>
<span class="p_add">+	ep-&gt;prepare_data_urb = NULL;</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -898,9 +903,7 @@</span> <span class="p_context"> int snd_usb_endpoint_set_params(struct snd_usb_endpoint *ep,</span>
 /**
  * snd_usb_endpoint_start: start an snd_usb_endpoint
  *
<span class="p_del">- * @ep:		the endpoint to start</span>
<span class="p_del">- * @can_sleep:	flag indicating whether the operation is executed in</span>
<span class="p_del">- * 		non-atomic context</span>
<span class="p_add">+ * @ep: the endpoint to start</span>
  *
  * A call to this function will increment the use count of the endpoint.
  * In case it is not already running, the URBs for this endpoint will be
<span class="p_chunk">@@ -910,7 +913,7 @@</span> <span class="p_context"> int snd_usb_endpoint_set_params(struct snd_usb_endpoint *ep,</span>
  *
  * Returns an error if the URB submission failed, 0 in all other cases.
  */
<span class="p_del">-int snd_usb_endpoint_start(struct snd_usb_endpoint *ep, bool can_sleep)</span>
<span class="p_add">+int snd_usb_endpoint_start(struct snd_usb_endpoint *ep)</span>
 {
 	int err;
 	unsigned int i;
<span class="p_chunk">@@ -924,8 +927,6 @@</span> <span class="p_context"> int snd_usb_endpoint_start(struct snd_usb_endpoint *ep, bool can_sleep)</span>
 
 	/* just to be sure */
 	deactivate_urbs(ep, false);
<span class="p_del">-	if (can_sleep)</span>
<span class="p_del">-		wait_clear_urbs(ep);</span>
 
 	ep-&gt;active_mask = 0;
 	ep-&gt;unlink_mask = 0;
<span class="p_chunk">@@ -1006,10 +1007,6 @@</span> <span class="p_context"> void snd_usb_endpoint_stop(struct snd_usb_endpoint *ep)</span>
 
 	if (--ep-&gt;use_count == 0) {
 		deactivate_urbs(ep, false);
<span class="p_del">-		ep-&gt;data_subs = NULL;</span>
<span class="p_del">-		ep-&gt;sync_slave = NULL;</span>
<span class="p_del">-		ep-&gt;retire_data_urb = NULL;</span>
<span class="p_del">-		ep-&gt;prepare_data_urb = NULL;</span>
 		set_bit(EP_FLAG_STOPPING, &amp;ep-&gt;flags);
 	}
 }
<span class="p_header">diff --git a/sound/usb/endpoint.h b/sound/usb/endpoint.h</span>
<span class="p_header">index 6428392d8f62..584f295d7c77 100644</span>
<span class="p_header">--- a/sound/usb/endpoint.h</span>
<span class="p_header">+++ b/sound/usb/endpoint.h</span>
<span class="p_chunk">@@ -18,7 +18,7 @@</span> <span class="p_context"> int snd_usb_endpoint_set_params(struct snd_usb_endpoint *ep,</span>
 				struct audioformat *fmt,
 				struct snd_usb_endpoint *sync_ep);
 
<span class="p_del">-int  snd_usb_endpoint_start(struct snd_usb_endpoint *ep, bool can_sleep);</span>
<span class="p_add">+int  snd_usb_endpoint_start(struct snd_usb_endpoint *ep);</span>
 void snd_usb_endpoint_stop(struct snd_usb_endpoint *ep);
 void snd_usb_endpoint_sync_pending_stop(struct snd_usb_endpoint *ep);
 int  snd_usb_endpoint_activate(struct snd_usb_endpoint *ep);
<span class="p_header">diff --git a/sound/usb/pcm.c b/sound/usb/pcm.c</span>
<span class="p_header">index 44d178ee9177..48afae053c56 100644</span>
<span class="p_header">--- a/sound/usb/pcm.c</span>
<span class="p_header">+++ b/sound/usb/pcm.c</span>
<span class="p_chunk">@@ -218,7 +218,7 @@</span> <span class="p_context"> int snd_usb_init_pitch(struct snd_usb_audio *chip, int iface,</span>
 	}
 }
 
<span class="p_del">-static int start_endpoints(struct snd_usb_substream *subs, bool can_sleep)</span>
<span class="p_add">+static int start_endpoints(struct snd_usb_substream *subs)</span>
 {
 	int err;
 
<span class="p_chunk">@@ -231,7 +231,7 @@</span> <span class="p_context"> static int start_endpoints(struct snd_usb_substream *subs, bool can_sleep)</span>
 		dev_dbg(&amp;subs-&gt;dev-&gt;dev, &quot;Starting data EP @%p\n&quot;, ep);
 
 		ep-&gt;data_subs = subs;
<span class="p_del">-		err = snd_usb_endpoint_start(ep, can_sleep);</span>
<span class="p_add">+		err = snd_usb_endpoint_start(ep);</span>
 		if (err &lt; 0) {
 			clear_bit(SUBSTREAM_FLAG_DATA_EP_STARTED, &amp;subs-&gt;flags);
 			return err;
<span class="p_chunk">@@ -260,7 +260,7 @@</span> <span class="p_context"> static int start_endpoints(struct snd_usb_substream *subs, bool can_sleep)</span>
 		dev_dbg(&amp;subs-&gt;dev-&gt;dev, &quot;Starting sync EP @%p\n&quot;, ep);
 
 		ep-&gt;sync_slave = subs-&gt;data_endpoint;
<span class="p_del">-		err = snd_usb_endpoint_start(ep, can_sleep);</span>
<span class="p_add">+		err = snd_usb_endpoint_start(ep);</span>
 		if (err &lt; 0) {
 			clear_bit(SUBSTREAM_FLAG_SYNC_EP_STARTED, &amp;subs-&gt;flags);
 			return err;
<span class="p_chunk">@@ -839,7 +839,7 @@</span> <span class="p_context"> static int snd_usb_pcm_prepare(struct snd_pcm_substream *substream)</span>
 	/* for playback, submit the URBs now; otherwise, the first hwptr_done
 	 * updates for all URBs would happen at the same time when starting */
 	if (subs-&gt;direction == SNDRV_PCM_STREAM_PLAYBACK)
<span class="p_del">-		ret = start_endpoints(subs, true);</span>
<span class="p_add">+		ret = start_endpoints(subs);</span>
 
  unlock:
 	snd_usb_unlock_shutdown(subs-&gt;stream-&gt;chip);
<span class="p_chunk">@@ -1655,7 +1655,7 @@</span> <span class="p_context"> static int snd_usb_substream_capture_trigger(struct snd_pcm_substream *substream</span>
 
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
<span class="p_del">-		err = start_endpoints(subs, false);</span>
<span class="p_add">+		err = start_endpoints(subs);</span>
 		if (err &lt; 0)
 			return err;
 

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



