
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[v4,5/6] iommu/mediatek: Add mt8173 IOMMU driver - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [v4,5/6] iommu/mediatek: Add mt8173 IOMMU driver</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=123111">Yong Wu</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Aug. 3, 2015, 10:21 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1438597279-2937-6-git-send-email-yong.wu@mediatek.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/6928521/mbox/"
   >mbox</a>
|
   <a href="/patch/6928521/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/6928521/">/patch/6928521/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork1.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork1.web.kernel.org (Postfix) with ESMTP id 7AB229F38B
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon,  3 Aug 2015 10:22:54 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id A40E7205DF
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon,  3 Aug 2015 10:22:52 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id AF7F320547
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon,  3 Aug 2015 10:22:50 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1753333AbbHCKWq (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Mon, 3 Aug 2015 06:22:46 -0400
Received: from mailgw02.mediatek.com ([210.61.82.184]:57978 &quot;EHLO
	mailgw02.mediatek.com&quot; rhost-flags-OK-FAIL-OK-FAIL) by
	vger.kernel.org with ESMTP id S1751791AbbHCKWo (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Mon, 3 Aug 2015 06:22:44 -0400
X-Listener-Flag: 11101
Received: from mtkhts09.mediatek.inc [(172.21.101.70)] by
	mailgw02.mediatek.com (envelope-from &lt;yong.wu@mediatek.com&gt;)
	(mhqrelay.mediatek.com ESMTP with TLS)
	with ESMTP id 1036987342; Mon, 03 Aug 2015 18:22:42 +0800
Received: from mhfsdcap03.mhfswrd (10.17.3.153) by mtkhts09.mediatek.inc
	(172.21.101.73) with Microsoft SMTP Server id 14.3.181.6;
	Mon, 3 Aug 2015 18:22:40 +0800
From: Yong Wu &lt;yong.wu@mediatek.com&gt;
To: Joerg Roedel &lt;joro@8bytes.org&gt;, Thierry Reding &lt;treding@nvidia.com&gt;,
	Mark Rutland &lt;mark.rutland@arm.com&gt;,
	Matthias Brugger &lt;matthias.bgg@gmail.com&gt;
CC: Robin Murphy &lt;robin.murphy@arm.com&gt;, Will Deacon &lt;will.deacon@arm.com&gt;,
	Daniel Kurtz &lt;djkurtz@google.com&gt;, Tomasz Figa &lt;tfiga@google.com&gt;,
	Lucas Stach &lt;l.stach@pengutronix.de&gt;, Rob Herring &lt;robh+dt@kernel.org&gt;,
	Catalin Marinas &lt;catalin.marinas@arm.com&gt;,
	&lt;linux-mediatek@lists.infradead.org&gt;,
	Sasha Hauer &lt;kernel@pengutronix.de&gt;,
	&lt;srv_heupstream@mediatek.com&gt;, &lt;devicetree@vger.kernel.org&gt;,
	&lt;linux-kernel@vger.kernel.org&gt;, &lt;linux-arm-kernel@lists.infradead.org&gt;,
	&lt;iommu@lists.linux-foundation.org&gt;, &lt;pebolle@tiscali.nl&gt;,
	&lt;arnd@arndb.de&gt;, &lt;mitchelh@codeaurora.org&gt;,
	&lt;youhua.li@mediatek.com&gt;, &lt;k.zhang@mediatek.com&gt;,
	&lt;frederic.chen@mediatek.com&gt;, Yong Wu &lt;yong.wu@mediatek.com&gt;
Subject: [PATCH v4 5/6] iommu/mediatek: Add mt8173 IOMMU driver
Date: Mon, 3 Aug 2015 18:21:18 +0800
Message-ID: &lt;1438597279-2937-6-git-send-email-yong.wu@mediatek.com&gt;
X-Mailer: git-send-email 1.8.1.1.dirty
In-Reply-To: &lt;1438597279-2937-1-git-send-email-yong.wu@mediatek.com&gt;
References: &lt;1438597279-2937-1-git-send-email-yong.wu@mediatek.com&gt;
MIME-Version: 1.0
Content-Type: text/plain
X-MTK: N
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-7.1 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=123111">Yong Wu</a> - Aug. 3, 2015, 10:21 a.m.</div>
<pre class="content">
This patch adds support for mediatek m4u (MultiMedia Memory Management
Unit).
<span class="signed-off-by">
Signed-off-by: Yong Wu &lt;yong.wu@mediatek.com&gt;</span>
---
 drivers/iommu/Kconfig     |  13 +
 drivers/iommu/Makefile    |   1 +
 drivers/iommu/mtk_iommu.c | 714 ++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 728 insertions(+)
 create mode 100644 drivers/iommu/mtk_iommu.c
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=317">Joerg Roedel</a> - Aug. 11, 2015, 3:39 p.m.</div>
<pre class="content">
On Mon, Aug 03, 2015 at 06:21:18PM +0800, Yong Wu wrote:
<span class="quote">&gt; +/*</span>
<span class="quote">&gt; + * There is only one iommu domain called the m4u domain that</span>
<span class="quote">&gt; + * all Multimedia modules share.</span>
<span class="quote">&gt; + */</span>
<span class="quote">&gt; +static struct mtk_iommu_domain	*m4udom;</span>

What is the reason you only implement one domain? Can&#39;t the IOMMU
isolate different devices from each other?
<span class="quote">

&gt; +static struct iommu_domain *mtk_iommu_domain_alloc(unsigned type)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mtk_iommu_domain *priv;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (type != IOMMU_DOMAIN_UNMANAGED &amp;&amp; type != IOMMU_DOMAIN_DMA)</span>
<span class="quote">&gt; +		return NULL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (m4udom)/* The m4u domain exist. */</span>
<span class="quote">&gt; +		return &amp;m4udom-&gt;domain;</span>

This is not going to work. If you always return the same domain the
iommu core might re-initialize domain state (and overwrite changed
state). At the moment this is only the domain-type which will change
every time this function is called, but there might be more.
<span class="quote">
&gt; +static int mtk_iommu_add_device(struct device *dev)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct iommu_group *group;</span>
<span class="quote">&gt; +	int ret;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (!dev-&gt;archdata.iommu) /* Not a iommu client device */</span>
<span class="quote">&gt; +		return -ENODEV;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	group = iommu_group_get(dev);</span>
<span class="quote">&gt; +	if (!group) {</span>
<span class="quote">&gt; +		group = iommu_group_alloc();</span>
<span class="quote">&gt; +		if (IS_ERR(group)) {</span>
<span class="quote">&gt; +			dev_err(dev, &quot;Failed to allocate IOMMU group\n&quot;);</span>
<span class="quote">&gt; +			return PTR_ERR(group);</span>
<span class="quote">&gt; +		}</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ret = iommu_group_add_device(group, dev);</span>
<span class="quote">&gt; +	if (ret) {</span>
<span class="quote">&gt; +		dev_err(dev, &quot;Failed to add IOMMU group\n&quot;);</span>
<span class="quote">&gt; +		goto err_group_put;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ret = iommu_attach_group(&amp;m4udom-&gt;domain, group);</span>
<span class="quote">&gt; +	if (ret)</span>
<span class="quote">&gt; +		dev_err(dev, &quot;Failed to attach IOMMU group\n&quot;);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +err_group_put:</span>
<span class="quote">&gt; +	iommu_group_put(group);</span>
<span class="quote">&gt; +	return ret;</span>
<span class="quote">&gt; +}</span>

Putting every device into its own group indicates that the IOMMU can
isolate between single devices on the bus, which makes it even more
questionable that you only allow one domain for the whole driver.


	Joerg

--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=123111">Yong Wu</a> - Aug. 12, 2015, 12:28 p.m.</div>
<pre class="content">
On Tue, 2015-08-11 at 17:39 +0200, Joerg Roedel wrote:
<span class="quote">&gt; On Mon, Aug 03, 2015 at 06:21:18PM +0800, Yong Wu wrote:</span>
<span class="quote">&gt; &gt; +/*</span>
<span class="quote">&gt; &gt; + * There is only one iommu domain called the m4u domain that</span>
<span class="quote">&gt; &gt; + * all Multimedia modules share.</span>
<span class="quote">&gt; &gt; + */</span>
<span class="quote">&gt; &gt; +static struct mtk_iommu_domain	*m4udom;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; What is the reason you only implement one domain? Can&#39;t the IOMMU</span>
<span class="quote">&gt; isolate different devices from each other?</span>
Hi Joerg,

  Thanks for your review.
  From your comment, you may care that we use only one domain.

  Our HW is called m4u(MultiMedia Memory Management Unit) which
help all the multimedia hardware access the dram, include display,video
decode,video encode,camera,mdp,etc. And the m4u has only one pagetable.
(Actually there is two pagetables in m4u, one is the normal pagetable,
the other is security pagetable. Currently We don&#39;t implement the
security one, so there is only one pagetable here.)
That is to say all the multimedia devices are in the m4u domain and
share the m4uâ€™s pagetable.

So We have only one domain here..
<span class="quote">
&gt; &gt; +static struct iommu_domain *mtk_iommu_domain_alloc(unsigned type)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	struct mtk_iommu_domain *priv;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	if (type != IOMMU_DOMAIN_UNMANAGED &amp;&amp; type != IOMMU_DOMAIN_DMA)</span>
<span class="quote">&gt; &gt; +		return NULL;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	if (m4udom)/* The m4u domain exist. */</span>
<span class="quote">&gt; &gt; +		return &amp;m4udom-&gt;domain;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This is not going to work. If you always return the same domain the</span>
<span class="quote">&gt; iommu core might re-initialize domain state (and overwrite changed</span>
<span class="quote">&gt; state). At the moment this is only the domain-type which will change</span>
<span class="quote">&gt; every time this function is called, but there might be more.</span>

In our v3[1],  I didn&#39;t return the same domain, Then I have to trick in
attach_device like below:
//============
static int mtk_iommu_attach_device(struct iommu_domain *domain,
                                  struct device *dev)
{
        struct device *imudev = xxxx;
        /*
         * Reserve one iommu domain as the m4u domain which
         * all Multimedia modules share and free the others.
         */
        if (!imudev-&gt;archdata.iommu)
               imudev-&gt;archdata.iommu = priv;
        else if (imudev-&gt;archdata.iommu != priv)
               iommu_domain_free(domain);
        xxxx
}
//==============
In this version, I used a global variable to record the m4u domain then
I can delete these code and make it simple.

Then how should I do in our case? .
If we can&#39;t return the same domain here, We have to add some code like
above in the attach_device.

[1]:http://lists.linuxfoundation.org/pipermail/iommu/2015-July/013631.html
<span class="quote"> 
&gt; </span>
<span class="quote">&gt; &gt; +static int mtk_iommu_add_device(struct device *dev)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	struct iommu_group *group;</span>
<span class="quote">&gt; &gt; +	int ret;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	if (!dev-&gt;archdata.iommu) /* Not a iommu client device */</span>
<span class="quote">&gt; &gt; +		return -ENODEV;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	group = iommu_group_get(dev);</span>
<span class="quote">&gt; &gt; +	if (!group) {</span>
<span class="quote">&gt; &gt; +		group = iommu_group_alloc();</span>
<span class="quote">&gt; &gt; +		if (IS_ERR(group)) {</span>
<span class="quote">&gt; &gt; +			dev_err(dev, &quot;Failed to allocate IOMMU group\n&quot;);</span>
<span class="quote">&gt; &gt; +			return PTR_ERR(group);</span>
<span class="quote">&gt; &gt; +		}</span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	ret = iommu_group_add_device(group, dev);</span>
<span class="quote">&gt; &gt; +	if (ret) {</span>
<span class="quote">&gt; &gt; +		dev_err(dev, &quot;Failed to add IOMMU group\n&quot;);</span>
<span class="quote">&gt; &gt; +		goto err_group_put;</span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	ret = iommu_attach_group(&amp;m4udom-&gt;domain, group);</span>
<span class="quote">&gt; &gt; +	if (ret)</span>
<span class="quote">&gt; &gt; +		dev_err(dev, &quot;Failed to attach IOMMU group\n&quot;);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +err_group_put:</span>
<span class="quote">&gt; &gt; +	iommu_group_put(group);</span>
<span class="quote">&gt; &gt; +	return ret;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Putting every device into its own group indicates that the IOMMU can</span>
<span class="quote">&gt; isolate between single devices on the bus, which makes it even more</span>
<span class="quote">&gt; questionable that you only allow one domain for the whole driver.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; 	Joerg</span>
<span class="quote">&gt; </span>


--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=77581">Robin Murphy</a> - Sept. 11, 2015, 3:33 p.m.</div>
<pre class="content">
On 03/08/15 11:21, Yong Wu wrote:
<span class="quote">&gt; This patch adds support for mediatek m4u (MultiMedia Memory Management</span>
<span class="quote">&gt; Unit).</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Signed-off-by: Yong Wu &lt;yong.wu@mediatek.com&gt;</span>
<span class="quote">&gt; ---</span>
[...]
<span class="quote">&gt; +/*</span>
<span class="quote">&gt; + * There is only one iommu domain called the m4u domain that</span>
<span class="quote">&gt; + * all Multimedia modules share.</span>
<span class="quote">&gt; + */</span>
<span class="quote">&gt; +static struct mtk_iommu_domain *m4udom;</span>

It&#39;s a shame this can&#39;t be part of the m4u device&#39;s mtk_iommu_data, but 
since the way iommu_domain_alloc works makes that impossible, I think we 
have little choice but to use the global and hope your guys never build 
a system with two of these things in ;)

[...]
<span class="quote">&gt; +static struct iommu_domain *mtk_iommu_domain_alloc(unsigned type)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct mtk_iommu_domain *priv;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if (type != IOMMU_DOMAIN_UNMANAGED &amp;&amp; type != IOMMU_DOMAIN_DMA)</span>
<span class="quote">&gt; +               return NULL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if (m4udom)/* The m4u domain exist. */</span>
<span class="quote">&gt; +               return &amp;m4udom-&gt;domain;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       priv = kzalloc(sizeof(*priv), GFP_KERNEL);</span>
<span class="quote">&gt; +       if (!priv)</span>
<span class="quote">&gt; +               return NULL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       priv-&gt;domain.geometry.aperture_start = 0;</span>
<span class="quote">&gt; +       priv-&gt;domain.geometry.aperture_end = DMA_BIT_MASK(32);</span>
<span class="quote">&gt; +       priv-&gt;domain.geometry.force_aperture = true;</span>

My intention is that in the IOMMU_DOMAIN_DMA case you&#39;d call 
iommu_get_dma_cookie(&amp;priv-&gt;domain) here as well, that way I can get rid 
of some of the dodgy workarounds in arch_setup_dma_ops which try to 
cover all possible cases (and which I&#39;m now not 100% confident in). I&#39;m 
just about to start trying to fix that up (expect a repost of my series 
in a week or two once -rc1 has landed).
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +       m4udom = priv;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       return &amp;priv-&gt;domain;</span>
<span class="quote">&gt; +}</span>
[...]
<span class="quote">&gt; +static int mtk_iommu_add_device(struct device *dev)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct iommu_group *group;</span>
<span class="quote">&gt; +       int ret;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if (!dev-&gt;archdata.iommu) /* Not a iommu client device */</span>
<span class="quote">&gt; +               return -ENODEV;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       group = iommu_group_get(dev);</span>
<span class="quote">&gt; +       if (!group) {</span>
<span class="quote">&gt; +               group = iommu_group_alloc();</span>
<span class="quote">&gt; +               if (IS_ERR(group)) {</span>
<span class="quote">&gt; +                       dev_err(dev, &quot;Failed to allocate IOMMU group\n&quot;);</span>
<span class="quote">&gt; +                       return PTR_ERR(group);</span>
<span class="quote">&gt; +               }</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +</span>
<span class="quote"> &gt; +       ret = iommu_group_add_device(group, dev);</span>
<span class="quote">&gt; +       if (ret) {</span>
<span class="quote">&gt; +               dev_err(dev, &quot;Failed to add IOMMU group\n&quot;);</span>
<span class="quote">&gt; +               goto err_group_put;</span>
<span class="quote">&gt; +       }</span>

I know the rest of the code means that you can&#39;t hit it in practice, but 
if you ever did have two client devices in the same group then the 
iommu_group_get() could legitimately succeed for the second device, then 
you&#39;d blow up creating a duplicate sysfs entry by adding the device to 
its own group again. Probably not what you want.
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +       ret = iommu_attach_group(&amp;m4udom-&gt;domain, group);</span>
<span class="quote">&gt; +       if (ret)</span>
<span class="quote">&gt; +               dev_err(dev, &quot;Failed to attach IOMMU group\n&quot;);</span>

Similarly here, if two devices did share a group then the group could 
legitimately already be attached to a domain here (by the first device), 
so attaching it again would be wrong. I think it would be nicer to check 
with iommu_get_domain_for_dev() first to see if you need to do anything 
at all (a valid domain from that implies a valid group).
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +err_group_put:</span>
<span class="quote">&gt; +       iommu_group_put(group);</span>
<span class="quote">&gt; +       return ret;</span>
<span class="quote">&gt; +}</span>
[...]
<span class="quote">&gt; +static int mtk_iommu_probe(struct platform_device *pdev)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct mtk_iommu_data   *data;</span>
<span class="quote">&gt; +       struct device           *dev = &amp;pdev-&gt;dev;</span>
<span class="quote">&gt; +       void __iomem            *protect;</span>
<span class="quote">&gt; +       int                     ret;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       data = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);</span>
<span class="quote">&gt; +       if (!data)</span>
<span class="quote">&gt; +               return -ENOMEM;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       /* Protect memory. HW will access here while translation fault.*/</span>
<span class="quote">&gt; +       protect = devm_kzalloc(dev, MTK_PROTECT_PA_ALIGN * 2, GFP_KERNEL);</span>
<span class="quote">&gt; +       if (!protect)</span>
<span class="quote">&gt; +               return -ENOMEM;</span>
<span class="quote">&gt; +       data-&gt;protect_base = virt_to_phys(protect);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       ret = mtk_iommu_parse_dt(pdev, data);</span>
<span class="quote">&gt; +       if (ret)</span>
<span class="quote">&gt; +               return ret;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if (!m4udom)/* There is no iommu client */</span>
<span class="quote">&gt; +               return 0;</span>

I don&#39;t quite follow this: m4udom is apparently only created by someone 
calling domain_alloc() - how can you guarantee that happens before this 
driver is probed? - but if they then go and try to attach the device to 
their new domain, it&#39;s going to end up in mtk_hw_init() poking the 
hardware of the m4u device that can&#39;t have even probed yet.

I can only imagine it currently works by sheer chance due to the 
horrible arch_setup_dma_ops delayed attachment workaround, so even if I 
can&#39;t remove that completely when I look at it next week I&#39;m liable to 
change it in a way that breaks this badly ;)

Robin.
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +       data-&gt;dev = dev;</span>
<span class="quote">&gt; +       m4udom-&gt;data = data;</span>
<span class="quote">&gt; +       dev_set_drvdata(dev, m4udom);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       return 0;</span>
<span class="quote">&gt; +}</span>

--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=123111">Yong Wu</a> - Sept. 15, 2015, 5:53 a.m.</div>
<pre class="content">
On Fri, 2015-09-11 at 16:33 +0100, Robin Murphy wrote:
<span class="quote">&gt; On 03/08/15 11:21, Yong Wu wrote:</span>
<span class="quote">&gt; &gt; This patch adds support for mediatek m4u (MultiMedia Memory Management</span>
<span class="quote">&gt; &gt; Unit).</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; Signed-off-by: Yong Wu &lt;yong.wu@mediatek.com&gt;</span>
<span class="quote">&gt; &gt; ---</span>
<span class="quote">&gt; [...]</span>
<span class="quote">&gt; &gt; +/*</span>
<span class="quote">&gt; &gt; + * There is only one iommu domain called the m4u domain that</span>
<span class="quote">&gt; &gt; + * all Multimedia modules share.</span>
<span class="quote">&gt; &gt; + */</span>
<span class="quote">&gt; &gt; +static struct mtk_iommu_domain *m4udom;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; It&#39;s a shame this can&#39;t be part of the m4u device&#39;s mtk_iommu_data, but </span>
<span class="quote">&gt; since the way iommu_domain_alloc works makes that impossible, I think we </span>
<span class="quote">&gt; have little choice but to use the global and hope your guys never build </span>
<span class="quote">&gt; a system with two of these things in ;)</span>

Hi Robin,
   Thanks very much for your review. This gobal variable trouble me very
much. please also help check below.
<span class="quote">
&gt; </span>
<span class="quote">&gt; [...]</span>
<span class="quote">&gt; &gt; +static struct iommu_domain *mtk_iommu_domain_alloc(unsigned type)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +       struct mtk_iommu_domain *priv;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       if (type != IOMMU_DOMAIN_UNMANAGED &amp;&amp; type != IOMMU_DOMAIN_DMA)</span>
<span class="quote">&gt; &gt; +               return NULL;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       if (m4udom)/* The m4u domain exist. */</span>
<span class="quote">&gt; &gt; +               return &amp;m4udom-&gt;domain;</span>

     From Joerg&#39;s comment[0]: &quot;This is not going to work. If you always
return the same domain the iommu core might re-initialize domain state
(and overwrite changed state).&quot;

     It seems that I have to delete this here. then alloc iommu-domain
every time. and add some workaround code in mtk_iommu_attach_device like
our v3[1](reserve one as the m4u domain and delete the others).
Then the code maybe not very concise, but it could also work in the
future, Is it OK?

[0]:http://lists.linuxfoundation.org/pipermail/iommu/2015-August/014057.html
[1]:http://lists.linuxfoundation.org/pipermail/iommu/2015-July/013631.html
<span class="quote">
&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       priv = kzalloc(sizeof(*priv), GFP_KERNEL);</span>
<span class="quote">&gt; &gt; +       if (!priv)</span>
<span class="quote">&gt; &gt; +               return NULL;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       priv-&gt;domain.geometry.aperture_start = 0;</span>
<span class="quote">&gt; &gt; +       priv-&gt;domain.geometry.aperture_end = DMA_BIT_MASK(32);</span>
<span class="quote">&gt; &gt; +       priv-&gt;domain.geometry.force_aperture = true;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; My intention is that in the IOMMU_DOMAIN_DMA case you&#39;d call </span>
<span class="quote">&gt; iommu_get_dma_cookie(&amp;priv-&gt;domain) here as well, that way I can get rid </span>
<span class="quote">&gt; of some of the dodgy workarounds in arch_setup_dma_ops which try to </span>
<span class="quote">&gt; cover all possible cases (and which I&#39;m now not 100% confident in). I&#39;m </span>
<span class="quote">&gt; just about to start trying to fix that up (expect a repost of my series </span>
<span class="quote">&gt; in a week or two once -rc1 has landed).</span>

  I will add like this:
  if (type == IOMMU_DOMAIN_DMA &amp;&amp; iommu_get_dma_cookie(&amp;priv-&gt;domain)) {
       kfree(priv);
       return NULL;
  }
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       m4udom = priv;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       return &amp;priv-&gt;domain;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; [...]</span>
<span class="quote">&gt; &gt; +static int mtk_iommu_add_device(struct device *dev)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +       struct iommu_group *group;</span>
<span class="quote">&gt; &gt; +       int ret;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       if (!dev-&gt;archdata.iommu) /* Not a iommu client device */</span>
<span class="quote">&gt; &gt; +               return -ENODEV;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       group = iommu_group_get(dev);</span>
<span class="quote">&gt; &gt; +       if (!group) {</span>
<span class="quote">&gt; &gt; +               group = iommu_group_alloc();</span>
<span class="quote">&gt; &gt; +               if (IS_ERR(group)) {</span>
<span class="quote">&gt; &gt; +                       dev_err(dev, &quot;Failed to allocate IOMMU group\n&quot;);</span>
<span class="quote">&gt; &gt; +                       return PTR_ERR(group);</span>
<span class="quote">&gt; &gt; +               }</span>
<span class="quote">&gt; &gt; +       }</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt;  &gt; +       ret = iommu_group_add_device(group, dev);</span>
<span class="quote">&gt; &gt; +       if (ret) {</span>
<span class="quote">&gt; &gt; +               dev_err(dev, &quot;Failed to add IOMMU group\n&quot;);</span>
<span class="quote">&gt; &gt; +               goto err_group_put;</span>
<span class="quote">&gt; &gt; +       }</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I know the rest of the code means that you can&#39;t hit it in practice, but </span>
<span class="quote">&gt; if you ever did have two client devices in the same group then the </span>
<span class="quote">&gt; iommu_group_get() could legitimately succeed for the second device, then </span>
<span class="quote">&gt; you&#39;d blow up creating a duplicate sysfs entry by adding the device to </span>
<span class="quote">&gt; its own group again. Probably not what you want.</span>

   the &quot;dev&quot; is different while enter this function, That is to say
every client device have its own iommu-group. is it right?
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       ret = iommu_attach_group(&amp;m4udom-&gt;domain, group);</span>
<span class="quote">&gt; &gt; +       if (ret)</span>
<span class="quote">&gt; &gt; +               dev_err(dev, &quot;Failed to attach IOMMU group\n&quot;);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Similarly here, if two devices did share a group then the group could </span>
<span class="quote">&gt; legitimately already be attached to a domain here (by the first device), </span>
<span class="quote">&gt; so attaching it again would be wrong. I think it would be nicer to check </span>
<span class="quote">&gt; with iommu_get_domain_for_dev() first to see if you need to do anything </span>
<span class="quote">&gt; at all (a valid domain from that implies a valid group).</span>

   Here all the devices has their own iommu-group, I only attach the
same iommu-domain for them due to our m4u HW. All the clients are in
M4U-HW&#39;s domain and there is only one pagetable here.
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +err_group_put:</span>
<span class="quote">&gt; &gt; +       iommu_group_put(group);</span>
<span class="quote">&gt; &gt; +       return ret;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; [...]</span>
<span class="quote">&gt; &gt; +static int mtk_iommu_probe(struct platform_device *pdev)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +       struct mtk_iommu_data   *data;</span>
<span class="quote">&gt; &gt; +       struct device           *dev = &amp;pdev-&gt;dev;</span>
<span class="quote">&gt; &gt; +       void __iomem            *protect;</span>
<span class="quote">&gt; &gt; +       int                     ret;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       data = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);</span>
<span class="quote">&gt; &gt; +       if (!data)</span>
<span class="quote">&gt; &gt; +               return -ENOMEM;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       /* Protect memory. HW will access here while translation fault.*/</span>
<span class="quote">&gt; &gt; +       protect = devm_kzalloc(dev, MTK_PROTECT_PA_ALIGN * 2, GFP_KERNEL);</span>
<span class="quote">&gt; &gt; +       if (!protect)</span>
<span class="quote">&gt; &gt; +               return -ENOMEM;</span>
<span class="quote">&gt; &gt; +       data-&gt;protect_base = virt_to_phys(protect);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       ret = mtk_iommu_parse_dt(pdev, data);</span>
<span class="quote">&gt; &gt; +       if (ret)</span>
<span class="quote">&gt; &gt; +               return ret;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       if (!m4udom)/* There is no iommu client */</span>
<span class="quote">&gt; &gt; +               return 0;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I don&#39;t quite follow this: m4udom is apparently only created by someone </span>
<span class="quote">&gt; calling domain_alloc() - how can you guarantee that happens before this </span>
<span class="quote">&gt; driver is probed? - but if they then go and try to attach the device to </span>
<span class="quote">&gt; their new domain, it&#39;s going to end up in mtk_hw_init() poking the </span>
<span class="quote">&gt; hardware of the m4u device that can&#39;t have even probed yet.</span>

    I think the probe will run always earlier than mtk_hw_init.
    In the mtk_iommu_attach_device below, I add iommu_group_get to
guarantee the sequence.
//==================
static int mtk_iommu_attach_device(struct iommu_domain *domain,
				   struct device *dev)
{
	struct mtk_iommu_domain *priv = to_mtk_domain(domain);
	struct iommu_group *group;
	int ret;

	group = iommu_group_get(dev);
	if (!group)
		return 0;
	iommu_group_put(group);

	ret = mtk_iommu_init_domain_context(priv);
	if (ret)
		return ret;

	return mtk_iommu_config(priv, dev, true);
}
//======================
   After the probe done, It will enter bus_set_iommu-&gt;
mtk_iommu_add_device where will create iommu group for it.
then enter iommu_attach_group-&gt;mtk_iommu_attach_device again.
is this ok here?

About &quot;how can you guarantee that happens before this 
driver is probed?&quot;
-&gt;Sorry, I can&#39;t guarantee this. The domain_alloc is called by
arch_setup_dma_ops in the DMA core, I will change this depend on the
next DMA.
<span class="quote">
&gt; </span>
<span class="quote">&gt; I can only imagine it currently works by sheer chance due to the </span>
<span class="quote">&gt; horrible arch_setup_dma_ops delayed attachment workaround, so even if I </span>
<span class="quote">&gt; can&#39;t remove that completely when I look at it next week I&#39;m liable to </span>
<span class="quote">&gt; change it in a way that breaks this badly ;)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Robin.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       data-&gt;dev = dev;</span>
<span class="quote">&gt; &gt; +       m4udom-&gt;data = data;</span>
<span class="quote">&gt; &gt; +       dev_set_drvdata(dev, m4udom);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       return 0;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; </span>


--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/drivers/iommu/Kconfig b/drivers/iommu/Kconfig</span>
<span class="p_header">index 3abd066..f0ae553e 100644</span>
<span class="p_header">--- a/drivers/iommu/Kconfig</span>
<span class="p_header">+++ b/drivers/iommu/Kconfig</span>
<span class="p_chunk">@@ -386,4 +386,17 @@</span> <span class="p_context"> config ARM_SMMU_V3</span>
 	  Say Y here if your system includes an IOMMU device implementing
 	  the ARM SMMUv3 architecture.
 
<span class="p_add">+config MTK_IOMMU</span>
<span class="p_add">+	bool &quot;MTK IOMMU Support&quot;</span>
<span class="p_add">+	depends on ARCH_MEDIATEK || COMPILE_TEST</span>
<span class="p_add">+	select IOMMU_API</span>
<span class="p_add">+	select IOMMU_DMA</span>
<span class="p_add">+	select IOMMU_IO_PGTABLE_SHORT</span>
<span class="p_add">+	select MEMORY</span>
<span class="p_add">+	select MTK_SMI</span>
<span class="p_add">+	help</span>
<span class="p_add">+	  Support for the IOMMUs on certain Mediatek SOCs.</span>
<span class="p_add">+</span>
<span class="p_add">+	  If unsure, say N here.</span>
<span class="p_add">+</span>
 endif # IOMMU_SUPPORT
<span class="p_header">diff --git a/drivers/iommu/Makefile b/drivers/iommu/Makefile</span>
<span class="p_header">index 06df3e6..f4f2f2c 100644</span>
<span class="p_header">--- a/drivers/iommu/Makefile</span>
<span class="p_header">+++ b/drivers/iommu/Makefile</span>
<span class="p_chunk">@@ -21,6 +21,7 @@</span> <span class="p_context"> obj-$(CONFIG_ROCKCHIP_IOMMU) += rockchip-iommu.o</span>
 obj-$(CONFIG_TEGRA_IOMMU_GART) += tegra-gart.o
 obj-$(CONFIG_TEGRA_IOMMU_SMMU) += tegra-smmu.o
 obj-$(CONFIG_EXYNOS_IOMMU) += exynos-iommu.o
<span class="p_add">+obj-$(CONFIG_MTK_IOMMU) += mtk_iommu.o</span>
 obj-$(CONFIG_SHMOBILE_IOMMU) += shmobile-iommu.o
 obj-$(CONFIG_SHMOBILE_IPMMU) += shmobile-ipmmu.o
 obj-$(CONFIG_FSL_PAMU) += fsl_pamu.o fsl_pamu_domain.o
<span class="p_header">diff --git a/drivers/iommu/mtk_iommu.c b/drivers/iommu/mtk_iommu.c</span>
new file mode 100644
<span class="p_header">index 0000000..3c4f1b5</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/drivers/iommu/mtk_iommu.c</span>
<span class="p_chunk">@@ -0,0 +1,714 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (c) 2014-2015 MediaTek Inc.</span>
<span class="p_add">+ * Author: Yong Wu &lt;yong.wu@mediatek.com&gt;</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License version 2 as</span>
<span class="p_add">+ * published by the Free Software Foundation.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#include &lt;linux/io.h&gt;</span>
<span class="p_add">+#include &lt;linux/interrupt.h&gt;</span>
<span class="p_add">+#include &lt;linux/platform_device.h&gt;</span>
<span class="p_add">+#include &lt;linux/iommu.h&gt;</span>
<span class="p_add">+#include &lt;linux/dma-mapping.h&gt;</span>
<span class="p_add">+#include &lt;linux/dma-iommu.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_iommu.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_address.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_irq.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_platform.h&gt;</span>
<span class="p_add">+#include &lt;linux/list.h&gt;</span>
<span class="p_add">+#include &lt;linux/clk.h&gt;</span>
<span class="p_add">+#include &lt;linux/iopoll.h&gt;</span>
<span class="p_add">+#include &lt;asm/cacheflush.h&gt;</span>
<span class="p_add">+#include &lt;soc/mediatek/smi.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &quot;io-pgtable.h&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_PT_BASE_ADDR			0x000</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_INVALIDATE			0x020</span>
<span class="p_add">+#define F_ALL_INVLD				0x2</span>
<span class="p_add">+#define F_MMU_INV_RANGE				0x1</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_INVLD_START_A			0x024</span>
<span class="p_add">+#define REG_MMU_INVLD_END_A			0x028</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_INV_SEL				0x038</span>
<span class="p_add">+#define F_INVLD_EN0				BIT(0)</span>
<span class="p_add">+#define F_INVLD_EN1				BIT(1)</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_STANDARD_AXI_MODE		0x048</span>
<span class="p_add">+#define REG_MMU_DCM_DIS				0x050</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_CTRL_REG			0x110</span>
<span class="p_add">+#define F_MMU_PREFETCH_RT_REPLACE_MOD		BIT(4)</span>
<span class="p_add">+#define F_MMU_TF_PROTECT_SEL(prot)		(((prot) &amp; 0x3) &lt;&lt; 5)</span>
<span class="p_add">+#define F_COHERENCE_EN				BIT(8)</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_IVRP_PADDR			0x114</span>
<span class="p_add">+#define F_MMU_IVRP_PA_SET(pa)			((pa) &gt;&gt; 1)</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_INT_CONTROL0			0x120</span>
<span class="p_add">+#define F_L2_MULIT_HIT_EN			BIT(0)</span>
<span class="p_add">+#define F_TABLE_WALK_FAULT_INT_EN		BIT(1)</span>
<span class="p_add">+#define F_PREETCH_FIFO_OVERFLOW_INT_EN		BIT(2)</span>
<span class="p_add">+#define F_MISS_FIFO_OVERFLOW_INT_EN		BIT(3)</span>
<span class="p_add">+#define F_PREFETCH_FIFO_ERR_INT_EN		BIT(5)</span>
<span class="p_add">+#define F_MISS_FIFO_ERR_INT_EN			BIT(6)</span>
<span class="p_add">+#define F_INT_L2_CLR_BIT			BIT(12)</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_INT_MAIN_CONTROL		0x124</span>
<span class="p_add">+#define F_INT_TRANSLATION_FAULT			BIT(0)</span>
<span class="p_add">+#define F_INT_MAIN_MULTI_HIT_FAULT		BIT(1)</span>
<span class="p_add">+#define F_INT_INVALID_PA_FAULT			BIT(2)</span>
<span class="p_add">+#define F_INT_ENTRY_REPLACEMENT_FAULT		BIT(3)</span>
<span class="p_add">+#define F_INT_TLB_MISS_FAULT			BIT(4)</span>
<span class="p_add">+#define F_INT_MISS_TRANSATION_FIFO_FAULT	BIT(5)</span>
<span class="p_add">+#define F_INT_PRETETCH_TRANSATION_FIFO_FAULT	BIT(6)</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_CPE_DONE			0x12C</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_FAULT_ST1			0x134</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_FAULT_VA			0x13c</span>
<span class="p_add">+#define F_MMU_FAULT_VA_MSK			0xfffff000</span>
<span class="p_add">+#define F_MMU_FAULT_VA_WRITE_BIT		BIT(1)</span>
<span class="p_add">+#define F_MMU_FAULT_VA_LAYER_BIT		BIT(0)</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_INVLD_PA			0x140</span>
<span class="p_add">+#define REG_MMU_INT_ID				0x150</span>
<span class="p_add">+#define F_MMU0_INT_ID_LARB_ID(a)		(((a) &gt;&gt; 7) &amp; 0x7)</span>
<span class="p_add">+#define F_MMU0_INT_ID_PORT_ID(a)		(((a) &gt;&gt; 2) &amp; 0x1f)</span>
<span class="p_add">+</span>
<span class="p_add">+#define MTK_PROTECT_PA_ALIGN			128</span>
<span class="p_add">+#define MTK_IOMMU_LARB_MAX_NR			8</span>
<span class="p_add">+#define MTK_IOMMU_REG_NR			10</span>
<span class="p_add">+</span>
<span class="p_add">+struct mtk_iommu_suspend_reg {</span>
<span class="p_add">+	u32				standard_axi_mode;</span>
<span class="p_add">+	u32				dcm_dis;</span>
<span class="p_add">+	u32				ctrl_reg;</span>
<span class="p_add">+	u32				ivrp_paddr;</span>
<span class="p_add">+	u32				int_control0;</span>
<span class="p_add">+	u32				int_main_control;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct mtk_iommu_data {</span>
<span class="p_add">+	void __iomem			*base;</span>
<span class="p_add">+	int				irq;</span>
<span class="p_add">+	struct device			*dev;</span>
<span class="p_add">+	struct device			*larbdev[MTK_IOMMU_LARB_MAX_NR];</span>
<span class="p_add">+	struct clk			*bclk;</span>
<span class="p_add">+	phys_addr_t			protect_base; /* protect memory base */</span>
<span class="p_add">+	int				larb_nr;/* local arbiter number */</span>
<span class="p_add">+	struct mtk_iommu_suspend_reg	reg;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct mtk_iommu_domain {</span>
<span class="p_add">+	struct imu_pgd_t		*pgd;</span>
<span class="p_add">+	spinlock_t			pgtlock; /* lock for page table */</span>
<span class="p_add">+</span>
<span class="p_add">+	struct io_pgtable_cfg		cfg;</span>
<span class="p_add">+	struct io_pgtable_ops		*iop;</span>
<span class="p_add">+</span>
<span class="p_add">+	struct mtk_iommu_data		*data;</span>
<span class="p_add">+	struct iommu_domain		domain;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct mtk_iommu_client_priv {</span>
<span class="p_add">+	struct list_head		client;</span>
<span class="p_add">+	unsigned int			larbid;</span>
<span class="p_add">+	unsigned int			portid;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static struct iommu_ops mtk_iommu_ops;</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * There is only one iommu domain called the m4u domain that</span>
<span class="p_add">+ * all Multimedia modules share.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static struct mtk_iommu_domain	*m4udom;</span>
<span class="p_add">+</span>
<span class="p_add">+static struct mtk_iommu_domain *to_mtk_domain(struct iommu_domain *dom)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return container_of(dom, struct mtk_iommu_domain, domain);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mtk_iommu_clear_intr(const struct mtk_iommu_data *data)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 val;</span>
<span class="p_add">+</span>
<span class="p_add">+	val = readl_relaxed(data-&gt;base + REG_MMU_INT_CONTROL0);</span>
<span class="p_add">+	val |= F_INT_L2_CLR_BIT;</span>
<span class="p_add">+	writel_relaxed(val, data-&gt;base + REG_MMU_INT_CONTROL0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mtk_iommu_tlb_flush_all(void *cookie)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *domain = cookie;</span>
<span class="p_add">+	void __iomem *base;</span>
<span class="p_add">+</span>
<span class="p_add">+	base = domain-&gt;data-&gt;base;</span>
<span class="p_add">+	writel_relaxed(F_INVLD_EN1 | F_INVLD_EN0, base + REG_MMU_INV_SEL);</span>
<span class="p_add">+	writel_relaxed(F_ALL_INVLD, base + REG_MMU_INVALIDATE);</span>
<span class="p_add">+	mb();/* Make sure flush all done */</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mtk_iommu_tlb_add_flush(unsigned long iova, size_t size,</span>
<span class="p_add">+				    bool leaf, void *cookie)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *domain = cookie;</span>
<span class="p_add">+	void __iomem *base = domain-&gt;data-&gt;base;</span>
<span class="p_add">+	unsigned int iova_start = iova, iova_end = iova + size - 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	writel_relaxed(F_INVLD_EN1 | F_INVLD_EN0, base + REG_MMU_INV_SEL);</span>
<span class="p_add">+</span>
<span class="p_add">+	writel_relaxed(iova_start, base + REG_MMU_INVLD_START_A);</span>
<span class="p_add">+	writel_relaxed(iova_end, base + REG_MMU_INVLD_END_A);</span>
<span class="p_add">+	writel_relaxed(F_MMU_INV_RANGE, base + REG_MMU_INVALIDATE);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mtk_iommu_tlb_sync(void *cookie)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *domain = cookie;</span>
<span class="p_add">+	void __iomem *base = domain-&gt;data-&gt;base;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+	u32 tmp;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = readl_poll_timeout_atomic(base + REG_MMU_CPE_DONE, tmp,</span>
<span class="p_add">+					tmp != 0, 10, 1000000);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		dev_warn(domain-&gt;data-&gt;dev,</span>
<span class="p_add">+			 &quot;Partial TLB flush timed out, falling back to full flush\n&quot;);</span>
<span class="p_add">+		mtk_iommu_tlb_flush_all(cookie);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	writel_relaxed(0, base + REG_MMU_CPE_DONE);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct iommu_gather_ops mtk_iommu_gather_ops = {</span>
<span class="p_add">+	.tlb_flush_all = mtk_iommu_tlb_flush_all,</span>
<span class="p_add">+	.tlb_add_flush = mtk_iommu_tlb_add_flush,</span>
<span class="p_add">+	.tlb_sync = mtk_iommu_tlb_sync,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static irqreturn_t mtk_iommu_isr(int irq, void *dev_id)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *mtkdom = dev_id;</span>
<span class="p_add">+	struct mtk_iommu_data *data = mtkdom-&gt;data;</span>
<span class="p_add">+	u32 int_state, regval, fault_iova, fault_pa;</span>
<span class="p_add">+	unsigned int fault_larb, fault_port;</span>
<span class="p_add">+	bool layer, write;</span>
<span class="p_add">+</span>
<span class="p_add">+	int_state = readl_relaxed(data-&gt;base + REG_MMU_FAULT_ST1);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* read error info from registers */</span>
<span class="p_add">+	fault_iova = readl_relaxed(data-&gt;base + REG_MMU_FAULT_VA);</span>
<span class="p_add">+	layer = fault_iova &amp; F_MMU_FAULT_VA_LAYER_BIT;</span>
<span class="p_add">+	write = fault_iova &amp; F_MMU_FAULT_VA_WRITE_BIT;</span>
<span class="p_add">+	fault_iova &amp;= F_MMU_FAULT_VA_MSK;</span>
<span class="p_add">+	fault_pa = readl_relaxed(data-&gt;base + REG_MMU_INVLD_PA);</span>
<span class="p_add">+	regval = readl_relaxed(data-&gt;base + REG_MMU_INT_ID);</span>
<span class="p_add">+	fault_larb = F_MMU0_INT_ID_LARB_ID(regval);</span>
<span class="p_add">+	fault_port = F_MMU0_INT_ID_PORT_ID(regval);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (report_iommu_fault(&amp;mtkdom-&gt;domain, data-&gt;dev, fault_iova,</span>
<span class="p_add">+			       write ? IOMMU_FAULT_WRITE : IOMMU_FAULT_READ)) {</span>
<span class="p_add">+		dev_err_ratelimited(</span>
<span class="p_add">+			data-&gt;dev,</span>
<span class="p_add">+			&quot;fault type=0x%x iova=0x%x pa=0x%x larb=%d port=%d layer=%d %s\n&quot;,</span>
<span class="p_add">+			int_state, fault_iova, fault_pa, fault_larb, fault_port,</span>
<span class="p_add">+			layer, write ? &quot;write&quot; : &quot;read&quot;);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	mtk_iommu_clear_intr(data);</span>
<span class="p_add">+	mtk_iommu_tlb_flush_all(mtkdom);</span>
<span class="p_add">+</span>
<span class="p_add">+	return IRQ_HANDLED;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_parse_dt(struct platform_device *pdev,</span>
<span class="p_add">+			      struct mtk_iommu_data *data)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct device *dev = &amp;pdev-&gt;dev;</span>
<span class="p_add">+	struct device_node *ofnode;</span>
<span class="p_add">+	struct resource *res;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	ofnode = dev-&gt;of_node;</span>
<span class="p_add">+</span>
<span class="p_add">+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);</span>
<span class="p_add">+	data-&gt;base = devm_ioremap_resource(&amp;pdev-&gt;dev, res);</span>
<span class="p_add">+	if (IS_ERR(data-&gt;base))</span>
<span class="p_add">+		return PTR_ERR(data-&gt;base);</span>
<span class="p_add">+</span>
<span class="p_add">+	data-&gt;irq = platform_get_irq(pdev, 0);</span>
<span class="p_add">+	if (data-&gt;irq &lt; 0)</span>
<span class="p_add">+		return data-&gt;irq;</span>
<span class="p_add">+</span>
<span class="p_add">+	data-&gt;bclk = devm_clk_get(dev, &quot;bclk&quot;);</span>
<span class="p_add">+	if (IS_ERR(data-&gt;bclk))</span>
<span class="p_add">+		return PTR_ERR(data-&gt;bclk);</span>
<span class="p_add">+</span>
<span class="p_add">+	data-&gt;larb_nr = of_count_phandle_with_args(</span>
<span class="p_add">+					ofnode, &quot;mediatek,larb&quot;, NULL);</span>
<span class="p_add">+	if (data-&gt;larb_nr &lt; 0)</span>
<span class="p_add">+		return data-&gt;larb_nr;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; data-&gt;larb_nr; i++) {</span>
<span class="p_add">+		struct device_node *larbnode;</span>
<span class="p_add">+		struct platform_device *plarbdev;</span>
<span class="p_add">+</span>
<span class="p_add">+		larbnode = of_parse_phandle(ofnode, &quot;mediatek,larb&quot;, i);</span>
<span class="p_add">+		if (!larbnode)</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+		plarbdev = of_find_device_by_node(larbnode);</span>
<span class="p_add">+		of_node_put(larbnode);</span>
<span class="p_add">+		if (!plarbdev)</span>
<span class="p_add">+			return -EPROBE_DEFER;</span>
<span class="p_add">+		data-&gt;larbdev[i] = &amp;plarbdev-&gt;dev;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_hw_init(const struct mtk_iommu_domain *mtkdom)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_data *data = mtkdom-&gt;data;</span>
<span class="p_add">+	void __iomem *base = data-&gt;base;</span>
<span class="p_add">+	u32 regval;</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = clk_prepare_enable(data-&gt;bclk);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		dev_err(data-&gt;dev, &quot;Failed to enable iommu clk(%d)\n&quot;, ret);</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	writel_relaxed(mtkdom-&gt;cfg.arm_short_cfg.ttbr[0],</span>
<span class="p_add">+		       base + REG_MMU_PT_BASE_ADDR);</span>
<span class="p_add">+</span>
<span class="p_add">+	regval = F_MMU_PREFETCH_RT_REPLACE_MOD |</span>
<span class="p_add">+		F_MMU_TF_PROTECT_SEL(2) |</span>
<span class="p_add">+		F_COHERENCE_EN;</span>
<span class="p_add">+	writel_relaxed(regval, base + REG_MMU_CTRL_REG);</span>
<span class="p_add">+</span>
<span class="p_add">+	regval = F_L2_MULIT_HIT_EN |</span>
<span class="p_add">+		F_TABLE_WALK_FAULT_INT_EN |</span>
<span class="p_add">+		F_PREETCH_FIFO_OVERFLOW_INT_EN |</span>
<span class="p_add">+		F_MISS_FIFO_OVERFLOW_INT_EN |</span>
<span class="p_add">+		F_PREFETCH_FIFO_ERR_INT_EN |</span>
<span class="p_add">+		F_MISS_FIFO_ERR_INT_EN;</span>
<span class="p_add">+	writel_relaxed(regval, base + REG_MMU_INT_CONTROL0);</span>
<span class="p_add">+</span>
<span class="p_add">+	regval = F_INT_TRANSLATION_FAULT |</span>
<span class="p_add">+		F_INT_MAIN_MULTI_HIT_FAULT |</span>
<span class="p_add">+		F_INT_INVALID_PA_FAULT |</span>
<span class="p_add">+		F_INT_ENTRY_REPLACEMENT_FAULT |</span>
<span class="p_add">+		F_INT_TLB_MISS_FAULT |</span>
<span class="p_add">+		F_INT_MISS_TRANSATION_FIFO_FAULT |</span>
<span class="p_add">+		F_INT_PRETETCH_TRANSATION_FIFO_FAULT;</span>
<span class="p_add">+	writel_relaxed(regval, base + REG_MMU_INT_MAIN_CONTROL);</span>
<span class="p_add">+</span>
<span class="p_add">+	regval = ALIGN(data-&gt;protect_base, MTK_PROTECT_PA_ALIGN);</span>
<span class="p_add">+	regval = F_MMU_IVRP_PA_SET(regval);</span>
<span class="p_add">+	writel_relaxed(regval, base + REG_MMU_IVRP_PADDR);</span>
<span class="p_add">+</span>
<span class="p_add">+	writel_relaxed(0, base + REG_MMU_DCM_DIS);</span>
<span class="p_add">+	writel_relaxed(0, base + REG_MMU_STANDARD_AXI_MODE);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (devm_request_irq(data-&gt;dev, data-&gt;irq, mtk_iommu_isr, 0,</span>
<span class="p_add">+			     dev_name(data-&gt;dev), (void *)mtkdom)) {</span>
<span class="p_add">+		writel_relaxed(0, base + REG_MMU_PT_BASE_ADDR);</span>
<span class="p_add">+		clk_disable_unprepare(data-&gt;bclk);</span>
<span class="p_add">+		dev_err(data-&gt;dev, &quot;Failed @ IRQ-%d Request\n&quot;, data-&gt;irq);</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_config(struct mtk_iommu_domain *mtkdom,</span>
<span class="p_add">+			    struct device *dev, bool enable)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_data *data = mtkdom-&gt;data;</span>
<span class="p_add">+	struct mtk_iommu_client_priv *head, *cur, *next;</span>
<span class="p_add">+</span>
<span class="p_add">+	head = dev-&gt;archdata.iommu;</span>
<span class="p_add">+	list_for_each_entry_safe(cur, next, &amp;head-&gt;client, client) {</span>
<span class="p_add">+		if (cur-&gt;larbid &gt;= data-&gt;larb_nr) {</span>
<span class="p_add">+			dev_err(data-&gt;dev, &quot;Invalid larb:%d\n&quot;, cur-&gt;larbid);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		mtk_smi_config_port(data-&gt;larbdev[cur-&gt;larbid],</span>
<span class="p_add">+				    cur-&gt;portid, enable);</span>
<span class="p_add">+		if (!enable) {</span>
<span class="p_add">+			list_del(&amp;cur-&gt;client);</span>
<span class="p_add">+			kfree(cur);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!enable) {</span>
<span class="p_add">+		kfree(head);</span>
<span class="p_add">+		dev-&gt;archdata.iommu = NULL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_init_domain_context(struct mtk_iommu_domain *dom)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (dom-&gt;iop)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_init(&amp;dom-&gt;pgtlock);</span>
<span class="p_add">+	dom-&gt;cfg.quirks = IO_PGTABLE_QUIRK_ARM_NS |</span>
<span class="p_add">+			IO_PGTABLE_QUIRK_SHORT_SUPERSECTION |</span>
<span class="p_add">+			IO_PGTABLE_QUIRK_SHORT_NO_XN |</span>
<span class="p_add">+			IO_PGTABLE_QUIRK_SHORT_NO_PERMS;</span>
<span class="p_add">+	dom-&gt;cfg.pgsize_bitmap = mtk_iommu_ops.pgsize_bitmap,</span>
<span class="p_add">+	dom-&gt;cfg.ias = 32;</span>
<span class="p_add">+	dom-&gt;cfg.oas = 32;</span>
<span class="p_add">+	dom-&gt;cfg.tlb = &amp;mtk_iommu_gather_ops;</span>
<span class="p_add">+	dom-&gt;cfg.iommu_dev = dom-&gt;data-&gt;dev;</span>
<span class="p_add">+</span>
<span class="p_add">+	dom-&gt;iop = alloc_io_pgtable_ops(ARM_SHORT_DESC, &amp;dom-&gt;cfg, dom);</span>
<span class="p_add">+	if (!dom-&gt;iop) {</span>
<span class="p_add">+		dev_err(dom-&gt;data-&gt;dev, &quot;Failed to alloc io pgtable\n&quot;);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Update our support page sizes bitmap */</span>
<span class="p_add">+	mtk_iommu_ops.pgsize_bitmap = dom-&gt;cfg.pgsize_bitmap;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = mtk_iommu_hw_init(dom);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		free_io_pgtable_ops(dom-&gt;iop);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct iommu_domain *mtk_iommu_domain_alloc(unsigned type)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *priv;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (type != IOMMU_DOMAIN_UNMANAGED &amp;&amp; type != IOMMU_DOMAIN_DMA)</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (m4udom)/* The m4u domain exist. */</span>
<span class="p_add">+		return &amp;m4udom-&gt;domain;</span>
<span class="p_add">+</span>
<span class="p_add">+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);</span>
<span class="p_add">+	if (!priv)</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	priv-&gt;domain.geometry.aperture_start = 0;</span>
<span class="p_add">+	priv-&gt;domain.geometry.aperture_end = DMA_BIT_MASK(32);</span>
<span class="p_add">+	priv-&gt;domain.geometry.force_aperture = true;</span>
<span class="p_add">+</span>
<span class="p_add">+	m4udom = priv;</span>
<span class="p_add">+</span>
<span class="p_add">+	return &amp;priv-&gt;domain;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mtk_iommu_domain_free(struct iommu_domain *domain)</span>
<span class="p_add">+{</span>
<span class="p_add">+	kfree(to_mtk_domain(domain));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_attach_device(struct iommu_domain *domain,</span>
<span class="p_add">+				   struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *priv = to_mtk_domain(domain);</span>
<span class="p_add">+	struct iommu_group *group;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	group = iommu_group_get(dev);</span>
<span class="p_add">+	if (!group)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	iommu_group_put(group);</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = mtk_iommu_init_domain_context(priv);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	return mtk_iommu_config(priv, dev, true);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mtk_iommu_detach_device(struct iommu_domain *domain,</span>
<span class="p_add">+				    struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	mtk_iommu_config(to_mtk_domain(domain), dev, false);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_map(struct iommu_domain *domain, unsigned long iova,</span>
<span class="p_add">+			 phys_addr_t paddr, size_t size, int prot)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *priv = to_mtk_domain(domain);</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;priv-&gt;pgtlock, flags);</span>
<span class="p_add">+	ret = priv-&gt;iop-&gt;map(priv-&gt;iop, iova, paddr, size, prot);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;priv-&gt;pgtlock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static size_t mtk_iommu_unmap(struct iommu_domain *domain,</span>
<span class="p_add">+			      unsigned long iova, size_t size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *priv = to_mtk_domain(domain);</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+	size_t unmapsize;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;priv-&gt;pgtlock, flags);</span>
<span class="p_add">+	unmapsize = priv-&gt;iop-&gt;unmap(priv-&gt;iop, iova, size);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;priv-&gt;pgtlock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	return unmapsize;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static phys_addr_t mtk_iommu_iova_to_phys(struct iommu_domain *domain,</span>
<span class="p_add">+					  dma_addr_t iova)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *priv = to_mtk_domain(domain);</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+	phys_addr_t pa;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;priv-&gt;pgtlock, flags);</span>
<span class="p_add">+	pa = priv-&gt;iop-&gt;iova_to_phys(priv-&gt;iop, iova);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;priv-&gt;pgtlock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	return pa;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_add_device(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct iommu_group *group;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!dev-&gt;archdata.iommu) /* Not a iommu client device */</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
<span class="p_add">+	group = iommu_group_get(dev);</span>
<span class="p_add">+	if (!group) {</span>
<span class="p_add">+		group = iommu_group_alloc();</span>
<span class="p_add">+		if (IS_ERR(group)) {</span>
<span class="p_add">+			dev_err(dev, &quot;Failed to allocate IOMMU group\n&quot;);</span>
<span class="p_add">+			return PTR_ERR(group);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = iommu_group_add_device(group, dev);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		dev_err(dev, &quot;Failed to add IOMMU group\n&quot;);</span>
<span class="p_add">+		goto err_group_put;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = iommu_attach_group(&amp;m4udom-&gt;domain, group);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		dev_err(dev, &quot;Failed to attach IOMMU group\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+err_group_put:</span>
<span class="p_add">+	iommu_group_put(group);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mtk_iommu_remove_device(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!dev-&gt;archdata.iommu)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	iommu_group_remove_device(dev);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_of_xlate(struct device *dev, struct of_phandle_args *args)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_client_priv *head, *priv, *next;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (args-&gt;args_count != 2) {</span>
<span class="p_add">+		dev_err(dev, &quot;invalid #iommu-cells(%d) property for IOMMU\n&quot;,</span>
<span class="p_add">+			args-&gt;args_count);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!dev-&gt;archdata.iommu) {</span>
<span class="p_add">+		head = kzalloc(sizeof(*head), GFP_KERNEL);</span>
<span class="p_add">+		if (!head)</span>
<span class="p_add">+			return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+		dev-&gt;archdata.iommu = head;</span>
<span class="p_add">+		INIT_LIST_HEAD(&amp;head-&gt;client);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		head = dev-&gt;archdata.iommu;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);</span>
<span class="p_add">+	if (!priv)</span>
<span class="p_add">+		goto err_free_mem;</span>
<span class="p_add">+</span>
<span class="p_add">+	priv-&gt;larbid = args-&gt;args[0];</span>
<span class="p_add">+	priv-&gt;portid = args-&gt;args[1];</span>
<span class="p_add">+	list_add_tail(&amp;priv-&gt;client, &amp;head-&gt;client);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+err_free_mem:</span>
<span class="p_add">+	list_for_each_entry_safe(priv, next, &amp;head-&gt;client, client)</span>
<span class="p_add">+		kfree(priv);</span>
<span class="p_add">+	kfree(head);</span>
<span class="p_add">+	dev-&gt;archdata.iommu = NULL;</span>
<span class="p_add">+	return -ENOMEM;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct iommu_ops mtk_iommu_ops = {</span>
<span class="p_add">+	.domain_alloc	= mtk_iommu_domain_alloc,</span>
<span class="p_add">+	.domain_free	= mtk_iommu_domain_free,</span>
<span class="p_add">+	.attach_dev	= mtk_iommu_attach_device,</span>
<span class="p_add">+	.detach_dev	= mtk_iommu_detach_device,</span>
<span class="p_add">+	.map		= mtk_iommu_map,</span>
<span class="p_add">+	.unmap		= mtk_iommu_unmap,</span>
<span class="p_add">+	.map_sg		= default_iommu_map_sg,</span>
<span class="p_add">+	.iova_to_phys	= mtk_iommu_iova_to_phys,</span>
<span class="p_add">+	.add_device	= mtk_iommu_add_device,</span>
<span class="p_add">+	.remove_device	= mtk_iommu_remove_device,</span>
<span class="p_add">+	.of_xlate	= mtk_iommu_of_xlate,</span>
<span class="p_add">+	.pgsize_bitmap	= SZ_4K | SZ_64K | SZ_1M | SZ_16M,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct of_device_id mtk_iommu_of_ids[] = {</span>
<span class="p_add">+	{ .compatible = &quot;mediatek,mt8173-m4u&quot;, },</span>
<span class="p_add">+	{}</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_init_fn(struct device_node *np)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct platform_device *pdev;</span>
<span class="p_add">+</span>
<span class="p_add">+	pdev = of_platform_device_create(np, NULL, platform_bus_type.dev_root);</span>
<span class="p_add">+	if (IS_ERR(pdev))</span>
<span class="p_add">+		return PTR_ERR(pdev);</span>
<span class="p_add">+</span>
<span class="p_add">+	of_iommu_set_ops(np, &amp;mtk_iommu_ops);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+IOMMU_OF_DECLARE(mtkm4u, &quot;mediatek,mt8173-m4u&quot;, mtk_iommu_init_fn);</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_probe(struct platform_device *pdev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_data   *data;</span>
<span class="p_add">+	struct device           *dev = &amp;pdev-&gt;dev;</span>
<span class="p_add">+	void __iomem	        *protect;</span>
<span class="p_add">+	int                     ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	data = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);</span>
<span class="p_add">+	if (!data)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Protect memory. HW will access here while translation fault.*/</span>
<span class="p_add">+	protect = devm_kzalloc(dev, MTK_PROTECT_PA_ALIGN * 2, GFP_KERNEL);</span>
<span class="p_add">+	if (!protect)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	data-&gt;protect_base = virt_to_phys(protect);</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = mtk_iommu_parse_dt(pdev, data);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!m4udom)/* There is no iommu client */</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	data-&gt;dev = dev;</span>
<span class="p_add">+	m4udom-&gt;data = data;</span>
<span class="p_add">+	dev_set_drvdata(dev, m4udom);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_remove(struct platform_device *pdev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *mtkdom = dev_get_drvdata(&amp;pdev-&gt;dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!mtkdom)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	free_io_pgtable_ops(mtkdom-&gt;iop); /* Destroy domain context */</span>
<span class="p_add">+	clk_disable_unprepare(mtkdom-&gt;data-&gt;bclk);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_suspend(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *mtkdom = dev_get_drvdata(dev);</span>
<span class="p_add">+	struct mtk_iommu_suspend_reg *reg = &amp;mtkdom-&gt;data-&gt;reg;</span>
<span class="p_add">+	void __iomem *base = mtkdom-&gt;data-&gt;base;</span>
<span class="p_add">+</span>
<span class="p_add">+	reg-&gt;standard_axi_mode = readl_relaxed(base +</span>
<span class="p_add">+					       REG_MMU_STANDARD_AXI_MODE);</span>
<span class="p_add">+	reg-&gt;dcm_dis = readl_relaxed(base + REG_MMU_DCM_DIS);</span>
<span class="p_add">+	reg-&gt;ctrl_reg = readl_relaxed(base + REG_MMU_CTRL_REG);</span>
<span class="p_add">+	reg-&gt;ivrp_paddr = readl_relaxed(base + REG_MMU_IVRP_PADDR);</span>
<span class="p_add">+	reg-&gt;int_control0 = readl_relaxed(base + REG_MMU_INT_CONTROL0);</span>
<span class="p_add">+	reg-&gt;int_main_control = readl_relaxed(base + REG_MMU_INT_MAIN_CONTROL);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_resume(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *mtkdom = dev_get_drvdata(dev);</span>
<span class="p_add">+	struct mtk_iommu_suspend_reg *reg = &amp;mtkdom-&gt;data-&gt;reg;</span>
<span class="p_add">+	void __iomem *base = mtkdom-&gt;data-&gt;base;</span>
<span class="p_add">+</span>
<span class="p_add">+	writel_relaxed(mtkdom-&gt;cfg.arm_short_cfg.ttbr[0],</span>
<span class="p_add">+		       base + REG_MMU_PT_BASE_ADDR);</span>
<span class="p_add">+	writel_relaxed(reg-&gt;standard_axi_mode,</span>
<span class="p_add">+		       base + REG_MMU_STANDARD_AXI_MODE);</span>
<span class="p_add">+	writel_relaxed(reg-&gt;dcm_dis, base + REG_MMU_DCM_DIS);</span>
<span class="p_add">+	writel_relaxed(reg-&gt;ctrl_reg, base + REG_MMU_CTRL_REG);</span>
<span class="p_add">+	writel_relaxed(reg-&gt;ivrp_paddr, base + REG_MMU_IVRP_PADDR);</span>
<span class="p_add">+	writel_relaxed(reg-&gt;int_control0, base + REG_MMU_INT_CONTROL0);</span>
<span class="p_add">+	writel_relaxed(reg-&gt;int_main_control, base + REG_MMU_INT_MAIN_CONTROL);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+const struct dev_pm_ops mtk_iommu_pm_ops = {</span>
<span class="p_add">+	SET_SYSTEM_SLEEP_PM_OPS(mtk_iommu_suspend, mtk_iommu_resume)</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static struct platform_driver mtk_iommu_driver = {</span>
<span class="p_add">+	.probe	= mtk_iommu_probe,</span>
<span class="p_add">+	.remove	= mtk_iommu_remove,</span>
<span class="p_add">+	.driver	= {</span>
<span class="p_add">+		.name = &quot;mtk-iommu&quot;,</span>
<span class="p_add">+		.of_match_table = mtk_iommu_of_ids,</span>
<span class="p_add">+		.pm = &amp;mtk_iommu_pm_ops,</span>
<span class="p_add">+	}</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init mtk_iommu_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = platform_driver_register(&amp;mtk_iommu_driver);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pr_err(&quot;%s: Failed to register driver\n&quot;, __func__);</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!iommu_present(&amp;platform_bus_type))</span>
<span class="p_add">+		bus_set_iommu(&amp;platform_bus_type, &amp;mtk_iommu_ops);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+subsys_initcall(mtk_iommu_init);</span>

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



