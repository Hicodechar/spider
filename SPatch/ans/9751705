
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[v6,6/6] drm/i915/gvt: Adding interface so user space can get the dma-buf - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [v6,6/6] drm/i915/gvt: Adding interface so user space can get the dma-buf</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=170581">Xiaoguang Chen</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>May 27, 2017, 8:38 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1495874332-2851-7-git-send-email-xiaoguang.chen@intel.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9751705/mbox/"
   >mbox</a>
|
   <a href="/patch/9751705/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9751705/">/patch/9751705/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	3904C60249 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sat, 27 May 2017 08:40:36 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 27D45284E4
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sat, 27 May 2017 08:40:36 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 24A2128554; Sat, 27 May 2017 08:40:36 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 2FA5928541
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sat, 27 May 2017 08:40:26 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1754775AbdE0IkT (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Sat, 27 May 2017 04:40:19 -0400
Received: from mga05.intel.com ([192.55.52.43]:20771 &quot;EHLO mga05.intel.com&quot;
	rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
	id S1754713AbdE0IkQ (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Sat, 27 May 2017 04:40:16 -0400
Received: from orsmga004.jf.intel.com ([10.7.209.38])
	by fmsmga105.fm.intel.com with ESMTP; 27 May 2017 01:40:15 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=Sophos;i=&quot;5.38,400,1491289200&quot;; d=&quot;scan&#39;208&quot;;a=&quot;92021793&quot;
Received: from chenxg-desktop.bj.intel.com ([10.238.135.170])
	by orsmga004.jf.intel.com with ESMTP; 27 May 2017 01:40:13 -0700
From: Xiaoguang Chen &lt;xiaoguang.chen@intel.com&gt;
To: alex.williamson@redhat.com, kraxel@redhat.com,
	chris@chris-wilson.co.uk, intel-gfx@lists.freedesktop.org,
	linux-kernel@vger.kernel.org, zhenyuw@linux.intel.com,
	zhiyuan.lv@intel.com, intel-gvt-dev@lists.freedesktop.org,
	zhi.a.wang@intel.com, kevin.tian@intel.com
Cc: Xiaoguang Chen &lt;xiaoguang.chen@intel.com&gt;
Subject: [PATCH v6 6/6] drm/i915/gvt: Adding interface so user space can get
	the dma-buf
Date: Sat, 27 May 2017 16:38:52 +0800
Message-Id: &lt;1495874332-2851-7-git-send-email-xiaoguang.chen@intel.com&gt;
X-Mailer: git-send-email 2.7.4
In-Reply-To: &lt;1495874332-2851-1-git-send-email-xiaoguang.chen@intel.com&gt;
References: &lt;1495874332-2851-1-git-send-email-xiaoguang.chen@intel.com&gt;
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=170581">Xiaoguang Chen</a> - May 27, 2017, 8:38 a.m.</div>
<pre class="content">
User space should create the management fd for the dma-buf operation first.
Then user can query the plane information and create dma-buf if necessary
using the management fd.
<span class="signed-off-by">
Signed-off-by: Xiaoguang Chen &lt;xiaoguang.chen@intel.com&gt;</span>
---
 drivers/gpu/drm/i915/gvt/dmabuf.c |  12 ++++
 drivers/gpu/drm/i915/gvt/dmabuf.h |   5 ++
 drivers/gpu/drm/i915/gvt/gvt.c    |   2 +
 drivers/gpu/drm/i915/gvt/gvt.h    |   5 ++
 drivers/gpu/drm/i915/gvt/kvmgt.c  | 144 ++++++++++++++++++++++++++++++++++++++
 drivers/gpu/drm/i915/gvt/vgpu.c   |   1 +
 6 files changed, 169 insertions(+)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7781">Alex Williamson</a> - June 1, 2017, 6:08 p.m.</div>
<pre class="content">
On Sat, 27 May 2017 16:38:52 +0800
Xiaoguang Chen &lt;xiaoguang.chen@intel.com&gt; wrote:
<span class="quote">
&gt; User space should create the management fd for the dma-buf operation first.</span>
<span class="quote">&gt; Then user can query the plane information and create dma-buf if necessary</span>
<span class="quote">&gt; using the management fd.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Signed-off-by: Xiaoguang Chen &lt;xiaoguang.chen@intel.com&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt;  drivers/gpu/drm/i915/gvt/dmabuf.c |  12 ++++</span>
<span class="quote">&gt;  drivers/gpu/drm/i915/gvt/dmabuf.h |   5 ++</span>
<span class="quote">&gt;  drivers/gpu/drm/i915/gvt/gvt.c    |   2 +</span>
<span class="quote">&gt;  drivers/gpu/drm/i915/gvt/gvt.h    |   5 ++</span>
<span class="quote">&gt;  drivers/gpu/drm/i915/gvt/kvmgt.c  | 144 ++++++++++++++++++++++++++++++++++++++</span>
<span class="quote">&gt;  drivers/gpu/drm/i915/gvt/vgpu.c   |   1 +</span>
<span class="quote">&gt;  6 files changed, 169 insertions(+)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; diff --git a/drivers/gpu/drm/i915/gvt/dmabuf.c b/drivers/gpu/drm/i915/gvt/dmabuf.c</span>
<span class="quote">&gt; index c831e91..9759e9a 100644</span>
<span class="quote">&gt; --- a/drivers/gpu/drm/i915/gvt/dmabuf.c</span>
<span class="quote">&gt; +++ b/drivers/gpu/drm/i915/gvt/dmabuf.c</span>
<span class="quote">&gt; @@ -226,6 +226,7 @@ int intel_vgpu_create_dmabuf(struct intel_vgpu *vgpu, void *args)</span>
<span class="quote">&gt;  	struct vfio_vgpu_dmabuf_info *gvt_dmabuf = args;</span>
<span class="quote">&gt;  	struct intel_vgpu_fb_info *fb_info;</span>
<span class="quote">&gt;  	int ret;</span>
<span class="quote">&gt; +	struct intel_vgpu_dmabuf_obj *dmabuf_obj;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	ret = intel_vgpu_get_plane_info(dev, vgpu, &amp;gvt_dmabuf-&gt;plane_info);</span>
<span class="quote">&gt;  	if (ret != 0)</span>
<span class="quote">&gt; @@ -263,6 +264,17 @@ int intel_vgpu_create_dmabuf(struct intel_vgpu *vgpu, void *args)</span>
<span class="quote">&gt;  		gvt_vgpu_err(&quot;create dma-buf fd failed ret:%d\n&quot;, ret);</span>
<span class="quote">&gt;  		return ret;</span>
<span class="quote">&gt;  	}</span>
<span class="quote">&gt; +	dmabuf_obj = kmalloc(sizeof(*dmabuf_obj), GFP_KERNEL);</span>
<span class="quote">&gt; +	if (dmabuf_obj == NULL) {</span>
<span class="quote">&gt; +		kfree(fb_info);</span>
<span class="quote">&gt; +		i915_gem_object_put(obj);</span>
<span class="quote">&gt; +		gvt_vgpu_err(&quot;alloc dmabuf_obj failed\n&quot;);</span>
<span class="quote">&gt; +		return -ENOMEM;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +	dmabuf_obj-&gt;obj = obj;</span>
<span class="quote">&gt; +	INIT_LIST_HEAD(&amp;dmabuf_obj-&gt;list);</span>
<span class="quote">&gt; +	list_add_tail(&amp;dmabuf_obj-&gt;list, &amp;vgpu-&gt;dmabuf_obj_list_head);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  	gvt_dmabuf-&gt;fd = ret;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	return 0;</span>
<span class="quote">&gt; diff --git a/drivers/gpu/drm/i915/gvt/dmabuf.h b/drivers/gpu/drm/i915/gvt/dmabuf.h</span>
<span class="quote">&gt; index 8be9979..cafa781 100644</span>
<span class="quote">&gt; --- a/drivers/gpu/drm/i915/gvt/dmabuf.h</span>
<span class="quote">&gt; +++ b/drivers/gpu/drm/i915/gvt/dmabuf.h</span>
<span class="quote">&gt; @@ -31,6 +31,11 @@ struct intel_vgpu_fb_info {</span>
<span class="quote">&gt;  	uint32_t fb_size;</span>
<span class="quote">&gt;  };</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +struct intel_vgpu_dmabuf_obj {</span>
<span class="quote">&gt; +	struct drm_i915_gem_object *obj;</span>
<span class="quote">&gt; +	struct list_head list;</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  int intel_vgpu_query_plane(struct intel_vgpu *vgpu, void *args);</span>
<span class="quote">&gt;  int intel_vgpu_create_dmabuf(struct intel_vgpu *vgpu, void *args);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c</span>
<span class="quote">&gt; index 2032917..dbc3f86 100644</span>
<span class="quote">&gt; --- a/drivers/gpu/drm/i915/gvt/gvt.c</span>
<span class="quote">&gt; +++ b/drivers/gpu/drm/i915/gvt/gvt.c</span>
<span class="quote">&gt; @@ -54,6 +54,8 @@ static const struct intel_gvt_ops intel_gvt_ops = {</span>
<span class="quote">&gt;  	.vgpu_reset = intel_gvt_reset_vgpu,</span>
<span class="quote">&gt;  	.vgpu_activate = intel_gvt_activate_vgpu,</span>
<span class="quote">&gt;  	.vgpu_deactivate = intel_gvt_deactivate_vgpu,</span>
<span class="quote">&gt; +	.vgpu_query_plane = intel_vgpu_query_plane,</span>
<span class="quote">&gt; +	.vgpu_create_dmabuf = intel_vgpu_create_dmabuf,</span>
<span class="quote">&gt;  };</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  /**</span>
<span class="quote">&gt; diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h</span>
<span class="quote">&gt; index 763a8c5..a855797 100644</span>
<span class="quote">&gt; --- a/drivers/gpu/drm/i915/gvt/gvt.h</span>
<span class="quote">&gt; +++ b/drivers/gpu/drm/i915/gvt/gvt.h</span>
<span class="quote">&gt; @@ -185,8 +185,11 @@ struct intel_vgpu {</span>
<span class="quote">&gt;  		struct kvm *kvm;</span>
<span class="quote">&gt;  		struct work_struct release_work;</span>
<span class="quote">&gt;  		atomic_t released;</span>
<span class="quote">&gt; +		struct vfio_device *vfio_device;</span>
<span class="quote">&gt;  	} vdev;</span>
<span class="quote">&gt;  #endif</span>
<span class="quote">&gt; +	int dmabuf_mgr_fd;</span>
<span class="quote">&gt; +	struct list_head dmabuf_obj_list_head;</span>
<span class="quote">&gt;  };</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  struct intel_gvt_gm {</span>
<span class="quote">&gt; @@ -467,6 +470,8 @@ struct intel_gvt_ops {</span>
<span class="quote">&gt;  	void (*vgpu_reset)(struct intel_vgpu *);</span>
<span class="quote">&gt;  	void (*vgpu_activate)(struct intel_vgpu *);</span>
<span class="quote">&gt;  	void (*vgpu_deactivate)(struct intel_vgpu *);</span>
<span class="quote">&gt; +	int (*vgpu_query_plane)(struct intel_vgpu *vgpu, void *);</span>
<span class="quote">&gt; +	int (*vgpu_create_dmabuf)(struct intel_vgpu *vgpu, void *);</span>
<span class="quote">&gt;  };</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; diff --git a/drivers/gpu/drm/i915/gvt/kvmgt.c b/drivers/gpu/drm/i915/gvt/kvmgt.c</span>
<span class="quote">&gt; index 389f072..a079080 100644</span>
<span class="quote">&gt; --- a/drivers/gpu/drm/i915/gvt/kvmgt.c</span>
<span class="quote">&gt; +++ b/drivers/gpu/drm/i915/gvt/kvmgt.c</span>
<span class="quote">&gt; @@ -41,6 +41,7 @@</span>
<span class="quote">&gt;  #include &lt;linux/kvm_host.h&gt;</span>
<span class="quote">&gt;  #include &lt;linux/vfio.h&gt;</span>
<span class="quote">&gt;  #include &lt;linux/mdev.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/anon_inodes.h&gt;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  #include &quot;i915_drv.h&quot;</span>
<span class="quote">&gt;  #include &quot;gvt.h&quot;</span>
<span class="quote">&gt; @@ -524,6 +525,125 @@ static int intel_vgpu_reg_init_opregion(struct intel_vgpu *vgpu)</span>
<span class="quote">&gt;  	return ret;</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +static int kvmgt_get_vfio_device(struct intel_vgpu *vgpu)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct vfio_device *device;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	device = vfio_device_get_from_dev(mdev_dev(vgpu-&gt;vdev.mdev));</span>
<span class="quote">&gt; +	if (device == NULL)</span>
<span class="quote">&gt; +		return -ENODEV;</span>
<span class="quote">&gt; +	vgpu-&gt;vdev.vfio_device = device;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void kvmgt_put_vfio_device(struct intel_vgpu *vgpu)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	vfio_device_put(vgpu-&gt;vdev.vfio_device);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int intel_vgpu_dmabuf_mgr_fd_mmap(struct file *file,</span>
<span class="quote">&gt; +		struct vm_area_struct *vma)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	return -EPERM;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int intel_vgpu_dmabuf_mgr_fd_release(struct inode *inode,</span>
<span class="quote">&gt; +		struct file *filp)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct intel_vgpu *vgpu = filp-&gt;private_data;</span>
<span class="quote">&gt; +	struct intel_vgpu_dmabuf_obj *obj;</span>
<span class="quote">&gt; +	struct list_head *pos;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (WARN_ON(!vgpu-&gt;vdev.vfio_device))</span>
<span class="quote">&gt; +		return -ENODEV;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	list_for_each(pos, &amp;vgpu-&gt;dmabuf_obj_list_head) {</span>
<span class="quote">&gt; +		obj = container_of(pos, struct intel_vgpu_dmabuf_obj, list);</span>
<span class="quote">&gt; +		if (WARN_ON(!obj))</span>
<span class="quote">&gt; +			return -ENODEV;</span>
<span class="quote">&gt; +		kfree(obj-&gt;obj-&gt;gvt_info);</span>
<span class="quote">&gt; +		i915_gem_object_put(obj-&gt;obj);</span>
<span class="quote">&gt; +		kfree(obj);</span>
<span class="quote">&gt; +		kvmgt_put_vfio_device(vgpu);</span>

Can we do this?  If I understand, we&#39;re releasing all the references
and allocations for the dmabuf fds on release of the manager fd.  What
happens if the user continues trying to access those dmabuf fds after
this?
<span class="quote">
&gt; +	}</span>
<span class="quote">&gt; +	kvmgt_put_vfio_device(vgpu);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static long intel_vgpu_dmabuf_mgr_fd_ioctl(struct file *filp,</span>
<span class="quote">&gt; +		unsigned int ioctl, unsigned long arg)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct intel_vgpu *vgpu = filp-&gt;private_data;</span>
<span class="quote">&gt; +	int minsz;</span>
<span class="quote">&gt; +	int ret;</span>
<span class="quote">&gt; +	struct fd f;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	f = fdget(vgpu-&gt;dmabuf_mgr_fd);</span>
<span class="quote">&gt; +	if (!f.file)</span>
<span class="quote">&gt; +		return -EBADF;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (ioctl == VFIO_DEVICE_QUERY_PLANE) {</span>
<span class="quote">&gt; +		struct vfio_vgpu_plane_info info;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		minsz = offsetofend(struct vfio_vgpu_plane_info, resv);</span>
<span class="quote">&gt; +		if (copy_from_user(&amp;info, (void __user *)arg, minsz)) {</span>
<span class="quote">&gt; +			fdput(f);</span>
<span class="quote">&gt; +			return -EFAULT;</span>
<span class="quote">&gt; +		}</span>
<span class="quote">&gt; +		if (info.argsz &lt; minsz) {</span>
<span class="quote">&gt; +			fdput(f);</span>
<span class="quote">&gt; +			return -EINVAL;</span>
<span class="quote">&gt; +		}</span>
<span class="quote">&gt; +		ret = intel_gvt_ops-&gt;vgpu_query_plane(vgpu, &amp;info);</span>
<span class="quote">&gt; +		if (ret != 0) {</span>
<span class="quote">&gt; +			fdput(f);</span>
<span class="quote">&gt; +			gvt_vgpu_err(&quot;query plane failed:%d\n&quot;, ret);</span>
<span class="quote">&gt; +			return -EINVAL;</span>
<span class="quote">&gt; +		}</span>
<span class="quote">&gt; +		fdput(f);</span>
<span class="quote">&gt; +		return copy_to_user((void __user *)arg, &amp;info, minsz) ?</span>
<span class="quote">&gt; +								-EFAULT : 0;</span>
<span class="quote">&gt; +	} else if (ioctl == VFIO_DEVICE_CREATE_DMABUF) {</span>
<span class="quote">&gt; +		struct vfio_vgpu_dmabuf_info dmabuf;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		minsz = offsetofend(struct vfio_vgpu_dmabuf_info, resv);</span>
<span class="quote">&gt; +		if (copy_from_user(&amp;dmabuf, (void __user *)arg, minsz)) {</span>
<span class="quote">&gt; +			fdput(f);</span>
<span class="quote">&gt; +			return -EFAULT;</span>
<span class="quote">&gt; +		}</span>
<span class="quote">&gt; +		if (dmabuf.argsz &lt; minsz) {</span>
<span class="quote">&gt; +			fdput(f);</span>
<span class="quote">&gt; +			return -EINVAL;</span>
<span class="quote">&gt; +		}</span>
<span class="quote">&gt; +		ret = kvmgt_get_vfio_device(vgpu);</span>
<span class="quote">&gt; +		if (ret != 0)</span>
<span class="quote">&gt; +			return ret;</span>

Missed an fdput, though I&#39;m not sure I understand the value of the
original fdget or the dmabuf_mgr_fd field at all.  dmabuf_mgr_fd is
only used here, presumably to add a reference to the fd while we&#39;re in
the ioctl, but we&#39;re in the ioctl function of that fd, so I think there
are already references elsewhere.
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +		ret = intel_gvt_ops-&gt;vgpu_create_dmabuf(vgpu, &amp;dmabuf);</span>
<span class="quote">&gt; +		if (ret != 0) {</span>
<span class="quote">&gt; +			kvmgt_put_vfio_device(vgpu);</span>
<span class="quote">&gt; +			fdput(f);</span>
<span class="quote">&gt; +			return -EINVAL;</span>

Why not return the errno that vgpu_create_dmabuf provided?
<span class="quote">
&gt; +		}</span>
<span class="quote">&gt; +		fdput(f);</span>
<span class="quote">&gt; +		return copy_to_user((void __user *)arg, &amp;dmabuf, minsz) ?</span>
<span class="quote">&gt; +								-EFAULT : 0;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	fdput(f);</span>
<span class="quote">&gt; +	gvt_vgpu_err(&quot;unsupported dmabuf operation\n&quot;);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return -EINVAL;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static const struct file_operations intel_vgpu_dmabuf_mgr_fd_ops = {</span>
<span class="quote">&gt; +	.release        = intel_vgpu_dmabuf_mgr_fd_release,</span>
<span class="quote">&gt; +	.unlocked_ioctl = intel_vgpu_dmabuf_mgr_fd_ioctl,</span>
<span class="quote">&gt; +	.mmap           = intel_vgpu_dmabuf_mgr_fd_mmap,</span>
<span class="quote">&gt; +	.llseek         = noop_llseek,</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt;  static int intel_vgpu_create(struct kobject *kobj, struct mdev_device *mdev)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt;  	struct intel_vgpu *vgpu = NULL;</span>
<span class="quote">&gt; @@ -1259,6 +1379,30 @@ static long intel_vgpu_ioctl(struct mdev_device *mdev, unsigned int cmd,</span>
<span class="quote">&gt;  	} else if (cmd == VFIO_DEVICE_RESET) {</span>
<span class="quote">&gt;  		intel_gvt_ops-&gt;vgpu_reset(vgpu);</span>
<span class="quote">&gt;  		return 0;</span>
<span class="quote">&gt; +	} else if (cmd == VFIO_DEVICE_GET_FD) {</span>
<span class="quote">&gt; +		int fd;</span>
<span class="quote">&gt; +		u32 type;</span>
<span class="quote">&gt; +		int ret;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		if (copy_from_user(&amp;type, (void __user *)arg, sizeof(type)))</span>
<span class="quote">&gt; +			return -EINVAL;</span>
<span class="quote">&gt; +		if (type != VFIO_DEVICE_DMABUF_MGR_FD)</span>
<span class="quote">&gt; +			return -EINVAL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		ret = kvmgt_get_vfio_device(vgpu);</span>
<span class="quote">&gt; +		if (ret != 0)</span>
<span class="quote">&gt; +			return ret;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		fd = anon_inode_getfd(&quot;intel-vgpu-dmabuf-mgr-fd&quot;,</span>
<span class="quote">&gt; +			&amp;intel_vgpu_dmabuf_mgr_fd_ops,</span>
<span class="quote">&gt; +			vgpu, O_RDWR | O_CLOEXEC);</span>
<span class="quote">&gt; +		if (fd &lt; 0) {</span>
<span class="quote">&gt; +			gvt_vgpu_err(&quot;create dmabuf mgr fd failed\n&quot;);</span>
<span class="quote">&gt; +			return -EINVAL;</span>

Error path leaks vfio_device reference.
<span class="quote">
&gt; +		}</span>
<span class="quote">&gt; +		vgpu-&gt;dmabuf_mgr_fd = fd;</span>

As above, unclear value of this field, additionally, what if the user
calls VFIO_DEVICE_GET_FD more than once?
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +		return fd;</span>
<span class="quote">&gt;  	}</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	return 0;</span>
<span class="quote">&gt; diff --git a/drivers/gpu/drm/i915/gvt/vgpu.c b/drivers/gpu/drm/i915/gvt/vgpu.c</span>
<span class="quote">&gt; index 6e3cbd8..af6fc74 100644</span>
<span class="quote">&gt; --- a/drivers/gpu/drm/i915/gvt/vgpu.c</span>
<span class="quote">&gt; +++ b/drivers/gpu/drm/i915/gvt/vgpu.c</span>
<span class="quote">&gt; @@ -346,6 +346,7 @@ static struct intel_vgpu *__intel_gvt_create_vgpu(struct intel_gvt *gvt,</span>
<span class="quote">&gt;  	vgpu-&gt;gvt = gvt;</span>
<span class="quote">&gt;  	vgpu-&gt;sched_ctl.weight = param-&gt;weight;</span>
<span class="quote">&gt;  	bitmap_zero(vgpu-&gt;tlb_handle_pending, I915_NUM_ENGINES);</span>
<span class="quote">&gt; +	INIT_LIST_HEAD(&amp;vgpu-&gt;dmabuf_obj_list_head);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	intel_vgpu_init_cfg_space(vgpu, param-&gt;primary);</span>
<span class="quote">&gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=170581">Xiaoguang Chen</a> - June 2, 2017, 3:24 a.m.</div>
<pre class="content">
Hi Alex,
<span class="quote">
&gt;-----Original Message-----</span>
<span class="quote">&gt;From: Alex Williamson [mailto:alex.williamson@redhat.com]</span>
<span class="quote">&gt;Sent: Friday, June 02, 2017 2:08 AM</span>
<span class="quote">&gt;To: Chen, Xiaoguang &lt;xiaoguang.chen@intel.com&gt;</span>
<span class="quote">&gt;Cc: kraxel@redhat.com; chris@chris-wilson.co.uk; intel-</span>
<span class="quote">&gt;gfx@lists.freedesktop.org; linux-kernel@vger.kernel.org;</span>
<span class="quote">&gt;zhenyuw@linux.intel.com; Lv, Zhiyuan &lt;zhiyuan.lv@intel.com&gt;; intel-gvt-</span>
<span class="quote">&gt;dev@lists.freedesktop.org; Wang, Zhi A &lt;zhi.a.wang@intel.com&gt;; Tian, Kevin</span>
<span class="quote">&gt;&lt;kevin.tian@intel.com&gt;</span>
<span class="quote">&gt;Subject: Re: [PATCH v6 6/6] drm/i915/gvt: Adding interface so user space can get</span>
<span class="quote">&gt;the dma-buf</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;On Sat, 27 May 2017 16:38:52 +0800</span>
<span class="quote">&gt;Xiaoguang Chen &lt;xiaoguang.chen@intel.com&gt; wrote:</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; User space should create the management fd for the dma-buf operation first.</span>
<span class="quote">&gt;&gt; Then user can query the plane information and create dma-buf if</span>
<span class="quote">&gt;&gt; necessary using the management fd.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Signed-off-by: Xiaoguang Chen &lt;xiaoguang.chen@intel.com&gt;</span>
<span class="quote">&gt;&gt; ---</span>
<span class="quote">&gt;&gt;  drivers/gpu/drm/i915/gvt/dmabuf.c |  12 ++++</span>
<span class="quote">&gt;&gt;  drivers/gpu/drm/i915/gvt/dmabuf.h |   5 ++</span>
<span class="quote">&gt;&gt;  drivers/gpu/drm/i915/gvt/gvt.c    |   2 +</span>
<span class="quote">&gt;&gt;  drivers/gpu/drm/i915/gvt/gvt.h    |   5 ++</span>
<span class="quote">&gt;&gt;  drivers/gpu/drm/i915/gvt/kvmgt.c  | 144</span>
<span class="quote">&gt;++++++++++++++++++++++++++++++++++++++</span>
<span class="quote">&gt;&gt;  drivers/gpu/drm/i915/gvt/vgpu.c   |   1 +</span>
<span class="quote">&gt;&gt;  6 files changed, 169 insertions(+)</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; diff --git a/drivers/gpu/drm/i915/gvt/dmabuf.c</span>
<span class="quote">&gt;&gt; b/drivers/gpu/drm/i915/gvt/dmabuf.c</span>
<span class="quote">&gt;&gt; index c831e91..9759e9a 100644</span>
<span class="quote">&gt;&gt; --- a/drivers/gpu/drm/i915/gvt/dmabuf.c</span>
<span class="quote">&gt;&gt; +++ b/drivers/gpu/drm/i915/gvt/dmabuf.c</span>
<span class="quote">&gt;&gt; @@ -226,6 +226,7 @@ int intel_vgpu_create_dmabuf(struct intel_vgpu *vgpu,</span>
<span class="quote">&gt;void *args)</span>
<span class="quote">&gt;&gt;  	struct vfio_vgpu_dmabuf_info *gvt_dmabuf = args;</span>
<span class="quote">&gt;&gt;  	struct intel_vgpu_fb_info *fb_info;</span>
<span class="quote">&gt;&gt;  	int ret;</span>
<span class="quote">&gt;&gt; +	struct intel_vgpu_dmabuf_obj *dmabuf_obj;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;  	ret = intel_vgpu_get_plane_info(dev, vgpu, &amp;gvt_dmabuf-&gt;plane_info);</span>
<span class="quote">&gt;&gt;  	if (ret != 0)</span>
<span class="quote">&gt;&gt; @@ -263,6 +264,17 @@ int intel_vgpu_create_dmabuf(struct intel_vgpu *vgpu,</span>
<span class="quote">&gt;void *args)</span>
<span class="quote">&gt;&gt;  		gvt_vgpu_err(&quot;create dma-buf fd failed ret:%d\n&quot;, ret);</span>
<span class="quote">&gt;&gt;  		return ret;</span>
<span class="quote">&gt;&gt;  	}</span>
<span class="quote">&gt;&gt; +	dmabuf_obj = kmalloc(sizeof(*dmabuf_obj), GFP_KERNEL);</span>
<span class="quote">&gt;&gt; +	if (dmabuf_obj == NULL) {</span>
<span class="quote">&gt;&gt; +		kfree(fb_info);</span>
<span class="quote">&gt;&gt; +		i915_gem_object_put(obj);</span>
<span class="quote">&gt;&gt; +		gvt_vgpu_err(&quot;alloc dmabuf_obj failed\n&quot;);</span>
<span class="quote">&gt;&gt; +		return -ENOMEM;</span>
<span class="quote">&gt;&gt; +	}</span>
<span class="quote">&gt;&gt; +	dmabuf_obj-&gt;obj = obj;</span>
<span class="quote">&gt;&gt; +	INIT_LIST_HEAD(&amp;dmabuf_obj-&gt;list);</span>
<span class="quote">&gt;&gt; +	list_add_tail(&amp;dmabuf_obj-&gt;list, &amp;vgpu-&gt;dmabuf_obj_list_head);</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt;  	gvt_dmabuf-&gt;fd = ret;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;  	return 0;</span>
<span class="quote">&gt;&gt; diff --git a/drivers/gpu/drm/i915/gvt/dmabuf.h</span>
<span class="quote">&gt;&gt; b/drivers/gpu/drm/i915/gvt/dmabuf.h</span>
<span class="quote">&gt;&gt; index 8be9979..cafa781 100644</span>
<span class="quote">&gt;&gt; --- a/drivers/gpu/drm/i915/gvt/dmabuf.h</span>
<span class="quote">&gt;&gt; +++ b/drivers/gpu/drm/i915/gvt/dmabuf.h</span>
<span class="quote">&gt;&gt; @@ -31,6 +31,11 @@ struct intel_vgpu_fb_info {</span>
<span class="quote">&gt;&gt;  	uint32_t fb_size;</span>
<span class="quote">&gt;&gt;  };</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; +struct intel_vgpu_dmabuf_obj {</span>
<span class="quote">&gt;&gt; +	struct drm_i915_gem_object *obj;</span>
<span class="quote">&gt;&gt; +	struct list_head list;</span>
<span class="quote">&gt;&gt; +};</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt;  int intel_vgpu_query_plane(struct intel_vgpu *vgpu, void *args);  int</span>
<span class="quote">&gt;&gt; intel_vgpu_create_dmabuf(struct intel_vgpu *vgpu, void *args);</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; diff --git a/drivers/gpu/drm/i915/gvt/gvt.c</span>
<span class="quote">&gt;&gt; b/drivers/gpu/drm/i915/gvt/gvt.c index 2032917..dbc3f86 100644</span>
<span class="quote">&gt;&gt; --- a/drivers/gpu/drm/i915/gvt/gvt.c</span>
<span class="quote">&gt;&gt; +++ b/drivers/gpu/drm/i915/gvt/gvt.c</span>
<span class="quote">&gt;&gt; @@ -54,6 +54,8 @@ static const struct intel_gvt_ops intel_gvt_ops = {</span>
<span class="quote">&gt;&gt;  	.vgpu_reset = intel_gvt_reset_vgpu,</span>
<span class="quote">&gt;&gt;  	.vgpu_activate = intel_gvt_activate_vgpu,</span>
<span class="quote">&gt;&gt;  	.vgpu_deactivate = intel_gvt_deactivate_vgpu,</span>
<span class="quote">&gt;&gt; +	.vgpu_query_plane = intel_vgpu_query_plane,</span>
<span class="quote">&gt;&gt; +	.vgpu_create_dmabuf = intel_vgpu_create_dmabuf,</span>
<span class="quote">&gt;&gt;  };</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;  /**</span>
<span class="quote">&gt;&gt; diff --git a/drivers/gpu/drm/i915/gvt/gvt.h</span>
<span class="quote">&gt;&gt; b/drivers/gpu/drm/i915/gvt/gvt.h index 763a8c5..a855797 100644</span>
<span class="quote">&gt;&gt; --- a/drivers/gpu/drm/i915/gvt/gvt.h</span>
<span class="quote">&gt;&gt; +++ b/drivers/gpu/drm/i915/gvt/gvt.h</span>
<span class="quote">&gt;&gt; @@ -185,8 +185,11 @@ struct intel_vgpu {</span>
<span class="quote">&gt;&gt;  		struct kvm *kvm;</span>
<span class="quote">&gt;&gt;  		struct work_struct release_work;</span>
<span class="quote">&gt;&gt;  		atomic_t released;</span>
<span class="quote">&gt;&gt; +		struct vfio_device *vfio_device;</span>
<span class="quote">&gt;&gt;  	} vdev;</span>
<span class="quote">&gt;&gt;  #endif</span>
<span class="quote">&gt;&gt; +	int dmabuf_mgr_fd;</span>
<span class="quote">&gt;&gt; +	struct list_head dmabuf_obj_list_head;</span>
<span class="quote">&gt;&gt;  };</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;  struct intel_gvt_gm {</span>
<span class="quote">&gt;&gt; @@ -467,6 +470,8 @@ struct intel_gvt_ops {</span>
<span class="quote">&gt;&gt;  	void (*vgpu_reset)(struct intel_vgpu *);</span>
<span class="quote">&gt;&gt;  	void (*vgpu_activate)(struct intel_vgpu *);</span>
<span class="quote">&gt;&gt;  	void (*vgpu_deactivate)(struct intel_vgpu *);</span>
<span class="quote">&gt;&gt; +	int (*vgpu_query_plane)(struct intel_vgpu *vgpu, void *);</span>
<span class="quote">&gt;&gt; +	int (*vgpu_create_dmabuf)(struct intel_vgpu *vgpu, void *);</span>
<span class="quote">&gt;&gt;  };</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; diff --git a/drivers/gpu/drm/i915/gvt/kvmgt.c</span>
<span class="quote">&gt;&gt; b/drivers/gpu/drm/i915/gvt/kvmgt.c</span>
<span class="quote">&gt;&gt; index 389f072..a079080 100644</span>
<span class="quote">&gt;&gt; --- a/drivers/gpu/drm/i915/gvt/kvmgt.c</span>
<span class="quote">&gt;&gt; +++ b/drivers/gpu/drm/i915/gvt/kvmgt.c</span>
<span class="quote">&gt;&gt; @@ -41,6 +41,7 @@</span>
<span class="quote">&gt;&gt;  #include &lt;linux/kvm_host.h&gt;</span>
<span class="quote">&gt;&gt;  #include &lt;linux/vfio.h&gt;</span>
<span class="quote">&gt;&gt;  #include &lt;linux/mdev.h&gt;</span>
<span class="quote">&gt;&gt; +#include &lt;linux/anon_inodes.h&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;  #include &quot;i915_drv.h&quot;</span>
<span class="quote">&gt;&gt;  #include &quot;gvt.h&quot;</span>
<span class="quote">&gt;&gt; @@ -524,6 +525,125 @@ static int intel_vgpu_reg_init_opregion(struct</span>
<span class="quote">&gt;intel_vgpu *vgpu)</span>
<span class="quote">&gt;&gt;  	return ret;</span>
<span class="quote">&gt;&gt;  }</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; +static int kvmgt_get_vfio_device(struct intel_vgpu *vgpu) {</span>
<span class="quote">&gt;&gt; +	struct vfio_device *device;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	device = vfio_device_get_from_dev(mdev_dev(vgpu-&gt;vdev.mdev));</span>
<span class="quote">&gt;&gt; +	if (device == NULL)</span>
<span class="quote">&gt;&gt; +		return -ENODEV;</span>
<span class="quote">&gt;&gt; +	vgpu-&gt;vdev.vfio_device = device;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	return 0;</span>
<span class="quote">&gt;&gt; +}</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +static void kvmgt_put_vfio_device(struct intel_vgpu *vgpu) {</span>
<span class="quote">&gt;&gt; +	vfio_device_put(vgpu-&gt;vdev.vfio_device);</span>
<span class="quote">&gt;&gt; +}</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +static int intel_vgpu_dmabuf_mgr_fd_mmap(struct file *file,</span>
<span class="quote">&gt;&gt; +		struct vm_area_struct *vma)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt;&gt; +	return -EPERM;</span>
<span class="quote">&gt;&gt; +}</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +static int intel_vgpu_dmabuf_mgr_fd_release(struct inode *inode,</span>
<span class="quote">&gt;&gt; +		struct file *filp)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt;&gt; +	struct intel_vgpu *vgpu = filp-&gt;private_data;</span>
<span class="quote">&gt;&gt; +	struct intel_vgpu_dmabuf_obj *obj;</span>
<span class="quote">&gt;&gt; +	struct list_head *pos;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	if (WARN_ON(!vgpu-&gt;vdev.vfio_device))</span>
<span class="quote">&gt;&gt; +		return -ENODEV;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	list_for_each(pos, &amp;vgpu-&gt;dmabuf_obj_list_head) {</span>
<span class="quote">&gt;&gt; +		obj = container_of(pos, struct intel_vgpu_dmabuf_obj, list);</span>
<span class="quote">&gt;&gt; +		if (WARN_ON(!obj))</span>
<span class="quote">&gt;&gt; +			return -ENODEV;</span>
<span class="quote">&gt;&gt; +		kfree(obj-&gt;obj-&gt;gvt_info);</span>
<span class="quote">&gt;&gt; +		i915_gem_object_put(obj-&gt;obj);</span>
<span class="quote">&gt;&gt; +		kfree(obj);</span>
<span class="quote">&gt;&gt; +		kvmgt_put_vfio_device(vgpu);</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;Can we do this?  If I understand, we&#39;re releasing all the references and allocations</span>
<span class="quote">&gt;for the dmabuf fds on release of the manager fd.  What happens if the user</span>
<span class="quote">&gt;continues trying to access those dmabuf fds after this?</span>
I think we can do this here.
The dma-buf&#39;s release function dma_buf_release() will be called by kernel which means all the created dmabufs will be invalid even we do not release all the references and allocations here.
<span class="quote">
&gt;</span>
<span class="quote">&gt;&gt; +	}</span>
<span class="quote">&gt;&gt; +	kvmgt_put_vfio_device(vgpu);</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	return 0;</span>
<span class="quote">&gt;&gt; +}</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +static long intel_vgpu_dmabuf_mgr_fd_ioctl(struct file *filp,</span>
<span class="quote">&gt;&gt; +		unsigned int ioctl, unsigned long arg) {</span>
<span class="quote">&gt;&gt; +	struct intel_vgpu *vgpu = filp-&gt;private_data;</span>
<span class="quote">&gt;&gt; +	int minsz;</span>
<span class="quote">&gt;&gt; +	int ret;</span>
<span class="quote">&gt;&gt; +	struct fd f;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	f = fdget(vgpu-&gt;dmabuf_mgr_fd);</span>
<span class="quote">&gt;&gt; +	if (!f.file)</span>
<span class="quote">&gt;&gt; +		return -EBADF;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	if (ioctl == VFIO_DEVICE_QUERY_PLANE) {</span>
<span class="quote">&gt;&gt; +		struct vfio_vgpu_plane_info info;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +		minsz = offsetofend(struct vfio_vgpu_plane_info, resv);</span>
<span class="quote">&gt;&gt; +		if (copy_from_user(&amp;info, (void __user *)arg, minsz)) {</span>
<span class="quote">&gt;&gt; +			fdput(f);</span>
<span class="quote">&gt;&gt; +			return -EFAULT;</span>
<span class="quote">&gt;&gt; +		}</span>
<span class="quote">&gt;&gt; +		if (info.argsz &lt; minsz) {</span>
<span class="quote">&gt;&gt; +			fdput(f);</span>
<span class="quote">&gt;&gt; +			return -EINVAL;</span>
<span class="quote">&gt;&gt; +		}</span>
<span class="quote">&gt;&gt; +		ret = intel_gvt_ops-&gt;vgpu_query_plane(vgpu, &amp;info);</span>
<span class="quote">&gt;&gt; +		if (ret != 0) {</span>
<span class="quote">&gt;&gt; +			fdput(f);</span>
<span class="quote">&gt;&gt; +			gvt_vgpu_err(&quot;query plane failed:%d\n&quot;, ret);</span>
<span class="quote">&gt;&gt; +			return -EINVAL;</span>
<span class="quote">&gt;&gt; +		}</span>
<span class="quote">&gt;&gt; +		fdput(f);</span>
<span class="quote">&gt;&gt; +		return copy_to_user((void __user *)arg, &amp;info, minsz) ?</span>
<span class="quote">&gt;&gt; +								-EFAULT : 0;</span>
<span class="quote">&gt;&gt; +	} else if (ioctl == VFIO_DEVICE_CREATE_DMABUF) {</span>
<span class="quote">&gt;&gt; +		struct vfio_vgpu_dmabuf_info dmabuf;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +		minsz = offsetofend(struct vfio_vgpu_dmabuf_info, resv);</span>
<span class="quote">&gt;&gt; +		if (copy_from_user(&amp;dmabuf, (void __user *)arg, minsz)) {</span>
<span class="quote">&gt;&gt; +			fdput(f);</span>
<span class="quote">&gt;&gt; +			return -EFAULT;</span>
<span class="quote">&gt;&gt; +		}</span>
<span class="quote">&gt;&gt; +		if (dmabuf.argsz &lt; minsz) {</span>
<span class="quote">&gt;&gt; +			fdput(f);</span>
<span class="quote">&gt;&gt; +			return -EINVAL;</span>
<span class="quote">&gt;&gt; +		}</span>
<span class="quote">&gt;&gt; +		ret = kvmgt_get_vfio_device(vgpu);</span>
<span class="quote">&gt;&gt; +		if (ret != 0)</span>
<span class="quote">&gt;&gt; +			return ret;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;Missed an fdput, though I&#39;m not sure I understand the value of the original fdget</span>
<span class="quote">&gt;or the dmabuf_mgr_fd field at all.  dmabuf_mgr_fd is only used here, presumably</span>
<span class="quote">&gt;to add a reference to the fd while we&#39;re in the ioctl, but we&#39;re in the ioctl function</span>
<span class="quote">&gt;of that fd, so I think there are already references elsewhere.</span>
Make sense. Fdget/fdput can be removed.
<span class="quote">
&gt;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +		ret = intel_gvt_ops-&gt;vgpu_create_dmabuf(vgpu, &amp;dmabuf);</span>
<span class="quote">&gt;&gt; +		if (ret != 0) {</span>
<span class="quote">&gt;&gt; +			kvmgt_put_vfio_device(vgpu);</span>
<span class="quote">&gt;&gt; +			fdput(f);</span>
<span class="quote">&gt;&gt; +			return -EINVAL;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;Why not return the errno that vgpu_create_dmabuf provided?</span>
Will change to use the returned errno.
<span class="quote">
&gt;</span>
<span class="quote">&gt;&gt; +		}</span>
<span class="quote">&gt;&gt; +		fdput(f);</span>
<span class="quote">&gt;&gt; +		return copy_to_user((void __user *)arg, &amp;dmabuf, minsz) ?</span>
<span class="quote">&gt;&gt; +								-EFAULT : 0;</span>
<span class="quote">&gt;&gt; +	}</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	fdput(f);</span>
<span class="quote">&gt;&gt; +	gvt_vgpu_err(&quot;unsupported dmabuf operation\n&quot;);</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	return -EINVAL;</span>
<span class="quote">&gt;&gt; +}</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +static const struct file_operations intel_vgpu_dmabuf_mgr_fd_ops = {</span>
<span class="quote">&gt;&gt; +	.release        = intel_vgpu_dmabuf_mgr_fd_release,</span>
<span class="quote">&gt;&gt; +	.unlocked_ioctl = intel_vgpu_dmabuf_mgr_fd_ioctl,</span>
<span class="quote">&gt;&gt; +	.mmap           = intel_vgpu_dmabuf_mgr_fd_mmap,</span>
<span class="quote">&gt;&gt; +	.llseek         = noop_llseek,</span>
<span class="quote">&gt;&gt; +};</span>
<span class="quote">&gt;&gt;  static int intel_vgpu_create(struct kobject *kobj, struct mdev_device</span>
<span class="quote">&gt;&gt; *mdev)  {</span>
<span class="quote">&gt;&gt;  	struct intel_vgpu *vgpu = NULL;</span>
<span class="quote">&gt;&gt; @@ -1259,6 +1379,30 @@ static long intel_vgpu_ioctl(struct mdev_device</span>
<span class="quote">&gt;*mdev, unsigned int cmd,</span>
<span class="quote">&gt;&gt;  	} else if (cmd == VFIO_DEVICE_RESET) {</span>
<span class="quote">&gt;&gt;  		intel_gvt_ops-&gt;vgpu_reset(vgpu);</span>
<span class="quote">&gt;&gt;  		return 0;</span>
<span class="quote">&gt;&gt; +	} else if (cmd == VFIO_DEVICE_GET_FD) {</span>
<span class="quote">&gt;&gt; +		int fd;</span>
<span class="quote">&gt;&gt; +		u32 type;</span>
<span class="quote">&gt;&gt; +		int ret;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +		if (copy_from_user(&amp;type, (void __user *)arg, sizeof(type)))</span>
<span class="quote">&gt;&gt; +			return -EINVAL;</span>
<span class="quote">&gt;&gt; +		if (type != VFIO_DEVICE_DMABUF_MGR_FD)</span>
<span class="quote">&gt;&gt; +			return -EINVAL;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +		ret = kvmgt_get_vfio_device(vgpu);</span>
<span class="quote">&gt;&gt; +		if (ret != 0)</span>
<span class="quote">&gt;&gt; +			return ret;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +		fd = anon_inode_getfd(&quot;intel-vgpu-dmabuf-mgr-fd&quot;,</span>
<span class="quote">&gt;&gt; +			&amp;intel_vgpu_dmabuf_mgr_fd_ops,</span>
<span class="quote">&gt;&gt; +			vgpu, O_RDWR | O_CLOEXEC);</span>
<span class="quote">&gt;&gt; +		if (fd &lt; 0) {</span>
<span class="quote">&gt;&gt; +			gvt_vgpu_err(&quot;create dmabuf mgr fd failed\n&quot;);</span>
<span class="quote">&gt;&gt; +			return -EINVAL;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;Error path leaks vfio_device reference.</span>
Will correct in the next version.
<span class="quote">
&gt;</span>
<span class="quote">&gt;&gt; +		}</span>
<span class="quote">&gt;&gt; +		vgpu-&gt;dmabuf_mgr_fd = fd;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;As above, unclear value of this field, additionally, what if the user calls</span>
<span class="quote">&gt;VFIO_DEVICE_GET_FD more than once?</span>
Ah, good question.
VFIO_DEVICE_GET_FD should only be called once.
And we should add a check if the vgpu-&gt;dmabuf_mgr_fd is not 0 which means VFIO_DEVICE_GET_FD had been called before we should return an error.
<span class="quote">
&gt;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +		return fd;</span>
<span class="quote">&gt;&gt;  	}</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;  	return 0;</span>
<span class="quote">&gt;&gt; diff --git a/drivers/gpu/drm/i915/gvt/vgpu.c</span>
<span class="quote">&gt;&gt; b/drivers/gpu/drm/i915/gvt/vgpu.c index 6e3cbd8..af6fc74 100644</span>
<span class="quote">&gt;&gt; --- a/drivers/gpu/drm/i915/gvt/vgpu.c</span>
<span class="quote">&gt;&gt; +++ b/drivers/gpu/drm/i915/gvt/vgpu.c</span>
<span class="quote">&gt;&gt; @@ -346,6 +346,7 @@ static struct intel_vgpu</span>
<span class="quote">&gt;*__intel_gvt_create_vgpu(struct intel_gvt *gvt,</span>
<span class="quote">&gt;&gt;  	vgpu-&gt;gvt = gvt;</span>
<span class="quote">&gt;&gt;  	vgpu-&gt;sched_ctl.weight = param-&gt;weight;</span>
<span class="quote">&gt;&gt;  	bitmap_zero(vgpu-&gt;tlb_handle_pending, I915_NUM_ENGINES);</span>
<span class="quote">&gt;&gt; +	INIT_LIST_HEAD(&amp;vgpu-&gt;dmabuf_obj_list_head);</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;  	intel_vgpu_init_cfg_space(vgpu, param-&gt;primary);</span>
<span class="quote">&gt;&gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7781">Alex Williamson</a> - June 2, 2017, 3:34 a.m.</div>
<pre class="content">
On Fri, 2 Jun 2017 03:24:35 +0000
&quot;Chen, Xiaoguang&quot; &lt;xiaoguang.chen@intel.com&gt; wrote:
<span class="quote">
&gt; Hi Alex,</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt;-----Original Message-----</span>
<span class="quote">&gt; &gt;From: Alex Williamson [mailto:alex.williamson@redhat.com]</span>
<span class="quote">&gt; &gt;Sent: Friday, June 02, 2017 2:08 AM</span>
<span class="quote">&gt; &gt;To: Chen, Xiaoguang &lt;xiaoguang.chen@intel.com&gt;</span>
<span class="quote">&gt; &gt;Cc: kraxel@redhat.com; chris@chris-wilson.co.uk; intel-</span>
<span class="quote">&gt; &gt;gfx@lists.freedesktop.org; linux-kernel@vger.kernel.org;</span>
<span class="quote">&gt; &gt;zhenyuw@linux.intel.com; Lv, Zhiyuan &lt;zhiyuan.lv@intel.com&gt;; intel-gvt-</span>
<span class="quote">&gt; &gt;dev@lists.freedesktop.org; Wang, Zhi A &lt;zhi.a.wang@intel.com&gt;; Tian, Kevin</span>
<span class="quote">&gt; &gt;&lt;kevin.tian@intel.com&gt;</span>
<span class="quote">&gt; &gt;Subject: Re: [PATCH v6 6/6] drm/i915/gvt: Adding interface so user space can get</span>
<span class="quote">&gt; &gt;the dma-buf</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;On Sat, 27 May 2017 16:38:52 +0800</span>
<span class="quote">&gt; &gt;Xiaoguang Chen &lt;xiaoguang.chen@intel.com&gt; wrote:</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;&gt; User space should create the management fd for the dma-buf operation first.</span>
<span class="quote">&gt; &gt;&gt; Then user can query the plane information and create dma-buf if</span>
<span class="quote">&gt; &gt;&gt; necessary using the management fd.</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; Signed-off-by: Xiaoguang Chen &lt;xiaoguang.chen@intel.com&gt;</span>
<span class="quote">&gt; &gt;&gt; ---</span>
<span class="quote">&gt; &gt;&gt;  drivers/gpu/drm/i915/gvt/dmabuf.c |  12 ++++</span>
<span class="quote">&gt; &gt;&gt;  drivers/gpu/drm/i915/gvt/dmabuf.h |   5 ++</span>
<span class="quote">&gt; &gt;&gt;  drivers/gpu/drm/i915/gvt/gvt.c    |   2 +</span>
<span class="quote">&gt; &gt;&gt;  drivers/gpu/drm/i915/gvt/gvt.h    |   5 ++</span>
<span class="quote">&gt; &gt;&gt;  drivers/gpu/drm/i915/gvt/kvmgt.c  | 144  </span>
<span class="quote">&gt; &gt;++++++++++++++++++++++++++++++++++++++  </span>
<span class="quote">&gt; &gt;&gt;  drivers/gpu/drm/i915/gvt/vgpu.c   |   1 +</span>
<span class="quote">&gt; &gt;&gt;  6 files changed, 169 insertions(+)</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; diff --git a/drivers/gpu/drm/i915/gvt/dmabuf.c</span>
<span class="quote">&gt; &gt;&gt; b/drivers/gpu/drm/i915/gvt/dmabuf.c</span>
<span class="quote">&gt; &gt;&gt; index c831e91..9759e9a 100644</span>
<span class="quote">&gt; &gt;&gt; --- a/drivers/gpu/drm/i915/gvt/dmabuf.c</span>
<span class="quote">&gt; &gt;&gt; +++ b/drivers/gpu/drm/i915/gvt/dmabuf.c</span>
<span class="quote">&gt; &gt;&gt; @@ -226,6 +226,7 @@ int intel_vgpu_create_dmabuf(struct intel_vgpu *vgpu,  </span>
<span class="quote">&gt; &gt;void *args)  </span>
<span class="quote">&gt; &gt;&gt;  	struct vfio_vgpu_dmabuf_info *gvt_dmabuf = args;</span>
<span class="quote">&gt; &gt;&gt;  	struct intel_vgpu_fb_info *fb_info;</span>
<span class="quote">&gt; &gt;&gt;  	int ret;</span>
<span class="quote">&gt; &gt;&gt; +	struct intel_vgpu_dmabuf_obj *dmabuf_obj;</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;  	ret = intel_vgpu_get_plane_info(dev, vgpu, &amp;gvt_dmabuf-&gt;plane_info);</span>
<span class="quote">&gt; &gt;&gt;  	if (ret != 0)</span>
<span class="quote">&gt; &gt;&gt; @@ -263,6 +264,17 @@ int intel_vgpu_create_dmabuf(struct intel_vgpu *vgpu,  </span>
<span class="quote">&gt; &gt;void *args)  </span>
<span class="quote">&gt; &gt;&gt;  		gvt_vgpu_err(&quot;create dma-buf fd failed ret:%d\n&quot;, ret);</span>
<span class="quote">&gt; &gt;&gt;  		return ret;</span>
<span class="quote">&gt; &gt;&gt;  	}</span>
<span class="quote">&gt; &gt;&gt; +	dmabuf_obj = kmalloc(sizeof(*dmabuf_obj), GFP_KERNEL);</span>
<span class="quote">&gt; &gt;&gt; +	if (dmabuf_obj == NULL) {</span>
<span class="quote">&gt; &gt;&gt; +		kfree(fb_info);</span>
<span class="quote">&gt; &gt;&gt; +		i915_gem_object_put(obj);</span>
<span class="quote">&gt; &gt;&gt; +		gvt_vgpu_err(&quot;alloc dmabuf_obj failed\n&quot;);</span>
<span class="quote">&gt; &gt;&gt; +		return -ENOMEM;</span>
<span class="quote">&gt; &gt;&gt; +	}</span>
<span class="quote">&gt; &gt;&gt; +	dmabuf_obj-&gt;obj = obj;</span>
<span class="quote">&gt; &gt;&gt; +	INIT_LIST_HEAD(&amp;dmabuf_obj-&gt;list);</span>
<span class="quote">&gt; &gt;&gt; +	list_add_tail(&amp;dmabuf_obj-&gt;list, &amp;vgpu-&gt;dmabuf_obj_list_head);</span>
<span class="quote">&gt; &gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt;  	gvt_dmabuf-&gt;fd = ret;</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;  	return 0;</span>
<span class="quote">&gt; &gt;&gt; diff --git a/drivers/gpu/drm/i915/gvt/dmabuf.h</span>
<span class="quote">&gt; &gt;&gt; b/drivers/gpu/drm/i915/gvt/dmabuf.h</span>
<span class="quote">&gt; &gt;&gt; index 8be9979..cafa781 100644</span>
<span class="quote">&gt; &gt;&gt; --- a/drivers/gpu/drm/i915/gvt/dmabuf.h</span>
<span class="quote">&gt; &gt;&gt; +++ b/drivers/gpu/drm/i915/gvt/dmabuf.h</span>
<span class="quote">&gt; &gt;&gt; @@ -31,6 +31,11 @@ struct intel_vgpu_fb_info {</span>
<span class="quote">&gt; &gt;&gt;  	uint32_t fb_size;</span>
<span class="quote">&gt; &gt;&gt;  };</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; +struct intel_vgpu_dmabuf_obj {</span>
<span class="quote">&gt; &gt;&gt; +	struct drm_i915_gem_object *obj;</span>
<span class="quote">&gt; &gt;&gt; +	struct list_head list;</span>
<span class="quote">&gt; &gt;&gt; +};</span>
<span class="quote">&gt; &gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt;  int intel_vgpu_query_plane(struct intel_vgpu *vgpu, void *args);  int</span>
<span class="quote">&gt; &gt;&gt; intel_vgpu_create_dmabuf(struct intel_vgpu *vgpu, void *args);</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; diff --git a/drivers/gpu/drm/i915/gvt/gvt.c</span>
<span class="quote">&gt; &gt;&gt; b/drivers/gpu/drm/i915/gvt/gvt.c index 2032917..dbc3f86 100644</span>
<span class="quote">&gt; &gt;&gt; --- a/drivers/gpu/drm/i915/gvt/gvt.c</span>
<span class="quote">&gt; &gt;&gt; +++ b/drivers/gpu/drm/i915/gvt/gvt.c</span>
<span class="quote">&gt; &gt;&gt; @@ -54,6 +54,8 @@ static const struct intel_gvt_ops intel_gvt_ops = {</span>
<span class="quote">&gt; &gt;&gt;  	.vgpu_reset = intel_gvt_reset_vgpu,</span>
<span class="quote">&gt; &gt;&gt;  	.vgpu_activate = intel_gvt_activate_vgpu,</span>
<span class="quote">&gt; &gt;&gt;  	.vgpu_deactivate = intel_gvt_deactivate_vgpu,</span>
<span class="quote">&gt; &gt;&gt; +	.vgpu_query_plane = intel_vgpu_query_plane,</span>
<span class="quote">&gt; &gt;&gt; +	.vgpu_create_dmabuf = intel_vgpu_create_dmabuf,</span>
<span class="quote">&gt; &gt;&gt;  };</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;  /**</span>
<span class="quote">&gt; &gt;&gt; diff --git a/drivers/gpu/drm/i915/gvt/gvt.h</span>
<span class="quote">&gt; &gt;&gt; b/drivers/gpu/drm/i915/gvt/gvt.h index 763a8c5..a855797 100644</span>
<span class="quote">&gt; &gt;&gt; --- a/drivers/gpu/drm/i915/gvt/gvt.h</span>
<span class="quote">&gt; &gt;&gt; +++ b/drivers/gpu/drm/i915/gvt/gvt.h</span>
<span class="quote">&gt; &gt;&gt; @@ -185,8 +185,11 @@ struct intel_vgpu {</span>
<span class="quote">&gt; &gt;&gt;  		struct kvm *kvm;</span>
<span class="quote">&gt; &gt;&gt;  		struct work_struct release_work;</span>
<span class="quote">&gt; &gt;&gt;  		atomic_t released;</span>
<span class="quote">&gt; &gt;&gt; +		struct vfio_device *vfio_device;</span>
<span class="quote">&gt; &gt;&gt;  	} vdev;</span>
<span class="quote">&gt; &gt;&gt;  #endif</span>
<span class="quote">&gt; &gt;&gt; +	int dmabuf_mgr_fd;</span>
<span class="quote">&gt; &gt;&gt; +	struct list_head dmabuf_obj_list_head;</span>
<span class="quote">&gt; &gt;&gt;  };</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;  struct intel_gvt_gm {</span>
<span class="quote">&gt; &gt;&gt; @@ -467,6 +470,8 @@ struct intel_gvt_ops {</span>
<span class="quote">&gt; &gt;&gt;  	void (*vgpu_reset)(struct intel_vgpu *);</span>
<span class="quote">&gt; &gt;&gt;  	void (*vgpu_activate)(struct intel_vgpu *);</span>
<span class="quote">&gt; &gt;&gt;  	void (*vgpu_deactivate)(struct intel_vgpu *);</span>
<span class="quote">&gt; &gt;&gt; +	int (*vgpu_query_plane)(struct intel_vgpu *vgpu, void *);</span>
<span class="quote">&gt; &gt;&gt; +	int (*vgpu_create_dmabuf)(struct intel_vgpu *vgpu, void *);</span>
<span class="quote">&gt; &gt;&gt;  };</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; diff --git a/drivers/gpu/drm/i915/gvt/kvmgt.c</span>
<span class="quote">&gt; &gt;&gt; b/drivers/gpu/drm/i915/gvt/kvmgt.c</span>
<span class="quote">&gt; &gt;&gt; index 389f072..a079080 100644</span>
<span class="quote">&gt; &gt;&gt; --- a/drivers/gpu/drm/i915/gvt/kvmgt.c</span>
<span class="quote">&gt; &gt;&gt; +++ b/drivers/gpu/drm/i915/gvt/kvmgt.c</span>
<span class="quote">&gt; &gt;&gt; @@ -41,6 +41,7 @@</span>
<span class="quote">&gt; &gt;&gt;  #include &lt;linux/kvm_host.h&gt;</span>
<span class="quote">&gt; &gt;&gt;  #include &lt;linux/vfio.h&gt;</span>
<span class="quote">&gt; &gt;&gt;  #include &lt;linux/mdev.h&gt;</span>
<span class="quote">&gt; &gt;&gt; +#include &lt;linux/anon_inodes.h&gt;</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;  #include &quot;i915_drv.h&quot;</span>
<span class="quote">&gt; &gt;&gt;  #include &quot;gvt.h&quot;</span>
<span class="quote">&gt; &gt;&gt; @@ -524,6 +525,125 @@ static int intel_vgpu_reg_init_opregion(struct  </span>
<span class="quote">&gt; &gt;intel_vgpu *vgpu)  </span>
<span class="quote">&gt; &gt;&gt;  	return ret;</span>
<span class="quote">&gt; &gt;&gt;  }</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; +static int kvmgt_get_vfio_device(struct intel_vgpu *vgpu) {</span>
<span class="quote">&gt; &gt;&gt; +	struct vfio_device *device;</span>
<span class="quote">&gt; &gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt; +	device = vfio_device_get_from_dev(mdev_dev(vgpu-&gt;vdev.mdev));</span>
<span class="quote">&gt; &gt;&gt; +	if (device == NULL)</span>
<span class="quote">&gt; &gt;&gt; +		return -ENODEV;</span>
<span class="quote">&gt; &gt;&gt; +	vgpu-&gt;vdev.vfio_device = device;</span>
<span class="quote">&gt; &gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt; +	return 0;</span>
<span class="quote">&gt; &gt;&gt; +}</span>
<span class="quote">&gt; &gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt; +static void kvmgt_put_vfio_device(struct intel_vgpu *vgpu) {</span>
<span class="quote">&gt; &gt;&gt; +	vfio_device_put(vgpu-&gt;vdev.vfio_device);</span>
<span class="quote">&gt; &gt;&gt; +}</span>
<span class="quote">&gt; &gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt; +static int intel_vgpu_dmabuf_mgr_fd_mmap(struct file *file,</span>
<span class="quote">&gt; &gt;&gt; +		struct vm_area_struct *vma)</span>
<span class="quote">&gt; &gt;&gt; +{</span>
<span class="quote">&gt; &gt;&gt; +	return -EPERM;</span>
<span class="quote">&gt; &gt;&gt; +}</span>
<span class="quote">&gt; &gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt; +static int intel_vgpu_dmabuf_mgr_fd_release(struct inode *inode,</span>
<span class="quote">&gt; &gt;&gt; +		struct file *filp)</span>
<span class="quote">&gt; &gt;&gt; +{</span>
<span class="quote">&gt; &gt;&gt; +	struct intel_vgpu *vgpu = filp-&gt;private_data;</span>
<span class="quote">&gt; &gt;&gt; +	struct intel_vgpu_dmabuf_obj *obj;</span>
<span class="quote">&gt; &gt;&gt; +	struct list_head *pos;</span>
<span class="quote">&gt; &gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt; +	if (WARN_ON(!vgpu-&gt;vdev.vfio_device))</span>
<span class="quote">&gt; &gt;&gt; +		return -ENODEV;</span>
<span class="quote">&gt; &gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt; +	list_for_each(pos, &amp;vgpu-&gt;dmabuf_obj_list_head) {</span>
<span class="quote">&gt; &gt;&gt; +		obj = container_of(pos, struct intel_vgpu_dmabuf_obj, list);</span>
<span class="quote">&gt; &gt;&gt; +		if (WARN_ON(!obj))</span>
<span class="quote">&gt; &gt;&gt; +			return -ENODEV;</span>
<span class="quote">&gt; &gt;&gt; +		kfree(obj-&gt;obj-&gt;gvt_info);</span>
<span class="quote">&gt; &gt;&gt; +		i915_gem_object_put(obj-&gt;obj);</span>
<span class="quote">&gt; &gt;&gt; +		kfree(obj);</span>
<span class="quote">&gt; &gt;&gt; +		kvmgt_put_vfio_device(vgpu);  </span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;Can we do this?  If I understand, we&#39;re releasing all the references and allocations</span>
<span class="quote">&gt; &gt;for the dmabuf fds on release of the manager fd.  What happens if the user</span>
<span class="quote">&gt; &gt;continues trying to access those dmabuf fds after this?  </span>
<span class="quote">&gt; I think we can do this here.</span>
<span class="quote">&gt; The dma-buf&#39;s release function dma_buf_release() will be called by kernel which means all the created dmabufs will be invalid even we do not release all the references and allocations here.</span>

Are you assuming that the user has closed the dmabuf fds?  They could
close the manager fd first, should the dmabuf fd continue to work?
<span class="quote">  
&gt; &gt;&gt; +	}</span>
<span class="quote">&gt; &gt;&gt; +	kvmgt_put_vfio_device(vgpu);</span>
<span class="quote">&gt; &gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt; +	return 0;</span>
<span class="quote">&gt; &gt;&gt; +}</span>
<span class="quote">&gt; &gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt; +static long intel_vgpu_dmabuf_mgr_fd_ioctl(struct file *filp,</span>
<span class="quote">&gt; &gt;&gt; +		unsigned int ioctl, unsigned long arg) {</span>
<span class="quote">&gt; &gt;&gt; +	struct intel_vgpu *vgpu = filp-&gt;private_data;</span>
<span class="quote">&gt; &gt;&gt; +	int minsz;</span>
<span class="quote">&gt; &gt;&gt; +	int ret;</span>
<span class="quote">&gt; &gt;&gt; +	struct fd f;</span>
<span class="quote">&gt; &gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt; +	f = fdget(vgpu-&gt;dmabuf_mgr_fd);</span>
<span class="quote">&gt; &gt;&gt; +	if (!f.file)</span>
<span class="quote">&gt; &gt;&gt; +		return -EBADF;</span>
<span class="quote">&gt; &gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt; +	if (ioctl == VFIO_DEVICE_QUERY_PLANE) {</span>
<span class="quote">&gt; &gt;&gt; +		struct vfio_vgpu_plane_info info;</span>
<span class="quote">&gt; &gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt; +		minsz = offsetofend(struct vfio_vgpu_plane_info, resv);</span>
<span class="quote">&gt; &gt;&gt; +		if (copy_from_user(&amp;info, (void __user *)arg, minsz)) {</span>
<span class="quote">&gt; &gt;&gt; +			fdput(f);</span>
<span class="quote">&gt; &gt;&gt; +			return -EFAULT;</span>
<span class="quote">&gt; &gt;&gt; +		}</span>
<span class="quote">&gt; &gt;&gt; +		if (info.argsz &lt; minsz) {</span>
<span class="quote">&gt; &gt;&gt; +			fdput(f);</span>
<span class="quote">&gt; &gt;&gt; +			return -EINVAL;</span>
<span class="quote">&gt; &gt;&gt; +		}</span>
<span class="quote">&gt; &gt;&gt; +		ret = intel_gvt_ops-&gt;vgpu_query_plane(vgpu, &amp;info);</span>
<span class="quote">&gt; &gt;&gt; +		if (ret != 0) {</span>
<span class="quote">&gt; &gt;&gt; +			fdput(f);</span>
<span class="quote">&gt; &gt;&gt; +			gvt_vgpu_err(&quot;query plane failed:%d\n&quot;, ret);</span>
<span class="quote">&gt; &gt;&gt; +			return -EINVAL;</span>
<span class="quote">&gt; &gt;&gt; +		}</span>
<span class="quote">&gt; &gt;&gt; +		fdput(f);</span>
<span class="quote">&gt; &gt;&gt; +		return copy_to_user((void __user *)arg, &amp;info, minsz) ?</span>
<span class="quote">&gt; &gt;&gt; +								-EFAULT : 0;</span>
<span class="quote">&gt; &gt;&gt; +	} else if (ioctl == VFIO_DEVICE_CREATE_DMABUF) {</span>
<span class="quote">&gt; &gt;&gt; +		struct vfio_vgpu_dmabuf_info dmabuf;</span>
<span class="quote">&gt; &gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt; +		minsz = offsetofend(struct vfio_vgpu_dmabuf_info, resv);</span>
<span class="quote">&gt; &gt;&gt; +		if (copy_from_user(&amp;dmabuf, (void __user *)arg, minsz)) {</span>
<span class="quote">&gt; &gt;&gt; +			fdput(f);</span>
<span class="quote">&gt; &gt;&gt; +			return -EFAULT;</span>
<span class="quote">&gt; &gt;&gt; +		}</span>
<span class="quote">&gt; &gt;&gt; +		if (dmabuf.argsz &lt; minsz) {</span>
<span class="quote">&gt; &gt;&gt; +			fdput(f);</span>
<span class="quote">&gt; &gt;&gt; +			return -EINVAL;</span>
<span class="quote">&gt; &gt;&gt; +		}</span>
<span class="quote">&gt; &gt;&gt; +		ret = kvmgt_get_vfio_device(vgpu);</span>
<span class="quote">&gt; &gt;&gt; +		if (ret != 0)</span>
<span class="quote">&gt; &gt;&gt; +			return ret;  </span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;Missed an fdput, though I&#39;m not sure I understand the value of the original fdget</span>
<span class="quote">&gt; &gt;or the dmabuf_mgr_fd field at all.  dmabuf_mgr_fd is only used here, presumably</span>
<span class="quote">&gt; &gt;to add a reference to the fd while we&#39;re in the ioctl, but we&#39;re in the ioctl function</span>
<span class="quote">&gt; &gt;of that fd, so I think there are already references elsewhere.  </span>
<span class="quote">&gt; Make sense. Fdget/fdput can be removed.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt; +		ret = intel_gvt_ops-&gt;vgpu_create_dmabuf(vgpu, &amp;dmabuf);</span>
<span class="quote">&gt; &gt;&gt; +		if (ret != 0) {</span>
<span class="quote">&gt; &gt;&gt; +			kvmgt_put_vfio_device(vgpu);</span>
<span class="quote">&gt; &gt;&gt; +			fdput(f);</span>
<span class="quote">&gt; &gt;&gt; +			return -EINVAL;  </span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;Why not return the errno that vgpu_create_dmabuf provided?  </span>
<span class="quote">&gt; Will change to use the returned errno.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;&gt; +		}</span>
<span class="quote">&gt; &gt;&gt; +		fdput(f);</span>
<span class="quote">&gt; &gt;&gt; +		return copy_to_user((void __user *)arg, &amp;dmabuf, minsz) ?</span>
<span class="quote">&gt; &gt;&gt; +								-EFAULT : 0;</span>
<span class="quote">&gt; &gt;&gt; +	}</span>
<span class="quote">&gt; &gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt; +	fdput(f);</span>
<span class="quote">&gt; &gt;&gt; +	gvt_vgpu_err(&quot;unsupported dmabuf operation\n&quot;);</span>
<span class="quote">&gt; &gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt; +	return -EINVAL;</span>
<span class="quote">&gt; &gt;&gt; +}</span>
<span class="quote">&gt; &gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt; +static const struct file_operations intel_vgpu_dmabuf_mgr_fd_ops = {</span>
<span class="quote">&gt; &gt;&gt; +	.release        = intel_vgpu_dmabuf_mgr_fd_release,</span>
<span class="quote">&gt; &gt;&gt; +	.unlocked_ioctl = intel_vgpu_dmabuf_mgr_fd_ioctl,</span>
<span class="quote">&gt; &gt;&gt; +	.mmap           = intel_vgpu_dmabuf_mgr_fd_mmap,</span>
<span class="quote">&gt; &gt;&gt; +	.llseek         = noop_llseek,</span>
<span class="quote">&gt; &gt;&gt; +};</span>
<span class="quote">&gt; &gt;&gt;  static int intel_vgpu_create(struct kobject *kobj, struct mdev_device</span>
<span class="quote">&gt; &gt;&gt; *mdev)  {</span>
<span class="quote">&gt; &gt;&gt;  	struct intel_vgpu *vgpu = NULL;</span>
<span class="quote">&gt; &gt;&gt; @@ -1259,6 +1379,30 @@ static long intel_vgpu_ioctl(struct mdev_device  </span>
<span class="quote">&gt; &gt;*mdev, unsigned int cmd,  </span>
<span class="quote">&gt; &gt;&gt;  	} else if (cmd == VFIO_DEVICE_RESET) {</span>
<span class="quote">&gt; &gt;&gt;  		intel_gvt_ops-&gt;vgpu_reset(vgpu);</span>
<span class="quote">&gt; &gt;&gt;  		return 0;</span>
<span class="quote">&gt; &gt;&gt; +	} else if (cmd == VFIO_DEVICE_GET_FD) {</span>
<span class="quote">&gt; &gt;&gt; +		int fd;</span>
<span class="quote">&gt; &gt;&gt; +		u32 type;</span>
<span class="quote">&gt; &gt;&gt; +		int ret;</span>
<span class="quote">&gt; &gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt; +		if (copy_from_user(&amp;type, (void __user *)arg, sizeof(type)))</span>
<span class="quote">&gt; &gt;&gt; +			return -EINVAL;</span>
<span class="quote">&gt; &gt;&gt; +		if (type != VFIO_DEVICE_DMABUF_MGR_FD)</span>
<span class="quote">&gt; &gt;&gt; +			return -EINVAL;</span>
<span class="quote">&gt; &gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt; +		ret = kvmgt_get_vfio_device(vgpu);</span>
<span class="quote">&gt; &gt;&gt; +		if (ret != 0)</span>
<span class="quote">&gt; &gt;&gt; +			return ret;</span>
<span class="quote">&gt; &gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt; +		fd = anon_inode_getfd(&quot;intel-vgpu-dmabuf-mgr-fd&quot;,</span>
<span class="quote">&gt; &gt;&gt; +			&amp;intel_vgpu_dmabuf_mgr_fd_ops,</span>
<span class="quote">&gt; &gt;&gt; +			vgpu, O_RDWR | O_CLOEXEC);</span>
<span class="quote">&gt; &gt;&gt; +		if (fd &lt; 0) {</span>
<span class="quote">&gt; &gt;&gt; +			gvt_vgpu_err(&quot;create dmabuf mgr fd failed\n&quot;);</span>
<span class="quote">&gt; &gt;&gt; +			return -EINVAL;  </span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;Error path leaks vfio_device reference.  </span>
<span class="quote">&gt; Will correct in the next version.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;&gt; +		}</span>
<span class="quote">&gt; &gt;&gt; +		vgpu-&gt;dmabuf_mgr_fd = fd;  </span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;As above, unclear value of this field, additionally, what if the user calls</span>
<span class="quote">&gt; &gt;VFIO_DEVICE_GET_FD more than once?  </span>
<span class="quote">&gt; Ah, good question.</span>
<span class="quote">&gt; VFIO_DEVICE_GET_FD should only be called once.</span>
<span class="quote">&gt; And we should add a check if the vgpu-&gt;dmabuf_mgr_fd is not 0 which means VFIO_DEVICE_GET_FD had been called before we should return an error.</span>

Except we no longer need that fd and we should probably use an atomic
&#39;opened&#39; so it&#39;s not racy.  Thanks,

Alex
<span class="quote">
&gt; &gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt; +		return fd;</span>
<span class="quote">&gt; &gt;&gt;  	}</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;  	return 0;</span>
<span class="quote">&gt; &gt;&gt; diff --git a/drivers/gpu/drm/i915/gvt/vgpu.c</span>
<span class="quote">&gt; &gt;&gt; b/drivers/gpu/drm/i915/gvt/vgpu.c index 6e3cbd8..af6fc74 100644</span>
<span class="quote">&gt; &gt;&gt; --- a/drivers/gpu/drm/i915/gvt/vgpu.c</span>
<span class="quote">&gt; &gt;&gt; +++ b/drivers/gpu/drm/i915/gvt/vgpu.c</span>
<span class="quote">&gt; &gt;&gt; @@ -346,6 +346,7 @@ static struct intel_vgpu  </span>
<span class="quote">&gt; &gt;*__intel_gvt_create_vgpu(struct intel_gvt *gvt,  </span>
<span class="quote">&gt; &gt;&gt;  	vgpu-&gt;gvt = gvt;</span>
<span class="quote">&gt; &gt;&gt;  	vgpu-&gt;sched_ctl.weight = param-&gt;weight;</span>
<span class="quote">&gt; &gt;&gt;  	bitmap_zero(vgpu-&gt;tlb_handle_pending, I915_NUM_ENGINES);</span>
<span class="quote">&gt; &gt;&gt; +	INIT_LIST_HEAD(&amp;vgpu-&gt;dmabuf_obj_list_head);</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;  	intel_vgpu_init_cfg_space(vgpu, param-&gt;primary);</span>
<span class="quote">&gt; &gt;&gt;  </span>
<span class="quote">&gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=170581">Xiaoguang Chen</a> - June 2, 2017, 9:31 a.m.</div>
<pre class="content">
<span class="quote">&gt;-----Original Message-----</span>
<span class="quote">&gt;From: Alex Williamson [mailto:alex.williamson@redhat.com]</span>
<span class="quote">&gt;Sent: Friday, June 02, 2017 11:35 AM</span>
<span class="quote">&gt;To: Chen, Xiaoguang &lt;xiaoguang.chen@intel.com&gt;</span>
<span class="quote">&gt;Cc: kraxel@redhat.com; chris@chris-wilson.co.uk; intel-</span>
<span class="quote">&gt;gfx@lists.freedesktop.org; linux-kernel@vger.kernel.org;</span>
<span class="quote">&gt;zhenyuw@linux.intel.com; Lv, Zhiyuan &lt;zhiyuan.lv@intel.com&gt;; intel-gvt-</span>
<span class="quote">&gt;dev@lists.freedesktop.org; Wang, Zhi A &lt;zhi.a.wang@intel.com&gt;; Tian, Kevin</span>
<span class="quote">&gt;&lt;kevin.tian@intel.com&gt;</span>
<span class="quote">&gt;Subject: Re: [PATCH v6 6/6] drm/i915/gvt: Adding interface so user space can get</span>
<span class="quote">&gt;the dma-buf</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;On Fri, 2 Jun 2017 03:24:35 +0000</span>
<span class="quote">&gt;&quot;Chen, Xiaoguang&quot; &lt;xiaoguang.chen@intel.com&gt; wrote:</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; Hi Alex,</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;-----Original Message-----</span>
<span class="quote">&gt;&gt; &gt;From: Alex Williamson [mailto:alex.williamson@redhat.com]</span>
<span class="quote">&gt;&gt; &gt;Sent: Friday, June 02, 2017 2:08 AM</span>
<span class="quote">&gt;&gt; &gt;To: Chen, Xiaoguang &lt;xiaoguang.chen@intel.com&gt;</span>
<span class="quote">&gt;&gt; &gt;Cc: kraxel@redhat.com; chris@chris-wilson.co.uk; intel-</span>
<span class="quote">&gt;&gt; &gt;gfx@lists.freedesktop.org; linux-kernel@vger.kernel.org;</span>
<span class="quote">&gt;&gt; &gt;zhenyuw@linux.intel.com; Lv, Zhiyuan &lt;zhiyuan.lv@intel.com&gt;;</span>
<span class="quote">&gt;&gt; &gt;intel-gvt- dev@lists.freedesktop.org; Wang, Zhi A</span>
<span class="quote">&gt;&gt; &gt;&lt;zhi.a.wang@intel.com&gt;; Tian, Kevin &lt;kevin.tian@intel.com&gt;</span>
<span class="quote">&gt;&gt; &gt;Subject: Re: [PATCH v6 6/6] drm/i915/gvt: Adding interface so user</span>
<span class="quote">&gt;&gt; &gt;space can get the dma-buf</span>
<span class="quote">&gt;&gt; &gt;</span>
<span class="quote">&gt;&gt; &gt;On Sat, 27 May 2017 16:38:52 +0800</span>
<span class="quote">&gt;&gt; &gt;Xiaoguang Chen &lt;xiaoguang.chen@intel.com&gt; wrote:</span>
<span class="quote">&gt;&gt; &gt;</span>
<span class="quote">&gt;&gt; &gt;&gt; User space should create the management fd for the dma-buf operation first.</span>
<span class="quote">&gt;&gt; &gt;&gt; Then user can query the plane information and create dma-buf if</span>
<span class="quote">&gt;&gt; &gt;&gt; necessary using the management fd.</span>
<span class="quote">&gt;&gt; &gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt; Signed-off-by: Xiaoguang Chen &lt;xiaoguang.chen@intel.com&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt; ---</span>
<span class="quote">&gt;&gt; &gt;&gt;  drivers/gpu/drm/i915/gvt/dmabuf.c |  12 ++++</span>
<span class="quote">&gt;&gt; &gt;&gt;  drivers/gpu/drm/i915/gvt/dmabuf.h |   5 ++</span>
<span class="quote">&gt;&gt; &gt;&gt;  drivers/gpu/drm/i915/gvt/gvt.c    |   2 +</span>
<span class="quote">&gt;&gt; &gt;&gt;  drivers/gpu/drm/i915/gvt/gvt.h    |   5 ++</span>
<span class="quote">&gt;&gt; &gt;&gt;  drivers/gpu/drm/i915/gvt/kvmgt.c  | 144</span>
<span class="quote">&gt;&gt; &gt;++++++++++++++++++++++++++++++++++++++</span>
<span class="quote">&gt;&gt; &gt;&gt;  drivers/gpu/drm/i915/gvt/vgpu.c   |   1 +</span>
<span class="quote">&gt;&gt; &gt;&gt;  6 files changed, 169 insertions(+)</span>
<span class="quote">&gt;&gt; &gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt; diff --git a/drivers/gpu/drm/i915/gvt/dmabuf.c</span>
<span class="quote">&gt;&gt; &gt;&gt; b/drivers/gpu/drm/i915/gvt/dmabuf.c</span>
<span class="quote">&gt;&gt; &gt;&gt; index c831e91..9759e9a 100644</span>
<span class="quote">&gt;&gt; &gt;&gt; --- a/drivers/gpu/drm/i915/gvt/dmabuf.c</span>
<span class="quote">&gt;&gt; &gt;&gt; +++ b/drivers/gpu/drm/i915/gvt/dmabuf.c</span>
<span class="quote">&gt;&gt; &gt;&gt; @@ -226,6 +226,7 @@ int intel_vgpu_create_dmabuf(struct intel_vgpu</span>
<span class="quote">&gt;&gt; &gt;&gt; *vgpu,</span>
<span class="quote">&gt;&gt; &gt;void *args)</span>
<span class="quote">&gt;&gt; &gt;&gt;  	struct vfio_vgpu_dmabuf_info *gvt_dmabuf = args;</span>
<span class="quote">&gt;&gt; &gt;&gt;  	struct intel_vgpu_fb_info *fb_info;</span>
<span class="quote">&gt;&gt; &gt;&gt;  	int ret;</span>
<span class="quote">&gt;&gt; &gt;&gt; +	struct intel_vgpu_dmabuf_obj *dmabuf_obj;</span>
<span class="quote">&gt;&gt; &gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt;  	ret = intel_vgpu_get_plane_info(dev, vgpu, &amp;gvt_dmabuf-&gt;plane_info);</span>
<span class="quote">&gt;&gt; &gt;&gt;  	if (ret != 0)</span>
<span class="quote">&gt;&gt; &gt;&gt; @@ -263,6 +264,17 @@ int intel_vgpu_create_dmabuf(struct intel_vgpu</span>
<span class="quote">&gt;&gt; &gt;&gt; *vgpu,</span>
<span class="quote">&gt;&gt; &gt;void *args)</span>
<span class="quote">&gt;&gt; &gt;&gt;  		gvt_vgpu_err(&quot;create dma-buf fd failed ret:%d\n&quot;, ret);</span>
<span class="quote">&gt;&gt; &gt;&gt;  		return ret;</span>
<span class="quote">&gt;&gt; &gt;&gt;  	}</span>
<span class="quote">&gt;&gt; &gt;&gt; +	dmabuf_obj = kmalloc(sizeof(*dmabuf_obj), GFP_KERNEL);</span>
<span class="quote">&gt;&gt; &gt;&gt; +	if (dmabuf_obj == NULL) {</span>
<span class="quote">&gt;&gt; &gt;&gt; +		kfree(fb_info);</span>
<span class="quote">&gt;&gt; &gt;&gt; +		i915_gem_object_put(obj);</span>
<span class="quote">&gt;&gt; &gt;&gt; +		gvt_vgpu_err(&quot;alloc dmabuf_obj failed\n&quot;);</span>
<span class="quote">&gt;&gt; &gt;&gt; +		return -ENOMEM;</span>
<span class="quote">&gt;&gt; &gt;&gt; +	}</span>
<span class="quote">&gt;&gt; &gt;&gt; +	dmabuf_obj-&gt;obj = obj;</span>
<span class="quote">&gt;&gt; &gt;&gt; +	INIT_LIST_HEAD(&amp;dmabuf_obj-&gt;list);</span>
<span class="quote">&gt;&gt; &gt;&gt; +	list_add_tail(&amp;dmabuf_obj-&gt;list, &amp;vgpu-&gt;dmabuf_obj_list_head);</span>
<span class="quote">&gt;&gt; &gt;&gt; +</span>
<span class="quote">&gt;&gt; &gt;&gt;  	gvt_dmabuf-&gt;fd = ret;</span>
<span class="quote">&gt;&gt; &gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt;  	return 0;</span>
<span class="quote">&gt;&gt; &gt;&gt; diff --git a/drivers/gpu/drm/i915/gvt/dmabuf.h</span>
<span class="quote">&gt;&gt; &gt;&gt; b/drivers/gpu/drm/i915/gvt/dmabuf.h</span>
<span class="quote">&gt;&gt; &gt;&gt; index 8be9979..cafa781 100644</span>
<span class="quote">&gt;&gt; &gt;&gt; --- a/drivers/gpu/drm/i915/gvt/dmabuf.h</span>
<span class="quote">&gt;&gt; &gt;&gt; +++ b/drivers/gpu/drm/i915/gvt/dmabuf.h</span>
<span class="quote">&gt;&gt; &gt;&gt; @@ -31,6 +31,11 @@ struct intel_vgpu_fb_info {</span>
<span class="quote">&gt;&gt; &gt;&gt;  	uint32_t fb_size;</span>
<span class="quote">&gt;&gt; &gt;&gt;  };</span>
<span class="quote">&gt;&gt; &gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt; +struct intel_vgpu_dmabuf_obj {</span>
<span class="quote">&gt;&gt; &gt;&gt; +	struct drm_i915_gem_object *obj;</span>
<span class="quote">&gt;&gt; &gt;&gt; +	struct list_head list;</span>
<span class="quote">&gt;&gt; &gt;&gt; +};</span>
<span class="quote">&gt;&gt; &gt;&gt; +</span>
<span class="quote">&gt;&gt; &gt;&gt;  int intel_vgpu_query_plane(struct intel_vgpu *vgpu, void *args);</span>
<span class="quote">&gt;&gt; &gt;&gt; int intel_vgpu_create_dmabuf(struct intel_vgpu *vgpu, void *args);</span>
<span class="quote">&gt;&gt; &gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt; diff --git a/drivers/gpu/drm/i915/gvt/gvt.c</span>
<span class="quote">&gt;&gt; &gt;&gt; b/drivers/gpu/drm/i915/gvt/gvt.c index 2032917..dbc3f86 100644</span>
<span class="quote">&gt;&gt; &gt;&gt; --- a/drivers/gpu/drm/i915/gvt/gvt.c</span>
<span class="quote">&gt;&gt; &gt;&gt; +++ b/drivers/gpu/drm/i915/gvt/gvt.c</span>
<span class="quote">&gt;&gt; &gt;&gt; @@ -54,6 +54,8 @@ static const struct intel_gvt_ops intel_gvt_ops = {</span>
<span class="quote">&gt;&gt; &gt;&gt;  	.vgpu_reset = intel_gvt_reset_vgpu,</span>
<span class="quote">&gt;&gt; &gt;&gt;  	.vgpu_activate = intel_gvt_activate_vgpu,</span>
<span class="quote">&gt;&gt; &gt;&gt;  	.vgpu_deactivate = intel_gvt_deactivate_vgpu,</span>
<span class="quote">&gt;&gt; &gt;&gt; +	.vgpu_query_plane = intel_vgpu_query_plane,</span>
<span class="quote">&gt;&gt; &gt;&gt; +	.vgpu_create_dmabuf = intel_vgpu_create_dmabuf,</span>
<span class="quote">&gt;&gt; &gt;&gt;  };</span>
<span class="quote">&gt;&gt; &gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt;  /**</span>
<span class="quote">&gt;&gt; &gt;&gt; diff --git a/drivers/gpu/drm/i915/gvt/gvt.h</span>
<span class="quote">&gt;&gt; &gt;&gt; b/drivers/gpu/drm/i915/gvt/gvt.h index 763a8c5..a855797 100644</span>
<span class="quote">&gt;&gt; &gt;&gt; --- a/drivers/gpu/drm/i915/gvt/gvt.h</span>
<span class="quote">&gt;&gt; &gt;&gt; +++ b/drivers/gpu/drm/i915/gvt/gvt.h</span>
<span class="quote">&gt;&gt; &gt;&gt; @@ -185,8 +185,11 @@ struct intel_vgpu {</span>
<span class="quote">&gt;&gt; &gt;&gt;  		struct kvm *kvm;</span>
<span class="quote">&gt;&gt; &gt;&gt;  		struct work_struct release_work;</span>
<span class="quote">&gt;&gt; &gt;&gt;  		atomic_t released;</span>
<span class="quote">&gt;&gt; &gt;&gt; +		struct vfio_device *vfio_device;</span>
<span class="quote">&gt;&gt; &gt;&gt;  	} vdev;</span>
<span class="quote">&gt;&gt; &gt;&gt;  #endif</span>
<span class="quote">&gt;&gt; &gt;&gt; +	int dmabuf_mgr_fd;</span>
<span class="quote">&gt;&gt; &gt;&gt; +	struct list_head dmabuf_obj_list_head;</span>
<span class="quote">&gt;&gt; &gt;&gt;  };</span>
<span class="quote">&gt;&gt; &gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt;  struct intel_gvt_gm {</span>
<span class="quote">&gt;&gt; &gt;&gt; @@ -467,6 +470,8 @@ struct intel_gvt_ops {</span>
<span class="quote">&gt;&gt; &gt;&gt;  	void (*vgpu_reset)(struct intel_vgpu *);</span>
<span class="quote">&gt;&gt; &gt;&gt;  	void (*vgpu_activate)(struct intel_vgpu *);</span>
<span class="quote">&gt;&gt; &gt;&gt;  	void (*vgpu_deactivate)(struct intel_vgpu *);</span>
<span class="quote">&gt;&gt; &gt;&gt; +	int (*vgpu_query_plane)(struct intel_vgpu *vgpu, void *);</span>
<span class="quote">&gt;&gt; &gt;&gt; +	int (*vgpu_create_dmabuf)(struct intel_vgpu *vgpu, void *);</span>
<span class="quote">&gt;&gt; &gt;&gt;  };</span>
<span class="quote">&gt;&gt; &gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt; diff --git a/drivers/gpu/drm/i915/gvt/kvmgt.c</span>
<span class="quote">&gt;&gt; &gt;&gt; b/drivers/gpu/drm/i915/gvt/kvmgt.c</span>
<span class="quote">&gt;&gt; &gt;&gt; index 389f072..a079080 100644</span>
<span class="quote">&gt;&gt; &gt;&gt; --- a/drivers/gpu/drm/i915/gvt/kvmgt.c</span>
<span class="quote">&gt;&gt; &gt;&gt; +++ b/drivers/gpu/drm/i915/gvt/kvmgt.c</span>
<span class="quote">&gt;&gt; &gt;&gt; @@ -41,6 +41,7 @@</span>
<span class="quote">&gt;&gt; &gt;&gt;  #include &lt;linux/kvm_host.h&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt;  #include &lt;linux/vfio.h&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt;  #include &lt;linux/mdev.h&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt; +#include &lt;linux/anon_inodes.h&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt;  #include &quot;i915_drv.h&quot;</span>
<span class="quote">&gt;&gt; &gt;&gt;  #include &quot;gvt.h&quot;</span>
<span class="quote">&gt;&gt; &gt;&gt; @@ -524,6 +525,125 @@ static int</span>
<span class="quote">&gt;&gt; &gt;&gt; intel_vgpu_reg_init_opregion(struct</span>
<span class="quote">&gt;&gt; &gt;intel_vgpu *vgpu)</span>
<span class="quote">&gt;&gt; &gt;&gt;  	return ret;</span>
<span class="quote">&gt;&gt; &gt;&gt;  }</span>
<span class="quote">&gt;&gt; &gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt; +static int kvmgt_get_vfio_device(struct intel_vgpu *vgpu) {</span>
<span class="quote">&gt;&gt; &gt;&gt; +	struct vfio_device *device;</span>
<span class="quote">&gt;&gt; &gt;&gt; +</span>
<span class="quote">&gt;&gt; &gt;&gt; +	device = vfio_device_get_from_dev(mdev_dev(vgpu-&gt;vdev.mdev));</span>
<span class="quote">&gt;&gt; &gt;&gt; +	if (device == NULL)</span>
<span class="quote">&gt;&gt; &gt;&gt; +		return -ENODEV;</span>
<span class="quote">&gt;&gt; &gt;&gt; +	vgpu-&gt;vdev.vfio_device = device;</span>
<span class="quote">&gt;&gt; &gt;&gt; +</span>
<span class="quote">&gt;&gt; &gt;&gt; +	return 0;</span>
<span class="quote">&gt;&gt; &gt;&gt; +}</span>
<span class="quote">&gt;&gt; &gt;&gt; +</span>
<span class="quote">&gt;&gt; &gt;&gt; +static void kvmgt_put_vfio_device(struct intel_vgpu *vgpu) {</span>
<span class="quote">&gt;&gt; &gt;&gt; +	vfio_device_put(vgpu-&gt;vdev.vfio_device);</span>
<span class="quote">&gt;&gt; &gt;&gt; +}</span>
<span class="quote">&gt;&gt; &gt;&gt; +</span>
<span class="quote">&gt;&gt; &gt;&gt; +static int intel_vgpu_dmabuf_mgr_fd_mmap(struct file *file,</span>
<span class="quote">&gt;&gt; &gt;&gt; +		struct vm_area_struct *vma)</span>
<span class="quote">&gt;&gt; &gt;&gt; +{</span>
<span class="quote">&gt;&gt; &gt;&gt; +	return -EPERM;</span>
<span class="quote">&gt;&gt; &gt;&gt; +}</span>
<span class="quote">&gt;&gt; &gt;&gt; +</span>
<span class="quote">&gt;&gt; &gt;&gt; +static int intel_vgpu_dmabuf_mgr_fd_release(struct inode *inode,</span>
<span class="quote">&gt;&gt; &gt;&gt; +		struct file *filp)</span>
<span class="quote">&gt;&gt; &gt;&gt; +{</span>
<span class="quote">&gt;&gt; &gt;&gt; +	struct intel_vgpu *vgpu = filp-&gt;private_data;</span>
<span class="quote">&gt;&gt; &gt;&gt; +	struct intel_vgpu_dmabuf_obj *obj;</span>
<span class="quote">&gt;&gt; &gt;&gt; +	struct list_head *pos;</span>
<span class="quote">&gt;&gt; &gt;&gt; +</span>
<span class="quote">&gt;&gt; &gt;&gt; +	if (WARN_ON(!vgpu-&gt;vdev.vfio_device))</span>
<span class="quote">&gt;&gt; &gt;&gt; +		return -ENODEV;</span>
<span class="quote">&gt;&gt; &gt;&gt; +</span>
<span class="quote">&gt;&gt; &gt;&gt; +	list_for_each(pos, &amp;vgpu-&gt;dmabuf_obj_list_head) {</span>
<span class="quote">&gt;&gt; &gt;&gt; +		obj = container_of(pos, struct intel_vgpu_dmabuf_obj, list);</span>
<span class="quote">&gt;&gt; &gt;&gt; +		if (WARN_ON(!obj))</span>
<span class="quote">&gt;&gt; &gt;&gt; +			return -ENODEV;</span>
<span class="quote">&gt;&gt; &gt;&gt; +		kfree(obj-&gt;obj-&gt;gvt_info);</span>
<span class="quote">&gt;&gt; &gt;&gt; +		i915_gem_object_put(obj-&gt;obj);</span>
<span class="quote">&gt;&gt; &gt;&gt; +		kfree(obj);</span>
<span class="quote">&gt;&gt; &gt;&gt; +		kvmgt_put_vfio_device(vgpu);</span>
<span class="quote">&gt;&gt; &gt;</span>
<span class="quote">&gt;&gt; &gt;Can we do this?  If I understand, we&#39;re releasing all the references</span>
<span class="quote">&gt;&gt; &gt;and allocations for the dmabuf fds on release of the manager fd.</span>
<span class="quote">&gt;&gt; &gt;What happens if the user continues trying to access those dmabuf fds after</span>
<span class="quote">&gt;this?</span>
<span class="quote">&gt;&gt; I think we can do this here.</span>
<span class="quote">&gt;&gt; The dma-buf&#39;s release function dma_buf_release() will be called by kernel which</span>
<span class="quote">&gt;means all the created dmabufs will be invalid even we do not release all the</span>
<span class="quote">&gt;references and allocations here.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;Are you assuming that the user has closed the dmabuf fds?  They could close the</span>
<span class="quote">&gt;manager fd first, should the dmabuf fd continue to work?</span>
If guest vm was shutdown it is ok system will release the allocated fds including the management fd and dmabuf fds.
But if user call the close() to close the management fd deliberately there are problems in current implementation.

Usually vendor of dma-buf defines its own dma_buf_ops(map, unmap, release.....) so vendor can release the reference and allocations in the release callback.
The calling sequence is: dma-buf framework&#39;s release()-&gt;vendor&#39;s dma-buf release(i915&#39;s in our case).

But in our case we did not create the dma-buf from the scratch but calling an existing i915 function i915_gem_prime_export() to create a dma-buf which use the i915&#39;s dma-buf-ops. 
In order to use this function we must create a gem object first(the reference count of the gem object is now 1!!!). 

When i915&#39;s dma-buf&#39;s release() callback is called it will try to free the gem object associated with the dma-buf if its ref count is 0. But in our case the ref count is 1 so no free callback is called so we can not release allocations there.
So we have to release our dma-buf releated allocations in the management fd&#39;s release callback which means the dma-bufs&#39; life cycle must the same with the management fd.

The reason we call i915_gem_prime_export() to create a dma-buf is we do not need to change the i915&#39;s dma-buf framework.

So: 1) we maintain current implementation that the dma-bufs have the same lifecycle with the management fd. User can not close the management fd. Or
        2) we create the dma-buf from scratch which need to change the dma-buf infrastructure of i915.

Chenxg
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt; +	}</span>
<span class="quote">&gt;&gt; &gt;&gt; +	kvmgt_put_vfio_device(vgpu);</span>
<span class="quote">&gt;&gt; &gt;&gt; +</span>
<span class="quote">&gt;&gt; &gt;&gt; +	return 0;</span>
<span class="quote">&gt;&gt; &gt;&gt; +}</span>
<span class="quote">&gt;&gt; &gt;&gt; +</span>
<span class="quote">&gt;&gt; &gt;&gt; +static long intel_vgpu_dmabuf_mgr_fd_ioctl(struct file *filp,</span>
<span class="quote">&gt;&gt; &gt;&gt; +		unsigned int ioctl, unsigned long arg) {</span>
<span class="quote">&gt;&gt; &gt;&gt; +	struct intel_vgpu *vgpu = filp-&gt;private_data;</span>
<span class="quote">&gt;&gt; &gt;&gt; +	int minsz;</span>
<span class="quote">&gt;&gt; &gt;&gt; +	int ret;</span>
<span class="quote">&gt;&gt; &gt;&gt; +	struct fd f;</span>
<span class="quote">&gt;&gt; &gt;&gt; +</span>
<span class="quote">&gt;&gt; &gt;&gt; +	f = fdget(vgpu-&gt;dmabuf_mgr_fd);</span>
<span class="quote">&gt;&gt; &gt;&gt; +	if (!f.file)</span>
<span class="quote">&gt;&gt; &gt;&gt; +		return -EBADF;</span>
<span class="quote">&gt;&gt; &gt;&gt; +</span>
<span class="quote">&gt;&gt; &gt;&gt; +	if (ioctl == VFIO_DEVICE_QUERY_PLANE) {</span>
<span class="quote">&gt;&gt; &gt;&gt; +		struct vfio_vgpu_plane_info info;</span>
<span class="quote">&gt;&gt; &gt;&gt; +</span>
<span class="quote">&gt;&gt; &gt;&gt; +		minsz = offsetofend(struct vfio_vgpu_plane_info, resv);</span>
<span class="quote">&gt;&gt; &gt;&gt; +		if (copy_from_user(&amp;info, (void __user *)arg, minsz)) {</span>
<span class="quote">&gt;&gt; &gt;&gt; +			fdput(f);</span>
<span class="quote">&gt;&gt; &gt;&gt; +			return -EFAULT;</span>
<span class="quote">&gt;&gt; &gt;&gt; +		}</span>
<span class="quote">&gt;&gt; &gt;&gt; +		if (info.argsz &lt; minsz) {</span>
<span class="quote">&gt;&gt; &gt;&gt; +			fdput(f);</span>
<span class="quote">&gt;&gt; &gt;&gt; +			return -EINVAL;</span>
<span class="quote">&gt;&gt; &gt;&gt; +		}</span>
<span class="quote">&gt;&gt; &gt;&gt; +		ret = intel_gvt_ops-&gt;vgpu_query_plane(vgpu, &amp;info);</span>
<span class="quote">&gt;&gt; &gt;&gt; +		if (ret != 0) {</span>
<span class="quote">&gt;&gt; &gt;&gt; +			fdput(f);</span>
<span class="quote">&gt;&gt; &gt;&gt; +			gvt_vgpu_err(&quot;query plane failed:%d\n&quot;, ret);</span>
<span class="quote">&gt;&gt; &gt;&gt; +			return -EINVAL;</span>
<span class="quote">&gt;&gt; &gt;&gt; +		}</span>
<span class="quote">&gt;&gt; &gt;&gt; +		fdput(f);</span>
<span class="quote">&gt;&gt; &gt;&gt; +		return copy_to_user((void __user *)arg, &amp;info, minsz) ?</span>
<span class="quote">&gt;&gt; &gt;&gt; +								-EFAULT : 0;</span>
<span class="quote">&gt;&gt; &gt;&gt; +	} else if (ioctl == VFIO_DEVICE_CREATE_DMABUF) {</span>
<span class="quote">&gt;&gt; &gt;&gt; +		struct vfio_vgpu_dmabuf_info dmabuf;</span>
<span class="quote">&gt;&gt; &gt;&gt; +</span>
<span class="quote">&gt;&gt; &gt;&gt; +		minsz = offsetofend(struct vfio_vgpu_dmabuf_info, resv);</span>
<span class="quote">&gt;&gt; &gt;&gt; +		if (copy_from_user(&amp;dmabuf, (void __user *)arg, minsz)) {</span>
<span class="quote">&gt;&gt; &gt;&gt; +			fdput(f);</span>
<span class="quote">&gt;&gt; &gt;&gt; +			return -EFAULT;</span>
<span class="quote">&gt;&gt; &gt;&gt; +		}</span>
<span class="quote">&gt;&gt; &gt;&gt; +		if (dmabuf.argsz &lt; minsz) {</span>
<span class="quote">&gt;&gt; &gt;&gt; +			fdput(f);</span>
<span class="quote">&gt;&gt; &gt;&gt; +			return -EINVAL;</span>
<span class="quote">&gt;&gt; &gt;&gt; +		}</span>
<span class="quote">&gt;&gt; &gt;&gt; +		ret = kvmgt_get_vfio_device(vgpu);</span>
<span class="quote">&gt;&gt; &gt;&gt; +		if (ret != 0)</span>
<span class="quote">&gt;&gt; &gt;&gt; +			return ret;</span>
<span class="quote">&gt;&gt; &gt;</span>
<span class="quote">&gt;&gt; &gt;Missed an fdput, though I&#39;m not sure I understand the value of the</span>
<span class="quote">&gt;&gt; &gt;original fdget or the dmabuf_mgr_fd field at all.  dmabuf_mgr_fd is</span>
<span class="quote">&gt;&gt; &gt;only used here, presumably to add a reference to the fd while we&#39;re</span>
<span class="quote">&gt;&gt; &gt;in the ioctl, but we&#39;re in the ioctl function of that fd, so I think there are</span>
<span class="quote">&gt;already references elsewhere.</span>
<span class="quote">&gt;&gt; Make sense. Fdget/fdput can be removed.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;</span>
<span class="quote">&gt;&gt; &gt;&gt; +</span>
<span class="quote">&gt;&gt; &gt;&gt; +		ret = intel_gvt_ops-&gt;vgpu_create_dmabuf(vgpu, &amp;dmabuf);</span>
<span class="quote">&gt;&gt; &gt;&gt; +		if (ret != 0) {</span>
<span class="quote">&gt;&gt; &gt;&gt; +			kvmgt_put_vfio_device(vgpu);</span>
<span class="quote">&gt;&gt; &gt;&gt; +			fdput(f);</span>
<span class="quote">&gt;&gt; &gt;&gt; +			return -EINVAL;</span>
<span class="quote">&gt;&gt; &gt;</span>
<span class="quote">&gt;&gt; &gt;Why not return the errno that vgpu_create_dmabuf provided?</span>
<span class="quote">&gt;&gt; Will change to use the returned errno.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;</span>
<span class="quote">&gt;&gt; &gt;&gt; +		}</span>
<span class="quote">&gt;&gt; &gt;&gt; +		fdput(f);</span>
<span class="quote">&gt;&gt; &gt;&gt; +		return copy_to_user((void __user *)arg, &amp;dmabuf, minsz) ?</span>
<span class="quote">&gt;&gt; &gt;&gt; +								-EFAULT : 0;</span>
<span class="quote">&gt;&gt; &gt;&gt; +	}</span>
<span class="quote">&gt;&gt; &gt;&gt; +</span>
<span class="quote">&gt;&gt; &gt;&gt; +	fdput(f);</span>
<span class="quote">&gt;&gt; &gt;&gt; +	gvt_vgpu_err(&quot;unsupported dmabuf operation\n&quot;);</span>
<span class="quote">&gt;&gt; &gt;&gt; +</span>
<span class="quote">&gt;&gt; &gt;&gt; +	return -EINVAL;</span>
<span class="quote">&gt;&gt; &gt;&gt; +}</span>
<span class="quote">&gt;&gt; &gt;&gt; +</span>
<span class="quote">&gt;&gt; &gt;&gt; +static const struct file_operations intel_vgpu_dmabuf_mgr_fd_ops = {</span>
<span class="quote">&gt;&gt; &gt;&gt; +	.release        = intel_vgpu_dmabuf_mgr_fd_release,</span>
<span class="quote">&gt;&gt; &gt;&gt; +	.unlocked_ioctl = intel_vgpu_dmabuf_mgr_fd_ioctl,</span>
<span class="quote">&gt;&gt; &gt;&gt; +	.mmap           = intel_vgpu_dmabuf_mgr_fd_mmap,</span>
<span class="quote">&gt;&gt; &gt;&gt; +	.llseek         = noop_llseek,</span>
<span class="quote">&gt;&gt; &gt;&gt; +};</span>
<span class="quote">&gt;&gt; &gt;&gt;  static int intel_vgpu_create(struct kobject *kobj, struct</span>
<span class="quote">&gt;&gt; &gt;&gt; mdev_device</span>
<span class="quote">&gt;&gt; &gt;&gt; *mdev)  {</span>
<span class="quote">&gt;&gt; &gt;&gt;  	struct intel_vgpu *vgpu = NULL;</span>
<span class="quote">&gt;&gt; &gt;&gt; @@ -1259,6 +1379,30 @@ static long intel_vgpu_ioctl(struct</span>
<span class="quote">&gt;&gt; &gt;&gt; mdev_device</span>
<span class="quote">&gt;&gt; &gt;*mdev, unsigned int cmd,</span>
<span class="quote">&gt;&gt; &gt;&gt;  	} else if (cmd == VFIO_DEVICE_RESET) {</span>
<span class="quote">&gt;&gt; &gt;&gt;  		intel_gvt_ops-&gt;vgpu_reset(vgpu);</span>
<span class="quote">&gt;&gt; &gt;&gt;  		return 0;</span>
<span class="quote">&gt;&gt; &gt;&gt; +	} else if (cmd == VFIO_DEVICE_GET_FD) {</span>
<span class="quote">&gt;&gt; &gt;&gt; +		int fd;</span>
<span class="quote">&gt;&gt; &gt;&gt; +		u32 type;</span>
<span class="quote">&gt;&gt; &gt;&gt; +		int ret;</span>
<span class="quote">&gt;&gt; &gt;&gt; +</span>
<span class="quote">&gt;&gt; &gt;&gt; +		if (copy_from_user(&amp;type, (void __user *)arg, sizeof(type)))</span>
<span class="quote">&gt;&gt; &gt;&gt; +			return -EINVAL;</span>
<span class="quote">&gt;&gt; &gt;&gt; +		if (type != VFIO_DEVICE_DMABUF_MGR_FD)</span>
<span class="quote">&gt;&gt; &gt;&gt; +			return -EINVAL;</span>
<span class="quote">&gt;&gt; &gt;&gt; +</span>
<span class="quote">&gt;&gt; &gt;&gt; +		ret = kvmgt_get_vfio_device(vgpu);</span>
<span class="quote">&gt;&gt; &gt;&gt; +		if (ret != 0)</span>
<span class="quote">&gt;&gt; &gt;&gt; +			return ret;</span>
<span class="quote">&gt;&gt; &gt;&gt; +</span>
<span class="quote">&gt;&gt; &gt;&gt; +		fd = anon_inode_getfd(&quot;intel-vgpu-dmabuf-mgr-fd&quot;,</span>
<span class="quote">&gt;&gt; &gt;&gt; +			&amp;intel_vgpu_dmabuf_mgr_fd_ops,</span>
<span class="quote">&gt;&gt; &gt;&gt; +			vgpu, O_RDWR | O_CLOEXEC);</span>
<span class="quote">&gt;&gt; &gt;&gt; +		if (fd &lt; 0) {</span>
<span class="quote">&gt;&gt; &gt;&gt; +			gvt_vgpu_err(&quot;create dmabuf mgr fd failed\n&quot;);</span>
<span class="quote">&gt;&gt; &gt;&gt; +			return -EINVAL;</span>
<span class="quote">&gt;&gt; &gt;</span>
<span class="quote">&gt;&gt; &gt;Error path leaks vfio_device reference.</span>
<span class="quote">&gt;&gt; Will correct in the next version.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;</span>
<span class="quote">&gt;&gt; &gt;&gt; +		}</span>
<span class="quote">&gt;&gt; &gt;&gt; +		vgpu-&gt;dmabuf_mgr_fd = fd;</span>
<span class="quote">&gt;&gt; &gt;</span>
<span class="quote">&gt;&gt; &gt;As above, unclear value of this field, additionally, what if the user</span>
<span class="quote">&gt;&gt; &gt;calls VFIO_DEVICE_GET_FD more than once?</span>
<span class="quote">&gt;&gt; Ah, good question.</span>
<span class="quote">&gt;&gt; VFIO_DEVICE_GET_FD should only be called once.</span>
<span class="quote">&gt;&gt; And we should add a check if the vgpu-&gt;dmabuf_mgr_fd is not 0 which means</span>
<span class="quote">&gt;VFIO_DEVICE_GET_FD had been called before we should return an error.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;Except we no longer need that fd and we should probably use an atomic &#39;opened&#39;</span>
<span class="quote">&gt;so it&#39;s not racy.  Thanks,</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;Alex</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt; +</span>
<span class="quote">&gt;&gt; &gt;&gt; +		return fd;</span>
<span class="quote">&gt;&gt; &gt;&gt;  	}</span>
<span class="quote">&gt;&gt; &gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt;  	return 0;</span>
<span class="quote">&gt;&gt; &gt;&gt; diff --git a/drivers/gpu/drm/i915/gvt/vgpu.c</span>
<span class="quote">&gt;&gt; &gt;&gt; b/drivers/gpu/drm/i915/gvt/vgpu.c index 6e3cbd8..af6fc74 100644</span>
<span class="quote">&gt;&gt; &gt;&gt; --- a/drivers/gpu/drm/i915/gvt/vgpu.c</span>
<span class="quote">&gt;&gt; &gt;&gt; +++ b/drivers/gpu/drm/i915/gvt/vgpu.c</span>
<span class="quote">&gt;&gt; &gt;&gt; @@ -346,6 +346,7 @@ static struct intel_vgpu</span>
<span class="quote">&gt;&gt; &gt;*__intel_gvt_create_vgpu(struct intel_gvt *gvt,</span>
<span class="quote">&gt;&gt; &gt;&gt;  	vgpu-&gt;gvt = gvt;</span>
<span class="quote">&gt;&gt; &gt;&gt;  	vgpu-&gt;sched_ctl.weight = param-&gt;weight;</span>
<span class="quote">&gt;&gt; &gt;&gt;  	bitmap_zero(vgpu-&gt;tlb_handle_pending, I915_NUM_ENGINES);</span>
<span class="quote">&gt;&gt; &gt;&gt; +	INIT_LIST_HEAD(&amp;vgpu-&gt;dmabuf_obj_list_head);</span>
<span class="quote">&gt;&gt; &gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt;  	intel_vgpu_init_cfg_space(vgpu, param-&gt;primary);</span>
<span class="quote">&gt;&gt; &gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7781">Alex Williamson</a> - June 2, 2017, 2:58 p.m.</div>
<pre class="content">
On Fri, 2 Jun 2017 09:31:41 +0000
&quot;Chen, Xiaoguang&quot; &lt;xiaoguang.chen@intel.com&gt; wrote:
<span class="quote">
&gt; &gt;-----Original Message-----</span>
<span class="quote">&gt; &gt;From: Alex Williamson [mailto:alex.williamson@redhat.com]</span>
<span class="quote">&gt; &gt;Sent: Friday, June 02, 2017 11:35 AM</span>
<span class="quote">&gt; &gt;To: Chen, Xiaoguang &lt;xiaoguang.chen@intel.com&gt;</span>
<span class="quote">&gt; &gt;Cc: kraxel@redhat.com; chris@chris-wilson.co.uk; intel-</span>
<span class="quote">&gt; &gt;gfx@lists.freedesktop.org; linux-kernel@vger.kernel.org;</span>
<span class="quote">&gt; &gt;zhenyuw@linux.intel.com; Lv, Zhiyuan &lt;zhiyuan.lv@intel.com&gt;; intel-gvt-</span>
<span class="quote">&gt; &gt;dev@lists.freedesktop.org; Wang, Zhi A &lt;zhi.a.wang@intel.com&gt;; Tian, Kevin</span>
<span class="quote">&gt; &gt;&lt;kevin.tian@intel.com&gt;</span>
<span class="quote">&gt; &gt;Subject: Re: [PATCH v6 6/6] drm/i915/gvt: Adding interface so user space can get</span>
<span class="quote">&gt; &gt;the dma-buf</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;On Fri, 2 Jun 2017 03:24:35 +0000</span>
<span class="quote">&gt; &gt;&quot;Chen, Xiaoguang&quot; &lt;xiaoguang.chen@intel.com&gt; wrote:</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;&gt; Hi Alex,</span>
<span class="quote">&gt; &gt;&gt;  </span>
<span class="quote">&gt; &gt;&gt; &gt;-----Original Message-----</span>
<span class="quote">&gt; &gt;&gt; &gt;From: Alex Williamson [mailto:alex.williamson@redhat.com]</span>
<span class="quote">&gt; &gt;&gt; &gt;Sent: Friday, June 02, 2017 2:08 AM</span>
<span class="quote">&gt; &gt;&gt; &gt;To: Chen, Xiaoguang &lt;xiaoguang.chen@intel.com&gt;</span>
<span class="quote">&gt; &gt;&gt; &gt;Cc: kraxel@redhat.com; chris@chris-wilson.co.uk; intel-</span>
<span class="quote">&gt; &gt;&gt; &gt;gfx@lists.freedesktop.org; linux-kernel@vger.kernel.org;</span>
<span class="quote">&gt; &gt;&gt; &gt;zhenyuw@linux.intel.com; Lv, Zhiyuan &lt;zhiyuan.lv@intel.com&gt;;</span>
<span class="quote">&gt; &gt;&gt; &gt;intel-gvt- dev@lists.freedesktop.org; Wang, Zhi A</span>
<span class="quote">&gt; &gt;&gt; &gt;&lt;zhi.a.wang@intel.com&gt;; Tian, Kevin &lt;kevin.tian@intel.com&gt;</span>
<span class="quote">&gt; &gt;&gt; &gt;Subject: Re: [PATCH v6 6/6] drm/i915/gvt: Adding interface so user</span>
<span class="quote">&gt; &gt;&gt; &gt;space can get the dma-buf</span>
<span class="quote">&gt; &gt;&gt; &gt;</span>
<span class="quote">&gt; &gt;&gt; &gt;On Sat, 27 May 2017 16:38:52 +0800</span>
<span class="quote">&gt; &gt;&gt; &gt;Xiaoguang Chen &lt;xiaoguang.chen@intel.com&gt; wrote:</span>
<span class="quote">&gt; &gt;&gt; &gt;  </span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; User space should create the management fd for the dma-buf operation first.</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; Then user can query the plane information and create dma-buf if</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; necessary using the management fd.</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; Signed-off-by: Xiaoguang Chen &lt;xiaoguang.chen@intel.com&gt;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; ---</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;  drivers/gpu/drm/i915/gvt/dmabuf.c |  12 ++++</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;  drivers/gpu/drm/i915/gvt/dmabuf.h |   5 ++</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;  drivers/gpu/drm/i915/gvt/gvt.c    |   2 +</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;  drivers/gpu/drm/i915/gvt/gvt.h    |   5 ++</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;  drivers/gpu/drm/i915/gvt/kvmgt.c  | 144  </span>
<span class="quote">&gt; &gt;&gt; &gt;++++++++++++++++++++++++++++++++++++++  </span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;  drivers/gpu/drm/i915/gvt/vgpu.c   |   1 +</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;  6 files changed, 169 insertions(+)</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; diff --git a/drivers/gpu/drm/i915/gvt/dmabuf.c</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; b/drivers/gpu/drm/i915/gvt/dmabuf.c</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; index c831e91..9759e9a 100644</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; --- a/drivers/gpu/drm/i915/gvt/dmabuf.c</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +++ b/drivers/gpu/drm/i915/gvt/dmabuf.c</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; @@ -226,6 +226,7 @@ int intel_vgpu_create_dmabuf(struct intel_vgpu</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; *vgpu,  </span>
<span class="quote">&gt; &gt;&gt; &gt;void *args)  </span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;  	struct vfio_vgpu_dmabuf_info *gvt_dmabuf = args;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;  	struct intel_vgpu_fb_info *fb_info;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;  	int ret;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +	struct intel_vgpu_dmabuf_obj *dmabuf_obj;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;  	ret = intel_vgpu_get_plane_info(dev, vgpu, &amp;gvt_dmabuf-&gt;plane_info);</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;  	if (ret != 0)</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; @@ -263,6 +264,17 @@ int intel_vgpu_create_dmabuf(struct intel_vgpu</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; *vgpu,  </span>
<span class="quote">&gt; &gt;&gt; &gt;void *args)  </span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;  		gvt_vgpu_err(&quot;create dma-buf fd failed ret:%d\n&quot;, ret);</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;  		return ret;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;  	}</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +	dmabuf_obj = kmalloc(sizeof(*dmabuf_obj), GFP_KERNEL);</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +	if (dmabuf_obj == NULL) {</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +		kfree(fb_info);</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +		i915_gem_object_put(obj);</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +		gvt_vgpu_err(&quot;alloc dmabuf_obj failed\n&quot;);</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +		return -ENOMEM;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +	}</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +	dmabuf_obj-&gt;obj = obj;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +	INIT_LIST_HEAD(&amp;dmabuf_obj-&gt;list);</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +	list_add_tail(&amp;dmabuf_obj-&gt;list, &amp;vgpu-&gt;dmabuf_obj_list_head);</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;  	gvt_dmabuf-&gt;fd = ret;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;  	return 0;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; diff --git a/drivers/gpu/drm/i915/gvt/dmabuf.h</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; b/drivers/gpu/drm/i915/gvt/dmabuf.h</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; index 8be9979..cafa781 100644</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; --- a/drivers/gpu/drm/i915/gvt/dmabuf.h</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +++ b/drivers/gpu/drm/i915/gvt/dmabuf.h</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; @@ -31,6 +31,11 @@ struct intel_vgpu_fb_info {</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;  	uint32_t fb_size;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;  };</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +struct intel_vgpu_dmabuf_obj {</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +	struct drm_i915_gem_object *obj;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +	struct list_head list;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +};</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;  int intel_vgpu_query_plane(struct intel_vgpu *vgpu, void *args);</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; int intel_vgpu_create_dmabuf(struct intel_vgpu *vgpu, void *args);</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; diff --git a/drivers/gpu/drm/i915/gvt/gvt.c</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; b/drivers/gpu/drm/i915/gvt/gvt.c index 2032917..dbc3f86 100644</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; --- a/drivers/gpu/drm/i915/gvt/gvt.c</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +++ b/drivers/gpu/drm/i915/gvt/gvt.c</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; @@ -54,6 +54,8 @@ static const struct intel_gvt_ops intel_gvt_ops = {</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;  	.vgpu_reset = intel_gvt_reset_vgpu,</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;  	.vgpu_activate = intel_gvt_activate_vgpu,</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;  	.vgpu_deactivate = intel_gvt_deactivate_vgpu,</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +	.vgpu_query_plane = intel_vgpu_query_plane,</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +	.vgpu_create_dmabuf = intel_vgpu_create_dmabuf,</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;  };</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;  /**</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; diff --git a/drivers/gpu/drm/i915/gvt/gvt.h</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; b/drivers/gpu/drm/i915/gvt/gvt.h index 763a8c5..a855797 100644</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; --- a/drivers/gpu/drm/i915/gvt/gvt.h</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +++ b/drivers/gpu/drm/i915/gvt/gvt.h</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; @@ -185,8 +185,11 @@ struct intel_vgpu {</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;  		struct kvm *kvm;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;  		struct work_struct release_work;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;  		atomic_t released;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +		struct vfio_device *vfio_device;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;  	} vdev;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;  #endif</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +	int dmabuf_mgr_fd;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +	struct list_head dmabuf_obj_list_head;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;  };</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;  struct intel_gvt_gm {</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; @@ -467,6 +470,8 @@ struct intel_gvt_ops {</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;  	void (*vgpu_reset)(struct intel_vgpu *);</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;  	void (*vgpu_activate)(struct intel_vgpu *);</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;  	void (*vgpu_deactivate)(struct intel_vgpu *);</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +	int (*vgpu_query_plane)(struct intel_vgpu *vgpu, void *);</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +	int (*vgpu_create_dmabuf)(struct intel_vgpu *vgpu, void *);</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;  };</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; diff --git a/drivers/gpu/drm/i915/gvt/kvmgt.c</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; b/drivers/gpu/drm/i915/gvt/kvmgt.c</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; index 389f072..a079080 100644</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; --- a/drivers/gpu/drm/i915/gvt/kvmgt.c</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +++ b/drivers/gpu/drm/i915/gvt/kvmgt.c</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; @@ -41,6 +41,7 @@</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;  #include &lt;linux/kvm_host.h&gt;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;  #include &lt;linux/vfio.h&gt;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;  #include &lt;linux/mdev.h&gt;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +#include &lt;linux/anon_inodes.h&gt;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;  #include &quot;i915_drv.h&quot;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;  #include &quot;gvt.h&quot;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; @@ -524,6 +525,125 @@ static int</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; intel_vgpu_reg_init_opregion(struct  </span>
<span class="quote">&gt; &gt;&gt; &gt;intel_vgpu *vgpu)  </span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;  	return ret;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;  }</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +static int kvmgt_get_vfio_device(struct intel_vgpu *vgpu) {</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +	struct vfio_device *device;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +	device = vfio_device_get_from_dev(mdev_dev(vgpu-&gt;vdev.mdev));</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +	if (device == NULL)</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +		return -ENODEV;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +	vgpu-&gt;vdev.vfio_device = device;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +	return 0;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +}</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +static void kvmgt_put_vfio_device(struct intel_vgpu *vgpu) {</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +	vfio_device_put(vgpu-&gt;vdev.vfio_device);</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +}</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +static int intel_vgpu_dmabuf_mgr_fd_mmap(struct file *file,</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +		struct vm_area_struct *vma)</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +{</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +	return -EPERM;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +}</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +static int intel_vgpu_dmabuf_mgr_fd_release(struct inode *inode,</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +		struct file *filp)</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +{</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +	struct intel_vgpu *vgpu = filp-&gt;private_data;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +	struct intel_vgpu_dmabuf_obj *obj;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +	struct list_head *pos;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +	if (WARN_ON(!vgpu-&gt;vdev.vfio_device))</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +		return -ENODEV;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +	list_for_each(pos, &amp;vgpu-&gt;dmabuf_obj_list_head) {</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +		obj = container_of(pos, struct intel_vgpu_dmabuf_obj, list);</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +		if (WARN_ON(!obj))</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +			return -ENODEV;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +		kfree(obj-&gt;obj-&gt;gvt_info);</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +		i915_gem_object_put(obj-&gt;obj);</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +		kfree(obj);</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +		kvmgt_put_vfio_device(vgpu);  </span>
<span class="quote">&gt; &gt;&gt; &gt;</span>
<span class="quote">&gt; &gt;&gt; &gt;Can we do this?  If I understand, we&#39;re releasing all the references</span>
<span class="quote">&gt; &gt;&gt; &gt;and allocations for the dmabuf fds on release of the manager fd.</span>
<span class="quote">&gt; &gt;&gt; &gt;What happens if the user continues trying to access those dmabuf fds after  </span>
<span class="quote">&gt; &gt;this?  </span>
<span class="quote">&gt; &gt;&gt; I think we can do this here.</span>
<span class="quote">&gt; &gt;&gt; The dma-buf&#39;s release function dma_buf_release() will be called by kernel which  </span>
<span class="quote">&gt; &gt;means all the created dmabufs will be invalid even we do not release all the</span>
<span class="quote">&gt; &gt;references and allocations here.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;Are you assuming that the user has closed the dmabuf fds?  They could close the</span>
<span class="quote">&gt; &gt;manager fd first, should the dmabuf fd continue to work?  </span>
<span class="quote">&gt; If guest vm was shutdown it is ok system will release the allocated fds including the management fd and dmabuf fds.</span>
<span class="quote">&gt; But if user call the close() to close the management fd deliberately there are problems in current implementation.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Usually vendor of dma-buf defines its own dma_buf_ops(map, unmap, release.....) so vendor can release the reference and allocations in the release callback.</span>
<span class="quote">&gt; The calling sequence is: dma-buf framework&#39;s release()-&gt;vendor&#39;s dma-buf release(i915&#39;s in our case).</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; But in our case we did not create the dma-buf from the scratch but calling an existing i915 function i915_gem_prime_export() to create a dma-buf which use the i915&#39;s dma-buf-ops. </span>
<span class="quote">&gt; In order to use this function we must create a gem object first(the reference count of the gem object is now 1!!!). </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; When i915&#39;s dma-buf&#39;s release() callback is called it will try to free the gem object associated with the dma-buf if its ref count is 0. But in our case the ref count is 1 so no free callback is called so we can not release allocations there.</span>
<span class="quote">&gt; So we have to release our dma-buf releated allocations in the management fd&#39;s release callback which means the dma-bufs&#39; life cycle must the same with the management fd.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The reason we call i915_gem_prime_export() to create a dma-buf is we do not need to change the i915&#39;s dma-buf framework.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; So: 1) we maintain current implementation that the dma-bufs have the same lifecycle with the management fd. User can not close the management fd. Or</span>
<span class="quote">&gt;         2) we create the dma-buf from scratch which need to change the dma-buf infrastructure of i915.</span>

We cannot simply say that the user isn&#39;t allowed to release them in
that order.  If they do, how does it break, including what might mmaps
into those dmabufs provide them access to after the underlying object is
removed. If the policy is that the management fd cannot be released
until the dmabufs are closed, then that needs to be actively enforced.
Otherwise it needs to be supported.  Requiring changes to dmabuf
handling in the i915 code isn&#39;t an excuse IMO.  Thanks,

Alex
<span class="quote">
&gt; &gt;&gt; &gt;&gt; +	}</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +	kvmgt_put_vfio_device(vgpu);</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +	return 0;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +}</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +static long intel_vgpu_dmabuf_mgr_fd_ioctl(struct file *filp,</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +		unsigned int ioctl, unsigned long arg) {</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +	struct intel_vgpu *vgpu = filp-&gt;private_data;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +	int minsz;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +	int ret;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +	struct fd f;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +	f = fdget(vgpu-&gt;dmabuf_mgr_fd);</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +	if (!f.file)</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +		return -EBADF;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +	if (ioctl == VFIO_DEVICE_QUERY_PLANE) {</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +		struct vfio_vgpu_plane_info info;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +		minsz = offsetofend(struct vfio_vgpu_plane_info, resv);</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +		if (copy_from_user(&amp;info, (void __user *)arg, minsz)) {</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +			fdput(f);</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +			return -EFAULT;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +		}</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +		if (info.argsz &lt; minsz) {</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +			fdput(f);</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +			return -EINVAL;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +		}</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +		ret = intel_gvt_ops-&gt;vgpu_query_plane(vgpu, &amp;info);</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +		if (ret != 0) {</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +			fdput(f);</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +			gvt_vgpu_err(&quot;query plane failed:%d\n&quot;, ret);</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +			return -EINVAL;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +		}</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +		fdput(f);</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +		return copy_to_user((void __user *)arg, &amp;info, minsz) ?</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +								-EFAULT : 0;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +	} else if (ioctl == VFIO_DEVICE_CREATE_DMABUF) {</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +		struct vfio_vgpu_dmabuf_info dmabuf;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +		minsz = offsetofend(struct vfio_vgpu_dmabuf_info, resv);</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +		if (copy_from_user(&amp;dmabuf, (void __user *)arg, minsz)) {</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +			fdput(f);</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +			return -EFAULT;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +		}</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +		if (dmabuf.argsz &lt; minsz) {</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +			fdput(f);</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +			return -EINVAL;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +		}</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +		ret = kvmgt_get_vfio_device(vgpu);</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +		if (ret != 0)</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +			return ret;  </span>
<span class="quote">&gt; &gt;&gt; &gt;</span>
<span class="quote">&gt; &gt;&gt; &gt;Missed an fdput, though I&#39;m not sure I understand the value of the</span>
<span class="quote">&gt; &gt;&gt; &gt;original fdget or the dmabuf_mgr_fd field at all.  dmabuf_mgr_fd is</span>
<span class="quote">&gt; &gt;&gt; &gt;only used here, presumably to add a reference to the fd while we&#39;re</span>
<span class="quote">&gt; &gt;&gt; &gt;in the ioctl, but we&#39;re in the ioctl function of that fd, so I think there are  </span>
<span class="quote">&gt; &gt;already references elsewhere.  </span>
<span class="quote">&gt; &gt;&gt; Make sense. Fdget/fdput can be removed.</span>
<span class="quote">&gt; &gt;&gt;  </span>
<span class="quote">&gt; &gt;&gt; &gt;  </span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +		ret = intel_gvt_ops-&gt;vgpu_create_dmabuf(vgpu, &amp;dmabuf);</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +		if (ret != 0) {</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +			kvmgt_put_vfio_device(vgpu);</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +			fdput(f);</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +			return -EINVAL;  </span>
<span class="quote">&gt; &gt;&gt; &gt;</span>
<span class="quote">&gt; &gt;&gt; &gt;Why not return the errno that vgpu_create_dmabuf provided?  </span>
<span class="quote">&gt; &gt;&gt; Will change to use the returned errno.</span>
<span class="quote">&gt; &gt;&gt;  </span>
<span class="quote">&gt; &gt;&gt; &gt;  </span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +		}</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +		fdput(f);</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +		return copy_to_user((void __user *)arg, &amp;dmabuf, minsz) ?</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +								-EFAULT : 0;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +	}</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +	fdput(f);</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +	gvt_vgpu_err(&quot;unsupported dmabuf operation\n&quot;);</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +	return -EINVAL;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +}</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +static const struct file_operations intel_vgpu_dmabuf_mgr_fd_ops = {</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +	.release        = intel_vgpu_dmabuf_mgr_fd_release,</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +	.unlocked_ioctl = intel_vgpu_dmabuf_mgr_fd_ioctl,</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +	.mmap           = intel_vgpu_dmabuf_mgr_fd_mmap,</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +	.llseek         = noop_llseek,</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +};</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;  static int intel_vgpu_create(struct kobject *kobj, struct</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; mdev_device</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; *mdev)  {</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;  	struct intel_vgpu *vgpu = NULL;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; @@ -1259,6 +1379,30 @@ static long intel_vgpu_ioctl(struct</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; mdev_device  </span>
<span class="quote">&gt; &gt;&gt; &gt;*mdev, unsigned int cmd,  </span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;  	} else if (cmd == VFIO_DEVICE_RESET) {</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;  		intel_gvt_ops-&gt;vgpu_reset(vgpu);</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;  		return 0;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +	} else if (cmd == VFIO_DEVICE_GET_FD) {</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +		int fd;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +		u32 type;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +		int ret;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +		if (copy_from_user(&amp;type, (void __user *)arg, sizeof(type)))</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +			return -EINVAL;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +		if (type != VFIO_DEVICE_DMABUF_MGR_FD)</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +			return -EINVAL;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +		ret = kvmgt_get_vfio_device(vgpu);</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +		if (ret != 0)</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +			return ret;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +		fd = anon_inode_getfd(&quot;intel-vgpu-dmabuf-mgr-fd&quot;,</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +			&amp;intel_vgpu_dmabuf_mgr_fd_ops,</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +			vgpu, O_RDWR | O_CLOEXEC);</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +		if (fd &lt; 0) {</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +			gvt_vgpu_err(&quot;create dmabuf mgr fd failed\n&quot;);</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +			return -EINVAL;  </span>
<span class="quote">&gt; &gt;&gt; &gt;</span>
<span class="quote">&gt; &gt;&gt; &gt;Error path leaks vfio_device reference.  </span>
<span class="quote">&gt; &gt;&gt; Will correct in the next version.</span>
<span class="quote">&gt; &gt;&gt;  </span>
<span class="quote">&gt; &gt;&gt; &gt;  </span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +		}</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +		vgpu-&gt;dmabuf_mgr_fd = fd;  </span>
<span class="quote">&gt; &gt;&gt; &gt;</span>
<span class="quote">&gt; &gt;&gt; &gt;As above, unclear value of this field, additionally, what if the user</span>
<span class="quote">&gt; &gt;&gt; &gt;calls VFIO_DEVICE_GET_FD more than once?  </span>
<span class="quote">&gt; &gt;&gt; Ah, good question.</span>
<span class="quote">&gt; &gt;&gt; VFIO_DEVICE_GET_FD should only be called once.</span>
<span class="quote">&gt; &gt;&gt; And we should add a check if the vgpu-&gt;dmabuf_mgr_fd is not 0 which means  </span>
<span class="quote">&gt; &gt;VFIO_DEVICE_GET_FD had been called before we should return an error.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;Except we no longer need that fd and we should probably use an atomic &#39;opened&#39;</span>
<span class="quote">&gt; &gt;so it&#39;s not racy.  Thanks,</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;Alex</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +		return fd;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;  	}</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;  	return 0;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; diff --git a/drivers/gpu/drm/i915/gvt/vgpu.c</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; b/drivers/gpu/drm/i915/gvt/vgpu.c index 6e3cbd8..af6fc74 100644</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; --- a/drivers/gpu/drm/i915/gvt/vgpu.c</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +++ b/drivers/gpu/drm/i915/gvt/vgpu.c</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; @@ -346,6 +346,7 @@ static struct intel_vgpu  </span>
<span class="quote">&gt; &gt;&gt; &gt;*__intel_gvt_create_vgpu(struct intel_gvt *gvt,  </span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;  	vgpu-&gt;gvt = gvt;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;  	vgpu-&gt;sched_ctl.weight = param-&gt;weight;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;  	bitmap_zero(vgpu-&gt;tlb_handle_pending, I915_NUM_ENGINES);</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; +	INIT_LIST_HEAD(&amp;vgpu-&gt;dmabuf_obj_list_head);</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;  	intel_vgpu_init_cfg_space(vgpu, param-&gt;primary);</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;  </span>
<span class="quote">&gt; &gt;&gt;  </span>
<span class="quote">&gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=690">Gerd Hoffmann</a> - June 2, 2017, 3:23 p.m.</div>
<pre class="content">
Hi,
<span class="quote">
&gt; &gt; When i915&#39;s dma-buf&#39;s release() callback is called it will try to</span>
<span class="quote">&gt; &gt; free the gem object associated with the dma-buf if its ref count is</span>
<span class="quote">&gt; &gt; 0. But in our case the ref count is 1 so no free callback is called</span>
<span class="quote">&gt; &gt; so we can not release allocations there.</span>

Why the ref count is one?  Who holds a reference and why?
Maybe it should be the other way around, i.e. the dmabuf holds a
reference on the vgpu instance backing it, i.e. you can&#39;t delete the
vgpu while dma-bufs exist?
<span class="quote">
&gt; We cannot simply say that the user isn&#39;t allowed to release them in</span>
<span class="quote">&gt; that order.</span>

Yep, not going to fly.  Can happen even unintentionally because we can
pass around dmabufs to other processes.  Example: qemu passes dmabuf to
spice-client, then qemu crashes.  mgmt fd is closed before dmabuf fd
then.  The kernel must be able to handle that.

cheers,
  Gerd
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=170581">Xiaoguang Chen</a> - June 5, 2017, 2:39 a.m.</div>
<pre class="content">
Hi, 
<span class="quote">
&gt;-----Original Message-----</span>
<span class="quote">&gt;From: intel-gvt-dev [mailto:intel-gvt-dev-bounces@lists.freedesktop.org] On</span>
<span class="quote">&gt;Behalf Of Gerd Hoffmann</span>
<span class="quote">&gt;Sent: Friday, June 02, 2017 11:24 PM</span>
<span class="quote">&gt;To: Alex Williamson &lt;alex.williamson@redhat.com&gt;; Chen, Xiaoguang</span>
<span class="quote">&gt;&lt;xiaoguang.chen@intel.com&gt;</span>
<span class="quote">&gt;Cc: Tian, Kevin &lt;kevin.tian@intel.com&gt;; intel-gfx@lists.freedesktop.org; linux-</span>
<span class="quote">&gt;kernel@vger.kernel.org; zhenyuw@linux.intel.com; chris@chris-wilson.co.uk; Lv,</span>
<span class="quote">&gt;Zhiyuan &lt;zhiyuan.lv@intel.com&gt;; intel-gvt-dev@lists.freedesktop.org; Wang, Zhi</span>
<span class="quote">&gt;A &lt;zhi.a.wang@intel.com&gt;</span>
<span class="quote">&gt;Subject: Re: [PATCH v6 6/6] drm/i915/gvt: Adding interface so user space can get</span>
<span class="quote">&gt;the dma-buf</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;  Hi,</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; &gt; When i915&#39;s dma-buf&#39;s release() callback is called it will try to</span>
<span class="quote">&gt;&gt; &gt; free the gem object associated with the dma-buf if its ref count is</span>
<span class="quote">&gt;&gt; &gt; 0. But in our case the ref count is 1 so no free callback is called</span>
<span class="quote">&gt;&gt; &gt; so we can not release allocations there.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;Why the ref count is one?  </span>
The gem object is created by us while creating the dma-buf(the ref count of the gem object is initialized to 1).
Later when user import the dma-buf the ref count of the gem object associate with the dma-buf will increased.
When user finished using the dma-buf it will decrease the ref count.
But the ref count of the gem object will become 1 when all the user finished using the dma-buf because we create the gem object(the test also showing this result).

Typically user only export a dma-buf(no gem object yet) then when user import the dma-buf then a gem object will be created.
But in our case we do not implement the dma-buf from scratch but calling the i915_gem_prime_export() where a gem object is an input parameter.

Chenxg
<span class="quote">

&gt;Who holds a reference and why?</span>
<span class="quote">&gt;Maybe it should be the other way around, i.e. the dmabuf holds a reference on</span>
<span class="quote">&gt;the vgpu instance backing it, i.e. you can&#39;t delete the vgpu while dma-bufs exist?</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; We cannot simply say that the user isn&#39;t allowed to release them in</span>
<span class="quote">&gt;&gt; that order.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;Yep, not going to fly.  Can happen even unintentionally because we can pass</span>
<span class="quote">&gt;around dmabufs to other processes.  Example: qemu passes dmabuf to spice-</span>
<span class="quote">&gt;client, then qemu crashes.  mgmt fd is closed before dmabuf fd then.  The kernel</span>
<span class="quote">&gt;must be able to handle that.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;cheers,</span>
<span class="quote">&gt;  Gerd</span>
<span class="quote">&gt;_______________________________________________</span>
<span class="quote">&gt;intel-gvt-dev mailing list</span>
<span class="quote">&gt;intel-gvt-dev@lists.freedesktop.org</span>
<span class="quote">&gt;https://lists.freedesktop.org/mailman/listinfo/intel-gvt-dev</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=690">Gerd Hoffmann</a> - June 6, 2017, 7:35 a.m.</div>
<pre class="content">
Hi,
<span class="quote">
&gt; &gt; Why the ref count is one?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The gem object is created by us while creating the dma-buf(the ref</span>
<span class="quote">&gt; count of the gem object is initialized to 1).</span>
<span class="quote">&gt; Later when user import the dma-buf the ref count of the gem object</span>
<span class="quote">&gt; associate with the dma-buf will increased.</span>

Creating the dma-buf should increase the gem object reference count
too.  So you should be able to unref the gem object after creating the
dma-buf.  That way the dma-buf is the only instance holding a reference
to the gem object, and when the dma-buf goes away (due to userspace
closing all file handles referring to it) the gem object will be
released too because the refcount goes down to zero then.

cheers,
  Gerd
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/drivers/gpu/drm/i915/gvt/dmabuf.c b/drivers/gpu/drm/i915/gvt/dmabuf.c</span>
<span class="p_header">index c831e91..9759e9a 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/gvt/dmabuf.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/gvt/dmabuf.c</span>
<span class="p_chunk">@@ -226,6 +226,7 @@</span> <span class="p_context"> int intel_vgpu_create_dmabuf(struct intel_vgpu *vgpu, void *args)</span>
 	struct vfio_vgpu_dmabuf_info *gvt_dmabuf = args;
 	struct intel_vgpu_fb_info *fb_info;
 	int ret;
<span class="p_add">+	struct intel_vgpu_dmabuf_obj *dmabuf_obj;</span>
 
 	ret = intel_vgpu_get_plane_info(dev, vgpu, &amp;gvt_dmabuf-&gt;plane_info);
 	if (ret != 0)
<span class="p_chunk">@@ -263,6 +264,17 @@</span> <span class="p_context"> int intel_vgpu_create_dmabuf(struct intel_vgpu *vgpu, void *args)</span>
 		gvt_vgpu_err(&quot;create dma-buf fd failed ret:%d\n&quot;, ret);
 		return ret;
 	}
<span class="p_add">+	dmabuf_obj = kmalloc(sizeof(*dmabuf_obj), GFP_KERNEL);</span>
<span class="p_add">+	if (dmabuf_obj == NULL) {</span>
<span class="p_add">+		kfree(fb_info);</span>
<span class="p_add">+		i915_gem_object_put(obj);</span>
<span class="p_add">+		gvt_vgpu_err(&quot;alloc dmabuf_obj failed\n&quot;);</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	dmabuf_obj-&gt;obj = obj;</span>
<span class="p_add">+	INIT_LIST_HEAD(&amp;dmabuf_obj-&gt;list);</span>
<span class="p_add">+	list_add_tail(&amp;dmabuf_obj-&gt;list, &amp;vgpu-&gt;dmabuf_obj_list_head);</span>
<span class="p_add">+</span>
 	gvt_dmabuf-&gt;fd = ret;
 
 	return 0;
<span class="p_header">diff --git a/drivers/gpu/drm/i915/gvt/dmabuf.h b/drivers/gpu/drm/i915/gvt/dmabuf.h</span>
<span class="p_header">index 8be9979..cafa781 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/gvt/dmabuf.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/gvt/dmabuf.h</span>
<span class="p_chunk">@@ -31,6 +31,11 @@</span> <span class="p_context"> struct intel_vgpu_fb_info {</span>
 	uint32_t fb_size;
 };
 
<span class="p_add">+struct intel_vgpu_dmabuf_obj {</span>
<span class="p_add">+	struct drm_i915_gem_object *obj;</span>
<span class="p_add">+	struct list_head list;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 int intel_vgpu_query_plane(struct intel_vgpu *vgpu, void *args);
 int intel_vgpu_create_dmabuf(struct intel_vgpu *vgpu, void *args);
 
<span class="p_header">diff --git a/drivers/gpu/drm/i915/gvt/gvt.c b/drivers/gpu/drm/i915/gvt/gvt.c</span>
<span class="p_header">index 2032917..dbc3f86 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/gvt/gvt.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/gvt/gvt.c</span>
<span class="p_chunk">@@ -54,6 +54,8 @@</span> <span class="p_context"> static const struct intel_gvt_ops intel_gvt_ops = {</span>
 	.vgpu_reset = intel_gvt_reset_vgpu,
 	.vgpu_activate = intel_gvt_activate_vgpu,
 	.vgpu_deactivate = intel_gvt_deactivate_vgpu,
<span class="p_add">+	.vgpu_query_plane = intel_vgpu_query_plane,</span>
<span class="p_add">+	.vgpu_create_dmabuf = intel_vgpu_create_dmabuf,</span>
 };
 
 /**
<span class="p_header">diff --git a/drivers/gpu/drm/i915/gvt/gvt.h b/drivers/gpu/drm/i915/gvt/gvt.h</span>
<span class="p_header">index 763a8c5..a855797 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/gvt/gvt.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/gvt/gvt.h</span>
<span class="p_chunk">@@ -185,8 +185,11 @@</span> <span class="p_context"> struct intel_vgpu {</span>
 		struct kvm *kvm;
 		struct work_struct release_work;
 		atomic_t released;
<span class="p_add">+		struct vfio_device *vfio_device;</span>
 	} vdev;
 #endif
<span class="p_add">+	int dmabuf_mgr_fd;</span>
<span class="p_add">+	struct list_head dmabuf_obj_list_head;</span>
 };
 
 struct intel_gvt_gm {
<span class="p_chunk">@@ -467,6 +470,8 @@</span> <span class="p_context"> struct intel_gvt_ops {</span>
 	void (*vgpu_reset)(struct intel_vgpu *);
 	void (*vgpu_activate)(struct intel_vgpu *);
 	void (*vgpu_deactivate)(struct intel_vgpu *);
<span class="p_add">+	int (*vgpu_query_plane)(struct intel_vgpu *vgpu, void *);</span>
<span class="p_add">+	int (*vgpu_create_dmabuf)(struct intel_vgpu *vgpu, void *);</span>
 };
 
 
<span class="p_header">diff --git a/drivers/gpu/drm/i915/gvt/kvmgt.c b/drivers/gpu/drm/i915/gvt/kvmgt.c</span>
<span class="p_header">index 389f072..a079080 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/gvt/kvmgt.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/gvt/kvmgt.c</span>
<span class="p_chunk">@@ -41,6 +41,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/kvm_host.h&gt;
 #include &lt;linux/vfio.h&gt;
 #include &lt;linux/mdev.h&gt;
<span class="p_add">+#include &lt;linux/anon_inodes.h&gt;</span>
 
 #include &quot;i915_drv.h&quot;
 #include &quot;gvt.h&quot;
<span class="p_chunk">@@ -524,6 +525,125 @@</span> <span class="p_context"> static int intel_vgpu_reg_init_opregion(struct intel_vgpu *vgpu)</span>
 	return ret;
 }
 
<span class="p_add">+static int kvmgt_get_vfio_device(struct intel_vgpu *vgpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct vfio_device *device;</span>
<span class="p_add">+</span>
<span class="p_add">+	device = vfio_device_get_from_dev(mdev_dev(vgpu-&gt;vdev.mdev));</span>
<span class="p_add">+	if (device == NULL)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+	vgpu-&gt;vdev.vfio_device = device;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void kvmgt_put_vfio_device(struct intel_vgpu *vgpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	vfio_device_put(vgpu-&gt;vdev.vfio_device);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int intel_vgpu_dmabuf_mgr_fd_mmap(struct file *file,</span>
<span class="p_add">+		struct vm_area_struct *vma)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return -EPERM;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int intel_vgpu_dmabuf_mgr_fd_release(struct inode *inode,</span>
<span class="p_add">+		struct file *filp)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct intel_vgpu *vgpu = filp-&gt;private_data;</span>
<span class="p_add">+	struct intel_vgpu_dmabuf_obj *obj;</span>
<span class="p_add">+	struct list_head *pos;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (WARN_ON(!vgpu-&gt;vdev.vfio_device))</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
<span class="p_add">+	list_for_each(pos, &amp;vgpu-&gt;dmabuf_obj_list_head) {</span>
<span class="p_add">+		obj = container_of(pos, struct intel_vgpu_dmabuf_obj, list);</span>
<span class="p_add">+		if (WARN_ON(!obj))</span>
<span class="p_add">+			return -ENODEV;</span>
<span class="p_add">+		kfree(obj-&gt;obj-&gt;gvt_info);</span>
<span class="p_add">+		i915_gem_object_put(obj-&gt;obj);</span>
<span class="p_add">+		kfree(obj);</span>
<span class="p_add">+		kvmgt_put_vfio_device(vgpu);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	kvmgt_put_vfio_device(vgpu);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static long intel_vgpu_dmabuf_mgr_fd_ioctl(struct file *filp,</span>
<span class="p_add">+		unsigned int ioctl, unsigned long arg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct intel_vgpu *vgpu = filp-&gt;private_data;</span>
<span class="p_add">+	int minsz;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+	struct fd f;</span>
<span class="p_add">+</span>
<span class="p_add">+	f = fdget(vgpu-&gt;dmabuf_mgr_fd);</span>
<span class="p_add">+	if (!f.file)</span>
<span class="p_add">+		return -EBADF;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ioctl == VFIO_DEVICE_QUERY_PLANE) {</span>
<span class="p_add">+		struct vfio_vgpu_plane_info info;</span>
<span class="p_add">+</span>
<span class="p_add">+		minsz = offsetofend(struct vfio_vgpu_plane_info, resv);</span>
<span class="p_add">+		if (copy_from_user(&amp;info, (void __user *)arg, minsz)) {</span>
<span class="p_add">+			fdput(f);</span>
<span class="p_add">+			return -EFAULT;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		if (info.argsz &lt; minsz) {</span>
<span class="p_add">+			fdput(f);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		ret = intel_gvt_ops-&gt;vgpu_query_plane(vgpu, &amp;info);</span>
<span class="p_add">+		if (ret != 0) {</span>
<span class="p_add">+			fdput(f);</span>
<span class="p_add">+			gvt_vgpu_err(&quot;query plane failed:%d\n&quot;, ret);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		fdput(f);</span>
<span class="p_add">+		return copy_to_user((void __user *)arg, &amp;info, minsz) ?</span>
<span class="p_add">+								-EFAULT : 0;</span>
<span class="p_add">+	} else if (ioctl == VFIO_DEVICE_CREATE_DMABUF) {</span>
<span class="p_add">+		struct vfio_vgpu_dmabuf_info dmabuf;</span>
<span class="p_add">+</span>
<span class="p_add">+		minsz = offsetofend(struct vfio_vgpu_dmabuf_info, resv);</span>
<span class="p_add">+		if (copy_from_user(&amp;dmabuf, (void __user *)arg, minsz)) {</span>
<span class="p_add">+			fdput(f);</span>
<span class="p_add">+			return -EFAULT;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		if (dmabuf.argsz &lt; minsz) {</span>
<span class="p_add">+			fdput(f);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		ret = kvmgt_get_vfio_device(vgpu);</span>
<span class="p_add">+		if (ret != 0)</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+		ret = intel_gvt_ops-&gt;vgpu_create_dmabuf(vgpu, &amp;dmabuf);</span>
<span class="p_add">+		if (ret != 0) {</span>
<span class="p_add">+			kvmgt_put_vfio_device(vgpu);</span>
<span class="p_add">+			fdput(f);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		fdput(f);</span>
<span class="p_add">+		return copy_to_user((void __user *)arg, &amp;dmabuf, minsz) ?</span>
<span class="p_add">+								-EFAULT : 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	fdput(f);</span>
<span class="p_add">+	gvt_vgpu_err(&quot;unsupported dmabuf operation\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+	return -EINVAL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct file_operations intel_vgpu_dmabuf_mgr_fd_ops = {</span>
<span class="p_add">+	.release        = intel_vgpu_dmabuf_mgr_fd_release,</span>
<span class="p_add">+	.unlocked_ioctl = intel_vgpu_dmabuf_mgr_fd_ioctl,</span>
<span class="p_add">+	.mmap           = intel_vgpu_dmabuf_mgr_fd_mmap,</span>
<span class="p_add">+	.llseek         = noop_llseek,</span>
<span class="p_add">+};</span>
 static int intel_vgpu_create(struct kobject *kobj, struct mdev_device *mdev)
 {
 	struct intel_vgpu *vgpu = NULL;
<span class="p_chunk">@@ -1259,6 +1379,30 @@</span> <span class="p_context"> static long intel_vgpu_ioctl(struct mdev_device *mdev, unsigned int cmd,</span>
 	} else if (cmd == VFIO_DEVICE_RESET) {
 		intel_gvt_ops-&gt;vgpu_reset(vgpu);
 		return 0;
<span class="p_add">+	} else if (cmd == VFIO_DEVICE_GET_FD) {</span>
<span class="p_add">+		int fd;</span>
<span class="p_add">+		u32 type;</span>
<span class="p_add">+		int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (copy_from_user(&amp;type, (void __user *)arg, sizeof(type)))</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		if (type != VFIO_DEVICE_DMABUF_MGR_FD)</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+		ret = kvmgt_get_vfio_device(vgpu);</span>
<span class="p_add">+		if (ret != 0)</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+		fd = anon_inode_getfd(&quot;intel-vgpu-dmabuf-mgr-fd&quot;,</span>
<span class="p_add">+			&amp;intel_vgpu_dmabuf_mgr_fd_ops,</span>
<span class="p_add">+			vgpu, O_RDWR | O_CLOEXEC);</span>
<span class="p_add">+		if (fd &lt; 0) {</span>
<span class="p_add">+			gvt_vgpu_err(&quot;create dmabuf mgr fd failed\n&quot;);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		vgpu-&gt;dmabuf_mgr_fd = fd;</span>
<span class="p_add">+</span>
<span class="p_add">+		return fd;</span>
 	}
 
 	return 0;
<span class="p_header">diff --git a/drivers/gpu/drm/i915/gvt/vgpu.c b/drivers/gpu/drm/i915/gvt/vgpu.c</span>
<span class="p_header">index 6e3cbd8..af6fc74 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/gvt/vgpu.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/gvt/vgpu.c</span>
<span class="p_chunk">@@ -346,6 +346,7 @@</span> <span class="p_context"> static struct intel_vgpu *__intel_gvt_create_vgpu(struct intel_gvt *gvt,</span>
 	vgpu-&gt;gvt = gvt;
 	vgpu-&gt;sched_ctl.weight = param-&gt;weight;
 	bitmap_zero(vgpu-&gt;tlb_handle_pending, I915_NUM_ENGINES);
<span class="p_add">+	INIT_LIST_HEAD(&amp;vgpu-&gt;dmabuf_obj_list_head);</span>
 
 	intel_vgpu_init_cfg_space(vgpu, param-&gt;primary);
 

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



