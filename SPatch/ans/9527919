
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.4.44 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.4.44</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Jan. 20, 2017, 10:19 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20170120101951.GB13706@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9527919/mbox/"
   >mbox</a>
|
   <a href="/patch/9527919/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9527919/">/patch/9527919/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	D9E0660459 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 20 Jan 2017 10:19:49 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id C6A8C28354
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 20 Jan 2017 10:19:49 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id BB64F28427; Fri, 20 Jan 2017 10:19:49 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 520F6285B8
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 20 Jan 2017 10:19:47 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1752090AbdATKTm (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Fri, 20 Jan 2017 05:19:42 -0500
Received: from mail.linuxfoundation.org ([140.211.169.12]:50572 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1751990AbdATKTj (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Fri, 20 Jan 2017 05:19:39 -0500
Received: from localhost (unknown [78.192.101.3])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 00DCF901;
	Fri, 20 Jan 2017 10:19:37 +0000 (UTC)
Date: Fri, 20 Jan 2017 11:19:51 +0100
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.4.44
Message-ID: &lt;20170120101951.GB13706@kroah.com&gt;
References: &lt;20170120101945.GA13706@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=iso-8859-1
Content-Disposition: inline
Content-Transfer-Encoding: 8bit
In-Reply-To: &lt;20170120101945.GA13706@kroah.com&gt;
User-Agent: Mutt/1.7.2 (2016-11-26)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Jan. 20, 2017, 10:19 a.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 04a2186a4276..d6a1de0e2bd7 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 4
<span class="p_del">-SUBLEVEL = 43</span>
<span class="p_add">+SUBLEVEL = 44</span>
 EXTRAVERSION =
 NAME = Blurry Fish Butt
 
<span class="p_header">diff --git a/arch/powerpc/kernel/ibmebus.c b/arch/powerpc/kernel/ibmebus.c</span>
<span class="p_header">index ac86c53e2542..e524a775fa5c 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/ibmebus.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/ibmebus.c</span>
<span class="p_chunk">@@ -180,6 +180,7 @@</span> <span class="p_context"> static int ibmebus_create_device(struct device_node *dn)</span>
 static int ibmebus_create_devices(const struct of_device_id *matches)
 {
 	struct device_node *root, *child;
<span class="p_add">+	struct device *dev;</span>
 	int ret = 0;
 
 	root = of_find_node_by_path(&quot;/&quot;);
<span class="p_chunk">@@ -188,9 +189,12 @@</span> <span class="p_context"> static int ibmebus_create_devices(const struct of_device_id *matches)</span>
 		if (!of_match_node(matches, child))
 			continue;
 
<span class="p_del">-		if (bus_find_device(&amp;ibmebus_bus_type, NULL, child,</span>
<span class="p_del">-				    ibmebus_match_node))</span>
<span class="p_add">+		dev = bus_find_device(&amp;ibmebus_bus_type, NULL, child,</span>
<span class="p_add">+				      ibmebus_match_node);</span>
<span class="p_add">+		if (dev) {</span>
<span class="p_add">+			put_device(dev);</span>
 			continue;
<span class="p_add">+		}</span>
 
 		ret = ibmebus_create_device(child);
 		if (ret) {
<span class="p_chunk">@@ -262,6 +266,7 @@</span> <span class="p_context"> static ssize_t ibmebus_store_probe(struct bus_type *bus,</span>
 				   const char *buf, size_t count)
 {
 	struct device_node *dn = NULL;
<span class="p_add">+	struct device *dev;</span>
 	char *path;
 	ssize_t rc = 0;
 
<span class="p_chunk">@@ -269,8 +274,10 @@</span> <span class="p_context"> static ssize_t ibmebus_store_probe(struct bus_type *bus,</span>
 	if (!path)
 		return -ENOMEM;
 
<span class="p_del">-	if (bus_find_device(&amp;ibmebus_bus_type, NULL, path,</span>
<span class="p_del">-			    ibmebus_match_path)) {</span>
<span class="p_add">+	dev = bus_find_device(&amp;ibmebus_bus_type, NULL, path,</span>
<span class="p_add">+			      ibmebus_match_path);</span>
<span class="p_add">+	if (dev) {</span>
<span class="p_add">+		put_device(dev);</span>
 		printk(KERN_WARNING &quot;%s: %s has already been probed\n&quot;,
 		       __func__, path);
 		rc = -EEXIST;
<span class="p_chunk">@@ -307,6 +314,7 @@</span> <span class="p_context"> static ssize_t ibmebus_store_remove(struct bus_type *bus,</span>
 	if ((dev = bus_find_device(&amp;ibmebus_bus_type, NULL, path,
 				   ibmebus_match_path))) {
 		of_device_unregister(to_platform_device(dev));
<span class="p_add">+		put_device(dev);</span>
 
 		kfree(path);
 		return count;
<span class="p_header">diff --git a/arch/x86/kernel/cpu/common.c b/arch/x86/kernel/cpu/common.c</span>
<span class="p_header">index 2b49b113d65d..637ca414d431 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/common.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/common.c</span>
<span class="p_chunk">@@ -1129,7 +1129,7 @@</span> <span class="p_context"> static __init int setup_disablecpuid(char *arg)</span>
 {
 	int bit;
 
<span class="p_del">-	if (get_option(&amp;arg, &amp;bit) &amp;&amp; bit &lt; NCAPINTS*32)</span>
<span class="p_add">+	if (get_option(&amp;arg, &amp;bit) &amp;&amp; bit &gt;= 0 &amp;&amp; bit &lt; NCAPINTS * 32)</span>
 		setup_clear_cpu_cap(bit);
 	else
 		return 0;
<span class="p_header">diff --git a/arch/x86/kvm/emulate.c b/arch/x86/kvm/emulate.c</span>
<span class="p_header">index f49e98062ea5..1dcea225977d 100644</span>
<span class="p_header">--- a/arch/x86/kvm/emulate.c</span>
<span class="p_header">+++ b/arch/x86/kvm/emulate.c</span>
<span class="p_chunk">@@ -172,6 +172,7 @@</span> <span class="p_context"></span>
 #define NearBranch  ((u64)1 &lt;&lt; 52)  /* Near branches */
 #define No16	    ((u64)1 &lt;&lt; 53)  /* No 16 bit operand */
 #define IncSP       ((u64)1 &lt;&lt; 54)  /* SP is incremented before ModRM calc */
<span class="p_add">+#define Aligned16   ((u64)1 &lt;&lt; 55)  /* Aligned to 16 byte boundary (e.g. FXSAVE) */</span>
 
 #define DstXacc     (DstAccLo | SrcAccHi | SrcWrite)
 
<span class="p_chunk">@@ -434,6 +435,26 @@</span> <span class="p_context"> FOP_END;</span>
 FOP_START(salc) &quot;pushf; sbb %al, %al; popf \n\t&quot; FOP_RET
 FOP_END;
 
<span class="p_add">+/*</span>
<span class="p_add">+ * XXX: inoutclob user must know where the argument is being expanded.</span>
<span class="p_add">+ *      Relying on CC_HAVE_ASM_GOTO would allow us to remove _fault.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define asm_safe(insn, inoutclob...) \</span>
<span class="p_add">+({ \</span>
<span class="p_add">+	int _fault = 0; \</span>
<span class="p_add">+ \</span>
<span class="p_add">+	asm volatile(&quot;1:&quot; insn &quot;\n&quot; \</span>
<span class="p_add">+	             &quot;2:\n&quot; \</span>
<span class="p_add">+	             &quot;.pushsection .fixup, \&quot;ax\&quot;\n&quot; \</span>
<span class="p_add">+	             &quot;3: movl $1, %[_fault]\n&quot; \</span>
<span class="p_add">+	             &quot;   jmp  2b\n&quot; \</span>
<span class="p_add">+	             &quot;.popsection\n&quot; \</span>
<span class="p_add">+	             _ASM_EXTABLE(1b, 3b) \</span>
<span class="p_add">+	             : [_fault] &quot;+qm&quot;(_fault) inoutclob ); \</span>
<span class="p_add">+ \</span>
<span class="p_add">+	_fault ? X86EMUL_UNHANDLEABLE : X86EMUL_CONTINUE; \</span>
<span class="p_add">+})</span>
<span class="p_add">+</span>
 static int emulator_check_intercept(struct x86_emulate_ctxt *ctxt,
 				    enum x86_intercept intercept,
 				    enum x86_intercept_stage stage)
<span class="p_chunk">@@ -620,21 +641,24 @@</span> <span class="p_context"> static void set_segment_selector(struct x86_emulate_ctxt *ctxt, u16 selector,</span>
  * depending on whether they&#39;re AVX encoded or not.
  *
  * Also included is CMPXCHG16B which is not a vector instruction, yet it is
<span class="p_del">- * subject to the same check.</span>
<span class="p_add">+ * subject to the same check.  FXSAVE and FXRSTOR are checked here too as their</span>
<span class="p_add">+ * 512 bytes of data must be aligned to a 16 byte boundary.</span>
  */
<span class="p_del">-static bool insn_aligned(struct x86_emulate_ctxt *ctxt, unsigned size)</span>
<span class="p_add">+static unsigned insn_alignment(struct x86_emulate_ctxt *ctxt, unsigned size)</span>
 {
 	if (likely(size &lt; 16))
<span class="p_del">-		return false;</span>
<span class="p_add">+		return 1;</span>
 
 	if (ctxt-&gt;d &amp; Aligned)
<span class="p_del">-		return true;</span>
<span class="p_add">+		return size;</span>
 	else if (ctxt-&gt;d &amp; Unaligned)
<span class="p_del">-		return false;</span>
<span class="p_add">+		return 1;</span>
 	else if (ctxt-&gt;d &amp; Avx)
<span class="p_del">-		return false;</span>
<span class="p_add">+		return 1;</span>
<span class="p_add">+	else if (ctxt-&gt;d &amp; Aligned16)</span>
<span class="p_add">+		return 16;</span>
 	else
<span class="p_del">-		return true;</span>
<span class="p_add">+		return size;</span>
 }
 
 static __always_inline int __linearize(struct x86_emulate_ctxt *ctxt,
<span class="p_chunk">@@ -692,7 +716,7 @@</span> <span class="p_context"> static __always_inline int __linearize(struct x86_emulate_ctxt *ctxt,</span>
 		}
 		break;
 	}
<span class="p_del">-	if (insn_aligned(ctxt, size) &amp;&amp; ((la &amp; (size - 1)) != 0))</span>
<span class="p_add">+	if (la &amp; (insn_alignment(ctxt, size) - 1))</span>
 		return emulate_gp(ctxt, 0);
 	return X86EMUL_CONTINUE;
 bad:
<span class="p_chunk">@@ -779,6 +803,20 @@</span> <span class="p_context"> static int segmented_read_std(struct x86_emulate_ctxt *ctxt,</span>
 	return ctxt-&gt;ops-&gt;read_std(ctxt, linear, data, size, &amp;ctxt-&gt;exception);
 }
 
<span class="p_add">+static int segmented_write_std(struct x86_emulate_ctxt *ctxt,</span>
<span class="p_add">+			       struct segmented_address addr,</span>
<span class="p_add">+			       void *data,</span>
<span class="p_add">+			       unsigned int size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int rc;</span>
<span class="p_add">+	ulong linear;</span>
<span class="p_add">+</span>
<span class="p_add">+	rc = linearize(ctxt, addr, size, true, &amp;linear);</span>
<span class="p_add">+	if (rc != X86EMUL_CONTINUE)</span>
<span class="p_add">+		return rc;</span>
<span class="p_add">+	return ctxt-&gt;ops-&gt;write_std(ctxt, linear, data, size, &amp;ctxt-&gt;exception);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * Prefetch the remaining bytes of the instruction without crossing page
  * boundary if they are not in fetch_cache yet.
<span class="p_chunk">@@ -1532,7 +1570,6 @@</span> <span class="p_context"> static int write_segment_descriptor(struct x86_emulate_ctxt *ctxt,</span>
 				    &amp;ctxt-&gt;exception);
 }
 
<span class="p_del">-/* Does not support long mode */</span>
 static int __load_segment_descriptor(struct x86_emulate_ctxt *ctxt,
 				     u16 selector, int seg, u8 cpl,
 				     enum x86_transfer_type transfer,
<span class="p_chunk">@@ -1569,20 +1606,34 @@</span> <span class="p_context"> static int __load_segment_descriptor(struct x86_emulate_ctxt *ctxt,</span>
 
 	rpl = selector &amp; 3;
 
<span class="p_del">-	/* NULL selector is not valid for TR, CS and SS (except for long mode) */</span>
<span class="p_del">-	if ((seg == VCPU_SREG_CS</span>
<span class="p_del">-	     || (seg == VCPU_SREG_SS</span>
<span class="p_del">-		 &amp;&amp; (ctxt-&gt;mode != X86EMUL_MODE_PROT64 || rpl != cpl))</span>
<span class="p_del">-	     || seg == VCPU_SREG_TR)</span>
<span class="p_del">-	    &amp;&amp; null_selector)</span>
<span class="p_del">-		goto exception;</span>
<span class="p_del">-</span>
 	/* TR should be in GDT only */
 	if (seg == VCPU_SREG_TR &amp;&amp; (selector &amp; (1 &lt;&lt; 2)))
 		goto exception;
 
<span class="p_del">-	if (null_selector) /* for NULL selector skip all following checks */</span>
<span class="p_add">+	/* NULL selector is not valid for TR, CS and (except for long mode) SS */</span>
<span class="p_add">+	if (null_selector) {</span>
<span class="p_add">+		if (seg == VCPU_SREG_CS || seg == VCPU_SREG_TR)</span>
<span class="p_add">+			goto exception;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (seg == VCPU_SREG_SS) {</span>
<span class="p_add">+			if (ctxt-&gt;mode != X86EMUL_MODE_PROT64 || rpl != cpl)</span>
<span class="p_add">+				goto exception;</span>
<span class="p_add">+</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * ctxt-&gt;ops-&gt;set_segment expects the CPL to be in</span>
<span class="p_add">+			 * SS.DPL, so fake an expand-up 32-bit data segment.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			seg_desc.type = 3;</span>
<span class="p_add">+			seg_desc.p = 1;</span>
<span class="p_add">+			seg_desc.s = 1;</span>
<span class="p_add">+			seg_desc.dpl = cpl;</span>
<span class="p_add">+			seg_desc.d = 1;</span>
<span class="p_add">+			seg_desc.g = 1;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Skip all following checks */</span>
 		goto load;
<span class="p_add">+	}</span>
 
 	ret = read_segment_descriptor(ctxt, selector, &amp;seg_desc, &amp;desc_addr);
 	if (ret != X86EMUL_CONTINUE)
<span class="p_chunk">@@ -1698,6 +1749,21 @@</span> <span class="p_context"> static int load_segment_descriptor(struct x86_emulate_ctxt *ctxt,</span>
 				   u16 selector, int seg)
 {
 	u8 cpl = ctxt-&gt;ops-&gt;cpl(ctxt);
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * None of MOV, POP and LSS can load a NULL selector in CPL=3, but</span>
<span class="p_add">+	 * they can load it at CPL&lt;3 (Intel&#39;s manual says only LSS can,</span>
<span class="p_add">+	 * but it&#39;s wrong).</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * However, the Intel manual says that putting IST=1/DPL=3 in</span>
<span class="p_add">+	 * an interrupt gate will result in SS=3 (the AMD manual instead</span>
<span class="p_add">+	 * says it doesn&#39;t), so allow SS=3 in __load_segment_descriptor</span>
<span class="p_add">+	 * and only forbid it here.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (seg == VCPU_SREG_SS &amp;&amp; selector == 3 &amp;&amp;</span>
<span class="p_add">+	    ctxt-&gt;mode == X86EMUL_MODE_PROT64)</span>
<span class="p_add">+		return emulate_exception(ctxt, GP_VECTOR, 0, true);</span>
<span class="p_add">+</span>
 	return __load_segment_descriptor(ctxt, selector, seg, cpl,
 					 X86_TRANSFER_NONE, NULL);
 }
<span class="p_chunk">@@ -3646,8 +3712,8 @@</span> <span class="p_context"> static int emulate_store_desc_ptr(struct x86_emulate_ctxt *ctxt,</span>
 	}
 	/* Disable writeback. */
 	ctxt-&gt;dst.type = OP_NONE;
<span class="p_del">-	return segmented_write(ctxt, ctxt-&gt;dst.addr.mem,</span>
<span class="p_del">-			       &amp;desc_ptr, 2 + ctxt-&gt;op_bytes);</span>
<span class="p_add">+	return segmented_write_std(ctxt, ctxt-&gt;dst.addr.mem,</span>
<span class="p_add">+				   &amp;desc_ptr, 2 + ctxt-&gt;op_bytes);</span>
 }
 
 static int em_sgdt(struct x86_emulate_ctxt *ctxt)
<span class="p_chunk">@@ -3830,6 +3896,131 @@</span> <span class="p_context"> static int em_movsxd(struct x86_emulate_ctxt *ctxt)</span>
 	return X86EMUL_CONTINUE;
 }
 
<span class="p_add">+static int check_fxsr(struct x86_emulate_ctxt *ctxt)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 eax = 1, ebx, ecx = 0, edx;</span>
<span class="p_add">+</span>
<span class="p_add">+	ctxt-&gt;ops-&gt;get_cpuid(ctxt, &amp;eax, &amp;ebx, &amp;ecx, &amp;edx);</span>
<span class="p_add">+	if (!(edx &amp; FFL(FXSR)))</span>
<span class="p_add">+		return emulate_ud(ctxt);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ctxt-&gt;ops-&gt;get_cr(ctxt, 0) &amp; (X86_CR0_TS | X86_CR0_EM))</span>
<span class="p_add">+		return emulate_nm(ctxt);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Don&#39;t emulate a case that should never be hit, instead of working</span>
<span class="p_add">+	 * around a lack of fxsave64/fxrstor64 on old compilers.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (ctxt-&gt;mode &gt;= X86EMUL_MODE_PROT64)</span>
<span class="p_add">+		return X86EMUL_UNHANDLEABLE;</span>
<span class="p_add">+</span>
<span class="p_add">+	return X86EMUL_CONTINUE;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * FXSAVE and FXRSTOR have 4 different formats depending on execution mode,</span>
<span class="p_add">+ *  1) 16 bit mode</span>
<span class="p_add">+ *  2) 32 bit mode</span>
<span class="p_add">+ *     - like (1), but FIP and FDP (foo) are only 16 bit.  At least Intel CPUs</span>
<span class="p_add">+ *       preserve whole 32 bit values, though, so (1) and (2) are the same wrt.</span>
<span class="p_add">+ *       save and restore</span>
<span class="p_add">+ *  3) 64-bit mode with REX.W prefix</span>
<span class="p_add">+ *     - like (2), but XMM 8-15 are being saved and restored</span>
<span class="p_add">+ *  4) 64-bit mode without REX.W prefix</span>
<span class="p_add">+ *     - like (3), but FIP and FDP are 64 bit</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Emulation uses (3) for (1) and (2) and preserves XMM 8-15 to reach the</span>
<span class="p_add">+ * desired result.  (4) is not emulated.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Note: Guest and host CPUID.(EAX=07H,ECX=0H):EBX[bit 13] (deprecate FPU CS</span>
<span class="p_add">+ * and FPU DS) should match.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int em_fxsave(struct x86_emulate_ctxt *ctxt)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct fxregs_state fx_state;</span>
<span class="p_add">+	size_t size;</span>
<span class="p_add">+	int rc;</span>
<span class="p_add">+</span>
<span class="p_add">+	rc = check_fxsr(ctxt);</span>
<span class="p_add">+	if (rc != X86EMUL_CONTINUE)</span>
<span class="p_add">+		return rc;</span>
<span class="p_add">+</span>
<span class="p_add">+	ctxt-&gt;ops-&gt;get_fpu(ctxt);</span>
<span class="p_add">+</span>
<span class="p_add">+	rc = asm_safe(&quot;fxsave %[fx]&quot;, , [fx] &quot;+m&quot;(fx_state));</span>
<span class="p_add">+</span>
<span class="p_add">+	ctxt-&gt;ops-&gt;put_fpu(ctxt);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (rc != X86EMUL_CONTINUE)</span>
<span class="p_add">+		return rc;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ctxt-&gt;ops-&gt;get_cr(ctxt, 4) &amp; X86_CR4_OSFXSR)</span>
<span class="p_add">+		size = offsetof(struct fxregs_state, xmm_space[8 * 16/4]);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		size = offsetof(struct fxregs_state, xmm_space[0]);</span>
<span class="p_add">+</span>
<span class="p_add">+	return segmented_write_std(ctxt, ctxt-&gt;memop.addr.mem, &amp;fx_state, size);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int fxrstor_fixup(struct x86_emulate_ctxt *ctxt,</span>
<span class="p_add">+		struct fxregs_state *new)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int rc = X86EMUL_CONTINUE;</span>
<span class="p_add">+	struct fxregs_state old;</span>
<span class="p_add">+</span>
<span class="p_add">+	rc = asm_safe(&quot;fxsave %[fx]&quot;, , [fx] &quot;+m&quot;(old));</span>
<span class="p_add">+	if (rc != X86EMUL_CONTINUE)</span>
<span class="p_add">+		return rc;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * 64 bit host will restore XMM 8-15, which is not correct on non-64</span>
<span class="p_add">+	 * bit guests.  Load the current values in order to preserve 64 bit</span>
<span class="p_add">+	 * XMMs after fxrstor.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+#ifdef CONFIG_X86_64</span>
<span class="p_add">+	/* XXX: accessing XMM 8-15 very awkwardly */</span>
<span class="p_add">+	memcpy(&amp;new-&gt;xmm_space[8 * 16/4], &amp;old.xmm_space[8 * 16/4], 8 * 16);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Hardware doesn&#39;t save and restore XMM 0-7 without CR4.OSFXSR, but</span>
<span class="p_add">+	 * does save and restore MXCSR.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!(ctxt-&gt;ops-&gt;get_cr(ctxt, 4) &amp; X86_CR4_OSFXSR))</span>
<span class="p_add">+		memcpy(new-&gt;xmm_space, old.xmm_space, 8 * 16);</span>
<span class="p_add">+</span>
<span class="p_add">+	return rc;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int em_fxrstor(struct x86_emulate_ctxt *ctxt)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct fxregs_state fx_state;</span>
<span class="p_add">+	int rc;</span>
<span class="p_add">+</span>
<span class="p_add">+	rc = check_fxsr(ctxt);</span>
<span class="p_add">+	if (rc != X86EMUL_CONTINUE)</span>
<span class="p_add">+		return rc;</span>
<span class="p_add">+</span>
<span class="p_add">+	rc = segmented_read_std(ctxt, ctxt-&gt;memop.addr.mem, &amp;fx_state, 512);</span>
<span class="p_add">+	if (rc != X86EMUL_CONTINUE)</span>
<span class="p_add">+		return rc;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (fx_state.mxcsr &gt;&gt; 16)</span>
<span class="p_add">+		return emulate_gp(ctxt, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	ctxt-&gt;ops-&gt;get_fpu(ctxt);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ctxt-&gt;mode &lt; X86EMUL_MODE_PROT64)</span>
<span class="p_add">+		rc = fxrstor_fixup(ctxt, &amp;fx_state);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (rc == X86EMUL_CONTINUE)</span>
<span class="p_add">+		rc = asm_safe(&quot;fxrstor %[fx]&quot;, : [fx] &quot;m&quot;(fx_state));</span>
<span class="p_add">+</span>
<span class="p_add">+	ctxt-&gt;ops-&gt;put_fpu(ctxt);</span>
<span class="p_add">+</span>
<span class="p_add">+	return rc;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static bool valid_cr(int nr)
 {
 	switch (nr) {
<span class="p_chunk">@@ -4182,7 +4373,9 @@</span> <span class="p_context"> static const struct gprefix pfx_0f_ae_7 = {</span>
 };
 
 static const struct group_dual group15 = { {
<span class="p_del">-	N, N, N, N, N, N, N, GP(0, &amp;pfx_0f_ae_7),</span>
<span class="p_add">+	I(ModRM | Aligned16, em_fxsave),</span>
<span class="p_add">+	I(ModRM | Aligned16, em_fxrstor),</span>
<span class="p_add">+	N, N, N, N, N, GP(0, &amp;pfx_0f_ae_7),</span>
 }, {
 	N, N, N, N, N, N, N, N,
 } };
<span class="p_chunk">@@ -5054,21 +5247,13 @@</span> <span class="p_context"> static bool string_insn_completed(struct x86_emulate_ctxt *ctxt)</span>
 
 static int flush_pending_x87_faults(struct x86_emulate_ctxt *ctxt)
 {
<span class="p_del">-	bool fault = false;</span>
<span class="p_add">+	int rc;</span>
 
 	ctxt-&gt;ops-&gt;get_fpu(ctxt);
<span class="p_del">-	asm volatile(&quot;1: fwait \n\t&quot;</span>
<span class="p_del">-		     &quot;2: \n\t&quot;</span>
<span class="p_del">-		     &quot;.pushsection .fixup,\&quot;ax\&quot; \n\t&quot;</span>
<span class="p_del">-		     &quot;3: \n\t&quot;</span>
<span class="p_del">-		     &quot;movb $1, %[fault] \n\t&quot;</span>
<span class="p_del">-		     &quot;jmp 2b \n\t&quot;</span>
<span class="p_del">-		     &quot;.popsection \n\t&quot;</span>
<span class="p_del">-		     _ASM_EXTABLE(1b, 3b)</span>
<span class="p_del">-		     : [fault]&quot;+qm&quot;(fault));</span>
<span class="p_add">+	rc = asm_safe(&quot;fwait&quot;);</span>
 	ctxt-&gt;ops-&gt;put_fpu(ctxt);
 
<span class="p_del">-	if (unlikely(fault))</span>
<span class="p_add">+	if (unlikely(rc != X86EMUL_CONTINUE))</span>
 		return emulate_exception(ctxt, MF_VECTOR, 0, false);
 
 	return X86EMUL_CONTINUE;
<span class="p_header">diff --git a/arch/x86/kvm/lapic.c b/arch/x86/kvm/lapic.c</span>
<span class="p_header">index 4d30b865be30..1c96f09367ae 100644</span>
<span class="p_header">--- a/arch/x86/kvm/lapic.c</span>
<span class="p_header">+++ b/arch/x86/kvm/lapic.c</span>
<span class="p_chunk">@@ -2187,3 +2187,9 @@</span> <span class="p_context"> void kvm_lapic_init(void)</span>
 	jump_label_rate_limit(&amp;apic_hw_disabled, HZ);
 	jump_label_rate_limit(&amp;apic_sw_disabled, HZ);
 }
<span class="p_add">+</span>
<span class="p_add">+void kvm_lapic_exit(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	static_key_deferred_flush(&amp;apic_hw_disabled);</span>
<span class="p_add">+	static_key_deferred_flush(&amp;apic_sw_disabled);</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/x86/kvm/lapic.h b/arch/x86/kvm/lapic.h</span>
<span class="p_header">index fde8e35d5850..eb418fd670ff 100644</span>
<span class="p_header">--- a/arch/x86/kvm/lapic.h</span>
<span class="p_header">+++ b/arch/x86/kvm/lapic.h</span>
<span class="p_chunk">@@ -95,6 +95,7 @@</span> <span class="p_context"> static inline bool kvm_hv_vapic_assist_page_enabled(struct kvm_vcpu *vcpu)</span>
 
 int kvm_lapic_enable_pv_eoi(struct kvm_vcpu *vcpu, u64 data);
 void kvm_lapic_init(void);
<span class="p_add">+void kvm_lapic_exit(void);</span>
 
 static inline u32 kvm_apic_get_reg(struct kvm_lapic *apic, int reg_off)
 {
<span class="p_header">diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c</span>
<span class="p_header">index b3c2ae7aa213..25a6efcfdf7f 100644</span>
<span class="p_header">--- a/arch/x86/kvm/x86.c</span>
<span class="p_header">+++ b/arch/x86/kvm/x86.c</span>
<span class="p_chunk">@@ -5842,6 +5842,7 @@</span> <span class="p_context"> out:</span>
 
 void kvm_arch_exit(void)
 {
<span class="p_add">+	kvm_lapic_exit();</span>
 	perf_unregister_guest_info_callbacks(&amp;kvm_guest_cbs);
 
 	if (!boot_cpu_has(X86_FEATURE_CONSTANT_TSC))
<span class="p_header">diff --git a/block/blk-mq.c b/block/blk-mq.c</span>
<span class="p_header">index 9f99a01b00e8..6cfc6b200366 100644</span>
<span class="p_header">--- a/block/blk-mq.c</span>
<span class="p_header">+++ b/block/blk-mq.c</span>
<span class="p_chunk">@@ -842,7 +842,7 @@</span> <span class="p_context"> static int blk_mq_hctx_next_cpu(struct blk_mq_hw_ctx *hctx)</span>
 		return WORK_CPU_UNBOUND;
 
 	if (--hctx-&gt;next_cpu_batch &lt;= 0) {
<span class="p_del">-		int cpu = hctx-&gt;next_cpu, next_cpu;</span>
<span class="p_add">+		int next_cpu;</span>
 
 		next_cpu = cpumask_next(hctx-&gt;next_cpu, hctx-&gt;cpumask);
 		if (next_cpu &gt;= nr_cpu_ids)
<span class="p_chunk">@@ -850,8 +850,6 @@</span> <span class="p_context"> static int blk_mq_hctx_next_cpu(struct blk_mq_hw_ctx *hctx)</span>
 
 		hctx-&gt;next_cpu = next_cpu;
 		hctx-&gt;next_cpu_batch = BLK_MQ_CPU_WORK_BATCH;
<span class="p_del">-</span>
<span class="p_del">-		return cpu;</span>
 	}
 
 	return hctx-&gt;next_cpu;
<span class="p_header">diff --git a/block/cfq-iosched.c b/block/cfq-iosched.c</span>
<span class="p_header">index 3ad307ee6029..e04a7b8492cf 100644</span>
<span class="p_header">--- a/block/cfq-iosched.c</span>
<span class="p_header">+++ b/block/cfq-iosched.c</span>
<span class="p_chunk">@@ -1572,7 +1572,7 @@</span> <span class="p_context"> static struct blkcg_policy_data *cfq_cpd_alloc(gfp_t gfp)</span>
 {
 	struct cfq_group_data *cgd;
 
<span class="p_del">-	cgd = kzalloc(sizeof(*cgd), GFP_KERNEL);</span>
<span class="p_add">+	cgd = kzalloc(sizeof(*cgd), gfp);</span>
 	if (!cgd)
 		return NULL;
 	return &amp;cgd-&gt;cpd;
<span class="p_header">diff --git a/drivers/acpi/apei/ghes.c b/drivers/acpi/apei/ghes.c</span>
<span class="p_header">index 8f8da9f92090..eac4f3b02df9 100644</span>
<span class="p_header">--- a/drivers/acpi/apei/ghes.c</span>
<span class="p_header">+++ b/drivers/acpi/apei/ghes.c</span>
<span class="p_chunk">@@ -847,6 +847,8 @@</span> <span class="p_context"> static int ghes_notify_nmi(unsigned int cmd, struct pt_regs *regs)</span>
 		if (ghes_read_estatus(ghes, 1)) {
 			ghes_clear_estatus(ghes);
 			continue;
<span class="p_add">+		} else {</span>
<span class="p_add">+			ret = NMI_HANDLED;</span>
 		}
 
 		sev = ghes_severity(ghes-&gt;estatus-&gt;error_severity);
<span class="p_chunk">@@ -858,12 +860,11 @@</span> <span class="p_context"> static int ghes_notify_nmi(unsigned int cmd, struct pt_regs *regs)</span>
 
 		__process_error(ghes);
 		ghes_clear_estatus(ghes);
<span class="p_del">-</span>
<span class="p_del">-		ret = NMI_HANDLED;</span>
 	}
 
 #ifdef CONFIG_ARCH_HAVE_NMI_SAFE_CMPXCHG
<span class="p_del">-	irq_work_queue(&amp;ghes_proc_irq_work);</span>
<span class="p_add">+	if (ret == NMI_HANDLED)</span>
<span class="p_add">+		irq_work_queue(&amp;ghes_proc_irq_work);</span>
 #endif
 	atomic_dec(&amp;ghes_in_nmi);
 	return ret;
<span class="p_header">diff --git a/drivers/bus/vexpress-config.c b/drivers/bus/vexpress-config.c</span>
<span class="p_header">index 6575c0fe6a4e..27ea64fa4f9b 100644</span>
<span class="p_header">--- a/drivers/bus/vexpress-config.c</span>
<span class="p_header">+++ b/drivers/bus/vexpress-config.c</span>
<span class="p_chunk">@@ -171,6 +171,7 @@</span> <span class="p_context"> static int vexpress_config_populate(struct device_node *node)</span>
 {
 	struct device_node *bridge;
 	struct device *parent;
<span class="p_add">+	int ret;</span>
 
 	bridge = of_parse_phandle(node, &quot;arm,vexpress,config-bridge&quot;, 0);
 	if (!bridge)
<span class="p_chunk">@@ -181,7 +182,11 @@</span> <span class="p_context"> static int vexpress_config_populate(struct device_node *node)</span>
 	if (WARN_ON(!parent))
 		return -ENODEV;
 
<span class="p_del">-	return of_platform_populate(node, NULL, NULL, parent);</span>
<span class="p_add">+	ret = of_platform_populate(node, NULL, NULL, parent);</span>
<span class="p_add">+</span>
<span class="p_add">+	put_device(parent);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
 }
 
 static int __init vexpress_config_init(void)
<span class="p_header">diff --git a/drivers/cpufreq/powernv-cpufreq.c b/drivers/cpufreq/powernv-cpufreq.c</span>
<span class="p_header">index cb501386eb6e..c4b0ef65988c 100644</span>
<span class="p_header">--- a/drivers/cpufreq/powernv-cpufreq.c</span>
<span class="p_header">+++ b/drivers/cpufreq/powernv-cpufreq.c</span>
<span class="p_chunk">@@ -373,8 +373,14 @@</span> <span class="p_context"> static int powernv_cpufreq_target_index(struct cpufreq_policy *policy,</span>
 	if (unlikely(rebooting) &amp;&amp; new_index != get_nominal_index())
 		return 0;
 
<span class="p_del">-	if (!throttled)</span>
<span class="p_add">+	if (!throttled) {</span>
<span class="p_add">+		/* we don&#39;t want to be preempted while</span>
<span class="p_add">+		 * checking if the CPU frequency has been throttled</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		preempt_disable();</span>
 		powernv_cpufreq_throttle_check(NULL);
<span class="p_add">+		preempt_enable();</span>
<span class="p_add">+	}</span>
 
 	freq_data.pstate_id = powernv_freqs[new_index].driver_data;
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/si_dpm.c b/drivers/gpu/drm/radeon/si_dpm.c</span>
<span class="p_header">index eb2a2a49974f..b6f16804e73b 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/si_dpm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/si_dpm.c</span>
<span class="p_chunk">@@ -3008,19 +3008,6 @@</span> <span class="p_context"> static void si_apply_state_adjust_rules(struct radeon_device *rdev,</span>
 		    (rdev-&gt;pdev-&gt;device == 0x6817) ||
 		    (rdev-&gt;pdev-&gt;device == 0x6806))
 			max_mclk = 120000;
<span class="p_del">-	} else if (rdev-&gt;family == CHIP_VERDE) {</span>
<span class="p_del">-		if ((rdev-&gt;pdev-&gt;revision == 0x81) ||</span>
<span class="p_del">-		    (rdev-&gt;pdev-&gt;revision == 0x83) ||</span>
<span class="p_del">-		    (rdev-&gt;pdev-&gt;revision == 0x87) ||</span>
<span class="p_del">-		    (rdev-&gt;pdev-&gt;device == 0x6820) ||</span>
<span class="p_del">-		    (rdev-&gt;pdev-&gt;device == 0x6821) ||</span>
<span class="p_del">-		    (rdev-&gt;pdev-&gt;device == 0x6822) ||</span>
<span class="p_del">-		    (rdev-&gt;pdev-&gt;device == 0x6823) ||</span>
<span class="p_del">-		    (rdev-&gt;pdev-&gt;device == 0x682A) ||</span>
<span class="p_del">-		    (rdev-&gt;pdev-&gt;device == 0x682B)) {</span>
<span class="p_del">-			max_sclk = 75000;</span>
<span class="p_del">-			max_mclk = 80000;</span>
<span class="p_del">-		}</span>
 	} else if (rdev-&gt;family == CHIP_OLAND) {
 		if ((rdev-&gt;pdev-&gt;revision == 0xC7) ||
 		    (rdev-&gt;pdev-&gt;revision == 0x80) ||
<span class="p_header">diff --git a/drivers/i2c/i2c-core.c b/drivers/i2c/i2c-core.c</span>
<span class="p_header">index d625167357cc..e4587411b447 100644</span>
<span class="p_header">--- a/drivers/i2c/i2c-core.c</span>
<span class="p_header">+++ b/drivers/i2c/i2c-core.c</span>
<span class="p_chunk">@@ -1400,7 +1400,7 @@</span> <span class="p_context"> static struct i2c_client *of_i2c_register_device(struct i2c_adapter *adap,</span>
 
 	if (i2c_check_addr_validity(addr, info.flags)) {
 		dev_err(&amp;adap-&gt;dev, &quot;of_i2c: invalid addr=%x on %s\n&quot;,
<span class="p_del">-			info.addr, node-&gt;full_name);</span>
<span class="p_add">+			addr, node-&gt;full_name);</span>
 		return ERR_PTR(-EINVAL);
 	}
 
<span class="p_header">diff --git a/drivers/i2c/i2c-dev.c b/drivers/i2c/i2c-dev.c</span>
<span class="p_header">index 2413ec9f8207..94c837046786 100644</span>
<span class="p_header">--- a/drivers/i2c/i2c-dev.c</span>
<span class="p_header">+++ b/drivers/i2c/i2c-dev.c</span>
<span class="p_chunk">@@ -329,7 +329,7 @@</span> <span class="p_context"> static noinline int i2cdev_ioctl_smbus(struct i2c_client *client,</span>
 		unsigned long arg)
 {
 	struct i2c_smbus_ioctl_data data_arg;
<span class="p_del">-	union i2c_smbus_data temp;</span>
<span class="p_add">+	union i2c_smbus_data temp = {};</span>
 	int datasize, res;
 
 	if (copy_from_user(&amp;data_arg,
<span class="p_header">diff --git a/drivers/input/joystick/xpad.c b/drivers/input/joystick/xpad.c</span>
<span class="p_header">index aff42d5e2296..16f000a76de5 100644</span>
<span class="p_header">--- a/drivers/input/joystick/xpad.c</span>
<span class="p_header">+++ b/drivers/input/joystick/xpad.c</span>
<span class="p_chunk">@@ -1238,6 +1238,12 @@</span> <span class="p_context"> static int xpad_init_input(struct usb_xpad *xpad)</span>
 	input_dev-&gt;name = xpad-&gt;name;
 	input_dev-&gt;phys = xpad-&gt;phys;
 	usb_to_input_id(xpad-&gt;udev, &amp;input_dev-&gt;id);
<span class="p_add">+</span>
<span class="p_add">+	if (xpad-&gt;xtype == XTYPE_XBOX360W) {</span>
<span class="p_add">+		/* x360w controllers and the receiver have different ids */</span>
<span class="p_add">+		input_dev-&gt;id.product = 0x02a1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	input_dev-&gt;dev.parent = &amp;xpad-&gt;intf-&gt;dev;
 
 	input_set_drvdata(input_dev, xpad);
<span class="p_header">diff --git a/drivers/input/serio/i8042-x86ia64io.h b/drivers/input/serio/i8042-x86ia64io.h</span>
<span class="p_header">index 073246c7d163..0cdd95801a25 100644</span>
<span class="p_header">--- a/drivers/input/serio/i8042-x86ia64io.h</span>
<span class="p_header">+++ b/drivers/input/serio/i8042-x86ia64io.h</span>
<span class="p_chunk">@@ -211,6 +211,12 @@</span> <span class="p_context"> static const struct dmi_system_id __initconst i8042_dmi_noloop_table[] = {</span>
 			DMI_MATCH(DMI_PRODUCT_VERSION, &quot;Rev 1&quot;),
 		},
 	},
<span class="p_add">+	{</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;PEGATRON CORPORATION&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;C15B&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
 	{ }
 };
 
<span class="p_header">diff --git a/drivers/input/touchscreen/elants_i2c.c b/drivers/input/touchscreen/elants_i2c.c</span>
<span class="p_header">index ac09855fa435..486f8fe242da 100644</span>
<span class="p_header">--- a/drivers/input/touchscreen/elants_i2c.c</span>
<span class="p_header">+++ b/drivers/input/touchscreen/elants_i2c.c</span>
<span class="p_chunk">@@ -905,9 +905,9 @@</span> <span class="p_context"> static irqreturn_t elants_i2c_irq(int irq, void *_dev)</span>
 
 		case QUEUE_HEADER_NORMAL:
 			report_count = ts-&gt;buf[FW_HDR_COUNT];
<span class="p_del">-			if (report_count &gt; 3) {</span>
<span class="p_add">+			if (report_count == 0 || report_count &gt; 3) {</span>
 				dev_err(&amp;client-&gt;dev,
<span class="p_del">-					&quot;too large report count: %*ph\n&quot;,</span>
<span class="p_add">+					&quot;bad report count: %*ph\n&quot;,</span>
 					HEADER_SIZE, ts-&gt;buf);
 				break;
 			}
<span class="p_header">diff --git a/drivers/pinctrl/meson/pinctrl-meson.c b/drivers/pinctrl/meson/pinctrl-meson.c</span>
<span class="p_header">index 84943e4cff09..13730ca151ad 100644</span>
<span class="p_header">--- a/drivers/pinctrl/meson/pinctrl-meson.c</span>
<span class="p_header">+++ b/drivers/pinctrl/meson/pinctrl-meson.c</span>
<span class="p_chunk">@@ -246,7 +246,7 @@</span> <span class="p_context"> static int meson_pmx_request_gpio(struct pinctrl_dev *pcdev,</span>
 {
 	struct meson_pinctrl *pc = pinctrl_dev_get_drvdata(pcdev);
 
<span class="p_del">-	meson_pmx_disable_other_groups(pc, range-&gt;pin_base + offset, -1);</span>
<span class="p_add">+	meson_pmx_disable_other_groups(pc, offset, -1);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/pinctrl/sh-pfc/pinctrl.c b/drivers/pinctrl/sh-pfc/pinctrl.c</span>
<span class="p_header">index 863c3e30ce05..50f2014fed55 100644</span>
<span class="p_header">--- a/drivers/pinctrl/sh-pfc/pinctrl.c</span>
<span class="p_header">+++ b/drivers/pinctrl/sh-pfc/pinctrl.c</span>
<span class="p_chunk">@@ -483,7 +483,8 @@</span> <span class="p_context"> static bool sh_pfc_pinconf_validate(struct sh_pfc *pfc, unsigned int _pin,</span>
 
 	switch (param) {
 	case PIN_CONFIG_BIAS_DISABLE:
<span class="p_del">-		return true;</span>
<span class="p_add">+		return pin-&gt;configs &amp;</span>
<span class="p_add">+			(SH_PFC_PIN_CFG_PULL_UP | SH_PFC_PIN_CFG_PULL_DOWN);</span>
 
 	case PIN_CONFIG_BIAS_PULL_UP:
 		return pin-&gt;configs &amp; SH_PFC_PIN_CFG_PULL_UP;
<span class="p_header">diff --git a/drivers/tty/serial/atmel_serial.c b/drivers/tty/serial/atmel_serial.c</span>
<span class="p_header">index e0b89b961e1b..a0f911641b04 100644</span>
<span class="p_header">--- a/drivers/tty/serial/atmel_serial.c</span>
<span class="p_header">+++ b/drivers/tty/serial/atmel_serial.c</span>
<span class="p_chunk">@@ -470,6 +470,14 @@</span> <span class="p_context"> static void atmel_stop_tx(struct uart_port *port)</span>
 		/* disable PDC transmit */
 		atmel_uart_writel(port, ATMEL_PDC_PTCR, ATMEL_PDC_TXTDIS);
 	}
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Disable the transmitter.</span>
<span class="p_add">+	 * This is mandatory when DMA is used, otherwise the DMA buffer</span>
<span class="p_add">+	 * is fully transmitted.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	atmel_uart_writel(port, ATMEL_US_CR, ATMEL_US_TXDIS);</span>
<span class="p_add">+</span>
 	/* Disable interrupts */
 	atmel_uart_writel(port, ATMEL_US_IDR, atmel_port-&gt;tx_done_mask);
 
<span class="p_chunk">@@ -502,6 +510,9 @@</span> <span class="p_context"> static void atmel_start_tx(struct uart_port *port)</span>
 
 	/* Enable interrupts */
 	atmel_uart_writel(port, ATMEL_US_IER, atmel_port-&gt;tx_done_mask);
<span class="p_add">+</span>
<span class="p_add">+	/* re-enable the transmitter */</span>
<span class="p_add">+	atmel_uart_writel(port, ATMEL_US_CR, ATMEL_US_TXEN);</span>
 }
 
 /*
<span class="p_header">diff --git a/drivers/tty/sysrq.c b/drivers/tty/sysrq.c</span>
<span class="p_header">index 5381a728d23e..1fa4128eb88e 100644</span>
<span class="p_header">--- a/drivers/tty/sysrq.c</span>
<span class="p_header">+++ b/drivers/tty/sysrq.c</span>
<span class="p_chunk">@@ -939,8 +939,8 @@</span> <span class="p_context"> static const struct input_device_id sysrq_ids[] = {</span>
 	{
 		.flags = INPUT_DEVICE_ID_MATCH_EVBIT |
 				INPUT_DEVICE_ID_MATCH_KEYBIT,
<span class="p_del">-		.evbit = { BIT_MASK(EV_KEY) },</span>
<span class="p_del">-		.keybit = { BIT_MASK(KEY_LEFTALT) },</span>
<span class="p_add">+		.evbit = { [BIT_WORD(EV_KEY)] = BIT_MASK(EV_KEY) },</span>
<span class="p_add">+		.keybit = { [BIT_WORD(KEY_LEFTALT)] = BIT_MASK(KEY_LEFTALT) },</span>
 	},
 	{ },
 };
<span class="p_header">diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">index fa5d8c2f6982..de7dce6eb474 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-ring.c</span>
<span class="p_chunk">@@ -913,17 +913,6 @@</span> <span class="p_context"> void xhci_stop_endpoint_command_watchdog(unsigned long arg)</span>
 	spin_lock_irqsave(&amp;xhci-&gt;lock, flags);
 
 	ep-&gt;stop_cmds_pending--;
<span class="p_del">-	if (xhci-&gt;xhc_state &amp; XHCI_STATE_REMOVING) {</span>
<span class="p_del">-		spin_unlock_irqrestore(&amp;xhci-&gt;lock, flags);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	if (xhci-&gt;xhc_state &amp; XHCI_STATE_DYING) {</span>
<span class="p_del">-		xhci_dbg_trace(xhci, trace_xhci_dbg_cancel_urb,</span>
<span class="p_del">-				&quot;Stop EP timer ran, but another timer marked &quot;</span>
<span class="p_del">-				&quot;xHCI as DYING, exiting.&quot;);</span>
<span class="p_del">-		spin_unlock_irqrestore(&amp;xhci-&gt;lock, flags);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
 	if (!(ep-&gt;stop_cmds_pending == 0 &amp;&amp; (ep-&gt;ep_state &amp; EP_HALT_PENDING))) {
 		xhci_dbg_trace(xhci, trace_xhci_dbg_cancel_urb,
 				&quot;Stop EP timer ran, but no command pending, &quot;
<span class="p_header">diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c</span>
<span class="p_header">index a8b3c0fc11fb..f2e9f59c90d6 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci.c</span>
<span class="p_chunk">@@ -1569,19 +1569,6 @@</span> <span class="p_context"> int xhci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)</span>
 		xhci_urb_free_priv(urb_priv);
 		return ret;
 	}
<span class="p_del">-	if ((xhci-&gt;xhc_state &amp; XHCI_STATE_DYING) ||</span>
<span class="p_del">-			(xhci-&gt;xhc_state &amp; XHCI_STATE_HALTED)) {</span>
<span class="p_del">-		xhci_dbg_trace(xhci, trace_xhci_dbg_cancel_urb,</span>
<span class="p_del">-				&quot;Ep 0x%x: URB %p to be canceled on &quot;</span>
<span class="p_del">-				&quot;non-responsive xHCI host.&quot;,</span>
<span class="p_del">-				urb-&gt;ep-&gt;desc.bEndpointAddress, urb);</span>
<span class="p_del">-		/* Let the stop endpoint command watchdog timer (which set this</span>
<span class="p_del">-		 * state) finish cleaning up the endpoint TD lists.  We must</span>
<span class="p_del">-		 * have caught it in the middle of dropping a lock and giving</span>
<span class="p_del">-		 * back an URB.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		goto done;</span>
<span class="p_del">-	}</span>
 
 	ep_index = xhci_get_endpoint_index(&amp;urb-&gt;ep-&gt;desc);
 	ep = &amp;xhci-&gt;devs[urb-&gt;dev-&gt;slot_id]-&gt;eps[ep_index];
<span class="p_header">diff --git a/drivers/usb/serial/ch341.c b/drivers/usb/serial/ch341.c</span>
<span class="p_header">index c73808f095bb..71133d96f97d 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ch341.c</span>
<span class="p_header">+++ b/drivers/usb/serial/ch341.c</span>
<span class="p_chunk">@@ -99,6 +99,8 @@</span> <span class="p_context"> static int ch341_control_out(struct usb_device *dev, u8 request,</span>
 	r = usb_control_msg(dev, usb_sndctrlpipe(dev, 0), request,
 			    USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_OUT,
 			    value, index, NULL, 0, DEFAULT_TIMEOUT);
<span class="p_add">+	if (r &lt; 0)</span>
<span class="p_add">+		dev_err(&amp;dev-&gt;dev, &quot;failed to send control message: %d\n&quot;, r);</span>
 
 	return r;
 }
<span class="p_chunk">@@ -116,7 +118,20 @@</span> <span class="p_context"> static int ch341_control_in(struct usb_device *dev,</span>
 	r = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0), request,
 			    USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,
 			    value, index, buf, bufsize, DEFAULT_TIMEOUT);
<span class="p_del">-	return r;</span>
<span class="p_add">+	if (r &lt; bufsize) {</span>
<span class="p_add">+		if (r &gt;= 0) {</span>
<span class="p_add">+			dev_err(&amp;dev-&gt;dev,</span>
<span class="p_add">+				&quot;short control message received (%d &lt; %u)\n&quot;,</span>
<span class="p_add">+				r, bufsize);</span>
<span class="p_add">+			r = -EIO;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		dev_err(&amp;dev-&gt;dev, &quot;failed to receive control message: %d\n&quot;,</span>
<span class="p_add">+			r);</span>
<span class="p_add">+		return r;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
 }
 
 static int ch341_set_baudrate(struct usb_device *dev,
<span class="p_chunk">@@ -158,9 +173,9 @@</span> <span class="p_context"> static int ch341_set_handshake(struct usb_device *dev, u8 control)</span>
 
 static int ch341_get_status(struct usb_device *dev, struct ch341_private *priv)
 {
<span class="p_add">+	const unsigned int size = 2;</span>
 	char *buffer;
 	int r;
<span class="p_del">-	const unsigned size = 8;</span>
 	unsigned long flags;
 
 	buffer = kmalloc(size, GFP_KERNEL);
<span class="p_chunk">@@ -171,14 +186,9 @@</span> <span class="p_context"> static int ch341_get_status(struct usb_device *dev, struct ch341_private *priv)</span>
 	if (r &lt; 0)
 		goto out;
 
<span class="p_del">-	/* setup the private status if available */</span>
<span class="p_del">-	if (r == 2) {</span>
<span class="p_del">-		r = 0;</span>
<span class="p_del">-		spin_lock_irqsave(&amp;priv-&gt;lock, flags);</span>
<span class="p_del">-		priv-&gt;line_status = (~(*buffer)) &amp; CH341_BITS_MODEM_STAT;</span>
<span class="p_del">-		spin_unlock_irqrestore(&amp;priv-&gt;lock, flags);</span>
<span class="p_del">-	} else</span>
<span class="p_del">-		r = -EPROTO;</span>
<span class="p_add">+	spin_lock_irqsave(&amp;priv-&gt;lock, flags);</span>
<span class="p_add">+	priv-&gt;line_status = (~(*buffer)) &amp; CH341_BITS_MODEM_STAT;</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;priv-&gt;lock, flags);</span>
 
 out:	kfree(buffer);
 	return r;
<span class="p_chunk">@@ -188,9 +198,9 @@</span> <span class="p_context"> out:	kfree(buffer);</span>
 
 static int ch341_configure(struct usb_device *dev, struct ch341_private *priv)
 {
<span class="p_add">+	const unsigned int size = 2;</span>
 	char *buffer;
 	int r;
<span class="p_del">-	const unsigned size = 8;</span>
 
 	buffer = kmalloc(size, GFP_KERNEL);
 	if (!buffer)
<span class="p_chunk">@@ -253,7 +263,6 @@</span> <span class="p_context"> static int ch341_port_probe(struct usb_serial_port *port)</span>
 
 	spin_lock_init(&amp;priv-&gt;lock);
 	priv-&gt;baud_rate = DEFAULT_BAUD_RATE;
<span class="p_del">-	priv-&gt;line_control = CH341_BIT_RTS | CH341_BIT_DTR;</span>
 
 	r = ch341_configure(port-&gt;serial-&gt;dev, priv);
 	if (r &lt; 0)
<span class="p_chunk">@@ -315,7 +324,7 @@</span> <span class="p_context"> static int ch341_open(struct tty_struct *tty, struct usb_serial_port *port)</span>
 
 	r = ch341_configure(serial-&gt;dev, priv);
 	if (r)
<span class="p_del">-		goto out;</span>
<span class="p_add">+		return r;</span>
 
 	if (tty)
 		ch341_set_termios(tty, port, NULL);
<span class="p_chunk">@@ -325,12 +334,19 @@</span> <span class="p_context"> static int ch341_open(struct tty_struct *tty, struct usb_serial_port *port)</span>
 	if (r) {
 		dev_err(&amp;port-&gt;dev, &quot;%s - failed to submit interrupt urb: %d\n&quot;,
 			__func__, r);
<span class="p_del">-		goto out;</span>
<span class="p_add">+		return r;</span>
 	}
 
 	r = usb_serial_generic_open(tty, port);
<span class="p_add">+	if (r)</span>
<span class="p_add">+		goto err_kill_interrupt_urb;</span>
 
<span class="p_del">-out:	return r;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+err_kill_interrupt_urb:</span>
<span class="p_add">+	usb_kill_urb(port-&gt;interrupt_in_urb);</span>
<span class="p_add">+</span>
<span class="p_add">+	return r;</span>
 }
 
 /* Old_termios contains the original termios settings and
<span class="p_chunk">@@ -345,26 +361,25 @@</span> <span class="p_context"> static void ch341_set_termios(struct tty_struct *tty,</span>
 
 	baud_rate = tty_get_baud_rate(tty);
 
<span class="p_del">-	priv-&gt;baud_rate = baud_rate;</span>
<span class="p_del">-</span>
 	if (baud_rate) {
<span class="p_del">-		spin_lock_irqsave(&amp;priv-&gt;lock, flags);</span>
<span class="p_del">-		priv-&gt;line_control |= (CH341_BIT_DTR | CH341_BIT_RTS);</span>
<span class="p_del">-		spin_unlock_irqrestore(&amp;priv-&gt;lock, flags);</span>
<span class="p_add">+		priv-&gt;baud_rate = baud_rate;</span>
 		ch341_set_baudrate(port-&gt;serial-&gt;dev, priv);
<span class="p_del">-	} else {</span>
<span class="p_del">-		spin_lock_irqsave(&amp;priv-&gt;lock, flags);</span>
<span class="p_del">-		priv-&gt;line_control &amp;= ~(CH341_BIT_DTR | CH341_BIT_RTS);</span>
<span class="p_del">-		spin_unlock_irqrestore(&amp;priv-&gt;lock, flags);</span>
 	}
 
<span class="p_del">-	ch341_set_handshake(port-&gt;serial-&gt;dev, priv-&gt;line_control);</span>
<span class="p_del">-</span>
 	/* Unimplemented:
 	 * (cflag &amp; CSIZE) : data bits [5, 8]
 	 * (cflag &amp; PARENB) : parity {NONE, EVEN, ODD}
 	 * (cflag &amp; CSTOPB) : stop bits [1, 2]
 	 */
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;priv-&gt;lock, flags);</span>
<span class="p_add">+	if (C_BAUD(tty) == B0)</span>
<span class="p_add">+		priv-&gt;line_control &amp;= ~(CH341_BIT_DTR | CH341_BIT_RTS);</span>
<span class="p_add">+	else if (old_termios &amp;&amp; (old_termios-&gt;c_cflag &amp; CBAUD) == B0)</span>
<span class="p_add">+		priv-&gt;line_control |= (CH341_BIT_DTR | CH341_BIT_RTS);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;priv-&gt;lock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	ch341_set_handshake(port-&gt;serial-&gt;dev, priv-&gt;line_control);</span>
 }
 
 static void ch341_break_ctl(struct tty_struct *tty, int break_state)
<span class="p_chunk">@@ -539,14 +554,23 @@</span> <span class="p_context"> static int ch341_tiocmget(struct tty_struct *tty)</span>
 
 static int ch341_reset_resume(struct usb_serial *serial)
 {
<span class="p_del">-	struct ch341_private *priv;</span>
<span class="p_del">-</span>
<span class="p_del">-	priv = usb_get_serial_port_data(serial-&gt;port[0]);</span>
<span class="p_add">+	struct usb_serial_port *port = serial-&gt;port[0];</span>
<span class="p_add">+	struct ch341_private *priv = usb_get_serial_port_data(port);</span>
<span class="p_add">+	int ret;</span>
 
 	/* reconfigure ch341 serial port after bus-reset */
 	ch341_configure(serial-&gt;dev, priv);
 
<span class="p_del">-	return 0;</span>
<span class="p_add">+	if (test_bit(ASYNCB_INITIALIZED, &amp;port-&gt;port.flags)) {</span>
<span class="p_add">+		ret = usb_submit_urb(port-&gt;interrupt_in_urb, GFP_NOIO);</span>
<span class="p_add">+		if (ret) {</span>
<span class="p_add">+			dev_err(&amp;port-&gt;dev, &quot;failed to submit interrupt urb: %d\n&quot;,</span>
<span class="p_add">+				ret);</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return usb_serial_generic_resume(serial);</span>
 }
 
 static struct usb_serial_driver ch341_device = {
<span class="p_header">diff --git a/drivers/usb/serial/kl5kusb105.c b/drivers/usb/serial/kl5kusb105.c</span>
<span class="p_header">index cd0322502ab1..83c823d32ff9 100644</span>
<span class="p_header">--- a/drivers/usb/serial/kl5kusb105.c</span>
<span class="p_header">+++ b/drivers/usb/serial/kl5kusb105.c</span>
<span class="p_chunk">@@ -192,10 +192,11 @@</span> <span class="p_context"> static int klsi_105_get_line_state(struct usb_serial_port *port,</span>
 			     status_buf, KLSI_STATUSBUF_LEN,
 			     10000
 			     );
<span class="p_del">-	if (rc &lt; 0)</span>
<span class="p_del">-		dev_err(&amp;port-&gt;dev, &quot;Reading line status failed (error = %d)\n&quot;,</span>
<span class="p_del">-			rc);</span>
<span class="p_del">-	else {</span>
<span class="p_add">+	if (rc != KLSI_STATUSBUF_LEN) {</span>
<span class="p_add">+		dev_err(&amp;port-&gt;dev, &quot;reading line status failed: %d\n&quot;, rc);</span>
<span class="p_add">+		if (rc &gt;= 0)</span>
<span class="p_add">+			rc = -EIO;</span>
<span class="p_add">+	} else {</span>
 		status = get_unaligned_le16(status_buf);
 
 		dev_info(&amp;port-&gt;serial-&gt;dev-&gt;dev, &quot;read status %x %x\n&quot;,
<span class="p_header">diff --git a/drivers/vme/bridges/vme_ca91cx42.c b/drivers/vme/bridges/vme_ca91cx42.c</span>
<span class="p_header">index b79a74a98a23..ad94d8a45728 100644</span>
<span class="p_header">--- a/drivers/vme/bridges/vme_ca91cx42.c</span>
<span class="p_header">+++ b/drivers/vme/bridges/vme_ca91cx42.c</span>
<span class="p_chunk">@@ -467,7 +467,7 @@</span> <span class="p_context"> static int ca91cx42_slave_get(struct vme_slave_resource *image, int *enabled,</span>
 	vme_bound = ioread32(bridge-&gt;base + CA91CX42_VSI_BD[i]);
 	pci_offset = ioread32(bridge-&gt;base + CA91CX42_VSI_TO[i]);
 
<span class="p_del">-	*pci_base = (dma_addr_t)vme_base + pci_offset;</span>
<span class="p_add">+	*pci_base = (dma_addr_t)*vme_base + pci_offset;</span>
 	*size = (unsigned long long)((vme_bound - *vme_base) + granularity);
 
 	*enabled = 0;
<span class="p_header">diff --git a/fs/btrfs/extent-tree.c b/fs/btrfs/extent-tree.c</span>
<span class="p_header">index 2af08c3de775..2a2e370399ba 100644</span>
<span class="p_header">--- a/fs/btrfs/extent-tree.c</span>
<span class="p_header">+++ b/fs/btrfs/extent-tree.c</span>
<span class="p_chunk">@@ -2520,11 +2520,11 @@</span> <span class="p_context"> static noinline int __btrfs_run_delayed_refs(struct btrfs_trans_handle *trans,</span>
 		if (ref &amp;&amp; ref-&gt;seq &amp;&amp;
 		    btrfs_check_delayed_seq(fs_info, delayed_refs, ref-&gt;seq)) {
 			spin_unlock(&amp;locked_ref-&gt;lock);
<span class="p_del">-			btrfs_delayed_ref_unlock(locked_ref);</span>
 			spin_lock(&amp;delayed_refs-&gt;lock);
 			locked_ref-&gt;processing = 0;
 			delayed_refs-&gt;num_heads_ready++;
 			spin_unlock(&amp;delayed_refs-&gt;lock);
<span class="p_add">+			btrfs_delayed_ref_unlock(locked_ref);</span>
 			locked_ref = NULL;
 			cond_resched();
 			count++;
<span class="p_chunk">@@ -2570,7 +2570,10 @@</span> <span class="p_context"> static noinline int __btrfs_run_delayed_refs(struct btrfs_trans_handle *trans,</span>
 					 */
 					if (must_insert_reserved)
 						locked_ref-&gt;must_insert_reserved = 1;
<span class="p_add">+					spin_lock(&amp;delayed_refs-&gt;lock);</span>
 					locked_ref-&gt;processing = 0;
<span class="p_add">+					delayed_refs-&gt;num_heads_ready++;</span>
<span class="p_add">+					spin_unlock(&amp;delayed_refs-&gt;lock);</span>
 					btrfs_debug(fs_info, &quot;run_delayed_extent_op returned %d&quot;, ret);
 					btrfs_delayed_ref_unlock(locked_ref);
 					return ret;
<span class="p_header">diff --git a/fs/dcache.c b/fs/dcache.c</span>
<span class="p_header">index 71b6056ad35d..849c1c1e787b 100644</span>
<span class="p_header">--- a/fs/dcache.c</span>
<span class="p_header">+++ b/fs/dcache.c</span>
<span class="p_chunk">@@ -1322,8 +1322,11 @@</span> <span class="p_context"> int d_set_mounted(struct dentry *dentry)</span>
 	}
 	spin_lock(&amp;dentry-&gt;d_lock);
 	if (!d_unlinked(dentry)) {
<span class="p_del">-		dentry-&gt;d_flags |= DCACHE_MOUNTED;</span>
<span class="p_del">-		ret = 0;</span>
<span class="p_add">+		ret = -EBUSY;</span>
<span class="p_add">+		if (!d_mountpoint(dentry)) {</span>
<span class="p_add">+			dentry-&gt;d_flags |= DCACHE_MOUNTED;</span>
<span class="p_add">+			ret = 0;</span>
<span class="p_add">+		}</span>
 	}
  	spin_unlock(&amp;dentry-&gt;d_lock);
 out:
<span class="p_header">diff --git a/fs/namespace.c b/fs/namespace.c</span>
<span class="p_header">index 5be02a0635be..da98a1bbd8b5 100644</span>
<span class="p_header">--- a/fs/namespace.c</span>
<span class="p_header">+++ b/fs/namespace.c</span>
<span class="p_chunk">@@ -743,26 +743,50 @@</span> <span class="p_context"> static struct mountpoint *lookup_mountpoint(struct dentry *dentry)</span>
 	return NULL;
 }
 
<span class="p_del">-static struct mountpoint *new_mountpoint(struct dentry *dentry)</span>
<span class="p_add">+static struct mountpoint *get_mountpoint(struct dentry *dentry)</span>
 {
<span class="p_del">-	struct hlist_head *chain = mp_hash(dentry);</span>
<span class="p_del">-	struct mountpoint *mp;</span>
<span class="p_add">+	struct mountpoint *mp, *new = NULL;</span>
 	int ret;
 
<span class="p_del">-	mp = kmalloc(sizeof(struct mountpoint), GFP_KERNEL);</span>
<span class="p_del">-	if (!mp)</span>
<span class="p_add">+	if (d_mountpoint(dentry)) {</span>
<span class="p_add">+mountpoint:</span>
<span class="p_add">+		read_seqlock_excl(&amp;mount_lock);</span>
<span class="p_add">+		mp = lookup_mountpoint(dentry);</span>
<span class="p_add">+		read_sequnlock_excl(&amp;mount_lock);</span>
<span class="p_add">+		if (mp)</span>
<span class="p_add">+			goto done;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!new)</span>
<span class="p_add">+		new = kmalloc(sizeof(struct mountpoint), GFP_KERNEL);</span>
<span class="p_add">+	if (!new)</span>
 		return ERR_PTR(-ENOMEM);
 
<span class="p_add">+</span>
<span class="p_add">+	/* Exactly one processes may set d_mounted */</span>
 	ret = d_set_mounted(dentry);
<span class="p_del">-	if (ret) {</span>
<span class="p_del">-		kfree(mp);</span>
<span class="p_del">-		return ERR_PTR(ret);</span>
<span class="p_del">-	}</span>
 
<span class="p_del">-	mp-&gt;m_dentry = dentry;</span>
<span class="p_del">-	mp-&gt;m_count = 1;</span>
<span class="p_del">-	hlist_add_head(&amp;mp-&gt;m_hash, chain);</span>
<span class="p_del">-	INIT_HLIST_HEAD(&amp;mp-&gt;m_list);</span>
<span class="p_add">+	/* Someone else set d_mounted? */</span>
<span class="p_add">+	if (ret == -EBUSY)</span>
<span class="p_add">+		goto mountpoint;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* The dentry is not available as a mountpoint? */</span>
<span class="p_add">+	mp = ERR_PTR(ret);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto done;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Add the new mountpoint to the hash table */</span>
<span class="p_add">+	read_seqlock_excl(&amp;mount_lock);</span>
<span class="p_add">+	new-&gt;m_dentry = dentry;</span>
<span class="p_add">+	new-&gt;m_count = 1;</span>
<span class="p_add">+	hlist_add_head(&amp;new-&gt;m_hash, mp_hash(dentry));</span>
<span class="p_add">+	INIT_HLIST_HEAD(&amp;new-&gt;m_list);</span>
<span class="p_add">+	read_sequnlock_excl(&amp;mount_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	mp = new;</span>
<span class="p_add">+	new = NULL;</span>
<span class="p_add">+done:</span>
<span class="p_add">+	kfree(new);</span>
 	return mp;
 }
 
<span class="p_chunk">@@ -1557,11 +1581,11 @@</span> <span class="p_context"> void __detach_mounts(struct dentry *dentry)</span>
 	struct mount *mnt;
 
 	namespace_lock();
<span class="p_add">+	lock_mount_hash();</span>
 	mp = lookup_mountpoint(dentry);
 	if (IS_ERR_OR_NULL(mp))
 		goto out_unlock;
 
<span class="p_del">-	lock_mount_hash();</span>
 	event++;
 	while (!hlist_empty(&amp;mp-&gt;m_list)) {
 		mnt = hlist_entry(mp-&gt;m_list.first, struct mount, mnt_mp_list);
<span class="p_chunk">@@ -1571,9 +1595,9 @@</span> <span class="p_context"> void __detach_mounts(struct dentry *dentry)</span>
 		}
 		else umount_tree(mnt, UMOUNT_CONNECTED);
 	}
<span class="p_del">-	unlock_mount_hash();</span>
 	put_mountpoint(mp);
 out_unlock:
<span class="p_add">+	unlock_mount_hash();</span>
 	namespace_unlock();
 }
 
<span class="p_chunk">@@ -1962,9 +1986,7 @@</span> <span class="p_context"> retry:</span>
 	namespace_lock();
 	mnt = lookup_mnt(path);
 	if (likely(!mnt)) {
<span class="p_del">-		struct mountpoint *mp = lookup_mountpoint(dentry);</span>
<span class="p_del">-		if (!mp)</span>
<span class="p_del">-			mp = new_mountpoint(dentry);</span>
<span class="p_add">+		struct mountpoint *mp = get_mountpoint(dentry);</span>
 		if (IS_ERR(mp)) {
 			namespace_unlock();
 			mutex_unlock(&amp;dentry-&gt;d_inode-&gt;i_mutex);
<span class="p_chunk">@@ -1983,7 +2005,11 @@</span> <span class="p_context"> retry:</span>
 static void unlock_mount(struct mountpoint *where)
 {
 	struct dentry *dentry = where-&gt;m_dentry;
<span class="p_add">+</span>
<span class="p_add">+	read_seqlock_excl(&amp;mount_lock);</span>
 	put_mountpoint(where);
<span class="p_add">+	read_sequnlock_excl(&amp;mount_lock);</span>
<span class="p_add">+</span>
 	namespace_unlock();
 	mutex_unlock(&amp;dentry-&gt;d_inode-&gt;i_mutex);
 }
<span class="p_chunk">@@ -3055,9 +3081,9 @@</span> <span class="p_context"> SYSCALL_DEFINE2(pivot_root, const char __user *, new_root,</span>
 	touch_mnt_namespace(current-&gt;nsproxy-&gt;mnt_ns);
 	/* A moved mount should not expire automatically */
 	list_del_init(&amp;new_mnt-&gt;mnt_expire);
<span class="p_add">+	put_mountpoint(root_mp);</span>
 	unlock_mount_hash();
 	chroot_fs_refs(&amp;root, &amp;new);
<span class="p_del">-	put_mountpoint(root_mp);</span>
 	error = 0;
 out4:
 	unlock_mount(old_mp);
<span class="p_header">diff --git a/fs/nfs/dir.c b/fs/nfs/dir.c</span>
<span class="p_header">index 46cfed63d229..52ee0b73ab4a 100644</span>
<span class="p_header">--- a/fs/nfs/dir.c</span>
<span class="p_header">+++ b/fs/nfs/dir.c</span>
<span class="p_chunk">@@ -462,7 +462,7 @@</span> <span class="p_context"> void nfs_force_use_readdirplus(struct inode *dir)</span>
 {
 	if (!list_empty(&amp;NFS_I(dir)-&gt;open_files)) {
 		nfs_advise_use_readdirplus(dir);
<span class="p_del">-		nfs_zap_mapping(dir, dir-&gt;i_mapping);</span>
<span class="p_add">+		invalidate_mapping_pages(dir-&gt;i_mapping, 0, -1);</span>
 	}
 }
 
<span class="p_chunk">@@ -847,17 +847,6 @@</span> <span class="p_context"> int uncached_readdir(nfs_readdir_descriptor_t *desc)</span>
 	goto out;
 }
 
<span class="p_del">-static bool nfs_dir_mapping_need_revalidate(struct inode *dir)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct nfs_inode *nfsi = NFS_I(dir);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (nfs_attribute_cache_expired(dir))</span>
<span class="p_del">-		return true;</span>
<span class="p_del">-	if (nfsi-&gt;cache_validity &amp; NFS_INO_INVALID_DATA)</span>
<span class="p_del">-		return true;</span>
<span class="p_del">-	return false;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /* The file offset position represents the dirent entry number.  A
    last cookie cache takes care of the common case of reading the
    whole directory.
<span class="p_chunk">@@ -890,7 +879,7 @@</span> <span class="p_context"> static int nfs_readdir(struct file *file, struct dir_context *ctx)</span>
 	desc-&gt;plus = nfs_use_readdirplus(inode, ctx) ? 1 : 0;
 
 	nfs_block_sillyrename(dentry);
<span class="p_del">-	if (ctx-&gt;pos == 0 || nfs_dir_mapping_need_revalidate(inode))</span>
<span class="p_add">+	if (ctx-&gt;pos == 0 || nfs_attribute_cache_expired(inode))</span>
 		res = nfs_revalidate_mapping(inode, file-&gt;f_mapping);
 	if (res &lt; 0)
 		goto out;
<span class="p_header">diff --git a/fs/nfs/filelayout/filelayoutdev.c b/fs/nfs/filelayout/filelayoutdev.c</span>
<span class="p_header">index 4946ef40ba87..85ef38f9765f 100644</span>
<span class="p_header">--- a/fs/nfs/filelayout/filelayoutdev.c</span>
<span class="p_header">+++ b/fs/nfs/filelayout/filelayoutdev.c</span>
<span class="p_chunk">@@ -283,7 +283,8 @@</span> <span class="p_context"> nfs4_fl_prepare_ds(struct pnfs_layout_segment *lseg, u32 ds_idx)</span>
 			     s-&gt;nfs_client-&gt;cl_rpcclient-&gt;cl_auth-&gt;au_flavor);
 
 out_test_devid:
<span class="p_del">-	if (filelayout_test_devid_unavailable(devid))</span>
<span class="p_add">+	if (ret-&gt;ds_clp == NULL ||</span>
<span class="p_add">+	    filelayout_test_devid_unavailable(devid))</span>
 		ret = NULL;
 out:
 	return ret;
<span class="p_header">diff --git a/fs/nfs/pnfs.c b/fs/nfs/pnfs.c</span>
<span class="p_header">index 5cd3568eea06..3cae0726c1b1 100644</span>
<span class="p_header">--- a/fs/nfs/pnfs.c</span>
<span class="p_header">+++ b/fs/nfs/pnfs.c</span>
<span class="p_chunk">@@ -1185,13 +1185,11 @@</span> <span class="p_context"> bool pnfs_wait_on_layoutreturn(struct inode *ino, struct rpc_task *task)</span>
 	 * i_lock */
         spin_lock(&amp;ino-&gt;i_lock);
         lo = nfsi-&gt;layout;
<span class="p_del">-        if (lo &amp;&amp; test_bit(NFS_LAYOUT_RETURN, &amp;lo-&gt;plh_flags))</span>
<span class="p_add">+        if (lo &amp;&amp; test_bit(NFS_LAYOUT_RETURN, &amp;lo-&gt;plh_flags)) {</span>
<span class="p_add">+                rpc_sleep_on(&amp;NFS_SERVER(ino)-&gt;roc_rpcwaitq, task, NULL);</span>
                 sleep = true;
<span class="p_add">+	}</span>
         spin_unlock(&amp;ino-&gt;i_lock);
<span class="p_del">-</span>
<span class="p_del">-        if (sleep)</span>
<span class="p_del">-                rpc_sleep_on(&amp;NFS_SERVER(ino)-&gt;roc_rpcwaitq, task, NULL);</span>
<span class="p_del">-</span>
         return sleep;
 }
 
<span class="p_header">diff --git a/fs/ocfs2/dlmglue.c b/fs/ocfs2/dlmglue.c</span>
<span class="p_header">index b002acf50203..60a5f1548cd9 100644</span>
<span class="p_header">--- a/fs/ocfs2/dlmglue.c</span>
<span class="p_header">+++ b/fs/ocfs2/dlmglue.c</span>
<span class="p_chunk">@@ -3321,6 +3321,16 @@</span> <span class="p_context"> static int ocfs2_downconvert_lock(struct ocfs2_super *osb,</span>
 	mlog(ML_BASTS, &quot;lockres %s, level %d =&gt; %d\n&quot;, lockres-&gt;l_name,
 	     lockres-&gt;l_level, new_level);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * On DLM_LKF_VALBLK, fsdlm behaves differently with o2cb. It always</span>
<span class="p_add">+	 * expects DLM_LKF_VALBLK being set if the LKB has LVB, so that</span>
<span class="p_add">+	 * we can recover correctly from node failure. Otherwise, we may get</span>
<span class="p_add">+	 * invalid LVB in LKB, but without DLM_SBF_VALNOTVALIDbeing set.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!ocfs2_is_o2cb_active() &amp;&amp;</span>
<span class="p_add">+	    lockres-&gt;l_ops-&gt;flags &amp; LOCK_TYPE_USES_LVB)</span>
<span class="p_add">+		lvb = 1;</span>
<span class="p_add">+</span>
 	if (lvb)
 		dlm_flags |= DLM_LKF_VALBLK;
 
<span class="p_header">diff --git a/fs/ocfs2/stackglue.c b/fs/ocfs2/stackglue.c</span>
<span class="p_header">index 5d965e83bd43..783bcdce5666 100644</span>
<span class="p_header">--- a/fs/ocfs2/stackglue.c</span>
<span class="p_header">+++ b/fs/ocfs2/stackglue.c</span>
<span class="p_chunk">@@ -48,6 +48,12 @@</span> <span class="p_context"> static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = &quot;/sbin/ocfs2_hb_ctl&quot;;</span>
  */
 static struct ocfs2_stack_plugin *active_stack;
 
<span class="p_add">+inline int ocfs2_is_o2cb_active(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return !strcmp(active_stack-&gt;sp_name, OCFS2_STACK_PLUGIN_O2CB);</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(ocfs2_is_o2cb_active);</span>
<span class="p_add">+</span>
 static struct ocfs2_stack_plugin *ocfs2_stack_lookup(const char *name)
 {
 	struct ocfs2_stack_plugin *p;
<span class="p_header">diff --git a/fs/ocfs2/stackglue.h b/fs/ocfs2/stackglue.h</span>
<span class="p_header">index 66334a30cea8..e1b30931974d 100644</span>
<span class="p_header">--- a/fs/ocfs2/stackglue.h</span>
<span class="p_header">+++ b/fs/ocfs2/stackglue.h</span>
<span class="p_chunk">@@ -298,4 +298,7 @@</span> <span class="p_context"> void ocfs2_stack_glue_set_max_proto_version(struct ocfs2_protocol_version *max_p</span>
 int ocfs2_stack_glue_register(struct ocfs2_stack_plugin *plugin);
 void ocfs2_stack_glue_unregister(struct ocfs2_stack_plugin *plugin);
 
<span class="p_add">+/* In ocfs2_downconvert_lock(), we need to know which stack we are using */</span>
<span class="p_add">+int ocfs2_is_o2cb_active(void);</span>
<span class="p_add">+</span>
 #endif  /* STACKGLUE_H */
<span class="p_header">diff --git a/fs/proc/proc_sysctl.c b/fs/proc/proc_sysctl.c</span>
<span class="p_header">index fe5b6e6c4671..4dbe1e2daeca 100644</span>
<span class="p_header">--- a/fs/proc/proc_sysctl.c</span>
<span class="p_header">+++ b/fs/proc/proc_sysctl.c</span>
<span class="p_chunk">@@ -703,7 +703,7 @@</span> <span class="p_context"> static int proc_sys_readdir(struct file *file, struct dir_context *ctx)</span>
 	ctl_dir = container_of(head, struct ctl_dir, header);
 
 	if (!dir_emit_dots(file, ctx))
<span class="p_del">-		return 0;</span>
<span class="p_add">+		goto out;</span>
 
 	pos = 2;
 
<span class="p_chunk">@@ -713,6 +713,7 @@</span> <span class="p_context"> static int proc_sys_readdir(struct file *file, struct dir_context *ctx)</span>
 			break;
 		}
 	}
<span class="p_add">+out:</span>
 	sysctl_head_finish(head);
 	return 0;
 }
<span class="p_header">diff --git a/include/linux/jump_label_ratelimit.h b/include/linux/jump_label_ratelimit.h</span>
<span class="p_header">index 089f70f83e97..23da3af459fe 100644</span>
<span class="p_header">--- a/include/linux/jump_label_ratelimit.h</span>
<span class="p_header">+++ b/include/linux/jump_label_ratelimit.h</span>
<span class="p_chunk">@@ -14,6 +14,7 @@</span> <span class="p_context"> struct static_key_deferred {</span>
 
 #ifdef HAVE_JUMP_LABEL
 extern void static_key_slow_dec_deferred(struct static_key_deferred *key);
<span class="p_add">+extern void static_key_deferred_flush(struct static_key_deferred *key);</span>
 extern void
 jump_label_rate_limit(struct static_key_deferred *key, unsigned long rl);
 
<span class="p_chunk">@@ -26,6 +27,10 @@</span> <span class="p_context"> static inline void static_key_slow_dec_deferred(struct static_key_deferred *key)</span>
 	STATIC_KEY_CHECK_USE();
 	static_key_slow_dec(&amp;key-&gt;key);
 }
<span class="p_add">+static inline void static_key_deferred_flush(struct static_key_deferred *key)</span>
<span class="p_add">+{</span>
<span class="p_add">+	STATIC_KEY_CHECK_USE();</span>
<span class="p_add">+}</span>
 static inline void
 jump_label_rate_limit(struct static_key_deferred *key,
 		unsigned long rl)
<span class="p_header">diff --git a/kernel/jump_label.c b/kernel/jump_label.c</span>
<span class="p_header">index 4b353e0be121..453ec4232852 100644</span>
<span class="p_header">--- a/kernel/jump_label.c</span>
<span class="p_header">+++ b/kernel/jump_label.c</span>
<span class="p_chunk">@@ -138,6 +138,13 @@</span> <span class="p_context"> void static_key_slow_dec_deferred(struct static_key_deferred *key)</span>
 }
 EXPORT_SYMBOL_GPL(static_key_slow_dec_deferred);
 
<span class="p_add">+void static_key_deferred_flush(struct static_key_deferred *key)</span>
<span class="p_add">+{</span>
<span class="p_add">+	STATIC_KEY_CHECK_USE();</span>
<span class="p_add">+	flush_delayed_work(&amp;key-&gt;work);</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(static_key_deferred_flush);</span>
<span class="p_add">+</span>
 void jump_label_rate_limit(struct static_key_deferred *key,
 		unsigned long rl)
 {
<span class="p_header">diff --git a/kernel/memremap.c b/kernel/memremap.c</span>
<span class="p_header">index 25ced161ebeb..f719c925cb54 100644</span>
<span class="p_header">--- a/kernel/memremap.c</span>
<span class="p_header">+++ b/kernel/memremap.c</span>
<span class="p_chunk">@@ -159,7 +159,9 @@</span> <span class="p_context"> static void devm_memremap_pages_release(struct device *dev, void *res)</span>
 	struct page_map *page_map = res;
 
 	/* pages are dead and unused, undo the arch mapping */
<span class="p_add">+	mem_hotplug_begin();</span>
 	arch_remove_memory(page_map-&gt;res.start, resource_size(&amp;page_map-&gt;res));
<span class="p_add">+	mem_hotplug_done();</span>
 }
 
 void *devm_memremap_pages(struct device *dev, struct resource *res)
<span class="p_chunk">@@ -189,7 +191,9 @@</span> <span class="p_context"> void *devm_memremap_pages(struct device *dev, struct resource *res)</span>
 	if (nid &lt; 0)
 		nid = numa_mem_id();
 
<span class="p_add">+	mem_hotplug_begin();</span>
 	error = arch_add_memory(nid, res-&gt;start, resource_size(res), true);
<span class="p_add">+	mem_hotplug_done();</span>
 	if (error) {
 		devres_free(page_map);
 		return ERR_PTR(error);
<span class="p_header">diff --git a/mm/hugetlb.c b/mm/hugetlb.c</span>
<span class="p_header">index 4434cdd4cd9a..ea11123a9249 100644</span>
<span class="p_header">--- a/mm/hugetlb.c</span>
<span class="p_header">+++ b/mm/hugetlb.c</span>
<span class="p_chunk">@@ -1723,23 +1723,32 @@</span> <span class="p_context"> free:</span>
 }
 
 /*
<span class="p_del">- * When releasing a hugetlb pool reservation, any surplus pages that were</span>
<span class="p_del">- * allocated to satisfy the reservation must be explicitly freed if they were</span>
<span class="p_del">- * never used.</span>
<span class="p_del">- * Called with hugetlb_lock held.</span>
<span class="p_add">+ * This routine has two main purposes:</span>
<span class="p_add">+ * 1) Decrement the reservation count (resv_huge_pages) by the value passed</span>
<span class="p_add">+ *    in unused_resv_pages.  This corresponds to the prior adjustments made</span>
<span class="p_add">+ *    to the associated reservation map.</span>
<span class="p_add">+ * 2) Free any unused surplus pages that may have been allocated to satisfy</span>
<span class="p_add">+ *    the reservation.  As many as unused_resv_pages may be freed.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Called with hugetlb_lock held.  However, the lock could be dropped (and</span>
<span class="p_add">+ * reacquired) during calls to cond_resched_lock.  Whenever dropping the lock,</span>
<span class="p_add">+ * we must make sure nobody else can claim pages we are in the process of</span>
<span class="p_add">+ * freeing.  Do this by ensuring resv_huge_page always is greater than the</span>
<span class="p_add">+ * number of huge pages we plan to free when dropping the lock.</span>
  */
 static void return_unused_surplus_pages(struct hstate *h,
 					unsigned long unused_resv_pages)
 {
 	unsigned long nr_pages;
 
<span class="p_del">-	/* Uncommit the reservation */</span>
<span class="p_del">-	h-&gt;resv_huge_pages -= unused_resv_pages;</span>
<span class="p_del">-</span>
 	/* Cannot return gigantic pages currently */
 	if (hstate_is_gigantic(h))
<span class="p_del">-		return;</span>
<span class="p_add">+		goto out;</span>
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Part (or even all) of the reservation could have been backed</span>
<span class="p_add">+	 * by pre-allocated pages. Only free surplus pages.</span>
<span class="p_add">+	 */</span>
 	nr_pages = min(unused_resv_pages, h-&gt;surplus_huge_pages);
 
 	/*
<span class="p_chunk">@@ -1749,12 +1758,22 @@</span> <span class="p_context"> static void return_unused_surplus_pages(struct hstate *h,</span>
 	 * when the nodes with surplus pages have no free pages.
 	 * free_pool_huge_page() will balance the the freed pages across the
 	 * on-line nodes with memory and will handle the hstate accounting.
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Note that we decrement resv_huge_pages as we free the pages.  If</span>
<span class="p_add">+	 * we drop the lock, resv_huge_pages will still be sufficiently large</span>
<span class="p_add">+	 * to cover subsequent pages we may free.</span>
 	 */
 	while (nr_pages--) {
<span class="p_add">+		h-&gt;resv_huge_pages--;</span>
<span class="p_add">+		unused_resv_pages--;</span>
 		if (!free_pool_huge_page(h, &amp;node_states[N_MEMORY], 1))
<span class="p_del">-			break;</span>
<span class="p_add">+			goto out;</span>
 		cond_resched_lock(&amp;hugetlb_lock);
 	}
<span class="p_add">+</span>
<span class="p_add">+out:</span>
<span class="p_add">+	/* Fully uncommit the reservation */</span>
<span class="p_add">+	h-&gt;resv_huge_pages -= unused_resv_pages;</span>
 }
 
 
<span class="p_header">diff --git a/net/wireless/nl80211.c b/net/wireless/nl80211.c</span>
<span class="p_header">index bf65f31bd55e..1f0de6d74daa 100644</span>
<span class="p_header">--- a/net/wireless/nl80211.c</span>
<span class="p_header">+++ b/net/wireless/nl80211.c</span>
<span class="p_chunk">@@ -13168,13 +13168,17 @@</span> <span class="p_context"> static int nl80211_netlink_notify(struct notifier_block * nb,</span>
 
 	list_for_each_entry_rcu(rdev, &amp;cfg80211_rdev_list, list) {
 		bool schedule_destroy_work = false;
<span class="p_del">-		bool schedule_scan_stop = false;</span>
 		struct cfg80211_sched_scan_request *sched_scan_req =
 			rcu_dereference(rdev-&gt;sched_scan_req);
 
 		if (sched_scan_req &amp;&amp; notify-&gt;portid &amp;&amp;
<span class="p_del">-		    sched_scan_req-&gt;owner_nlportid == notify-&gt;portid)</span>
<span class="p_del">-			schedule_scan_stop = true;</span>
<span class="p_add">+		    sched_scan_req-&gt;owner_nlportid == notify-&gt;portid) {</span>
<span class="p_add">+			sched_scan_req-&gt;owner_nlportid = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+			if (rdev-&gt;ops-&gt;sched_scan_stop &amp;&amp;</span>
<span class="p_add">+			    rdev-&gt;wiphy.flags &amp; WIPHY_FLAG_SUPPORTS_SCHED_SCAN)</span>
<span class="p_add">+				schedule_work(&amp;rdev-&gt;sched_scan_stop_wk);</span>
<span class="p_add">+		}</span>
 
 		list_for_each_entry_rcu(wdev, &amp;rdev-&gt;wdev_list, list) {
 			cfg80211_mlme_unregister_socket(wdev, notify-&gt;portid);
<span class="p_chunk">@@ -13205,12 +13209,6 @@</span> <span class="p_context"> static int nl80211_netlink_notify(struct notifier_block * nb,</span>
 				spin_unlock(&amp;rdev-&gt;destroy_list_lock);
 				schedule_work(&amp;rdev-&gt;destroy_work);
 			}
<span class="p_del">-		} else if (schedule_scan_stop) {</span>
<span class="p_del">-			sched_scan_req-&gt;owner_nlportid = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-			if (rdev-&gt;ops-&gt;sched_scan_stop &amp;&amp;</span>
<span class="p_del">-			    rdev-&gt;wiphy.flags &amp; WIPHY_FLAG_SUPPORTS_SCHED_SCAN)</span>
<span class="p_del">-				schedule_work(&amp;rdev-&gt;sched_scan_stop_wk);</span>
 		}
 	}
 
<span class="p_header">diff --git a/tools/testing/selftests/Makefile b/tools/testing/selftests/Makefile</span>
<span class="p_header">index c8edff6803d1..24ebd3e3eb7d 100644</span>
<span class="p_header">--- a/tools/testing/selftests/Makefile</span>
<span class="p_header">+++ b/tools/testing/selftests/Makefile</span>
<span class="p_chunk">@@ -83,7 +83,7 @@</span> <span class="p_context"> ifdef INSTALL_PATH</span>
 	done;
 
 	@# Ask all targets to emit their test scripts
<span class="p_del">-	echo &quot;#!/bin/bash&quot; &gt; $(ALL_SCRIPT)</span>
<span class="p_add">+	echo &quot;#!/bin/sh&quot; &gt; $(ALL_SCRIPT)</span>
 	echo &quot;cd \$$(dirname \$$0)&quot; &gt;&gt; $(ALL_SCRIPT)
 	echo &quot;ROOT=\$$PWD&quot; &gt;&gt; $(ALL_SCRIPT)
 
<span class="p_header">diff --git a/tools/testing/selftests/net/run_netsocktests b/tools/testing/selftests/net/run_netsocktests</span>
<span class="p_header">index c09a682df56a..16058bbea7a8 100755</span>
<span class="p_header">--- a/tools/testing/selftests/net/run_netsocktests</span>
<span class="p_header">+++ b/tools/testing/selftests/net/run_netsocktests</span>
<span class="p_chunk">@@ -1,4 +1,4 @@</span> <span class="p_context"></span>
<span class="p_del">-#!/bin/bash</span>
<span class="p_add">+#!/bin/sh</span>
 
 echo &quot;--------------------&quot;
 echo &quot;running socket test&quot;
<span class="p_header">diff --git a/virt/lib/irqbypass.c b/virt/lib/irqbypass.c</span>
<span class="p_header">index 09a03b5a21ff..e5d5dde6bf75 100644</span>
<span class="p_header">--- a/virt/lib/irqbypass.c</span>
<span class="p_header">+++ b/virt/lib/irqbypass.c</span>
<span class="p_chunk">@@ -188,7 +188,7 @@</span> <span class="p_context"> int irq_bypass_register_consumer(struct irq_bypass_consumer *consumer)</span>
 	mutex_lock(&amp;lock);
 
 	list_for_each_entry(tmp, &amp;consumers, node) {
<span class="p_del">-		if (tmp-&gt;token == consumer-&gt;token) {</span>
<span class="p_add">+		if (tmp-&gt;token == consumer-&gt;token || tmp == consumer) {</span>
 			mutex_unlock(&amp;lock);
 			module_put(THIS_MODULE);
 			return -EBUSY;
<span class="p_chunk">@@ -235,7 +235,7 @@</span> <span class="p_context"> void irq_bypass_unregister_consumer(struct irq_bypass_consumer *consumer)</span>
 	mutex_lock(&amp;lock);
 
 	list_for_each_entry(tmp, &amp;consumers, node) {
<span class="p_del">-		if (tmp-&gt;token != consumer-&gt;token)</span>
<span class="p_add">+		if (tmp != consumer)</span>
 			continue;
 
 		list_for_each_entry(producer, &amp;producers, node) {

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



