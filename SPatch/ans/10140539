
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 3.2.97 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 3.2.97</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=131">Ben Hutchings</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Jan. 2, 2018, 1:36 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20180102133644.GU2971@decadent.org.uk&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/10140539/mbox/"
   >mbox</a>
|
   <a href="/patch/10140539/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/10140539/">/patch/10140539/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	AB9B260362 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  2 Jan 2018 13:37:21 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 8233728AC8
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  2 Jan 2018 13:37:21 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 758F928B27; Tue,  2 Jan 2018 13:37:21 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-5.9 required=2.0 tests=BAYES_00,HEXHASH_WORD,
	RCVD_IN_DNSWL_HI autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 4F98228AC8
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  2 Jan 2018 13:37:15 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1753334AbeABNhI (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Tue, 2 Jan 2018 08:37:08 -0500
Received: from shadbolt.e.decadent.org.uk ([88.96.1.126]:37303 &quot;EHLO
	shadbolt.e.decadent.org.uk&quot; rhost-flags-OK-OK-OK-OK)
	by vger.kernel.org with ESMTP id S1751550AbeABNgz (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Tue, 2 Jan 2018 08:36:55 -0500
Received: from ben by shadbolt.decadent.org.uk with local (Exim 4.84_2)
	(envelope-from &lt;ben@decadent.org.uk&gt;)
	id 1eWMkH-0007wW-5r; Tue, 02 Jan 2018 13:36:50 +0000
Date: Tue, 2 Jan 2018 13:36:45 +0000
From: Ben Hutchings &lt;ben@decadent.org.uk&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, Jiri Slaby &lt;jslaby@suse.cz&gt;,
	stable@vger.kernel.org
Cc: lwn@lwn.net
Message-ID: &lt;20180102133644.GU2971@decadent.org.uk&gt;
MIME-Version: 1.0
Content-Type: multipart/signed; micalg=pgp-sha512;
	protocol=&quot;application/pgp-signature&quot;; boundary=&quot;OJWLbGElk4npXSe3&quot;
Content-Disposition: inline
X-Mailer: LinuxStableQueue (scripts by bwh)
User-Agent: Mutt/1.5.23 (2014-03-12)
X-SA-Exim-Connect-IP: &lt;locally generated&gt;
X-SA-Exim-Mail-From: ben@decadent.org.uk
Subject: Linux 3.2.97
X-SA-Exim-Version: 4.2.1 (built Mon, 26 Dec 2011 16:24:06 +0000)
X-SA-Exim-Scanned: Yes (on shadbolt.decadent.org.uk)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=131">Ben Hutchings</a> - Jan. 2, 2018, 1:36 p.m.</div>
<pre class="content">
I&#39;m announcing the release of the 3.2.97 kernel.

All users of the 3.2 kernel series should upgrade.

The updated 3.2.y git tree can be found at:
        https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git linux-3.2.y
and can be browsed at the normal kernel.org git web browser:
        https://git.kernel.org/?p=linux/kernel/git/stable/linux-stable.git

The diff from 3.2.96 is attached to this message.

Ben.

------------

 Makefile                                 |   2 +-
 arch/arm/kernel/traps.c                  |  28 ++++++---
 arch/mips/ar7/platform.c                 |   1 +
 arch/s390/mm/gup.c                       |   7 +--
 arch/sh/include/cpu-sh4/cpu/sh7722.h     |   2 +-
 arch/sh/include/cpu-sh4/cpu/sh7757.h     |   8 +--
 arch/tile/kernel/setup.c                 |   3 +-
 arch/x86/crypto/salsa20_glue.c           |   7 ---
 arch/x86/include/asm/kvm_para.h          |   4 +-
 arch/x86/kernel/kvm.c                    |  22 +++----
 arch/x86/kvm/svm.c                       |   2 +-
 arch/x86/kvm/vmx.c                       |   7 +--
 arch/x86/kvm/x86.c                       |   8 +--
 arch/x86/oprofile/op_model_ppro.c        |   4 +-
 crypto/hmac.c                            |   6 +-
 crypto/salsa20_generic.c                 |   7 ---
 crypto/shash.c                           |  13 ++--
 drivers/crypto/talitos.c                 |   4 +-
 drivers/input/ff-core.c                  |  13 +++-
 drivers/input/misc/uinput.c              |  18 ++++++
 drivers/iommu/amd_iommu.c                |   1 +
 drivers/net/can/usb/esd_usb2.c           |   2 +-
 drivers/net/macvtap.c                    |   6 +-
 drivers/net/tun.c                        |   4 ++
 drivers/s390/scsi/zfcp_aux.c             |   5 ++
 drivers/s390/scsi/zfcp_erp.c             |  18 +++---
 drivers/s390/scsi/zfcp_scsi.c            |   5 ++
 drivers/scsi/libiscsi.c                  |   2 +-
 drivers/scsi/lpfc/lpfc_init.c            |   1 +
 drivers/scsi/scsi_scan.c                 |   3 +
 drivers/scsi/sd.c                        |  14 ++++-
 drivers/staging/iio/meter/ade7759.c      |   2 +-
 drivers/usb/class/cdc-acm.c              |   3 +
 drivers/usb/core/config.c                |   6 +-
 drivers/usb/core/hub.c                   |   2 +-
 drivers/usb/core/quirks.c                |   4 ++
 drivers/usb/gadget/dummy_hcd.c           |  56 +++++++++++++----
 drivers/usb/gadget/inode.c               |  72 ++++++++++++++++-----
 drivers/usb/host/pci-quirks.c            |   8 +--
 drivers/usb/host/xhci.h                  |   2 +-
 drivers/usb/renesas_usbhs/fifo.c         |  23 +++++--
 drivers/usb/serial/cp210x.c              |   1 +
 drivers/usb/serial/ftdi_sio.c            |   2 +
 drivers/usb/serial/ftdi_sio_ids.h        |   7 +++
 drivers/usb/serial/option.c              |   2 +
 drivers/usb/storage/unusual_devs.h       |   7 +++
 drivers/uwb/hwa-rc.c                     |   2 +
 drivers/uwb/uwbd.c                       |  12 ++--
 fs/bio.c                                 |  14 +++--
 fs/ecryptfs/ecryptfs_kernel.h            |  25 +++++---
 fs/ecryptfs/keystore.c                   |   9 ++-
 fs/fscache/object-list.c                 |   7 +++
 fs/ocfs2/alloc.c                         |  24 +++++--
 fs/read_write.c                          |   4 +-
 fs/xattr.c                               |   2 +-
 include/crypto/internal/hash.h           |   8 +++
 include/linux/input.h                    |   1 +
 include/linux/key.h                      |   2 +
 include/linux/spi/spidev.h               |   1 +
 include/net/bluetooth/l2cap.h            |   1 +
 include/net/tcp.h                        |   6 +-
 include/scsi/scsi_device.h               |   1 +
 include/scsi/scsi_devinfo.h              |   1 +
 include/sound/seq_kernel.h               |   3 +-
 include/sound/seq_virmidi.h              |   1 +
 include/sound/timer.h                    |   2 +
 include/trace/events/kvm.h               |   7 ++-
 kernel/params.c                          |   2 +-
 kernel/ptrace.c                          |   3 +-
 kernel/sysctl.c                          |   3 +-
 net/bluetooth/bnep/core.c                |   3 +
 net/bluetooth/cmtp/core.c                |   3 +
 net/bluetooth/hidp/core.c                |   2 +
 net/bluetooth/l2cap_sock.c               |   6 ++
 net/core/rtnetlink.c                     |   5 +-
 net/dccp/proto.c                         |   5 ++
 net/ipv4/tcp_output.c                    |   3 +-
 net/l2tp/l2tp_eth.c                      |  51 +--------------
 net/l2tp/l2tp_ip.c                       |  20 +++---
 net/l2tp/l2tp_ppp.c                      |  10 ++-
 net/packet/af_packet.c                   |   4 +-
 net/sctp/sm_sideeffect.c                 |   4 +-
 net/xfrm/xfrm_user.c                     |   3 +-
 security/keys/encrypted-keys/encrypted.c |   7 +++
 security/keys/internal.h                 |   2 +-
 security/keys/key.c                      |   2 +
 security/keys/keyctl.c                   |   8 +--
 security/keys/keyring.c                  |  23 ++++---
 security/keys/process_keys.c             |   9 ++-
 security/keys/request_key.c              |  46 +++++++++++---
 security/keys/request_key_auth.c         |  69 ++++++++++-----------
 security/keys/trusted.c                  |  71 ++++++++++-----------
 security/selinux/hooks.c                 |   2 +-
 security/smack/smack_lsm.c               |  57 ++++++++---------
 sound/core/hrtimer.c                     |   1 +
 sound/core/seq/oss/seq_oss_midi.c        |   4 +-
 sound/core/seq/oss/seq_oss_readq.c       |  29 +++++++++
 sound/core/seq/oss/seq_oss_readq.h       |   2 +
 sound/core/seq/seq_clientmgr.c           |   2 +-
 sound/core/seq/seq_virmidi.c             |  27 +++++---
 sound/core/timer.c                       | 103 +++++++++++++++++++++----------
 sound/core/timer_compat.c                |  17 ++++-
 sound/usb/caiaq/device.c                 |  12 +++-
 sound/usb/usx2y/usb_stream.c             |   6 +-
 104 files changed, 768 insertions(+), 415 deletions(-)

Al Viro (3):
      more bio_map_user_iov() leak fixes
      Bluetooth: cmtp: cmtp_add_connection() should verify that it&#39;s dealing with l2cap socket
      Bluetooth: bnep: bnep_add_connection() should verify that it&#39;s dealing with l2cap socket

Alan Stern (8):
      usb-storage: unusual_devs entry to fix write-access regression for Seagate external drives
      USB: gadgetfs: fix copy_to_user while holding spinlock
      USB: gadgetfs: Fix crash caused by inadequate synchronization
      USB: dummy-hcd: fix infinite-loop resubmission bug
      USB: gadgetfs, dummy-hcd, net2280: fix locking for callbacks
      USB: dummy-hcd: Fix erroneous synchronization change
      USB: dummy-hcd: Fix deadlock caused by disconnect detection
      USB: core: prevent malicious bNumInterfaces overflow

Andreas Engel (1):
      USB: serial: cp210x: add support for ELV TFD500

Andreas Gruenbacher (1):
      vfs: Return -ENXIO for negative SEEK_HOLE / SEEK_DATA offsets

Andrew Honig (1):
      KVM: VMX: remove I/O port 0x80 bypass on Intel hosts

Andrey Konovalov (2):
      uwb: ensure that endpoint is interrupt
      uwb: properly check kthread_run return value

Ashish Samant (1):
      ocfs2: fstrim: Fix start offset of first cluster group during fstrim

Baruch Siach (1):
      spi: uapi: spidev: add missing ioctl header

Ben Hutchings (3):
      ipsec: Fix aborted xfrm policy dump crash
      security: Fix mode test in selinux_ptrace_access_check()
      Linux 3.2.97

Bin Liu (1):
      usb: gadget: fix spinlock dead lock in gadgetfs

Boqun Feng (2):
      kvm/x86: Handle async PF in RCU read-side critical sections
      kvm/x86: Avoid async PF preempting the kernel incorrectly

Borislav Petkov (1):
      x86/oprofile/ppro: Do not use __this_cpu*() in preemptible context

Casey Schaufler (1):
      lsm: fix smack_inode_removexattr and xattr_getsecurity memleak

Colin Ian King (1):
      staging: iio: ade7759: fix signed extension bug on shift of a u8

Craig Gallek (1):
      tun/tap: sanitize TUNSETSNDBUF input

Dan Carpenter (1):
      tile: array underflow in setup_maxnodemem()

David Herrmann (1):
      Bluetooth: hidp: verify l2cap sockets

Dmitry Fleytman (1):
      usb: Increase quirk delay for USB devices

Dmitry Torokhov (1):
      Input: uinput - avoid FF flush when destroying device

Eric Biggers (13):
      KEYS: fix cred refcount leak in request_key_auth_new()
      KEYS: don&#39;t revoke uninstantiated key in request_key_auth_new()
      KEYS: fix key refcount leak in keyctl_assume_authority()
      KEYS: fix key refcount leak in keyctl_read_key()
      KEYS: prevent creating a different user&#39;s keyrings
      KEYS: encrypted: fix dereference of NULL user_key_payload
      FS-Cache: fix dereference of NULL user_key_payload
      ecryptfs: fix dereference of NULL user_key_payload
      KEYS: trusted: sanitize all key material
      KEYS: trusted: fix writing past end of buffer in trusted_read()
      crypto: salsa20 - fix blkcipher_walk API usage
      crypto: hmac - require that the underlying hash algorithm is unkeyed
      KEYS: add missing permission check for request_key() destination

Eric Dumazet (1):
      tcp: fix tcp_mtu_probe() vs highest_sack

Ethan Zhao (1):
      sched/sysctl: Check user input value of sysctl_sched_time_avg

Felipe Balbi (1):
      usb: quirks: add quirk for WORLDE MINI MIDI keyboard

Geert Uytterhoeven (2):
      sh: sh7722: remove nonexistent GPIO_PTQ7 to fix pinctrl registration
      sh: sh7757: remove nonexistent GPIO_PT[JLNQ]7_RESV to fix pinctrl registration

Gerald Schaefer (1):
      s390/mm: fix write access check in gup_huge_pmd()

Gleb Natapov (1):
      KVM: Do not take reference to mm during async #PF

Guillaume Nault (6):
      l2tp: fix l2tp_eth module loading
      l2tp: check ps-&gt;sock before running pppol2tp_session_ioctl()
      l2tp: hold tunnel in pppol2tp_connect()
      l2tp: hold socket before dropping lock in l2tp_ip{, 6}_recv()
      l2tp: hold tunnel socket when handling control frames in l2tp_ip and l2tp_ip6
      l2tp: don&#39;t use l2tp_tunnel_find() in l2tp_ip and l2tp_ip6

Haozhong Zhang (1):
      KVM: nVMX: fix guest CR4 loading when emulating L2 to L1 exit

Henryk Heisig (1):
      USB: serial: option: add support for TP-Link LTE module

Herbert Xu (1):
      crypto: shash - Fix zero-length shash ahash digest crash

Jean Delvare (1):
      kernel/params.c: align add_sysfs_param documentation with code

Jeffrey Chu (1):
      USB: serial: ftdi_sio: add id for Cypress WICED dev board

Jim Dickerson (1):
      usb: pci-quirks.c: Corrected timeout values used in handshake

Joerg Roedel (1):
      iommu/amd: Finish TLB flush in amd_iommu_unmap()

Johannes Thumshirn (1):
      scsi: libiscsi: fix shifting of DID_REQUEUE host byte

Kazuya Mizuguchi (1):
      usb: renesas_usbhs: Fix DMAC sequence for receiving zero-length packet

Konstantin Khlebnikov (1):
      Smack: remove unneeded NULL-termination from securtity label

LEROY Christophe (1):
      crypto: talitos - fix sha224

Maksim Salau (1):
      usb: cdc_acm: Add quirk for Elatec TWN3

Mark Rutland (1):
      ARM: 8720/1: ensure dump_instr() checks addr_limit

Martin K. Petersen (1):
      scsi: sd: Implement blacklist option for WRITE SAME w/ UNMAP

Mathias Nyman (1):
      xhci: fix finding correct bus_state structure for USB 3.1 hosts

Michael S. Tsirkin (1):
      macvtap: fix TUNSETSNDBUF values &gt; 64k

Mohamed Ghannam (1):
      dccp: CVE-2017-8824: use-after-free in DCCP code

Nicolas Dichtel (1):
      net: enable interface alias removal via rtnl

Oleg Nesterov (1):
      ptrace: change __ptrace_unlink() to clear -&gt;ptrace under -&gt;siglock

Oswald Buddenhagen (1):
      MIPS: AR7: Ensure that serial ports are properly set up

Stefan MÃ¤tje (1):
      can: esd_usb2: Fix can_dlc value for received RTR, frames

Stefano Brivio (1):
      scsi: lpfc: Don&#39;t return internal MBXERR_ERROR code from probe function

Steffen Maier (1):
      scsi: zfcp: fix erp_action use-before-initialize in REC action trace

Takashi Iwai (9):
      ALSA: usx2y: Suppress kernel warning at page allocation failures
      ALSA: seq: Fix copy_from_user() call inside lock
      ALSA: caiaq: Fix stray URB at probe error path
      ALSA: timer: Add missing mutex lock for compat ioctls
      ALSA: seq: Fix nested rwsem annotation for lockdep splat
      ALSA: timer: Protect the whole snd_timer_close() with open race
      ALSA: timer: Limit max instances per timer
      ALSA: seq: Avoid invalid lockdep class warning
      ALSA: seq: Fix OSS sysex delivery in OSS emulation

Wanpeng Li (1):
      KVM: Fix stack-out-of-bounds read in write_mmio

Willem de Bruijn (1):
      packet: only test po-&gt;has_vnet_hdr once in packet_snd

Xin Long (1):
      sctp: fix a type cast warnings that causes a_rwnd gets the wrong value

Yoshihiro Shimoda (2):
      usb: renesas_usbhs: fix the BCLR setting condition for non-DCP pipe
      usb: renesas_usbhs: fix usbhsf_fifo_clear() for RX direction
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 3dddb453d7d8..5f8f4c5d7c65 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 3
 PATCHLEVEL = 2
<span class="p_del">-SUBLEVEL = 96</span>
<span class="p_add">+SUBLEVEL = 97</span>
 EXTRAVERSION =
 NAME = Saber-toothed Squirrel
 
<span class="p_header">diff --git a/arch/arm/kernel/traps.c b/arch/arm/kernel/traps.c</span>
<span class="p_header">index d45fd2269e79..9be66c1dffce 100644</span>
<span class="p_header">--- a/arch/arm/kernel/traps.c</span>
<span class="p_header">+++ b/arch/arm/kernel/traps.c</span>
<span class="p_chunk">@@ -130,30 +130,26 @@</span> <span class="p_context"> static void dump_mem(const char *lvl, const char *str, unsigned long bottom,</span>
 	set_fs(fs);
 }
 
<span class="p_del">-static void dump_instr(const char *lvl, struct pt_regs *regs)</span>
<span class="p_add">+static void __dump_instr(const char *lvl, struct pt_regs *regs)</span>
 {
 	unsigned long addr = instruction_pointer(regs);
 	const int thumb = thumb_mode(regs);
 	const int width = thumb ? 4 : 8;
<span class="p_del">-	mm_segment_t fs;</span>
 	char str[sizeof(&quot;00000000 &quot;) * 5 + 2 + 1], *p = str;
 	int i;
 
 	/*
<span class="p_del">-	 * We need to switch to kernel mode so that we can use __get_user</span>
<span class="p_del">-	 * to safely read from kernel space.  Note that we now dump the</span>
<span class="p_del">-	 * code first, just in case the backtrace kills us.</span>
<span class="p_add">+	 * Note that we now dump the code first, just in case the backtrace</span>
<span class="p_add">+	 * kills us.</span>
 	 */
<span class="p_del">-	fs = get_fs();</span>
<span class="p_del">-	set_fs(KERNEL_DS);</span>
 
 	for (i = -4; i &lt; 1 + !!thumb; i++) {
 		unsigned int val, bad;
 
 		if (thumb)
<span class="p_del">-			bad = __get_user(val, &amp;((u16 *)addr)[i]);</span>
<span class="p_add">+			bad = get_user(val, &amp;((u16 *)addr)[i]);</span>
 		else
<span class="p_del">-			bad = __get_user(val, &amp;((u32 *)addr)[i]);</span>
<span class="p_add">+			bad = get_user(val, &amp;((u32 *)addr)[i]);</span>
 
 		if (!bad)
 			p += sprintf(p, i == 0 ? &quot;(%0*x) &quot; : &quot;%0*x &quot;,
<span class="p_chunk">@@ -164,8 +160,20 @@</span> <span class="p_context"> static void dump_instr(const char *lvl, struct pt_regs *regs)</span>
 		}
 	}
 	printk(&quot;%sCode: %s\n&quot;, lvl, str);
<span class="p_add">+}</span>
 
<span class="p_del">-	set_fs(fs);</span>
<span class="p_add">+static void dump_instr(const char *lvl, struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	mm_segment_t fs;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!user_mode(regs)) {</span>
<span class="p_add">+		fs = get_fs();</span>
<span class="p_add">+		set_fs(KERNEL_DS);</span>
<span class="p_add">+		__dump_instr(lvl, regs);</span>
<span class="p_add">+		set_fs(fs);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		__dump_instr(lvl, regs);</span>
<span class="p_add">+	}</span>
 }
 
 #ifdef CONFIG_ARM_UNWIND
<span class="p_header">diff --git a/arch/mips/ar7/platform.c b/arch/mips/ar7/platform.c</span>
<span class="p_header">index 33ffecf6a6d6..8e64ab593091 100644</span>
<span class="p_header">--- a/arch/mips/ar7/platform.c</span>
<span class="p_header">+++ b/arch/mips/ar7/platform.c</span>
<span class="p_chunk">@@ -541,6 +541,7 @@</span> <span class="p_context"> static int __init ar7_register_uarts(void)</span>
 	uart_port.type		= PORT_AR7;
 	uart_port.uartclk	= clk_get_rate(bus_clk) / 2;
 	uart_port.iotype	= UPIO_MEM32;
<span class="p_add">+	uart_port.flags		= UPF_FIXED_TYPE;</span>
 	uart_port.regshift	= 2;
 
 	uart_port.line		= 0;
<span class="p_header">diff --git a/arch/s390/mm/gup.c b/arch/s390/mm/gup.c</span>
<span class="p_header">index 4ccf9f54355e..65dcae761da9 100644</span>
<span class="p_header">--- a/arch/s390/mm/gup.c</span>
<span class="p_header">+++ b/arch/s390/mm/gup.c</span>
<span class="p_chunk">@@ -51,13 +51,12 @@</span> <span class="p_context"> static inline int gup_pte_range(pmd_t *pmdp, pmd_t pmd, unsigned long addr,</span>
 static inline int gup_huge_pmd(pmd_t *pmdp, pmd_t pmd, unsigned long addr,
 		unsigned long end, int write, struct page **pages, int *nr)
 {
<span class="p_del">-	unsigned long mask, result;</span>
 	struct page *head, *page, *tail;
<span class="p_add">+	unsigned long mask;</span>
 	int refs;
 
<span class="p_del">-	result = write ? 0 : _SEGMENT_ENTRY_RO;</span>
<span class="p_del">-	mask = result | _SEGMENT_ENTRY_INV;</span>
<span class="p_del">-	if ((pmd_val(pmd) &amp; mask) != result)</span>
<span class="p_add">+	mask = (write ? _SEGMENT_ENTRY_RO : 0) | _SEGMENT_ENTRY_INV;</span>
<span class="p_add">+	if ((pmd_val(pmd) &amp; mask) != 0)</span>
 		return 0;
 	VM_BUG_ON(!pfn_valid(pmd_val(pmd) &gt;&gt; PAGE_SHIFT));
 
<span class="p_header">diff --git a/arch/sh/include/cpu-sh4/cpu/sh7722.h b/arch/sh/include/cpu-sh4/cpu/sh7722.h</span>
<span class="p_header">index bd0622788d64..e84a5cf9d67f 100644</span>
<span class="p_header">--- a/arch/sh/include/cpu-sh4/cpu/sh7722.h</span>
<span class="p_header">+++ b/arch/sh/include/cpu-sh4/cpu/sh7722.h</span>
<span class="p_chunk">@@ -67,7 +67,7 @@</span> <span class="p_context"> enum {</span>
 	GPIO_PTN3, GPIO_PTN2, GPIO_PTN1, GPIO_PTN0,
 
 	/* PTQ */
<span class="p_del">-	GPIO_PTQ7, GPIO_PTQ6, GPIO_PTQ5, GPIO_PTQ4,</span>
<span class="p_add">+	GPIO_PTQ6, GPIO_PTQ5, GPIO_PTQ4,</span>
 	GPIO_PTQ3, GPIO_PTQ2, GPIO_PTQ1, GPIO_PTQ0,
 
 	/* PTR */
<span class="p_header">diff --git a/arch/sh/include/cpu-sh4/cpu/sh7757.h b/arch/sh/include/cpu-sh4/cpu/sh7757.h</span>
<span class="p_header">index 41f9f8b9db73..004759bf12c9 100644</span>
<span class="p_header">--- a/arch/sh/include/cpu-sh4/cpu/sh7757.h</span>
<span class="p_header">+++ b/arch/sh/include/cpu-sh4/cpu/sh7757.h</span>
<span class="p_chunk">@@ -40,7 +40,7 @@</span> <span class="p_context"> enum {</span>
 
 	/* PTJ */
 	GPIO_PTJ0, GPIO_PTJ1, GPIO_PTJ2, GPIO_PTJ3,
<span class="p_del">-	GPIO_PTJ4, GPIO_PTJ5, GPIO_PTJ6, GPIO_PTJ7_RESV,</span>
<span class="p_add">+	GPIO_PTJ4, GPIO_PTJ5, GPIO_PTJ6,</span>
 
 	/* PTK */
 	GPIO_PTK0, GPIO_PTK1, GPIO_PTK2, GPIO_PTK3,
<span class="p_chunk">@@ -48,7 +48,7 @@</span> <span class="p_context"> enum {</span>
 
 	/* PTL */
 	GPIO_PTL0, GPIO_PTL1, GPIO_PTL2, GPIO_PTL3,
<span class="p_del">-	GPIO_PTL4, GPIO_PTL5, GPIO_PTL6, GPIO_PTL7_RESV,</span>
<span class="p_add">+	GPIO_PTL4, GPIO_PTL5, GPIO_PTL6,</span>
 
 	/* PTM */
 	GPIO_PTM0, GPIO_PTM1, GPIO_PTM2, GPIO_PTM3,
<span class="p_chunk">@@ -56,7 +56,7 @@</span> <span class="p_context"> enum {</span>
 
 	/* PTN */
 	GPIO_PTN0, GPIO_PTN1, GPIO_PTN2, GPIO_PTN3,
<span class="p_del">-	GPIO_PTN4, GPIO_PTN5, GPIO_PTN6, GPIO_PTN7_RESV,</span>
<span class="p_add">+	GPIO_PTN4, GPIO_PTN5, GPIO_PTN6,</span>
 
 	/* PTO */
 	GPIO_PTO0, GPIO_PTO1, GPIO_PTO2, GPIO_PTO3,
<span class="p_chunk">@@ -68,7 +68,7 @@</span> <span class="p_context"> enum {</span>
 
 	/* PTQ */
 	GPIO_PTQ0, GPIO_PTQ1, GPIO_PTQ2, GPIO_PTQ3,
<span class="p_del">-	GPIO_PTQ4, GPIO_PTQ5, GPIO_PTQ6, GPIO_PTQ7_RESV,</span>
<span class="p_add">+	GPIO_PTQ4, GPIO_PTQ5, GPIO_PTQ6,</span>
 
 	/* PTR */
 	GPIO_PTR0, GPIO_PTR1, GPIO_PTR2, GPIO_PTR3,
<span class="p_header">diff --git a/arch/tile/kernel/setup.c b/arch/tile/kernel/setup.c</span>
<span class="p_header">index bf3e71a3bf10..b737c939af81 100644</span>
<span class="p_header">--- a/arch/tile/kernel/setup.c</span>
<span class="p_header">+++ b/arch/tile/kernel/setup.c</span>
<span class="p_chunk">@@ -119,7 +119,8 @@</span> <span class="p_context"> early_param(&quot;maxmem&quot;, setup_maxmem);</span>
 static int __init setup_maxnodemem(char *str)
 {
 	char *endp;
<span class="p_del">-	long maxnodemem_mb, node;</span>
<span class="p_add">+	long maxnodemem_mb;</span>
<span class="p_add">+	unsigned long node;</span>
 
 	node = str ? simple_strtoul(str, &amp;endp, 0) : INT_MAX;
 	if (node &gt;= MAX_NUMNODES || *endp != &#39;:&#39; ||
<span class="p_header">diff --git a/arch/x86/crypto/salsa20_glue.c b/arch/x86/crypto/salsa20_glue.c</span>
<span class="p_header">index ae1ee37f925d..6d8c7a428cff 100644</span>
<span class="p_header">--- a/arch/x86/crypto/salsa20_glue.c</span>
<span class="p_header">+++ b/arch/x86/crypto/salsa20_glue.c</span>
<span class="p_chunk">@@ -64,13 +64,6 @@</span> <span class="p_context"> static int encrypt(struct blkcipher_desc *desc,</span>
 
 	salsa20_ivsetup(ctx, walk.iv);
 
<span class="p_del">-	if (likely(walk.nbytes == nbytes))</span>
<span class="p_del">-	{</span>
<span class="p_del">-		salsa20_encrypt_bytes(ctx, walk.src.virt.addr,</span>
<span class="p_del">-				      walk.dst.virt.addr, nbytes);</span>
<span class="p_del">-		return blkcipher_walk_done(desc, &amp;walk, 0);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	while (walk.nbytes &gt;= 64) {
 		salsa20_encrypt_bytes(ctx, walk.src.virt.addr,
 				      walk.dst.virt.addr,
<span class="p_header">diff --git a/arch/x86/include/asm/kvm_para.h b/arch/x86/include/asm/kvm_para.h</span>
<span class="p_header">index 9f0a680a7e12..22d3fb1e5290 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/kvm_para.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/kvm_para.h</span>
<span class="p_chunk">@@ -195,13 +195,13 @@</span> <span class="p_context"> static inline unsigned int kvm_arch_para_features(void)</span>
 
 #ifdef CONFIG_KVM_GUEST
 void __init kvm_guest_init(void);
<span class="p_del">-void kvm_async_pf_task_wait(u32 token);</span>
<span class="p_add">+void kvm_async_pf_task_wait(u32 token, int interrupt_kernel);</span>
 void kvm_async_pf_task_wake(u32 token);
 u32 kvm_read_and_reset_pf_reason(void);
 extern void kvm_disable_steal_time(void);
 #else
 #define kvm_guest_init() do { } while (0)
<span class="p_del">-#define kvm_async_pf_task_wait(T) do {} while(0)</span>
<span class="p_add">+#define kvm_async_pf_task_wait(T, I) do {} while(0)</span>
 #define kvm_async_pf_task_wake(T) do {} while(0)
 static inline u32 kvm_read_and_reset_pf_reason(void)
 {
<span class="p_header">diff --git a/arch/x86/kernel/kvm.c b/arch/x86/kernel/kvm.c</span>
<span class="p_header">index 4b6701e95ae7..9d1121d6b00c 100644</span>
<span class="p_header">--- a/arch/x86/kernel/kvm.c</span>
<span class="p_header">+++ b/arch/x86/kernel/kvm.c</span>
<span class="p_chunk">@@ -91,7 +91,6 @@</span> <span class="p_context"> struct kvm_task_sleep_node {</span>
 	u32 token;
 	int cpu;
 	bool halted;
<span class="p_del">-	struct mm_struct *mm;</span>
 };
 
 static struct kvm_task_sleep_head {
<span class="p_chunk">@@ -114,7 +113,11 @@</span> <span class="p_context"> static struct kvm_task_sleep_node *_find_apf_task(struct kvm_task_sleep_head *b,</span>
 	return NULL;
 }
 
<span class="p_del">-void kvm_async_pf_task_wait(u32 token)</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * @interrupt_kernel: Is this called from a routine which interrupts the kernel</span>
<span class="p_add">+ * 		      (other than user space)?</span>
<span class="p_add">+ */</span>
<span class="p_add">+void kvm_async_pf_task_wait(u32 token, int interrupt_kernel)</span>
 {
 	u32 key = hash_32(token, KVM_TASK_SLEEP_HASHBITS);
 	struct kvm_task_sleep_head *b = &amp;async_pf_sleepers[key];
<span class="p_chunk">@@ -138,9 +141,10 @@</span> <span class="p_context"> void kvm_async_pf_task_wait(u32 token)</span>
 
 	n.token = token;
 	n.cpu = smp_processor_id();
<span class="p_del">-	n.mm = current-&gt;active_mm;</span>
<span class="p_del">-	n.halted = idle || preempt_count() &gt; 1;</span>
<span class="p_del">-	atomic_inc(&amp;n.mm-&gt;mm_count);</span>
<span class="p_add">+	n.halted = idle ||</span>
<span class="p_add">+		   (IS_ENABLED(CONFIG_PREEMPT_COUNT)</span>
<span class="p_add">+		    ? preempt_count() &gt; 1 || rcu_preempt_depth()</span>
<span class="p_add">+		    : interrupt_kernel);</span>
 	init_waitqueue_head(&amp;n.wq);
 	hlist_add_head(&amp;n.link, &amp;b-&gt;list);
 	spin_unlock(&amp;b-&gt;lock);
<span class="p_chunk">@@ -173,9 +177,6 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(kvm_async_pf_task_wait);</span>
 static void apf_task_wake_one(struct kvm_task_sleep_node *n)
 {
 	hlist_del_init(&amp;n-&gt;link);
<span class="p_del">-	if (!n-&gt;mm)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	mmdrop(n-&gt;mm);</span>
 	if (n-&gt;halted)
 		smp_send_reschedule(n-&gt;cpu);
 	else if (waitqueue_active(&amp;n-&gt;wq))
<span class="p_chunk">@@ -219,7 +220,7 @@</span> <span class="p_context"> void kvm_async_pf_task_wake(u32 token)</span>
 		 * async PF was not yet handled.
 		 * Add dummy entry for the token.
 		 */
<span class="p_del">-		n = kmalloc(sizeof(*n), GFP_ATOMIC);</span>
<span class="p_add">+		n = kzalloc(sizeof(*n), GFP_ATOMIC);</span>
 		if (!n) {
 			/*
 			 * Allocation failed! Busy wait while other cpu
<span class="p_chunk">@@ -231,7 +232,6 @@</span> <span class="p_context"> void kvm_async_pf_task_wake(u32 token)</span>
 		}
 		n-&gt;token = token;
 		n-&gt;cpu = smp_processor_id();
<span class="p_del">-		n-&gt;mm = NULL;</span>
 		init_waitqueue_head(&amp;n-&gt;wq);
 		hlist_add_head(&amp;n-&gt;link, &amp;b-&gt;list);
 	} else
<span class="p_chunk">@@ -263,7 +263,7 @@</span> <span class="p_context"> do_async_page_fault(struct pt_regs *regs, unsigned long error_code)</span>
 		break;
 	case KVM_PV_REASON_PAGE_NOT_PRESENT:
 		/* page is swapped out by the host. */
<span class="p_del">-		kvm_async_pf_task_wait((u32)read_cr2());</span>
<span class="p_add">+		kvm_async_pf_task_wait((u32)read_cr2(), !user_mode_vm(regs));</span>
 		break;
 	case KVM_PV_REASON_PAGE_READY:
 		kvm_async_pf_task_wake((u32)read_cr2());
<span class="p_header">diff --git a/arch/x86/kvm/svm.c b/arch/x86/kvm/svm.c</span>
<span class="p_header">index 0970c3f0c11d..fba31b73e4bc 100644</span>
<span class="p_header">--- a/arch/x86/kvm/svm.c</span>
<span class="p_header">+++ b/arch/x86/kvm/svm.c</span>
<span class="p_chunk">@@ -1620,7 +1620,7 @@</span> <span class="p_context"> static int pf_interception(struct vcpu_svm *svm)</span>
 	case KVM_PV_REASON_PAGE_NOT_PRESENT:
 		svm-&gt;apf_reason = 0;
 		local_irq_disable();
<span class="p_del">-		kvm_async_pf_task_wait(fault_address);</span>
<span class="p_add">+		kvm_async_pf_task_wait(fault_address, 0);</span>
 		local_irq_enable();
 		break;
 	case KVM_PV_REASON_PAGE_READY:
<span class="p_header">diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c</span>
<span class="p_header">index 88280620f77f..39d40adcaaf0 100644</span>
<span class="p_header">--- a/arch/x86/kvm/vmx.c</span>
<span class="p_header">+++ b/arch/x86/kvm/vmx.c</span>
<span class="p_chunk">@@ -7055,7 +7055,7 @@</span> <span class="p_context"> void load_vmcs12_host_state(struct kvm_vcpu *vcpu, struct vmcs12 *vmcs12)</span>
 	 * (KVM doesn&#39;t change it)- no reason to call set_cr4_guest_host_mask();
 	 */
 	vcpu-&gt;arch.cr4_guest_owned_bits = ~vmcs_readl(CR4_GUEST_HOST_MASK);
<span class="p_del">-	kvm_set_cr4(vcpu, vmcs12-&gt;host_cr4);</span>
<span class="p_add">+	vmx_set_cr4(vcpu, vmcs12-&gt;host_cr4);</span>
 
 	/* shadow page tables on either EPT or shadow page tables */
 	kvm_set_cr3(vcpu, vmcs12-&gt;host_cr3);
<span class="p_chunk">@@ -7285,12 +7285,7 @@</span> <span class="p_context"> static int __init vmx_init(void)</span>
 		goto out2;
 	}
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Allow direct access to the PC debug port (it is often used for I/O</span>
<span class="p_del">-	 * delays, but the vmexits simply slow things down).</span>
<span class="p_del">-	 */</span>
 	memset(vmx_io_bitmap_a, 0xff, PAGE_SIZE);
<span class="p_del">-	clear_bit(0x80, vmx_io_bitmap_a);</span>
 
 	memset(vmx_io_bitmap_b, 0xff, PAGE_SIZE);
 
<span class="p_header">diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c</span>
<span class="p_header">index 4baab231292f..7e6094b0308b 100644</span>
<span class="p_header">--- a/arch/x86/kvm/x86.c</span>
<span class="p_header">+++ b/arch/x86/kvm/x86.c</span>
<span class="p_chunk">@@ -3920,7 +3920,7 @@</span> <span class="p_context"> static int vcpu_mmio_read(struct kvm_vcpu *vcpu, gpa_t addr, int len, void *v)</span>
 		      !kvm_iodevice_read(&amp;vcpu-&gt;arch.apic-&gt;dev, addr, n, v))
 		    &amp;&amp; kvm_io_bus_read(vcpu-&gt;kvm, KVM_MMIO_BUS, addr, n, v))
 			break;
<span class="p_del">-		trace_kvm_mmio(KVM_TRACE_MMIO_READ, n, addr, *(u64 *)v);</span>
<span class="p_add">+		trace_kvm_mmio(KVM_TRACE_MMIO_READ, n, addr, v);</span>
 		handled += n;
 		addr += n;
 		len -= n;
<span class="p_chunk">@@ -4152,7 +4152,7 @@</span> <span class="p_context"> static int read_prepare(struct kvm_vcpu *vcpu, void *val, int bytes)</span>
 	if (vcpu-&gt;mmio_read_completed) {
 		memcpy(val, vcpu-&gt;mmio_data, bytes);
 		trace_kvm_mmio(KVM_TRACE_MMIO_READ, bytes,
<span class="p_del">-			       vcpu-&gt;mmio_phys_addr, *(u64 *)val);</span>
<span class="p_add">+			       vcpu-&gt;mmio_phys_addr, val);</span>
 		vcpu-&gt;mmio_read_completed = 0;
 		return 1;
 	}
<span class="p_chunk">@@ -4174,14 +4174,14 @@</span> <span class="p_context"> static int write_emulate(struct kvm_vcpu *vcpu, gpa_t gpa,</span>
 
 static int write_mmio(struct kvm_vcpu *vcpu, gpa_t gpa, int bytes, void *val)
 {
<span class="p_del">-	trace_kvm_mmio(KVM_TRACE_MMIO_WRITE, bytes, gpa, *(u64 *)val);</span>
<span class="p_add">+	trace_kvm_mmio(KVM_TRACE_MMIO_WRITE, bytes, gpa, val);</span>
 	return vcpu_mmio_write(vcpu, gpa, bytes, val);
 }
 
 static int read_exit_mmio(struct kvm_vcpu *vcpu, gpa_t gpa,
 			  void *val, int bytes)
 {
<span class="p_del">-	trace_kvm_mmio(KVM_TRACE_MMIO_READ_UNSATISFIED, bytes, gpa, 0);</span>
<span class="p_add">+	trace_kvm_mmio(KVM_TRACE_MMIO_READ_UNSATISFIED, bytes, gpa, NULL);</span>
 	return X86EMUL_IO_NEEDED;
 }
 
<span class="p_header">diff --git a/arch/x86/oprofile/op_model_ppro.c b/arch/x86/oprofile/op_model_ppro.c</span>
<span class="p_header">index d90528ea5412..12c051d19e4b 100644</span>
<span class="p_header">--- a/arch/x86/oprofile/op_model_ppro.c</span>
<span class="p_header">+++ b/arch/x86/oprofile/op_model_ppro.c</span>
<span class="p_chunk">@@ -212,8 +212,8 @@</span> <span class="p_context"> static void arch_perfmon_setup_counters(void)</span>
 	eax.full = cpuid_eax(0xa);
 
 	/* Workaround for BIOS bugs in 6/15. Taken from perfmon2 */
<span class="p_del">-	if (eax.split.version_id == 0 &amp;&amp; __this_cpu_read(cpu_info.x86) == 6 &amp;&amp;</span>
<span class="p_del">-		__this_cpu_read(cpu_info.x86_model) == 15) {</span>
<span class="p_add">+	if (eax.split.version_id == 0 &amp;&amp; boot_cpu_data.x86 == 6 &amp;&amp;</span>
<span class="p_add">+	    boot_cpu_data.x86_model == 15) {</span>
 		eax.split.version_id = 2;
 		eax.split.num_counters = 2;
 		eax.split.bit_width = 40;
<span class="p_header">diff --git a/crypto/hmac.c b/crypto/hmac.c</span>
<span class="p_header">index ade790b454e9..758688b4bc6b 100644</span>
<span class="p_header">--- a/crypto/hmac.c</span>
<span class="p_header">+++ b/crypto/hmac.c</span>
<span class="p_chunk">@@ -197,11 +197,15 @@</span> <span class="p_context"> static int hmac_create(struct crypto_template *tmpl, struct rtattr **tb)</span>
 	salg = shash_attr_alg(tb[1], 0, 0);
 	if (IS_ERR(salg))
 		return PTR_ERR(salg);
<span class="p_add">+	alg = &amp;salg-&gt;base;</span>
 
<span class="p_add">+	/* The underlying hash algorithm must be unkeyed */</span>
 	err = -EINVAL;
<span class="p_add">+	if (crypto_shash_alg_has_setkey(salg))</span>
<span class="p_add">+		goto out_put_alg;</span>
<span class="p_add">+</span>
 	ds = salg-&gt;digestsize;
 	ss = salg-&gt;statesize;
<span class="p_del">-	alg = &amp;salg-&gt;base;</span>
 	if (ds &gt; alg-&gt;cra_blocksize ||
 	    ss &lt; alg-&gt;cra_blocksize)
 		goto out_put_alg;
<span class="p_header">diff --git a/crypto/salsa20_generic.c b/crypto/salsa20_generic.c</span>
<span class="p_header">index f5e5a3386c82..5d2d5483fe38 100644</span>
<span class="p_header">--- a/crypto/salsa20_generic.c</span>
<span class="p_header">+++ b/crypto/salsa20_generic.c</span>
<span class="p_chunk">@@ -188,13 +188,6 @@</span> <span class="p_context"> static int encrypt(struct blkcipher_desc *desc,</span>
 
 	salsa20_ivsetup(ctx, walk.iv);
 
<span class="p_del">-	if (likely(walk.nbytes == nbytes))</span>
<span class="p_del">-	{</span>
<span class="p_del">-		salsa20_encrypt_bytes(ctx, walk.dst.virt.addr,</span>
<span class="p_del">-				      walk.src.virt.addr, nbytes);</span>
<span class="p_del">-		return blkcipher_walk_done(desc, &amp;walk, 0);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	while (walk.nbytes &gt;= 64) {
 		salsa20_encrypt_bytes(ctx, walk.dst.virt.addr,
 				      walk.src.virt.addr,
<span class="p_header">diff --git a/crypto/shash.c b/crypto/shash.c</span>
<span class="p_header">index 060e42bf2b37..0d66c2edc6d8 100644</span>
<span class="p_header">--- a/crypto/shash.c</span>
<span class="p_header">+++ b/crypto/shash.c</span>
<span class="p_chunk">@@ -24,11 +24,12 @@</span> <span class="p_context"></span>
 
 static const struct crypto_type crypto_shash_type;
 
<span class="p_del">-static int shash_no_setkey(struct crypto_shash *tfm, const u8 *key,</span>
<span class="p_del">-			   unsigned int keylen)</span>
<span class="p_add">+int shash_no_setkey(struct crypto_shash *tfm, const u8 *key,</span>
<span class="p_add">+		    unsigned int keylen)</span>
 {
 	return -ENOSYS;
 }
<span class="p_add">+EXPORT_SYMBOL_GPL(shash_no_setkey);</span>
 
 static int shash_setkey_unaligned(struct crypto_shash *tfm, const u8 *key,
 				  unsigned int keylen)
<span class="p_chunk">@@ -273,12 +274,14 @@</span> <span class="p_context"> static int shash_async_finup(struct ahash_request *req)</span>
 
 int shash_ahash_digest(struct ahash_request *req, struct shash_desc *desc)
 {
<span class="p_del">-	struct scatterlist *sg = req-&gt;src;</span>
<span class="p_del">-	unsigned int offset = sg-&gt;offset;</span>
 	unsigned int nbytes = req-&gt;nbytes;
<span class="p_add">+	struct scatterlist *sg;</span>
<span class="p_add">+	unsigned int offset;</span>
 	int err;
 
<span class="p_del">-	if (nbytes &lt; min(sg-&gt;length, ((unsigned int)(PAGE_SIZE)) - offset)) {</span>
<span class="p_add">+	if (nbytes &amp;&amp;</span>
<span class="p_add">+	    (sg = req-&gt;src, offset = sg-&gt;offset,</span>
<span class="p_add">+	     nbytes &lt; min(sg-&gt;length, ((unsigned int)(PAGE_SIZE)) - offset))) {</span>
 		void *data;
 
 		data = crypto_kmap(sg_page(sg), 0);
<span class="p_header">diff --git a/drivers/crypto/talitos.c b/drivers/crypto/talitos.c</span>
<span class="p_header">index 90c76fc2addd..68acc0dcb37d 100644</span>
<span class="p_header">--- a/drivers/crypto/talitos.c</span>
<span class="p_header">+++ b/drivers/crypto/talitos.c</span>
<span class="p_chunk">@@ -1632,9 +1632,9 @@</span> <span class="p_context"> static int common_nonsnoop_hash(struct talitos_edesc *edesc,</span>
 		req_ctx-&gt;swinit = 0;
 	} else {
 		desc-&gt;ptr[1] = zero_entry;
<span class="p_del">-		/* Indicate next op is not the first. */</span>
<span class="p_del">-		req_ctx-&gt;first = 0;</span>
 	}
<span class="p_add">+	/* Indicate next op is not the first. */</span>
<span class="p_add">+	req_ctx-&gt;first = 0;</span>
 
 	/* HMAC key */
 	if (ctx-&gt;keylen)
<span class="p_header">diff --git a/drivers/input/ff-core.c b/drivers/input/ff-core.c</span>
<span class="p_header">index 480eb9d9876a..6c8df172c25f 100644</span>
<span class="p_header">--- a/drivers/input/ff-core.c</span>
<span class="p_header">+++ b/drivers/input/ff-core.c</span>
<span class="p_chunk">@@ -239,9 +239,15 @@</span> <span class="p_context"> int input_ff_erase(struct input_dev *dev, int effect_id, struct file *file)</span>
 EXPORT_SYMBOL_GPL(input_ff_erase);
 
 /*
<span class="p_del">- * flush_effects - erase all effects owned by a file handle</span>
<span class="p_add">+ * input_ff_flush - erase all effects owned by a file handle</span>
<span class="p_add">+ * @dev: input device to erase effect from</span>
<span class="p_add">+ * @file: purported owner of the effects</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This function erases all force-feedback effects associated with</span>
<span class="p_add">+ * the given owner from specified device. Note that @file may be %NULL,</span>
<span class="p_add">+ * in which case all effects will be erased.</span>
  */
<span class="p_del">-static int flush_effects(struct input_dev *dev, struct file *file)</span>
<span class="p_add">+int input_ff_flush(struct input_dev *dev, struct file *file)</span>
 {
 	struct ff_device *ff = dev-&gt;ff;
 	int i;
<span class="p_chunk">@@ -257,6 +263,7 @@</span> <span class="p_context"> static int flush_effects(struct input_dev *dev, struct file *file)</span>
 
 	return 0;
 }
<span class="p_add">+EXPORT_SYMBOL_GPL(input_ff_flush);</span>
 
 /**
  * input_ff_event() - generic handler for force-feedback events
<span class="p_chunk">@@ -340,7 +347,7 @@</span> <span class="p_context"> int input_ff_create(struct input_dev *dev, unsigned int max_effects)</span>
 	mutex_init(&amp;ff-&gt;mutex);
 
 	dev-&gt;ff = ff;
<span class="p_del">-	dev-&gt;flush = flush_effects;</span>
<span class="p_add">+	dev-&gt;flush = input_ff_flush;</span>
 	dev-&gt;event = input_ff_event;
 	__set_bit(EV_FF, dev-&gt;evbit);
 
<span class="p_header">diff --git a/drivers/input/misc/uinput.c b/drivers/input/misc/uinput.c</span>
<span class="p_header">index f236a29a67ae..2a57de5d22f9 100644</span>
<span class="p_header">--- a/drivers/input/misc/uinput.c</span>
<span class="p_header">+++ b/drivers/input/misc/uinput.c</span>
<span class="p_chunk">@@ -218,6 +218,18 @@</span> <span class="p_context"> static int uinput_dev_erase_effect(struct input_dev *dev, int effect_id)</span>
 	return retval;
 }
 
<span class="p_add">+static int uinput_dev_flush(struct input_dev *dev, struct file *file)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If we are called with file == NULL that means we are tearing</span>
<span class="p_add">+	 * down the device, and therefore we can not handle FF erase</span>
<span class="p_add">+	 * requests: either we are handling UI_DEV_DESTROY (and holding</span>
<span class="p_add">+	 * the udev-&gt;mutex), or the file descriptor is closed and there is</span>
<span class="p_add">+	 * nobody on the other side anymore.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	return file ? input_ff_flush(dev, file) : 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void uinput_destroy_device(struct uinput_device *udev)
 {
 	const char *name, *phys;
<span class="p_chunk">@@ -261,6 +273,12 @@</span> <span class="p_context"> static int uinput_create_device(struct uinput_device *udev)</span>
 		dev-&gt;ff-&gt;playback = uinput_dev_playback;
 		dev-&gt;ff-&gt;set_gain = uinput_dev_set_gain;
 		dev-&gt;ff-&gt;set_autocenter = uinput_dev_set_autocenter;
<span class="p_add">+		/*</span>
<span class="p_add">+		 * The standard input_ff_flush() implementation does</span>
<span class="p_add">+		 * not quite work for uinput as we can&#39;t reasonably</span>
<span class="p_add">+		 * handle FF requests during device teardown.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		dev-&gt;flush = uinput_dev_flush;</span>
 	}
 
 	error = input_register_device(udev-&gt;dev);
<span class="p_header">diff --git a/drivers/iommu/amd_iommu.c b/drivers/iommu/amd_iommu.c</span>
<span class="p_header">index a80369032bd8..94e8fc45cd56 100644</span>
<span class="p_header">--- a/drivers/iommu/amd_iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/amd_iommu.c</span>
<span class="p_chunk">@@ -2772,6 +2772,7 @@</span> <span class="p_context"> static int amd_iommu_unmap(struct iommu_domain *dom, unsigned long iova,</span>
 	mutex_unlock(&amp;domain-&gt;api_lock);
 
 	domain_flush_tlb_pde(domain);
<span class="p_add">+	domain_flush_complete(domain);</span>
 
 	return get_order(unmap_size);
 }
<span class="p_header">diff --git a/drivers/net/can/usb/esd_usb2.c b/drivers/net/can/usb/esd_usb2.c</span>
<span class="p_header">index 9ecf09809682..8e6b832ea061 100644</span>
<span class="p_header">--- a/drivers/net/can/usb/esd_usb2.c</span>
<span class="p_header">+++ b/drivers/net/can/usb/esd_usb2.c</span>
<span class="p_chunk">@@ -332,7 +332,7 @@</span> <span class="p_context"> static void esd_usb2_rx_can_msg(struct esd_usb2_net_priv *priv,</span>
 		}
 
 		cf-&gt;can_id = id &amp; ESD_IDMASK;
<span class="p_del">-		cf-&gt;can_dlc = get_can_dlc(msg-&gt;msg.rx.dlc);</span>
<span class="p_add">+		cf-&gt;can_dlc = get_can_dlc(msg-&gt;msg.rx.dlc &amp; ~ESD_RTR);</span>
 
 		if (id &amp; ESD_EXTID)
 			cf-&gt;can_id |= CAN_EFF_FLAG;
<span class="p_header">diff --git a/drivers/net/macvtap.c b/drivers/net/macvtap.c</span>
<span class="p_header">index 1c3db94e4237..de286ef18543 100644</span>
<span class="p_header">--- a/drivers/net/macvtap.c</span>
<span class="p_header">+++ b/drivers/net/macvtap.c</span>
<span class="p_chunk">@@ -951,10 +951,12 @@</span> <span class="p_context"> static long macvtap_ioctl(struct file *file, unsigned int cmd,</span>
 		return 0;
 
 	case TUNSETSNDBUF:
<span class="p_del">-		if (get_user(u, up))</span>
<span class="p_add">+		if (get_user(s, sp))</span>
 			return -EFAULT;
<span class="p_add">+		if (s &lt;= 0)</span>
<span class="p_add">+			return -EINVAL;</span>
 
<span class="p_del">-		q-&gt;sk.sk_sndbuf = u;</span>
<span class="p_add">+		q-&gt;sk.sk_sndbuf = s;</span>
 		return 0;
 
 	case TUNGETVNETHDRSZ:
<span class="p_header">diff --git a/drivers/net/tun.c b/drivers/net/tun.c</span>
<span class="p_header">index 9c2e91c5a6bc..e4788b14acae 100644</span>
<span class="p_header">--- a/drivers/net/tun.c</span>
<span class="p_header">+++ b/drivers/net/tun.c</span>
<span class="p_chunk">@@ -1397,6 +1397,10 @@</span> <span class="p_context"> static long __tun_chr_ioctl(struct file *file, unsigned int cmd,</span>
 			ret = -EFAULT;
 			break;
 		}
<span class="p_add">+		if (sndbuf &lt;= 0) {</span>
<span class="p_add">+			ret = -EINVAL;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
 
 		tun-&gt;socket.sk-&gt;sk_sndbuf = sndbuf;
 		break;
<span class="p_header">diff --git a/drivers/s390/scsi/zfcp_aux.c b/drivers/s390/scsi/zfcp_aux.c</span>
<span class="p_header">index 3743ac931231..7acfa9514ca5 100644</span>
<span class="p_header">--- a/drivers/s390/scsi/zfcp_aux.c</span>
<span class="p_header">+++ b/drivers/s390/scsi/zfcp_aux.c</span>
<span class="p_chunk">@@ -366,6 +366,8 @@</span> <span class="p_context"> struct zfcp_adapter *zfcp_adapter_enqueue(struct ccw_device *ccw_device)</span>
 	INIT_WORK(&amp;adapter-&gt;scan_work, zfcp_fc_scan_ports);
 	INIT_WORK(&amp;adapter-&gt;ns_up_work, zfcp_fc_sym_name_update);
 
<span class="p_add">+	adapter-&gt;erp_action.adapter = adapter;</span>
<span class="p_add">+</span>
 	if (zfcp_qdio_setup(adapter))
 		goto failed;
 
<span class="p_chunk">@@ -535,6 +537,9 @@</span> <span class="p_context"> struct zfcp_port *zfcp_port_enqueue(struct zfcp_adapter *adapter, u64 wwpn,</span>
 	port-&gt;dev.parent = &amp;adapter-&gt;ccw_device-&gt;dev;
 	port-&gt;dev.release = zfcp_port_release;
 
<span class="p_add">+	port-&gt;erp_action.adapter = adapter;</span>
<span class="p_add">+	port-&gt;erp_action.port = port;</span>
<span class="p_add">+</span>
 	if (dev_set_name(&amp;port-&gt;dev, &quot;0x%016llx&quot;, (unsigned long long)wwpn)) {
 		kfree(port);
 		goto err_out;
<span class="p_header">diff --git a/drivers/s390/scsi/zfcp_erp.c b/drivers/s390/scsi/zfcp_erp.c</span>
<span class="p_header">index 126fa412a059..a0b7fc5cb6ad 100644</span>
<span class="p_header">--- a/drivers/s390/scsi/zfcp_erp.c</span>
<span class="p_header">+++ b/drivers/s390/scsi/zfcp_erp.c</span>
<span class="p_chunk">@@ -193,9 +193,8 @@</span> <span class="p_context"> static struct zfcp_erp_action *zfcp_erp_setup_act(int need, u32 act_status,</span>
 		atomic_set_mask(ZFCP_STATUS_COMMON_ERP_INUSE,
 				&amp;zfcp_sdev-&gt;status);
 		erp_action = &amp;zfcp_sdev-&gt;erp_action;
<span class="p_del">-		memset(erp_action, 0, sizeof(struct zfcp_erp_action));</span>
<span class="p_del">-		erp_action-&gt;port = port;</span>
<span class="p_del">-		erp_action-&gt;sdev = sdev;</span>
<span class="p_add">+		WARN_ON_ONCE(erp_action-&gt;port != port);</span>
<span class="p_add">+		WARN_ON_ONCE(erp_action-&gt;sdev != sdev);</span>
 		if (!(atomic_read(&amp;zfcp_sdev-&gt;status) &amp;
 		      ZFCP_STATUS_COMMON_RUNNING))
 			act_status |= ZFCP_STATUS_ERP_CLOSE_ONLY;
<span class="p_chunk">@@ -208,8 +207,8 @@</span> <span class="p_context"> static struct zfcp_erp_action *zfcp_erp_setup_act(int need, u32 act_status,</span>
 		zfcp_erp_action_dismiss_port(port);
 		atomic_set_mask(ZFCP_STATUS_COMMON_ERP_INUSE, &amp;port-&gt;status);
 		erp_action = &amp;port-&gt;erp_action;
<span class="p_del">-		memset(erp_action, 0, sizeof(struct zfcp_erp_action));</span>
<span class="p_del">-		erp_action-&gt;port = port;</span>
<span class="p_add">+		WARN_ON_ONCE(erp_action-&gt;port != port);</span>
<span class="p_add">+		WARN_ON_ONCE(erp_action-&gt;sdev != NULL);</span>
 		if (!(atomic_read(&amp;port-&gt;status) &amp; ZFCP_STATUS_COMMON_RUNNING))
 			act_status |= ZFCP_STATUS_ERP_CLOSE_ONLY;
 		break;
<span class="p_chunk">@@ -219,7 +218,8 @@</span> <span class="p_context"> static struct zfcp_erp_action *zfcp_erp_setup_act(int need, u32 act_status,</span>
 		zfcp_erp_action_dismiss_adapter(adapter);
 		atomic_set_mask(ZFCP_STATUS_COMMON_ERP_INUSE, &amp;adapter-&gt;status);
 		erp_action = &amp;adapter-&gt;erp_action;
<span class="p_del">-		memset(erp_action, 0, sizeof(struct zfcp_erp_action));</span>
<span class="p_add">+		WARN_ON_ONCE(erp_action-&gt;port != NULL);</span>
<span class="p_add">+		WARN_ON_ONCE(erp_action-&gt;sdev != NULL);</span>
 		if (!(atomic_read(&amp;adapter-&gt;status) &amp;
 		      ZFCP_STATUS_COMMON_RUNNING))
 			act_status |= ZFCP_STATUS_ERP_CLOSE_ONLY;
<span class="p_chunk">@@ -229,7 +229,11 @@</span> <span class="p_context"> static struct zfcp_erp_action *zfcp_erp_setup_act(int need, u32 act_status,</span>
 		return NULL;
 	}
 
<span class="p_del">-	erp_action-&gt;adapter = adapter;</span>
<span class="p_add">+	WARN_ON_ONCE(erp_action-&gt;adapter != adapter);</span>
<span class="p_add">+	memset(&amp;erp_action-&gt;list, 0, sizeof(erp_action-&gt;list));</span>
<span class="p_add">+	memset(&amp;erp_action-&gt;timer, 0, sizeof(erp_action-&gt;timer));</span>
<span class="p_add">+	erp_action-&gt;step = ZFCP_ERP_STEP_UNINITIALIZED;</span>
<span class="p_add">+	erp_action-&gt;fsf_req_id = 0;</span>
 	erp_action-&gt;action = need;
 	erp_action-&gt;status = act_status;
 
<span class="p_header">diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c</span>
<span class="p_header">index b495c085a0b5..0c03ae19b689 100644</span>
<span class="p_header">--- a/drivers/s390/scsi/zfcp_scsi.c</span>
<span class="p_header">+++ b/drivers/s390/scsi/zfcp_scsi.c</span>
<span class="p_chunk">@@ -136,10 +136,15 @@</span> <span class="p_context"> static int zfcp_scsi_slave_alloc(struct scsi_device *sdev)</span>
 	struct zfcp_unit *unit;
 	int npiv = adapter-&gt;connection_features &amp; FSF_FEATURE_NPIV_MODE;
 
<span class="p_add">+	zfcp_sdev-&gt;erp_action.adapter = adapter;</span>
<span class="p_add">+	zfcp_sdev-&gt;erp_action.sdev = sdev;</span>
<span class="p_add">+</span>
 	port = zfcp_get_port_by_wwpn(adapter, rport-&gt;port_name);
 	if (!port)
 		return -ENXIO;
 
<span class="p_add">+	zfcp_sdev-&gt;erp_action.port = port;</span>
<span class="p_add">+</span>
 	unit = zfcp_unit_find(port, zfcp_scsi_dev_lun(sdev));
 	if (unit)
 		put_device(&amp;unit-&gt;dev);
<span class="p_header">diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c</span>
<span class="p_header">index 8771c03af340..22f9aa0dff6d 100644</span>
<span class="p_header">--- a/drivers/scsi/libiscsi.c</span>
<span class="p_header">+++ b/drivers/scsi/libiscsi.c</span>
<span class="p_chunk">@@ -1660,7 +1660,7 @@</span> <span class="p_context"> int iscsi_queuecommand(struct Scsi_Host *host, struct scsi_cmnd *sc)</span>
 
 	if (test_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_tx)) {
 		reason = FAILURE_SESSION_IN_RECOVERY;
<span class="p_del">-		sc-&gt;result = DID_REQUEUE;</span>
<span class="p_add">+		sc-&gt;result = DID_REQUEUE &lt;&lt; 16;</span>
 		goto fault;
 	}
 
<span class="p_header">diff --git a/drivers/scsi/lpfc/lpfc_init.c b/drivers/scsi/lpfc/lpfc_init.c</span>
<span class="p_header">index 1421ca3ea477..0fa2c205f00e 100644</span>
<span class="p_header">--- a/drivers/scsi/lpfc/lpfc_init.c</span>
<span class="p_header">+++ b/drivers/scsi/lpfc/lpfc_init.c</span>
<span class="p_chunk">@@ -4490,6 +4490,7 @@</span> <span class="p_context"> lpfc_sli4_driver_resource_setup(struct lpfc_hba *phba)</span>
 			lpfc_printf_log(phba, KERN_ERR, LOG_INIT,
 				&quot;2999 Unsupported SLI4 Parameters &quot;
 				&quot;Extents and RPI headers enabled.\n&quot;);
<span class="p_add">+			rc = -EIO;</span>
 			goto out_free_bsmbx;
 		}
 	}
<span class="p_header">diff --git a/drivers/scsi/scsi_scan.c b/drivers/scsi/scsi_scan.c</span>
<span class="p_header">index 5d207f1aca7a..8d640eb8b287 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_scan.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_scan.c</span>
<span class="p_chunk">@@ -957,6 +957,9 @@</span> <span class="p_context"> static int scsi_add_lun(struct scsi_device *sdev, unsigned char *inq_result,</span>
 	if (*bflags &amp; BLIST_RETRY_HWERROR)
 		sdev-&gt;retry_hwerror = 1;
 
<span class="p_add">+	if (*bflags &amp; BLIST_UNMAP_LIMIT_WS)</span>
<span class="p_add">+		sdev-&gt;unmap_limit_for_ws = 1;</span>
<span class="p_add">+</span>
 	transport_configure_device(&amp;sdev-&gt;sdev_gendev);
 
 	if (sdev-&gt;host-&gt;hostt-&gt;slave_configure) {
<span class="p_header">diff --git a/drivers/scsi/sd.c b/drivers/scsi/sd.c</span>
<span class="p_header">index 6cbe2eb5326d..ff16bc3057cd 100644</span>
<span class="p_header">--- a/drivers/scsi/sd.c</span>
<span class="p_header">+++ b/drivers/scsi/sd.c</span>
<span class="p_chunk">@@ -523,11 +523,21 @@</span> <span class="p_context"> static void sd_config_discard(struct scsi_disk *sdkp, unsigned int mode)</span>
 		break;
 
 	case SD_LBP_WS16:
<span class="p_del">-		max_blocks = min_not_zero(sdkp-&gt;max_ws_blocks, 0xffffffff);</span>
<span class="p_add">+		if (sdkp-&gt;device-&gt;unmap_limit_for_ws)</span>
<span class="p_add">+			max_blocks = sdkp-&gt;max_unmap_blocks;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			max_blocks = sdkp-&gt;max_ws_blocks;</span>
<span class="p_add">+</span>
<span class="p_add">+		max_blocks = min_not_zero(max_blocks, 0xffffffff);</span>
 		break;
 
 	case SD_LBP_WS10:
<span class="p_del">-		max_blocks = min_not_zero(sdkp-&gt;max_ws_blocks, (u32)0xffff);</span>
<span class="p_add">+		if (sdkp-&gt;device-&gt;unmap_limit_for_ws)</span>
<span class="p_add">+			max_blocks = sdkp-&gt;max_unmap_blocks;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			max_blocks = sdkp-&gt;max_ws_blocks;</span>
<span class="p_add">+</span>
<span class="p_add">+		max_blocks = min_not_zero(max_blocks, (u32)0xffff);</span>
 		break;
 
 	case SD_LBP_ZERO:
<span class="p_header">diff --git a/drivers/staging/iio/meter/ade7759.c b/drivers/staging/iio/meter/ade7759.c</span>
<span class="p_header">index b691f10ce988..60376d33cd40 100644</span>
<span class="p_header">--- a/drivers/staging/iio/meter/ade7759.c</span>
<span class="p_header">+++ b/drivers/staging/iio/meter/ade7759.c</span>
<span class="p_chunk">@@ -128,7 +128,7 @@</span> <span class="p_context"> static int ade7759_spi_read_reg_40(struct device *dev,</span>
 				reg_address);
 		goto error_ret;
 	}
<span class="p_del">-	*val = ((u64)st-&gt;rx[1] &lt;&lt; 32) | (st-&gt;rx[2] &lt;&lt; 24) |</span>
<span class="p_add">+	*val = ((u64)st-&gt;rx[1] &lt;&lt; 32) | ((u64)st-&gt;rx[2] &lt;&lt; 24) |</span>
 		(st-&gt;rx[3] &lt;&lt; 16) | (st-&gt;rx[4] &lt;&lt; 8) | st-&gt;rx[5];
 
 error_ret:
<span class="p_header">diff --git a/drivers/usb/class/cdc-acm.c b/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">index bcadc2e3cacc..95fb78bbdbce 100644</span>
<span class="p_header">--- a/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">+++ b/drivers/usb/class/cdc-acm.c</span>
<span class="p_chunk">@@ -1595,6 +1595,9 @@</span> <span class="p_context"> static const struct usb_device_id acm_ids[] = {</span>
 	{ USB_DEVICE(0xfff0, 0x0100), /* DATECS FP-2000 */
 	.driver_info = NO_UNION_NORMAL, /* reports zero length descriptor */
 	},
<span class="p_add">+	{ USB_DEVICE(0x09d8, 0x0320), /* Elatec GmbH TWN3 */</span>
<span class="p_add">+	.driver_info = NO_UNION_NORMAL, /* has misplaced union descriptor */</span>
<span class="p_add">+	},</span>
 
 	{ USB_DEVICE(0x2912, 0x0001), /* ATOL FPrint */
 	.driver_info = CLEAR_HALT_CONDITIONS,
<span class="p_header">diff --git a/drivers/usb/core/config.c b/drivers/usb/core/config.c</span>
<span class="p_header">index ea15bccf30a7..0a80b5991773 100644</span>
<span class="p_header">--- a/drivers/usb/core/config.c</span>
<span class="p_header">+++ b/drivers/usb/core/config.c</span>
<span class="p_chunk">@@ -521,6 +521,9 @@</span> <span class="p_context"> static int usb_parse_configuration(struct usb_device *dev, int cfgidx,</span>
 	unsigned iad_num = 0;
 
 	memcpy(&amp;config-&gt;desc, buffer, USB_DT_CONFIG_SIZE);
<span class="p_add">+	nintf = nintf_orig = config-&gt;desc.bNumInterfaces;</span>
<span class="p_add">+	config-&gt;desc.bNumInterfaces = 0;	// Adjusted later</span>
<span class="p_add">+</span>
 	if (config-&gt;desc.bDescriptorType != USB_DT_CONFIG ||
 	    config-&gt;desc.bLength &lt; USB_DT_CONFIG_SIZE ||
 	    config-&gt;desc.bLength &gt; size) {
<span class="p_chunk">@@ -534,7 +537,6 @@</span> <span class="p_context"> static int usb_parse_configuration(struct usb_device *dev, int cfgidx,</span>
 	buffer += config-&gt;desc.bLength;
 	size -= config-&gt;desc.bLength;
 
<span class="p_del">-	nintf = nintf_orig = config-&gt;desc.bNumInterfaces;</span>
 	if (nintf &gt; USB_MAXINTERFACES) {
 		dev_warn(ddev, &quot;config %d has too many interfaces: %d, &quot;
 		    &quot;using maximum allowed: %d\n&quot;,
<span class="p_chunk">@@ -830,7 +832,7 @@</span> <span class="p_context"> int usb_get_configuration(struct usb_device *dev)</span>
 		}
 
 		if (dev-&gt;quirks &amp; USB_QUIRK_DELAY_INIT)
<span class="p_del">-			msleep(100);</span>
<span class="p_add">+			msleep(200);</span>
 
 		result = usb_get_descriptor(dev, USB_DT_CONFIG, cfgno,
 		    bigbuffer, length);
<span class="p_header">diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c</span>
<span class="p_header">index 7c5946640888..18dcd1c763ab 100644</span>
<span class="p_header">--- a/drivers/usb/core/hub.c</span>
<span class="p_header">+++ b/drivers/usb/core/hub.c</span>
<span class="p_chunk">@@ -3552,7 +3552,7 @@</span> <span class="p_context"> static void hub_port_connect_change(struct usb_hub *hub, int port1,</span>
 
 		usb_detect_quirks(udev);
 		if (udev-&gt;quirks &amp; USB_QUIRK_DELAY_INIT)
<span class="p_del">-			msleep(1000);</span>
<span class="p_add">+			msleep(2000);</span>
 
 		/* consecutive bus-powered hubs aren&#39;t reliable; they can
 		 * violate the voltage drop budget.  if the new child has
<span class="p_header">diff --git a/drivers/usb/core/quirks.c b/drivers/usb/core/quirks.c</span>
<span class="p_header">index 73b16be692af..512c2a4493f8 100644</span>
<span class="p_header">--- a/drivers/usb/core/quirks.c</span>
<span class="p_header">+++ b/drivers/usb/core/quirks.c</span>
<span class="p_chunk">@@ -205,6 +205,10 @@</span> <span class="p_context"> static const struct usb_device_id usb_quirk_list[] = {</span>
 	/* Corsair Strafe RGB */
 	{ USB_DEVICE(0x1b1c, 0x1b20), .driver_info = USB_QUIRK_DELAY_INIT },
 
<span class="p_add">+	/* MIDI keyboard WORLDE MINI */</span>
<span class="p_add">+	{ USB_DEVICE(0x1c75, 0x0204), .driver_info =</span>
<span class="p_add">+			USB_QUIRK_CONFIG_INTF_STRINGS },</span>
<span class="p_add">+</span>
 	{ }  /* terminating entry must be last */
 };
 
<span class="p_header">diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c</span>
<span class="p_header">index 03a9222a03b3..2506e3a14c0a 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/dummy_hcd.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/dummy_hcd.c</span>
<span class="p_chunk">@@ -167,6 +167,7 @@</span> <span class="p_context"> struct dummy_hcd {</span>
 
 	struct usb_device		*udev;
 	struct list_head		urbp_list;
<span class="p_add">+	struct urbp			*next_frame_urbp;</span>
 
 	unsigned			active:1;
 	unsigned			old_active:1;
<span class="p_chunk">@@ -181,11 +182,13 @@</span> <span class="p_context"> struct dummy {</span>
 	 */
 	struct dummy_ep			ep [DUMMY_ENDPOINTS];
 	int				address;
<span class="p_add">+	int				callback_usage;</span>
 	struct usb_gadget		gadget;
 	struct usb_gadget_driver	*driver;
 	struct dummy_request		fifo_req;
 	u8				fifo_buf [FIFO_SIZE];
 	u16				devstatus;
<span class="p_add">+	unsigned			ints_enabled:1;</span>
 	unsigned			udc_suspended:1;
 	unsigned			pullup:1;
 
<span class="p_chunk">@@ -347,6 +350,7 @@</span> <span class="p_context"> static void set_link_state_by_speed(struct dummy_hcd *dum_hcd)</span>
 static void set_link_state(struct dummy_hcd *dum_hcd)
 {
 	struct dummy *dum = dum_hcd-&gt;dum;
<span class="p_add">+	unsigned int power_bit;</span>
 
 	dum_hcd-&gt;active = 0;
 	if (dum-&gt;pullup)
<span class="p_chunk">@@ -357,36 +361,40 @@</span> <span class="p_context"> static void set_link_state(struct dummy_hcd *dum_hcd)</span>
 			return;
 
 	set_link_state_by_speed(dum_hcd);
<span class="p_add">+	power_bit = (dummy_hcd_to_hcd(dum_hcd)-&gt;speed == HCD_USB3 ?</span>
<span class="p_add">+			USB_SS_PORT_STAT_POWER : USB_PORT_STAT_POWER);</span>
 
 	if ((dum_hcd-&gt;port_status &amp; USB_PORT_STAT_ENABLE) == 0 ||
 	     dum_hcd-&gt;active)
 		dum_hcd-&gt;resuming = 0;
 
 	/* if !connected or reset */
<span class="p_del">-	if ((dum_hcd-&gt;port_status &amp; USB_PORT_STAT_CONNECTION) == 0 ||</span>
<span class="p_add">+	if ((dum_hcd-&gt;port_status &amp; power_bit) == 0 ||</span>
 			(dum_hcd-&gt;port_status &amp; USB_PORT_STAT_RESET) != 0) {
 		/*
 		 * We&#39;re connected and not reset (reset occurred now),
 		 * and driver attached - disconnect!
 		 */
<span class="p_del">-		if ((dum_hcd-&gt;old_status &amp; USB_PORT_STAT_CONNECTION) != 0 &amp;&amp;</span>
<span class="p_add">+		if ((dum_hcd-&gt;old_status &amp; power_bit) != 0 &amp;&amp;</span>
 		    (dum_hcd-&gt;old_status &amp; USB_PORT_STAT_RESET) == 0 &amp;&amp;
<span class="p_del">-		    dum-&gt;driver) {</span>
<span class="p_add">+		    dum-&gt;ints_enabled) {</span>
 			stop_activity(dum);
<span class="p_add">+			++dum-&gt;callback_usage;</span>
 			spin_unlock(&amp;dum-&gt;lock);
 			dum-&gt;driver-&gt;disconnect(&amp;dum-&gt;gadget);
 			spin_lock(&amp;dum-&gt;lock);
<span class="p_add">+			--dum-&gt;callback_usage;</span>
 		}
<span class="p_del">-	} else if (dum_hcd-&gt;active != dum_hcd-&gt;old_active) {</span>
<span class="p_del">-		if (dum_hcd-&gt;old_active &amp;&amp; dum-&gt;driver-&gt;suspend) {</span>
<span class="p_del">-			spin_unlock(&amp;dum-&gt;lock);</span>
<span class="p_add">+	} else if (dum_hcd-&gt;active != dum_hcd-&gt;old_active &amp;&amp;</span>
<span class="p_add">+			dum-&gt;ints_enabled) {</span>
<span class="p_add">+		++dum-&gt;callback_usage;</span>
<span class="p_add">+		spin_unlock(&amp;dum-&gt;lock);</span>
<span class="p_add">+		if (dum_hcd-&gt;old_active &amp;&amp; dum-&gt;driver-&gt;suspend)</span>
 			dum-&gt;driver-&gt;suspend(&amp;dum-&gt;gadget);
<span class="p_del">-			spin_lock(&amp;dum-&gt;lock);</span>
<span class="p_del">-		} else if (!dum_hcd-&gt;old_active &amp;&amp;  dum-&gt;driver-&gt;resume) {</span>
<span class="p_del">-			spin_unlock(&amp;dum-&gt;lock);</span>
<span class="p_add">+		else if (!dum_hcd-&gt;old_active &amp;&amp;  dum-&gt;driver-&gt;resume)</span>
 			dum-&gt;driver-&gt;resume(&amp;dum-&gt;gadget);
<span class="p_del">-			spin_lock(&amp;dum-&gt;lock);</span>
<span class="p_del">-		}</span>
<span class="p_add">+		spin_lock(&amp;dum-&gt;lock);</span>
<span class="p_add">+		--dum-&gt;callback_usage;</span>
 	}
 
 	dum_hcd-&gt;old_status = dum_hcd-&gt;port_status;
<span class="p_chunk">@@ -907,9 +915,12 @@</span> <span class="p_context"> static int dummy_udc_start(struct usb_gadget *g,</span>
 	 * can&#39;t enumerate without help from the driver we&#39;re binding.
 	 */
 
<span class="p_add">+	spin_lock_irq(&amp;dum-&gt;lock);</span>
 	dum-&gt;devstatus = 0;
 
 	dum-&gt;driver = driver;
<span class="p_add">+	dum-&gt;ints_enabled = 1;</span>
<span class="p_add">+	spin_unlock_irq(&amp;dum-&gt;lock);</span>
 	dev_dbg (udc_dev(dum), &quot;binding gadget driver &#39;%s&#39;\n&quot;,
 			driver-&gt;driver.name);
 	return 0;
<span class="p_chunk">@@ -924,7 +935,19 @@</span> <span class="p_context"> static int dummy_udc_stop(struct usb_gadget *g,</span>
 	dev_dbg (udc_dev(dum), &quot;unregister gadget driver &#39;%s&#39;\n&quot;,
 			driver-&gt;driver.name);
 
<span class="p_add">+	spin_lock_irq(&amp;dum-&gt;lock);</span>
<span class="p_add">+	dum-&gt;ints_enabled = 0;</span>
<span class="p_add">+	stop_activity(dum);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* emulate synchronize_irq(): wait for callbacks to finish */</span>
<span class="p_add">+	while (dum-&gt;callback_usage &gt; 0) {</span>
<span class="p_add">+		spin_unlock_irq(&amp;dum-&gt;lock);</span>
<span class="p_add">+		usleep_range(1000, 2000);</span>
<span class="p_add">+		spin_lock_irq(&amp;dum-&gt;lock);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	dum-&gt;driver = NULL;
<span class="p_add">+	spin_unlock_irq(&amp;dum-&gt;lock);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -1108,6 +1131,8 @@</span> <span class="p_context"> static int dummy_urb_enqueue (</span>
 
 	list_add_tail(&amp;urbp-&gt;urbp_list, &amp;dum_hcd-&gt;urbp_list);
 	urb-&gt;hcpriv = urbp;
<span class="p_add">+	if (!dum_hcd-&gt;next_frame_urbp)</span>
<span class="p_add">+		dum_hcd-&gt;next_frame_urbp = urbp;</span>
 	if (usb_pipetype (urb-&gt;pipe) == PIPE_CONTROL)
 		urb-&gt;error_count = 1;		/* mark as a new urb */
 
<span class="p_chunk">@@ -1303,6 +1328,8 @@</span> <span class="p_context"> static struct dummy_ep *find_endpoint (struct dummy *dum, u8 address)</span>
 	if (!is_active((dum-&gt;gadget.speed == USB_SPEED_SUPER ?
 			dum-&gt;ss_hcd : dum-&gt;hs_hcd)))
 		return NULL;
<span class="p_add">+	if (!dum-&gt;ints_enabled)</span>
<span class="p_add">+		return NULL;</span>
 	if ((address &amp; ~USB_DIR_IN) == 0)
 		return &amp;dum-&gt;ep [0];
 	for (i = 1; i &lt; DUMMY_ENDPOINTS; i++) {
<span class="p_chunk">@@ -1544,6 +1571,7 @@</span> <span class="p_context"> static void dummy_timer(unsigned long _dum_hcd)</span>
 		spin_unlock_irqrestore (&amp;dum-&gt;lock, flags);
 		return;
 	}
<span class="p_add">+	dum_hcd-&gt;next_frame_urbp = NULL;</span>
 
 	for (i = 0; i &lt; DUMMY_ENDPOINTS; i++) {
 		if (!ep_name [i])
<span class="p_chunk">@@ -1560,6 +1588,10 @@</span> <span class="p_context"> static void dummy_timer(unsigned long _dum_hcd)</span>
 		int			type;
 		int			status = -EINPROGRESS;
 
<span class="p_add">+		/* stop when we reach URBs queued after the timer interrupt */</span>
<span class="p_add">+		if (urbp == dum_hcd-&gt;next_frame_urbp)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
 		urb = urbp-&gt;urb;
 		if (urb-&gt;unlinked)
 			goto return_urb;
<span class="p_chunk">@@ -1639,10 +1671,12 @@</span> <span class="p_context"> static void dummy_timer(unsigned long _dum_hcd)</span>
 			 * until setup() returns; no reentrancy issues etc.
 			 */
 			if (value &gt; 0) {
<span class="p_add">+				++dum-&gt;callback_usage;</span>
 				spin_unlock (&amp;dum-&gt;lock);
 				value = dum-&gt;driver-&gt;setup (&amp;dum-&gt;gadget,
 						&amp;setup);
 				spin_lock (&amp;dum-&gt;lock);
<span class="p_add">+				--dum-&gt;callback_usage;</span>
 
 				if (value &gt;= 0) {
 					/* no delays (max 64KB data stage) */
<span class="p_header">diff --git a/drivers/usb/gadget/inode.c b/drivers/usb/gadget/inode.c</span>
<span class="p_header">index 287c6ab505d6..bc3273dd92c3 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/inode.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/inode.c</span>
<span class="p_chunk">@@ -24,7 +24,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/sched.h&gt;
 #include &lt;linux/slab.h&gt;
 #include &lt;linux/poll.h&gt;
<span class="p_del">-</span>
<span class="p_add">+#include &lt;linux/delay.h&gt;</span>
 #include &lt;linux/device.h&gt;
 #include &lt;linux/moduleparam.h&gt;
 
<span class="p_chunk">@@ -112,6 +112,7 @@</span> <span class="p_context"> enum ep0_state {</span>
 struct dev_data {
 	spinlock_t			lock;
 	atomic_t			count;
<span class="p_add">+	int				udc_usage;</span>
 	enum ep0_state			state;		/* P: lock */
 	struct usb_gadgetfs_event	event [N_EVENT];
 	unsigned			ev_next;
<span class="p_chunk">@@ -608,9 +609,9 @@</span> <span class="p_context"> static void ep_aio_complete(struct usb_ep *ep, struct usb_request *req)</span>
 		priv-&gt;actual = req-&gt;actual;
 		kick_iocb(iocb);
 	}
<span class="p_del">-	spin_unlock(&amp;epdata-&gt;dev-&gt;lock);</span>
 
 	usb_ep_free_request(ep, req);
<span class="p_add">+	spin_unlock(&amp;epdata-&gt;dev-&gt;lock);</span>
 	put_ep(epdata);
 }
 
<span class="p_chunk">@@ -1009,8 +1010,13 @@</span> <span class="p_context"> ep0_read (struct file *fd, char __user *buf, size_t len, loff_t *ptr)</span>
 			struct usb_ep		*ep = dev-&gt;gadget-&gt;ep0;
 			struct usb_request	*req = dev-&gt;req;
 
<span class="p_del">-			if ((retval = setup_req (ep, req, 0)) == 0)</span>
<span class="p_del">-				retval = usb_ep_queue (ep, req, GFP_ATOMIC);</span>
<span class="p_add">+			if ((retval = setup_req (ep, req, 0)) == 0) {</span>
<span class="p_add">+				++dev-&gt;udc_usage;</span>
<span class="p_add">+				spin_unlock_irq (&amp;dev-&gt;lock);</span>
<span class="p_add">+				retval = usb_ep_queue (ep, req, GFP_KERNEL);</span>
<span class="p_add">+				spin_lock_irq (&amp;dev-&gt;lock);</span>
<span class="p_add">+				--dev-&gt;udc_usage;</span>
<span class="p_add">+			}</span>
 			dev-&gt;state = STATE_DEV_CONNECTED;
 
 			/* assume that was SET_CONFIGURATION */
<span class="p_chunk">@@ -1051,11 +1057,14 @@</span> <span class="p_context"> ep0_read (struct file *fd, char __user *buf, size_t len, loff_t *ptr)</span>
 				retval = -EIO;
 			else {
 				len = min (len, (size_t)dev-&gt;req-&gt;actual);
<span class="p_del">-// FIXME don&#39;t call this with the spinlock held ...</span>
<span class="p_add">+				++dev-&gt;udc_usage;</span>
<span class="p_add">+				spin_unlock_irq(&amp;dev-&gt;lock);</span>
 				if (copy_to_user (buf, dev-&gt;req-&gt;buf, len))
 					retval = -EFAULT;
 				else
 					retval = len;
<span class="p_add">+				spin_lock_irq(&amp;dev-&gt;lock);</span>
<span class="p_add">+				--dev-&gt;udc_usage;</span>
 				clean_req (dev-&gt;gadget-&gt;ep0, dev-&gt;req);
 				/* NOTE userspace can&#39;t yet choose to stall */
 			}
<span class="p_chunk">@@ -1201,6 +1210,7 @@</span> <span class="p_context"> ep0_write (struct file *fd, const char __user *buf, size_t len, loff_t *ptr)</span>
 			retval = setup_req (dev-&gt;gadget-&gt;ep0, dev-&gt;req, len);
 			if (retval == 0) {
 				dev-&gt;state = STATE_DEV_CONNECTED;
<span class="p_add">+				++dev-&gt;udc_usage;</span>
 				spin_unlock_irq (&amp;dev-&gt;lock);
 				if (copy_from_user (dev-&gt;req-&gt;buf, buf, len))
 					retval = -EFAULT;
<span class="p_chunk">@@ -1211,12 +1221,13 @@</span> <span class="p_context"> ep0_write (struct file *fd, const char __user *buf, size_t len, loff_t *ptr)</span>
 						dev-&gt;gadget-&gt;ep0, dev-&gt;req,
 						GFP_KERNEL);
 				}
<span class="p_add">+				spin_lock_irq(&amp;dev-&gt;lock);</span>
<span class="p_add">+				--dev-&gt;udc_usage;</span>
 				if (retval &lt; 0) {
<span class="p_del">-					spin_lock_irq (&amp;dev-&gt;lock);</span>
 					clean_req (dev-&gt;gadget-&gt;ep0, dev-&gt;req);
<span class="p_del">-					spin_unlock_irq (&amp;dev-&gt;lock);</span>
 				} else
 					retval = len;
<span class="p_add">+				spin_unlock_irq(&amp;dev-&gt;lock);</span>
 
 				return retval;
 			}
<span class="p_chunk">@@ -1308,9 +1319,21 @@</span> <span class="p_context"> static long dev_ioctl (struct file *fd, unsigned code, unsigned long value)</span>
 	struct usb_gadget	*gadget = dev-&gt;gadget;
 	long ret = -ENOTTY;
 
<span class="p_del">-	if (gadget-&gt;ops-&gt;ioctl)</span>
<span class="p_add">+	spin_lock_irq(&amp;dev-&gt;lock);</span>
<span class="p_add">+	if (dev-&gt;state == STATE_DEV_OPENED ||</span>
<span class="p_add">+			dev-&gt;state == STATE_DEV_UNBOUND) {</span>
<span class="p_add">+		/* Not bound to a UDC */</span>
<span class="p_add">+	} else if (gadget-&gt;ops-&gt;ioctl) {</span>
<span class="p_add">+		++dev-&gt;udc_usage;</span>
<span class="p_add">+		spin_unlock_irq(&amp;dev-&gt;lock);</span>
<span class="p_add">+</span>
 		ret = gadget-&gt;ops-&gt;ioctl (gadget, code, value);
 
<span class="p_add">+		spin_lock_irq(&amp;dev-&gt;lock);</span>
<span class="p_add">+		--dev-&gt;udc_usage;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	spin_unlock_irq(&amp;dev-&gt;lock);</span>
<span class="p_add">+</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -1544,8 +1567,13 @@</span> <span class="p_context"> gadgetfs_setup (struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)</span>
 							w_length);
 				if (value &lt; 0)
 					break;
<span class="p_add">+</span>
<span class="p_add">+				++dev-&gt;udc_usage;</span>
<span class="p_add">+				spin_unlock (&amp;dev-&gt;lock);</span>
 				value = usb_ep_queue (gadget-&gt;ep0, dev-&gt;req,
<span class="p_del">-							GFP_ATOMIC);</span>
<span class="p_add">+							GFP_KERNEL);</span>
<span class="p_add">+				spin_lock (&amp;dev-&gt;lock);</span>
<span class="p_add">+				--dev-&gt;udc_usage;</span>
 				if (value &lt; 0) {
 					clean_req (gadget-&gt;ep0, dev-&gt;req);
 					break;
<span class="p_chunk">@@ -1568,11 +1596,18 @@</span> <span class="p_context"> gadgetfs_setup (struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)</span>
 	if (value &gt;= 0 &amp;&amp; dev-&gt;state != STATE_DEV_SETUP) {
 		req-&gt;length = value;
 		req-&gt;zero = value &lt; w_length;
<span class="p_del">-		value = usb_ep_queue (gadget-&gt;ep0, req, GFP_ATOMIC);</span>
<span class="p_add">+</span>
<span class="p_add">+		++dev-&gt;udc_usage;</span>
<span class="p_add">+		spin_unlock (&amp;dev-&gt;lock);</span>
<span class="p_add">+		value = usb_ep_queue (gadget-&gt;ep0, req, GFP_KERNEL);</span>
<span class="p_add">+		spin_lock(&amp;dev-&gt;lock);</span>
<span class="p_add">+		--dev-&gt;udc_usage;</span>
<span class="p_add">+		spin_unlock(&amp;dev-&gt;lock);</span>
 		if (value &lt; 0) {
 			DBG (dev, &quot;ep_queue --&gt; %d\n&quot;, value);
 			req-&gt;status = 0;
 		}
<span class="p_add">+		return value;</span>
 	}
 
 	/* device stalls when value &lt; 0 */
<span class="p_chunk">@@ -1597,21 +1632,24 @@</span> <span class="p_context"> static void destroy_ep_files (struct dev_data *dev)</span>
 		/* break link to FS */
 		ep = list_entry (entry, struct ep_data, epfiles);
 		list_del_init (&amp;ep-&gt;epfiles);
<span class="p_add">+		spin_unlock_irq (&amp;dev-&gt;lock);</span>
<span class="p_add">+</span>
 		dentry = ep-&gt;dentry;
 		ep-&gt;dentry = NULL;
 		parent = dentry-&gt;d_parent-&gt;d_inode;
 
 		/* break link to controller */
<span class="p_add">+		mutex_lock(&amp;ep-&gt;lock);</span>
 		if (ep-&gt;state == STATE_EP_ENABLED)
 			(void) usb_ep_disable (ep-&gt;ep);
 		ep-&gt;state = STATE_EP_UNBOUND;
 		usb_ep_free_request (ep-&gt;ep, ep-&gt;req);
 		ep-&gt;ep = NULL;
<span class="p_add">+		mutex_unlock(&amp;ep-&gt;lock);</span>
<span class="p_add">+</span>
 		wake_up (&amp;ep-&gt;wait);
 		put_ep (ep);
 
<span class="p_del">-		spin_unlock_irq (&amp;dev-&gt;lock);</span>
<span class="p_del">-</span>
 		/* break link to dcache */
 		mutex_lock (&amp;parent-&gt;i_mutex);
 		d_delete (dentry);
<span class="p_chunk">@@ -1685,6 +1723,11 @@</span> <span class="p_context"> gadgetfs_unbind (struct usb_gadget *gadget)</span>
 
 	spin_lock_irq (&amp;dev-&gt;lock);
 	dev-&gt;state = STATE_DEV_UNBOUND;
<span class="p_add">+	while (dev-&gt;udc_usage &gt; 0) {</span>
<span class="p_add">+		spin_unlock_irq(&amp;dev-&gt;lock);</span>
<span class="p_add">+		usleep_range(1000, 2000);</span>
<span class="p_add">+		spin_lock_irq(&amp;dev-&gt;lock);</span>
<span class="p_add">+	}</span>
 	spin_unlock_irq (&amp;dev-&gt;lock);
 
 	destroy_ep_files (dev);
<span class="p_chunk">@@ -1761,9 +1804,10 @@</span> <span class="p_context"> static void</span>
 gadgetfs_suspend (struct usb_gadget *gadget)
 {
 	struct dev_data		*dev = get_gadget_data (gadget);
<span class="p_add">+	unsigned long		flags;</span>
 
 	INFO (dev, &quot;suspended from state %d\n&quot;, dev-&gt;state);
<span class="p_del">-	spin_lock (&amp;dev-&gt;lock);</span>
<span class="p_add">+	spin_lock_irqsave(&amp;dev-&gt;lock, flags);</span>
 	switch (dev-&gt;state) {
 	case STATE_DEV_SETUP:		// VERY odd... host died??
 	case STATE_DEV_CONNECTED:
<span class="p_chunk">@@ -1774,7 +1818,7 @@</span> <span class="p_context"> gadgetfs_suspend (struct usb_gadget *gadget)</span>
 	default:
 		break;
 	}
<span class="p_del">-	spin_unlock (&amp;dev-&gt;lock);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;dev-&gt;lock, flags);</span>
 }
 
 static struct usb_gadget_driver gadgetfs_driver = {
<span class="p_header">diff --git a/drivers/usb/host/pci-quirks.c b/drivers/usb/host/pci-quirks.c</span>
<span class="p_header">index d5cb1488c24c..0d608f1772b3 100644</span>
<span class="p_header">--- a/drivers/usb/host/pci-quirks.c</span>
<span class="p_header">+++ b/drivers/usb/host/pci-quirks.c</span>
<span class="p_chunk">@@ -866,7 +866,7 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(usb_disable_xhci_ports);</span>
  *
  * Takes care of the handoff between the Pre-OS (i.e. BIOS) and the OS.
  * It signals to the BIOS that the OS wants control of the host controller,
<span class="p_del">- * and then waits 5 seconds for the BIOS to hand over control.</span>
<span class="p_add">+ * and then waits 1 second for the BIOS to hand over control.</span>
  * If we timeout, assume the BIOS is broken and take control anyway.
  */
 static void __devinit quirk_usb_handoff_xhci(struct pci_dev *pdev)
<span class="p_chunk">@@ -912,9 +912,9 @@</span> <span class="p_context"> static void __devinit quirk_usb_handoff_xhci(struct pci_dev *pdev)</span>
 	if (val &amp; XHCI_HC_BIOS_OWNED) {
 		writel(val | XHCI_HC_OS_OWNED, base + ext_cap_offset);
 
<span class="p_del">-		/* Wait for 5 seconds with 10 microsecond polling interval */</span>
<span class="p_add">+		/* Wait for 1 second with 10 microsecond polling interval */</span>
 		timeout = handshake(base + ext_cap_offset, XHCI_HC_BIOS_OWNED,
<span class="p_del">-				0, 5000, 10);</span>
<span class="p_add">+				0, 1000000, 10);</span>
 
 		/* Assume a buggy BIOS and take HC ownership anyway */
 		if (timeout) {
<span class="p_chunk">@@ -942,7 +942,7 @@</span> <span class="p_context"> static void __devinit quirk_usb_handoff_xhci(struct pci_dev *pdev)</span>
 	 * operational or runtime registers.  Wait 5 seconds and no more.
 	 */
 	timeout = handshake(op_reg_base + XHCI_STS_OFFSET, XHCI_STS_CNR, 0,
<span class="p_del">-			5000, 10);</span>
<span class="p_add">+			5000000, 10);</span>
 	/* Assume a buggy HC and start HC initialization anyway */
 	if (timeout) {
 		val = readl(op_reg_base + XHCI_STS_OFFSET);
<span class="p_header">diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h</span>
<span class="p_header">index 307e3cc48195..7642c017bf5a 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci.h</span>
<span class="p_header">+++ b/drivers/usb/host/xhci.h</span>
<span class="p_chunk">@@ -1375,7 +1375,7 @@</span> <span class="p_context"> struct xhci_bus_state {</span>
 
 static inline unsigned int hcd_index(struct usb_hcd *hcd)
 {
<span class="p_del">-	if (hcd-&gt;speed == HCD_USB3)</span>
<span class="p_add">+	if (hcd-&gt;speed &gt;= HCD_USB3)</span>
 		return 0;
 	else
 		return 1;
<span class="p_header">diff --git a/drivers/usb/renesas_usbhs/fifo.c b/drivers/usb/renesas_usbhs/fifo.c</span>
<span class="p_header">index 2eb39b39ea1b..c47ba7288433 100644</span>
<span class="p_header">--- a/drivers/usb/renesas_usbhs/fifo.c</span>
<span class="p_header">+++ b/drivers/usb/renesas_usbhs/fifo.c</span>
<span class="p_chunk">@@ -261,11 +261,26 @@</span> <span class="p_context"> static void usbhsf_fifo_clear(struct usbhs_pipe *pipe,</span>
 			      struct usbhs_fifo *fifo)
 {
 	struct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);
<span class="p_add">+	int ret = 0;</span>
 
<span class="p_del">-	if (!usbhs_pipe_is_dcp(pipe))</span>
<span class="p_del">-		usbhsf_fifo_barrier(priv, fifo);</span>
<span class="p_add">+	if (!usbhs_pipe_is_dcp(pipe)) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * This driver checks the pipe condition first to avoid -EBUSY</span>
<span class="p_add">+		 * from usbhsf_fifo_barrier() with about 10 msec delay in</span>
<span class="p_add">+		 * the interrupt handler if the pipe is RX direction and empty.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (usbhs_pipe_is_dir_in(pipe))</span>
<span class="p_add">+			ret = usbhs_pipe_is_accessible(pipe);</span>
<span class="p_add">+		if (!ret)</span>
<span class="p_add">+			ret = usbhsf_fifo_barrier(priv, fifo);</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	usbhs_write(priv, fifo-&gt;ctr, BCLR);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * if non-DCP pipe, this driver should set BCLR when</span>
<span class="p_add">+	 * usbhsf_fifo_barrier() returns 0.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!ret)</span>
<span class="p_add">+		usbhs_write(priv, fifo-&gt;ctr, BCLR);</span>
 }
 
 static int usbhsf_fifo_rcv_len(struct usbhs_priv *priv,
<span class="p_chunk">@@ -802,8 +817,8 @@</span> <span class="p_context"> static void usbhsf_dma_prepare_tasklet(unsigned long data)</span>
 	dev_dbg(dev, &quot;  %s %d (%d/ %d)\n&quot;,
 		fifo-&gt;name, usbhs_pipe_number(pipe), pkt-&gt;length, pkt-&gt;zero);
 
<span class="p_del">-	usbhsf_dma_start(pipe, fifo);</span>
 	dma_async_issue_pending(chan);
<span class="p_add">+	usbhsf_dma_start(pipe, fifo);</span>
 
 xfer_work_end:
 	usbhs_unlock(priv, flags);
<span class="p_header">diff --git a/drivers/usb/serial/cp210x.c b/drivers/usb/serial/cp210x.c</span>
<span class="p_header">index 2de2053f2cde..6594ddcc2281 100644</span>
<span class="p_header">--- a/drivers/usb/serial/cp210x.c</span>
<span class="p_header">+++ b/drivers/usb/serial/cp210x.c</span>
<span class="p_chunk">@@ -176,6 +176,7 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{ USB_DEVICE(0x1843, 0x0200) }, /* Vaisala USB Instrument Cable */
 	{ USB_DEVICE(0x18EF, 0xE00F) }, /* ELV USB-I2C-Interface */
 	{ USB_DEVICE(0x18EF, 0xE025) }, /* ELV Marble Sound Board 1 */
<span class="p_add">+	{ USB_DEVICE(0x18EF, 0xE032) }, /* ELV TFD500 Data Logger */</span>
 	{ USB_DEVICE(0x1901, 0x0190) }, /* GE B850 CP2105 Recorder interface */
 	{ USB_DEVICE(0x1901, 0x0193) }, /* GE B650 CP2104 PMC interface */
 	{ USB_DEVICE(0x1901, 0x0194) },	/* GE Healthcare Remote Alarm Box */
<span class="p_header">diff --git a/drivers/usb/serial/ftdi_sio.c b/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_header">index a42adabce86a..c4c4d024b701 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_header">+++ b/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_chunk">@@ -1035,6 +1035,8 @@</span> <span class="p_context"> static struct usb_device_id id_table_combined [] = {</span>
 	{ USB_DEVICE(WICED_VID, WICED_USB20706V2_PID) },
 	{ USB_DEVICE(TI_VID, TI_CC3200_LAUNCHPAD_PID),
 		.driver_info = (kernel_ulong_t)&amp;ftdi_jtag_quirk },
<span class="p_add">+	{ USB_DEVICE(CYPRESS_VID, CYPRESS_WICED_BT_USB_PID) },</span>
<span class="p_add">+	{ USB_DEVICE(CYPRESS_VID, CYPRESS_WICED_WL_USB_PID) },</span>
 	{ },					/* Optional parameter entry */
 	{ }					/* Terminating entry */
 };
<span class="p_header">diff --git a/drivers/usb/serial/ftdi_sio_ids.h b/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_header">index 6181b79c2ed0..28640a8177b2 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_header">+++ b/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_chunk">@@ -609,6 +609,13 @@</span> <span class="p_context"></span>
 #define ADI_GNICE_PID		0xF000
 #define ADI_GNICEPLUS_PID	0xF001
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Cypress WICED USB UART</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define CYPRESS_VID			0x04B4</span>
<span class="p_add">+#define CYPRESS_WICED_BT_USB_PID	0x009B</span>
<span class="p_add">+#define CYPRESS_WICED_WL_USB_PID	0xF900</span>
<span class="p_add">+</span>
 /*
  * Microchip Technology, Inc.
  *
<span class="p_header">diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c</span>
<span class="p_header">index cfb35ec9a2a2..eb9018e7e0ba 100644</span>
<span class="p_header">--- a/drivers/usb/serial/option.c</span>
<span class="p_header">+++ b/drivers/usb/serial/option.c</span>
<span class="p_chunk">@@ -508,6 +508,7 @@</span> <span class="p_context"> static void option_instat_callback(struct urb *urb);</span>
 
 /* TP-LINK Incorporated products */
 #define TPLINK_VENDOR_ID			0x2357
<span class="p_add">+#define TPLINK_PRODUCT_LTE			0x000D</span>
 #define TPLINK_PRODUCT_MA180			0x0201
 
 /* Changhong products */
<span class="p_chunk">@@ -1959,6 +1960,7 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 	{ USB_DEVICE(CELLIENT_VENDOR_ID, CELLIENT_PRODUCT_MEN200) },
 	{ USB_DEVICE(PETATEL_VENDOR_ID, PETATEL_PRODUCT_NP10T_600A) },
 	{ USB_DEVICE(PETATEL_VENDOR_ID, PETATEL_PRODUCT_NP10T_600E) },
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(TPLINK_VENDOR_ID, TPLINK_PRODUCT_LTE, 0xff, 0x00, 0x00) },	/* TP-Link LTE Module */</span>
 	{ USB_DEVICE(TPLINK_VENDOR_ID, TPLINK_PRODUCT_MA180),
 	  .driver_info = (kernel_ulong_t)&amp;net_intf4_blacklist },
 	{ USB_DEVICE(TPLINK_VENDOR_ID, 0x9000),					/* TP-Link MA260 */
<span class="p_header">diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h</span>
<span class="p_header">index a0c4cc45eda0..93e49bd7c16f 100644</span>
<span class="p_header">--- a/drivers/usb/storage/unusual_devs.h</span>
<span class="p_header">+++ b/drivers/usb/storage/unusual_devs.h</span>
<span class="p_chunk">@@ -1346,6 +1346,13 @@</span> <span class="p_context"> UNUSUAL_DEV( 0x0bc2, 0x3010, 0x0000, 0x0000,</span>
 		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
 		US_FL_SANE_SENSE ),
 
<span class="p_add">+/* Reported by Kris Lindgren &lt;kris.lindgren@gmail.com&gt; */</span>
<span class="p_add">+UNUSUAL_DEV( 0x0bc2, 0x3332, 0x0000, 0x9999,</span>
<span class="p_add">+		&quot;Seagate&quot;,</span>
<span class="p_add">+		&quot;External&quot;,</span>
<span class="p_add">+		USB_SC_DEVICE, USB_PR_DEVICE, NULL,</span>
<span class="p_add">+		US_FL_NO_WP_DETECT ),</span>
<span class="p_add">+</span>
 UNUSUAL_DEV(  0x0d49, 0x7310, 0x0000, 0x9999,
 		&quot;Maxtor&quot;,
 		&quot;USB to SATA&quot;,
<span class="p_header">diff --git a/drivers/uwb/hwa-rc.c b/drivers/uwb/hwa-rc.c</span>
<span class="p_header">index ad971df0f35b..eb0a952cdba2 100644</span>
<span class="p_header">--- a/drivers/uwb/hwa-rc.c</span>
<span class="p_header">+++ b/drivers/uwb/hwa-rc.c</span>
<span class="p_chunk">@@ -813,6 +813,8 @@</span> <span class="p_context"> static int hwarc_probe(struct usb_interface *iface,</span>
 
 	if (iface-&gt;cur_altsetting-&gt;desc.bNumEndpoints &lt; 1)
 		return -ENODEV;
<span class="p_add">+	if (!usb_endpoint_xfer_int(&amp;iface-&gt;cur_altsetting-&gt;endpoint[0].desc))</span>
<span class="p_add">+		return -ENODEV;</span>
 
 	result = -ENOMEM;
 	uwb_rc = uwb_rc_alloc();
<span class="p_header">diff --git a/drivers/uwb/uwbd.c b/drivers/uwb/uwbd.c</span>
<span class="p_header">index bdcb13cc1d54..5c9828370217 100644</span>
<span class="p_header">--- a/drivers/uwb/uwbd.c</span>
<span class="p_header">+++ b/drivers/uwb/uwbd.c</span>
<span class="p_chunk">@@ -303,18 +303,22 @@</span> <span class="p_context"> static int uwbd(void *param)</span>
 /** Start the UWB daemon */
 void uwbd_start(struct uwb_rc *rc)
 {
<span class="p_del">-	rc-&gt;uwbd.task = kthread_run(uwbd, rc, &quot;uwbd&quot;);</span>
<span class="p_del">-	if (rc-&gt;uwbd.task == NULL)</span>
<span class="p_add">+	struct task_struct *task = kthread_run(uwbd, rc, &quot;uwbd&quot;);</span>
<span class="p_add">+	if (IS_ERR(task)) {</span>
<span class="p_add">+		rc-&gt;uwbd.task = NULL;</span>
 		printk(KERN_ERR &quot;UWB: Cannot start management daemon; &quot;
 		       &quot;UWB won&#39;t work\n&quot;);
<span class="p_del">-	else</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		rc-&gt;uwbd.task = task;</span>
 		rc-&gt;uwbd.pid = rc-&gt;uwbd.task-&gt;pid;
<span class="p_add">+	}</span>
 }
 
 /* Stop the UWB daemon and free any unprocessed events */
 void uwbd_stop(struct uwb_rc *rc)
 {
<span class="p_del">-	kthread_stop(rc-&gt;uwbd.task);</span>
<span class="p_add">+	if (rc-&gt;uwbd.task)</span>
<span class="p_add">+		kthread_stop(rc-&gt;uwbd.task);</span>
 	uwbd_flush(rc);
 }
 
<span class="p_header">diff --git a/fs/bio.c b/fs/bio.c</span>
<span class="p_header">index 1fa6b825240d..081747c89b62 100644</span>
<span class="p_header">--- a/fs/bio.c</span>
<span class="p_header">+++ b/fs/bio.c</span>
<span class="p_chunk">@@ -976,6 +976,7 @@</span> <span class="p_context"> static struct bio *__bio_map_user_iov(struct request_queue *q,</span>
 	struct bio *bio;
 	int cur_page = 0;
 	int ret, offset;
<span class="p_add">+	struct bio_vec *bvec;</span>
 
 	for (i = 0; i &lt; iov_count; i++) {
 		unsigned long uaddr = (unsigned long)iov[i].iov_base;
<span class="p_chunk">@@ -1019,7 +1020,12 @@</span> <span class="p_context"> static struct bio *__bio_map_user_iov(struct request_queue *q,</span>
 
 		ret = get_user_pages_fast(uaddr, local_nr_pages,
 				write_to_vm, &amp;pages[cur_page]);
<span class="p_del">-		if (ret &lt; local_nr_pages) {</span>
<span class="p_add">+		if (unlikely(ret &lt; local_nr_pages)) {</span>
<span class="p_add">+			for (j = cur_page; j &lt; page_limit; j++) {</span>
<span class="p_add">+				if (!pages[j])</span>
<span class="p_add">+					break;</span>
<span class="p_add">+				put_page(pages[j]);</span>
<span class="p_add">+			}</span>
 			ret = -EFAULT;
 			goto out_unmap;
 		}
<span class="p_chunk">@@ -1074,10 +1080,8 @@</span> <span class="p_context"> static struct bio *__bio_map_user_iov(struct request_queue *q,</span>
 	return bio;
 
  out_unmap:
<span class="p_del">-	for (i = 0; i &lt; nr_pages; i++) {</span>
<span class="p_del">-		if(!pages[i])</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		page_cache_release(pages[i]);</span>
<span class="p_add">+	bio_for_each_segment_all(bvec, bio, j) {</span>
<span class="p_add">+		put_page(bvec-&gt;bv_page);</span>
 	}
  out:
 	kfree(pages);
<span class="p_header">diff --git a/fs/ecryptfs/ecryptfs_kernel.h b/fs/ecryptfs/ecryptfs_kernel.h</span>
<span class="p_header">index 2262a77872cf..6e84387affd1 100644</span>
<span class="p_header">--- a/fs/ecryptfs/ecryptfs_kernel.h</span>
<span class="p_header">+++ b/fs/ecryptfs/ecryptfs_kernel.h</span>
<span class="p_chunk">@@ -83,11 +83,16 @@</span> <span class="p_context"> struct ecryptfs_page_crypt_context {</span>
 static inline struct ecryptfs_auth_tok *
 ecryptfs_get_encrypted_key_payload_data(struct key *key)
 {
<span class="p_del">-	if (key-&gt;type == &amp;key_type_encrypted)</span>
<span class="p_del">-		return (struct ecryptfs_auth_tok *)</span>
<span class="p_del">-			(&amp;((struct encrypted_key_payload *)key-&gt;payload.data)-&gt;payload_data);</span>
<span class="p_del">-	else</span>
<span class="p_add">+	struct encrypted_key_payload *payload;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (key-&gt;type != &amp;key_type_encrypted)</span>
 		return NULL;
<span class="p_add">+</span>
<span class="p_add">+	payload = key-&gt;payload.data;</span>
<span class="p_add">+	if (!payload)</span>
<span class="p_add">+		return ERR_PTR(-EKEYREVOKED);</span>
<span class="p_add">+</span>
<span class="p_add">+	return (struct ecryptfs_auth_tok *)payload-&gt;payload_data;</span>
 }
 
 static inline struct key *ecryptfs_get_encrypted_key(char *sig)
<span class="p_chunk">@@ -113,13 +118,17 @@</span> <span class="p_context"> static inline struct ecryptfs_auth_tok *</span>
 ecryptfs_get_key_payload_data(struct key *key)
 {
 	struct ecryptfs_auth_tok *auth_tok;
<span class="p_add">+	struct user_key_payload *ukp;</span>
 
 	auth_tok = ecryptfs_get_encrypted_key_payload_data(key);
<span class="p_del">-	if (!auth_tok)</span>
<span class="p_del">-		return (struct ecryptfs_auth_tok *)</span>
<span class="p_del">-			(((struct user_key_payload *)key-&gt;payload.data)-&gt;data);</span>
<span class="p_del">-	else</span>
<span class="p_add">+	if (auth_tok)</span>
 		return auth_tok;
<span class="p_add">+</span>
<span class="p_add">+	ukp = key-&gt;payload.data;</span>
<span class="p_add">+	if (!ukp)</span>
<span class="p_add">+		return ERR_PTR(-EKEYREVOKED);</span>
<span class="p_add">+</span>
<span class="p_add">+	return (struct ecryptfs_auth_tok *)ukp-&gt;data;</span>
 }
 
 #define ECRYPTFS_MAX_KEYSET_SIZE 1024
<span class="p_header">diff --git a/fs/ecryptfs/keystore.c b/fs/ecryptfs/keystore.c</span>
<span class="p_header">index 848b3031c908..5b8c402b1868 100644</span>
<span class="p_header">--- a/fs/ecryptfs/keystore.c</span>
<span class="p_header">+++ b/fs/ecryptfs/keystore.c</span>
<span class="p_chunk">@@ -458,7 +458,8 @@</span> <span class="p_context"> static int ecryptfs_verify_version(u16 version)</span>
  * @auth_tok_key: key containing the authentication token
  * @auth_tok: authentication token
  *
<span class="p_del">- * Returns zero on valid auth tok; -EINVAL otherwise</span>
<span class="p_add">+ * Returns zero on valid auth tok; -EINVAL if the payload is invalid; or</span>
<span class="p_add">+ * -EKEYREVOKED if the key was revoked before we acquired its semaphore.</span>
  */
 static int
 ecryptfs_verify_auth_tok_from_key(struct key *auth_tok_key,
<span class="p_chunk">@@ -467,6 +468,12 @@</span> <span class="p_context"> ecryptfs_verify_auth_tok_from_key(struct key *auth_tok_key,</span>
 	int rc = 0;
 
 	(*auth_tok) = ecryptfs_get_key_payload_data(auth_tok_key);
<span class="p_add">+	if (IS_ERR(*auth_tok)) {</span>
<span class="p_add">+		rc = PTR_ERR(*auth_tok);</span>
<span class="p_add">+		*auth_tok = NULL;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (ecryptfs_verify_version((*auth_tok)-&gt;version)) {
 		printk(KERN_ERR &quot;Data structure version mismatch. Userspace &quot;
 		       &quot;tools must match eCryptfs kernel module with major &quot;
<span class="p_header">diff --git a/fs/fscache/object-list.c b/fs/fscache/object-list.c</span>
<span class="p_header">index ebe29c581380..53d7fd3c6344 100644</span>
<span class="p_header">--- a/fs/fscache/object-list.c</span>
<span class="p_header">+++ b/fs/fscache/object-list.c</span>
<span class="p_chunk">@@ -338,6 +338,13 @@</span> <span class="p_context"> static void fscache_objlist_config(struct fscache_objlist_data *data)</span>
 	rcu_read_lock();
 
 	confkey = key-&gt;payload.data;
<span class="p_add">+	if (!confkey) {</span>
<span class="p_add">+		/* key was revoked */</span>
<span class="p_add">+		rcu_read_unlock();</span>
<span class="p_add">+		key_put(key);</span>
<span class="p_add">+		goto no_config;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	buf = confkey-&gt;data;
 
 	for (len = confkey-&gt;datalen - 1; len &gt;= 0; len--) {
<span class="p_header">diff --git a/fs/ocfs2/alloc.c b/fs/ocfs2/alloc.c</span>
<span class="p_header">index 31b9463fba1f..b4ebdc12e40b 100644</span>
<span class="p_header">--- a/fs/ocfs2/alloc.c</span>
<span class="p_header">+++ b/fs/ocfs2/alloc.c</span>
<span class="p_chunk">@@ -7188,13 +7188,24 @@</span> <span class="p_context"> int ocfs2_truncate_inline(struct inode *inode, struct buffer_head *di_bh,</span>
 
 static int ocfs2_trim_extent(struct super_block *sb,
 			     struct ocfs2_group_desc *gd,
<span class="p_del">-			     u32 start, u32 count)</span>
<span class="p_add">+			     u64 group, u32 start, u32 count)</span>
 {
 	u64 discard, bcount;
<span class="p_add">+	struct ocfs2_super *osb = OCFS2_SB(sb);</span>
 
 	bcount = ocfs2_clusters_to_blocks(sb, count);
<span class="p_del">-	discard = le64_to_cpu(gd-&gt;bg_blkno) +</span>
<span class="p_del">-			ocfs2_clusters_to_blocks(sb, start);</span>
<span class="p_add">+	discard = ocfs2_clusters_to_blocks(sb, start);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * For the first cluster group, the gd-&gt;bg_blkno is not at the start</span>
<span class="p_add">+	 * of the group, but at an offset from the start. If we add it while</span>
<span class="p_add">+	 * calculating discard for first group, we will wrongly start fstrim a</span>
<span class="p_add">+	 * few blocks after the desried start block and the range can cross</span>
<span class="p_add">+	 * over into the next cluster group. So, add it only if this is not</span>
<span class="p_add">+	 * the first cluster group.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (group != osb-&gt;first_cluster_group_blkno)</span>
<span class="p_add">+		discard += le64_to_cpu(gd-&gt;bg_blkno);</span>
 
 	trace_ocfs2_trim_extent(sb, (unsigned long long)discard, bcount);
 
<span class="p_chunk">@@ -7202,7 +7213,7 @@</span> <span class="p_context"> static int ocfs2_trim_extent(struct super_block *sb,</span>
 }
 
 static int ocfs2_trim_group(struct super_block *sb,
<span class="p_del">-			    struct ocfs2_group_desc *gd,</span>
<span class="p_add">+			    struct ocfs2_group_desc *gd, u64 group,</span>
 			    u32 start, u32 max, u32 minbits)
 {
 	int ret = 0, count = 0, next;
<span class="p_chunk">@@ -7221,7 +7232,7 @@</span> <span class="p_context"> static int ocfs2_trim_group(struct super_block *sb,</span>
 		next = ocfs2_find_next_bit(bitmap, max, start);
 
 		if ((next - start) &gt;= minbits) {
<span class="p_del">-			ret = ocfs2_trim_extent(sb, gd,</span>
<span class="p_add">+			ret = ocfs2_trim_extent(sb, gd, group,</span>
 						start, next - start);
 			if (ret &lt; 0) {
 				mlog_errno(ret);
<span class="p_chunk">@@ -7323,7 +7334,8 @@</span> <span class="p_context"> int ocfs2_trim_fs(struct super_block *sb, struct fstrim_range *range)</span>
 		}
 
 		gd = (struct ocfs2_group_desc *)gd_bh-&gt;b_data;
<span class="p_del">-		cnt = ocfs2_trim_group(sb, gd, first_bit, last_bit, minlen);</span>
<span class="p_add">+		cnt = ocfs2_trim_group(sb, gd, group,</span>
<span class="p_add">+				       first_bit, last_bit, minlen);</span>
 		brelse(gd_bh);
 		gd_bh = NULL;
 		if (cnt &lt; 0) {
<span class="p_header">diff --git a/fs/read_write.c b/fs/read_write.c</span>
<span class="p_header">index 5ad4248b0cd8..3649bfda8466 100644</span>
<span class="p_header">--- a/fs/read_write.c</span>
<span class="p_header">+++ b/fs/read_write.c</span>
<span class="p_chunk">@@ -99,7 +99,7 @@</span> <span class="p_context"> generic_file_llseek_size(struct file *file, loff_t offset, int origin,</span>
 		 * In the generic case the entire file is data, so as long as
 		 * offset isn&#39;t at the end of the file then the offset is data.
 		 */
<span class="p_del">-		if (offset &gt;= i_size_read(inode))</span>
<span class="p_add">+		if ((unsigned long long)offset &gt;= i_size_read(inode))</span>
 			return -ENXIO;
 		break;
 	case SEEK_HOLE:
<span class="p_chunk">@@ -107,7 +107,7 @@</span> <span class="p_context"> generic_file_llseek_size(struct file *file, loff_t offset, int origin,</span>
 		 * There is a virtual hole at the end of the file, so as long as
 		 * offset isn&#39;t i_size or larger, return i_size.
 		 */
<span class="p_del">-		if (offset &gt;= i_size_read(inode))</span>
<span class="p_add">+		if ((unsigned long long)offset &gt;= i_size_read(inode))</span>
 			return -ENXIO;
 		offset = i_size_read(inode);
 		break;
<span class="p_header">diff --git a/fs/xattr.c b/fs/xattr.c</span>
<span class="p_header">index 67583de8218c..f91e3c1d57a9 100644</span>
<span class="p_header">--- a/fs/xattr.c</span>
<span class="p_header">+++ b/fs/xattr.c</span>
<span class="p_chunk">@@ -161,7 +161,7 @@</span> <span class="p_context"> xattr_getsecurity(struct inode *inode, const char *name, void *value,</span>
 	}
 	memcpy(value, buffer, len);
 out:
<span class="p_del">-	security_release_secctx(buffer, len);</span>
<span class="p_add">+	kfree(buffer);</span>
 out_noalloc:
 	return len;
 }
<span class="p_header">diff --git a/include/crypto/internal/hash.h b/include/crypto/internal/hash.h</span>
<span class="p_header">index 7bdb81267d44..b813ae921506 100644</span>
<span class="p_header">--- a/include/crypto/internal/hash.h</span>
<span class="p_header">+++ b/include/crypto/internal/hash.h</span>
<span class="p_chunk">@@ -70,6 +70,14 @@</span> <span class="p_context"> int ahash_register_instance(struct crypto_template *tmpl,</span>
 			    struct ahash_instance *inst);
 void ahash_free_instance(struct crypto_instance *inst);
 
<span class="p_add">+int shash_no_setkey(struct crypto_shash *tfm, const u8 *key,</span>
<span class="p_add">+		    unsigned int keylen);</span>
<span class="p_add">+</span>
<span class="p_add">+static inline bool crypto_shash_alg_has_setkey(struct shash_alg *alg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return alg-&gt;setkey != shash_no_setkey;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int crypto_init_ahash_spawn(struct crypto_ahash_spawn *spawn,
 			    struct hash_alg_common *alg,
 			    struct crypto_instance *inst);
<span class="p_header">diff --git a/include/linux/input.h b/include/linux/input.h</span>
<span class="p_header">index 3862e32c4eeb..763180950123 100644</span>
<span class="p_header">--- a/include/linux/input.h</span>
<span class="p_header">+++ b/include/linux/input.h</span>
<span class="p_chunk">@@ -1618,6 +1618,7 @@</span> <span class="p_context"> int input_ff_event(struct input_dev *dev, unsigned int type, unsigned int code,</span>
 
 int input_ff_upload(struct input_dev *dev, struct ff_effect *effect, struct file *file);
 int input_ff_erase(struct input_dev *dev, int effect_id, struct file *file);
<span class="p_add">+int input_ff_flush(struct input_dev *dev, struct file *file);</span>
 
 int input_ff_create_memless(struct input_dev *dev, void *data,
 		int (*play_effect)(struct input_dev *, void *, struct ff_effect *));
<span class="p_header">diff --git a/include/linux/key.h b/include/linux/key.h</span>
<span class="p_header">index 183a6af7715d..2c631b4c559e 100644</span>
<span class="p_header">--- a/include/linux/key.h</span>
<span class="p_header">+++ b/include/linux/key.h</span>
<span class="p_chunk">@@ -155,6 +155,7 @@</span> <span class="p_context"> struct key {</span>
 #define KEY_FLAG_IN_QUOTA	3	/* set if key consumes quota */
 #define KEY_FLAG_USER_CONSTRUCT	4	/* set if key is being constructed in userspace */
 #define KEY_FLAG_NEGATIVE	5	/* set if key is negative */
<span class="p_add">+#define KEY_FLAG_UID_KEYRING	11	/* set if key is a user or user session keyring */</span>
 
 	/* the description string
 	 * - this is used to match a key against search criteria
<span class="p_chunk">@@ -196,6 +197,7 @@</span> <span class="p_context"> extern struct key *key_alloc(struct key_type *type,</span>
 #define KEY_ALLOC_IN_QUOTA	0x0000	/* add to quota, reject if would overrun */
 #define KEY_ALLOC_QUOTA_OVERRUN	0x0001	/* add to quota, permit even if overrun */
 #define KEY_ALLOC_NOT_IN_QUOTA	0x0002	/* not in quota */
<span class="p_add">+#define KEY_ALLOC_UID_KEYRING	0x0010	/* allocating a user or user session keyring */</span>
 
 extern void key_revoke(struct key *key);
 extern void key_put(struct key *key);
<span class="p_header">diff --git a/include/linux/spi/spidev.h b/include/linux/spi/spidev.h</span>
<span class="p_header">index 52d9ed01855f..834d2f6c892e 100644</span>
<span class="p_header">--- a/include/linux/spi/spidev.h</span>
<span class="p_header">+++ b/include/linux/spi/spidev.h</span>
<span class="p_chunk">@@ -23,6 +23,7 @@</span> <span class="p_context"></span>
 #define SPIDEV_H
 
 #include &lt;linux/types.h&gt;
<span class="p_add">+#include &lt;linux/ioctl.h&gt;</span>
 
 /* User space versions of kernel symbols for SPI clocking modes,
  * matching &lt;linux/spi/spi.h&gt;
<span class="p_header">diff --git a/include/net/bluetooth/l2cap.h b/include/net/bluetooth/l2cap.h</span>
<span class="p_header">index 6cc18f371675..5f66b9f9fc44 100644</span>
<span class="p_header">--- a/include/net/bluetooth/l2cap.h</span>
<span class="p_header">+++ b/include/net/bluetooth/l2cap.h</span>
<span class="p_chunk">@@ -496,6 +496,7 @@</span> <span class="p_context"> extern int disable_ertm;</span>
 
 int l2cap_init_sockets(void);
 void l2cap_cleanup_sockets(void);
<span class="p_add">+bool l2cap_is_socket(struct socket *sock);</span>
 
 void __l2cap_connect_rsp_defer(struct l2cap_chan *chan);
 int __l2cap_wait_ack(struct sock *sk);
<span class="p_header">diff --git a/include/net/tcp.h b/include/net/tcp.h</span>
<span class="p_header">index 95c4211f47a7..3ff241edf62b 100644</span>
<span class="p_header">--- a/include/net/tcp.h</span>
<span class="p_header">+++ b/include/net/tcp.h</span>
<span class="p_chunk">@@ -1394,12 +1394,12 @@</span> <span class="p_context"> static inline void tcp_highest_sack_reset(struct sock *sk)</span>
 	tcp_sk(sk)-&gt;highest_sack = tcp_write_queue_head(sk);
 }
 
<span class="p_del">-/* Called when old skb is about to be deleted (to be combined with new skb) */</span>
<span class="p_del">-static inline void tcp_highest_sack_combine(struct sock *sk,</span>
<span class="p_add">+/* Called when old skb is about to be deleted and replaced by new skb */</span>
<span class="p_add">+static inline void tcp_highest_sack_replace(struct sock *sk,</span>
 					    struct sk_buff *old,
 					    struct sk_buff *new)
 {
<span class="p_del">-	if (tcp_sk(sk)-&gt;sacked_out &amp;&amp; (old == tcp_sk(sk)-&gt;highest_sack))</span>
<span class="p_add">+	if (old == tcp_highest_sack(sk))</span>
 		tcp_sk(sk)-&gt;highest_sack = new;
 }
 
<span class="p_header">diff --git a/include/scsi/scsi_device.h b/include/scsi/scsi_device.h</span>
<span class="p_header">index 377ba61cf229..4f768ae2185f 100644</span>
<span class="p_header">--- a/include/scsi/scsi_device.h</span>
<span class="p_header">+++ b/include/scsi/scsi_device.h</span>
<span class="p_chunk">@@ -152,6 +152,7 @@</span> <span class="p_context"> struct scsi_device {</span>
 	unsigned no_read_capacity_16:1; /* Avoid READ_CAPACITY_16 cmds */
 	unsigned is_visible:1;	/* is the device visible in sysfs */
 	unsigned broken_fua:1;		/* Don&#39;t set FUA bit */
<span class="p_add">+	unsigned unmap_limit_for_ws:1;	/* Use the UNMAP limit for WRITE SAME */</span>
 
 	DECLARE_BITMAP(supported_events, SDEV_EVT_MAXBITS); /* supported events */
 	struct list_head event_list;	/* asserted events */
<span class="p_header">diff --git a/include/scsi/scsi_devinfo.h b/include/scsi/scsi_devinfo.h</span>
<span class="p_header">index b4ddd3b18b4c..f25ba760c223 100644</span>
<span class="p_header">--- a/include/scsi/scsi_devinfo.h</span>
<span class="p_header">+++ b/include/scsi/scsi_devinfo.h</span>
<span class="p_chunk">@@ -30,4 +30,5 @@</span> <span class="p_context"></span>
 #define BLIST_RETRY_HWERROR	0x400000 /* retry HARDWARE_ERROR */
 #define BLIST_MAX_512		0x800000 /* maximum 512 sector cdb length */
 #define BLIST_ATTACH_PQ3	0x1000000 /* Scan: Attach to PQ3 devices */
<span class="p_add">+#define BLIST_UNMAP_LIMIT_WS	0x80000000 /* Use UNMAP limit for WRITE SAME */</span>
 #endif
<span class="p_header">diff --git a/include/sound/seq_kernel.h b/include/sound/seq_kernel.h</span>
<span class="p_header">index f352a98ce4f4..1495fd5536bb 100644</span>
<span class="p_header">--- a/include/sound/seq_kernel.h</span>
<span class="p_header">+++ b/include/sound/seq_kernel.h</span>
<span class="p_chunk">@@ -55,7 +55,8 @@</span> <span class="p_context"> typedef union snd_seq_timestamp snd_seq_timestamp_t;</span>
 #define SNDRV_SEQ_DEFAULT_CLIENT_EVENTS	200
 
 /* max delivery path length */
<span class="p_del">-#define SNDRV_SEQ_MAX_HOPS		10</span>
<span class="p_add">+/* NOTE: this shouldn&#39;t be greater than MAX_LOCKDEP_SUBCLASSES */</span>
<span class="p_add">+#define SNDRV_SEQ_MAX_HOPS		8</span>
 
 /* max size of event size */
 #define SNDRV_SEQ_MAX_EVENT_LEN		0x3fffffff
<span class="p_header">diff --git a/include/sound/seq_virmidi.h b/include/sound/seq_virmidi.h</span>
<span class="p_header">index d888433a3096..ecfd52698931 100644</span>
<span class="p_header">--- a/include/sound/seq_virmidi.h</span>
<span class="p_header">+++ b/include/sound/seq_virmidi.h</span>
<span class="p_chunk">@@ -60,6 +60,7 @@</span> <span class="p_context"> struct snd_virmidi_dev {</span>
 	int port;			/* created/attached port */
 	unsigned int flags;		/* SNDRV_VIRMIDI_* */
 	rwlock_t filelist_lock;
<span class="p_add">+	struct rw_semaphore filelist_sem;</span>
 	struct list_head filelist;
 };
 
<span class="p_header">diff --git a/include/sound/timer.h b/include/sound/timer.h</span>
<span class="p_header">index 7990469a44ce..b0489b850c93 100644</span>
<span class="p_header">--- a/include/sound/timer.h</span>
<span class="p_header">+++ b/include/sound/timer.h</span>
<span class="p_chunk">@@ -90,6 +90,8 @@</span> <span class="p_context"> struct snd_timer {</span>
 	struct list_head ack_list_head;
 	struct list_head sack_list_head; /* slow ack list head */
 	struct tasklet_struct task_queue;
<span class="p_add">+	int max_instances;	/* upper limit of timer instances */</span>
<span class="p_add">+	int num_instances;	/* current number of timer instances */</span>
 };
 
 struct snd_timer_instance {
<span class="p_header">diff --git a/include/trace/events/kvm.h b/include/trace/events/kvm.h</span>
<span class="p_header">index 46e3cd8e197a..215a904f5e41 100644</span>
<span class="p_header">--- a/include/trace/events/kvm.h</span>
<span class="p_header">+++ b/include/trace/events/kvm.h</span>
<span class="p_chunk">@@ -152,7 +152,7 @@</span> <span class="p_context"> TRACE_EVENT(kvm_ack_irq,</span>
 	{ KVM_TRACE_MMIO_WRITE, &quot;write&quot; }
 
 TRACE_EVENT(kvm_mmio,
<span class="p_del">-	TP_PROTO(int type, int len, u64 gpa, u64 val),</span>
<span class="p_add">+	TP_PROTO(int type, int len, u64 gpa, void *val),</span>
 	TP_ARGS(type, len, gpa, val),
 
 	TP_STRUCT__entry(
<span class="p_chunk">@@ -166,7 +166,10 @@</span> <span class="p_context"> TRACE_EVENT(kvm_mmio,</span>
 		__entry-&gt;type		= type;
 		__entry-&gt;len		= len;
 		__entry-&gt;gpa		= gpa;
<span class="p_del">-		__entry-&gt;val		= val;</span>
<span class="p_add">+		__entry-&gt;val		= 0;</span>
<span class="p_add">+		if (val)</span>
<span class="p_add">+			memcpy(&amp;__entry-&gt;val, val,</span>
<span class="p_add">+			       min_t(u32, sizeof(__entry-&gt;val), len));</span>
 	),
 
 	TP_printk(&quot;mmio %s len %u gpa 0x%llx val 0x%llx&quot;,
<span class="p_header">diff --git a/kernel/params.c b/kernel/params.c</span>
<span class="p_header">index 65aae11eb93f..48a806f963b0 100644</span>
<span class="p_header">--- a/kernel/params.c</span>
<span class="p_header">+++ b/kernel/params.c</span>
<span class="p_chunk">@@ -578,7 +578,7 @@</span> <span class="p_context"> EXPORT_SYMBOL(__kernel_param_unlock);</span>
 /*
  * add_sysfs_param - add a parameter to sysfs
  * @mk: struct module_kobject
<span class="p_del">- * @kparam: the actual parameter definition to add to sysfs</span>
<span class="p_add">+ * @kp: the actual parameter definition to add to sysfs</span>
  * @name: name of parameter
  *
  * Create a kobject if for a (per-module) parameter if mp NULL, and
<span class="p_header">diff --git a/kernel/ptrace.c b/kernel/ptrace.c</span>
<span class="p_header">index b50cded5b80e..f05d14c9fc04 100644</span>
<span class="p_header">--- a/kernel/ptrace.c</span>
<span class="p_header">+++ b/kernel/ptrace.c</span>
<span class="p_chunk">@@ -77,12 +77,11 @@</span> <span class="p_context"> void __ptrace_unlink(struct task_struct *child)</span>
 {
 	BUG_ON(!child-&gt;ptrace);
 
<span class="p_del">-	child-&gt;ptrace = 0;</span>
 	child-&gt;parent = child-&gt;real_parent;
 	list_del_init(&amp;child-&gt;ptrace_entry);
 
 	spin_lock(&amp;child-&gt;sighand-&gt;siglock);
<span class="p_del">-</span>
<span class="p_add">+	child-&gt;ptrace = 0;</span>
 	/*
 	 * Clear all pending traps and TRAPPING.  TRAPPING should be
 	 * cleared regardless of JOBCTL_STOP_PENDING.  Do it explicitly.
<span class="p_header">diff --git a/kernel/sysctl.c b/kernel/sysctl.c</span>
<span class="p_header">index cb0d862b8a2e..59c254de23a4 100644</span>
<span class="p_header">--- a/kernel/sysctl.c</span>
<span class="p_header">+++ b/kernel/sysctl.c</span>
<span class="p_chunk">@@ -329,7 +329,8 @@</span> <span class="p_context"> static struct ctl_table kern_table[] = {</span>
 		.data		= &amp;sysctl_sched_time_avg,
 		.maxlen		= sizeof(unsigned int),
 		.mode		= 0644,
<span class="p_del">-		.proc_handler	= proc_dointvec,</span>
<span class="p_add">+		.proc_handler	= proc_dointvec_minmax,</span>
<span class="p_add">+		.extra1		= &amp;one,</span>
 	},
 	{
 		.procname	= &quot;sched_shares_window&quot;,
<span class="p_header">diff --git a/net/bluetooth/bnep/core.c b/net/bluetooth/bnep/core.c</span>
<span class="p_header">index 1eea8208b2cc..1bafa4c50b28 100644</span>
<span class="p_header">--- a/net/bluetooth/bnep/core.c</span>
<span class="p_header">+++ b/net/bluetooth/bnep/core.c</span>
<span class="p_chunk">@@ -560,6 +560,9 @@</span> <span class="p_context"> int bnep_add_connection(struct bnep_connadd_req *req, struct socket *sock)</span>
 
 	BT_DBG(&quot;&quot;);
 
<span class="p_add">+	if (!l2cap_is_socket(sock))</span>
<span class="p_add">+		return -EBADFD;</span>
<span class="p_add">+</span>
 	baswap((void *) dst, &amp;bt_sk(sock-&gt;sk)-&gt;dst);
 	baswap((void *) src, &amp;bt_sk(sock-&gt;sk)-&gt;src);
 
<span class="p_header">diff --git a/net/bluetooth/cmtp/core.c b/net/bluetooth/cmtp/core.c</span>
<span class="p_header">index 5a6e634f7fca..f129e13507a5 100644</span>
<span class="p_header">--- a/net/bluetooth/cmtp/core.c</span>
<span class="p_header">+++ b/net/bluetooth/cmtp/core.c</span>
<span class="p_chunk">@@ -336,6 +336,9 @@</span> <span class="p_context"> int cmtp_add_connection(struct cmtp_connadd_req *req, struct socket *sock)</span>
 
 	BT_DBG(&quot;&quot;);
 
<span class="p_add">+	if (!l2cap_is_socket(sock))</span>
<span class="p_add">+		return -EBADFD;</span>
<span class="p_add">+</span>
 	session = kzalloc(sizeof(struct cmtp_session), GFP_KERNEL);
 	if (!session)
 		return -ENOMEM;
<span class="p_header">diff --git a/net/bluetooth/hidp/core.c b/net/bluetooth/hidp/core.c</span>
<span class="p_header">index 0274157fdadd..b91d354fa16b 100644</span>
<span class="p_header">--- a/net/bluetooth/hidp/core.c</span>
<span class="p_header">+++ b/net/bluetooth/hidp/core.c</span>
<span class="p_chunk">@@ -972,6 +972,8 @@</span> <span class="p_context"> int hidp_add_connection(struct hidp_connadd_req *req, struct socket *ctrl_sock,</span>
 
 	BT_DBG(&quot;&quot;);
 
<span class="p_add">+	if (!l2cap_is_socket(ctrl_sock) || !l2cap_is_socket(intr_sock))</span>
<span class="p_add">+		return -EINVAL;</span>
 	if (bacmp(&amp;bt_sk(ctrl_sock-&gt;sk)-&gt;src, &amp;bt_sk(intr_sock-&gt;sk)-&gt;src) ||
 			bacmp(&amp;bt_sk(ctrl_sock-&gt;sk)-&gt;dst, &amp;bt_sk(intr_sock-&gt;sk)-&gt;dst))
 		return -ENOTUNIQ;
<span class="p_header">diff --git a/net/bluetooth/l2cap_sock.c b/net/bluetooth/l2cap_sock.c</span>
<span class="p_header">index 6c89d61aaa6f..d47a1973468c 100644</span>
<span class="p_header">--- a/net/bluetooth/l2cap_sock.c</span>
<span class="p_header">+++ b/net/bluetooth/l2cap_sock.c</span>
<span class="p_chunk">@@ -38,6 +38,12 @@</span> <span class="p_context"> static const struct proto_ops l2cap_sock_ops;</span>
 static void l2cap_sock_init(struct sock *sk, struct sock *parent);
 static struct sock *l2cap_sock_alloc(struct net *net, struct socket *sock, int proto, gfp_t prio);
 
<span class="p_add">+bool l2cap_is_socket(struct socket *sock)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return sock &amp;&amp; sock-&gt;ops == &amp;l2cap_sock_ops;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL(l2cap_is_socket);</span>
<span class="p_add">+</span>
 static int l2cap_sock_bind(struct socket *sock, struct sockaddr *addr, int alen)
 {
 	struct sock *sk = sock-&gt;sk;
<span class="p_header">diff --git a/net/core/rtnetlink.c b/net/core/rtnetlink.c</span>
<span class="p_header">index f2007b3d4177..9b9236d29e7b 100644</span>
<span class="p_header">--- a/net/core/rtnetlink.c</span>
<span class="p_header">+++ b/net/core/rtnetlink.c</span>
<span class="p_chunk">@@ -1137,7 +1137,10 @@</span> <span class="p_context"> const struct nla_policy ifla_policy[IFLA_MAX+1] = {</span>
 	[IFLA_LINKINFO]		= { .type = NLA_NESTED },
 	[IFLA_NET_NS_PID]	= { .type = NLA_U32 },
 	[IFLA_NET_NS_FD]	= { .type = NLA_U32 },
<span class="p_del">-	[IFLA_IFALIAS]	        = { .type = NLA_STRING, .len = IFALIASZ-1 },</span>
<span class="p_add">+	/* IFLA_IFALIAS is a string, but policy is set to NLA_BINARY to</span>
<span class="p_add">+	 * allow 0-length string (needed to remove an alias).</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	[IFLA_IFALIAS]	        = { .type = NLA_BINARY, .len = IFALIASZ - 1 },</span>
 	[IFLA_VFINFO_LIST]	= {. type = NLA_NESTED },
 	[IFLA_VF_PORTS]		= { .type = NLA_NESTED },
 	[IFLA_PORT_SELF]	= { .type = NLA_NESTED },
<span class="p_header">diff --git a/net/dccp/proto.c b/net/dccp/proto.c</span>
<span class="p_header">index bd3ecdd67121..4c9061eab75e 100644</span>
<span class="p_header">--- a/net/dccp/proto.c</span>
<span class="p_header">+++ b/net/dccp/proto.c</span>
<span class="p_chunk">@@ -252,6 +252,7 @@</span> <span class="p_context"> int dccp_disconnect(struct sock *sk, int flags)</span>
 {
 	struct inet_connection_sock *icsk = inet_csk(sk);
 	struct inet_sock *inet = inet_sk(sk);
<span class="p_add">+	struct dccp_sock *dp = dccp_sk(sk);</span>
 	int err = 0;
 	const int old_state = sk-&gt;sk_state;
 
<span class="p_chunk">@@ -271,6 +272,10 @@</span> <span class="p_context"> int dccp_disconnect(struct sock *sk, int flags)</span>
 		sk-&gt;sk_err = ECONNRESET;
 
 	dccp_clear_xmit_timers(sk);
<span class="p_add">+	ccid_hc_rx_delete(dp-&gt;dccps_hc_rx_ccid, sk);</span>
<span class="p_add">+	ccid_hc_tx_delete(dp-&gt;dccps_hc_tx_ccid, sk);</span>
<span class="p_add">+	dp-&gt;dccps_hc_rx_ccid = NULL;</span>
<span class="p_add">+	dp-&gt;dccps_hc_tx_ccid = NULL;</span>
 
 	__skb_queue_purge(&amp;sk-&gt;sk_receive_queue);
 	__skb_queue_purge(&amp;sk-&gt;sk_write_queue);
<span class="p_header">diff --git a/net/ipv4/tcp_output.c b/net/ipv4/tcp_output.c</span>
<span class="p_header">index 1c96e9b25e58..da11cd75e6f6 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_output.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_output.c</span>
<span class="p_chunk">@@ -1676,6 +1676,7 @@</span> <span class="p_context"> static int tcp_mtu_probe(struct sock *sk)</span>
 	nskb-&gt;ip_summed = skb-&gt;ip_summed;
 
 	tcp_insert_write_queue_before(nskb, skb, sk);
<span class="p_add">+	tcp_highest_sack_replace(sk, skb, nskb);</span>
 
 	len = 0;
 	tcp_for_write_queue_from_safe(skb, next, sk) {
<span class="p_chunk">@@ -1987,7 +1988,7 @@</span> <span class="p_context"> static void tcp_collapse_retrans(struct sock *sk, struct sk_buff *skb)</span>
 
 	BUG_ON(tcp_skb_pcount(skb) != 1 || tcp_skb_pcount(next_skb) != 1);
 
<span class="p_del">-	tcp_highest_sack_combine(sk, next_skb, skb);</span>
<span class="p_add">+	tcp_highest_sack_replace(sk, next_skb, skb);</span>
 
 	tcp_unlink_write_queue(next_skb, sk);
 
<span class="p_header">diff --git a/net/l2tp/l2tp_eth.c b/net/l2tp/l2tp_eth.c</span>
<span class="p_header">index 683fa797d099..ec1148c1f12d 100644</span>
<span class="p_header">--- a/net/l2tp/l2tp_eth.c</span>
<span class="p_header">+++ b/net/l2tp/l2tp_eth.c</span>
<span class="p_chunk">@@ -39,7 +39,6 @@</span> <span class="p_context"> struct l2tp_eth {</span>
 	struct net_device	*dev;
 	struct sock		*tunnel_sock;
 	struct l2tp_session	*session;
<span class="p_del">-	struct list_head	list;</span>
 };
 
 /* via l2tp_session_priv() */
<span class="p_chunk">@@ -47,17 +46,6 @@</span> <span class="p_context"> struct l2tp_eth_sess {</span>
 	struct net_device	*dev;
 };
 
<span class="p_del">-/* per-net private data for this module */</span>
<span class="p_del">-static unsigned int l2tp_eth_net_id;</span>
<span class="p_del">-struct l2tp_eth_net {</span>
<span class="p_del">-	struct list_head l2tp_eth_dev_list;</span>
<span class="p_del">-	spinlock_t l2tp_eth_lock;</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-static inline struct l2tp_eth_net *l2tp_eth_pernet(struct net *net)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return net_generic(net, l2tp_eth_net_id);</span>
<span class="p_del">-}</span>
 
 static int l2tp_eth_dev_init(struct net_device *dev)
 {
<span class="p_chunk">@@ -72,12 +60,6 @@</span> <span class="p_context"> static int l2tp_eth_dev_init(struct net_device *dev)</span>
 
 static void l2tp_eth_dev_uninit(struct net_device *dev)
 {
<span class="p_del">-	struct l2tp_eth *priv = netdev_priv(dev);</span>
<span class="p_del">-	struct l2tp_eth_net *pn = l2tp_eth_pernet(dev_net(dev));</span>
<span class="p_del">-</span>
<span class="p_del">-	spin_lock(&amp;pn-&gt;l2tp_eth_lock);</span>
<span class="p_del">-	list_del_init(&amp;priv-&gt;list);</span>
<span class="p_del">-	spin_unlock(&amp;pn-&gt;l2tp_eth_lock);</span>
 	dev_put(dev);
 }
 
<span class="p_chunk">@@ -193,7 +175,6 @@</span> <span class="p_context"> static int l2tp_eth_create(struct net *net, struct l2tp_tunnel *tunnel,</span>
 	struct l2tp_eth *priv;
 	struct l2tp_eth_sess *spriv;
 	int rc;
<span class="p_del">-	struct l2tp_eth_net *pn;</span>
 
 	if (cfg-&gt;ifname) {
 		dev = dev_get_by_name(net, cfg-&gt;ifname);
<span class="p_chunk">@@ -228,7 +209,6 @@</span> <span class="p_context"> static int l2tp_eth_create(struct net *net, struct l2tp_tunnel *tunnel,</span>
 	priv = netdev_priv(dev);
 	priv-&gt;dev = dev;
 	priv-&gt;session = session;
<span class="p_del">-	INIT_LIST_HEAD(&amp;priv-&gt;list);</span>
 
 	priv-&gt;tunnel_sock = tunnel-&gt;sock;
 	session-&gt;recv_skb = l2tp_eth_dev_recv;
<span class="p_chunk">@@ -249,10 +229,6 @@</span> <span class="p_context"> static int l2tp_eth_create(struct net *net, struct l2tp_tunnel *tunnel,</span>
 	strlcpy(session-&gt;ifname, dev-&gt;name, IFNAMSIZ);
 
 	dev_hold(dev);
<span class="p_del">-	pn = l2tp_eth_pernet(dev_net(dev));</span>
<span class="p_del">-	spin_lock(&amp;pn-&gt;l2tp_eth_lock);</span>
<span class="p_del">-	list_add(&amp;priv-&gt;list, &amp;pn-&gt;l2tp_eth_dev_list);</span>
<span class="p_del">-	spin_unlock(&amp;pn-&gt;l2tp_eth_lock);</span>
 
 	return 0;
 
<span class="p_chunk">@@ -265,22 +241,6 @@</span> <span class="p_context"> static int l2tp_eth_create(struct net *net, struct l2tp_tunnel *tunnel,</span>
 	return rc;
 }
 
<span class="p_del">-static __net_init int l2tp_eth_init_net(struct net *net)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct l2tp_eth_net *pn = net_generic(net, l2tp_eth_net_id);</span>
<span class="p_del">-</span>
<span class="p_del">-	INIT_LIST_HEAD(&amp;pn-&gt;l2tp_eth_dev_list);</span>
<span class="p_del">-	spin_lock_init(&amp;pn-&gt;l2tp_eth_lock);</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static struct pernet_operations l2tp_eth_net_ops = {</span>
<span class="p_del">-	.init = l2tp_eth_init_net,</span>
<span class="p_del">-	.id   = &amp;l2tp_eth_net_id,</span>
<span class="p_del">-	.size = sizeof(struct l2tp_eth_net),</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
 
 static const struct l2tp_nl_cmd_ops l2tp_eth_nl_cmd_ops = {
 	.session_create	= l2tp_eth_create,
<span class="p_chunk">@@ -294,25 +254,18 @@</span> <span class="p_context"> static int __init l2tp_eth_init(void)</span>
 
 	err = l2tp_nl_register_ops(L2TP_PWTYPE_ETH, &amp;l2tp_eth_nl_cmd_ops);
 	if (err)
<span class="p_del">-		goto out;</span>
<span class="p_del">-</span>
<span class="p_del">-	err = register_pernet_device(&amp;l2tp_eth_net_ops);</span>
<span class="p_del">-	if (err)</span>
<span class="p_del">-		goto out_unreg;</span>
<span class="p_add">+		goto err;</span>
 
 	printk(KERN_INFO &quot;L2TP ethernet pseudowire support (L2TPv3)\n&quot;);
 
 	return 0;
 
<span class="p_del">-out_unreg:</span>
<span class="p_del">-	l2tp_nl_unregister_ops(L2TP_PWTYPE_ETH);</span>
<span class="p_del">-out:</span>
<span class="p_add">+err:</span>
 	return err;
 }
 
 static void __exit l2tp_eth_exit(void)
 {
<span class="p_del">-	unregister_pernet_device(&amp;l2tp_eth_net_ops);</span>
 	l2tp_nl_unregister_ops(L2TP_PWTYPE_ETH);
 }
 
<span class="p_header">diff --git a/net/l2tp/l2tp_ip.c b/net/l2tp/l2tp_ip.c</span>
<span class="p_header">index 6f12fd694d29..2e2225437f12 100644</span>
<span class="p_header">--- a/net/l2tp/l2tp_ip.c</span>
<span class="p_header">+++ b/net/l2tp/l2tp_ip.c</span>
<span class="p_chunk">@@ -127,6 +127,7 @@</span> <span class="p_context"> static int l2tp_ip_recv(struct sk_buff *skb)</span>
 	unsigned char *ptr, *optr;
 	struct l2tp_session *session;
 	struct l2tp_tunnel *tunnel = NULL;
<span class="p_add">+	struct iphdr *iph;</span>
 	int length;
 	int offset;
 
<span class="p_chunk">@@ -189,21 +190,16 @@</span> <span class="p_context"> static int l2tp_ip_recv(struct sk_buff *skb)</span>
 		goto discard;
 
 	tunnel_id = ntohl(*(__be32 *) &amp;skb-&gt;data[4]);
<span class="p_del">-	tunnel = l2tp_tunnel_find(&amp;init_net, tunnel_id);</span>
<span class="p_del">-	if (tunnel != NULL)</span>
<span class="p_del">-		sk = tunnel-&gt;sock;</span>
<span class="p_del">-	else {</span>
<span class="p_del">-		struct iphdr *iph = (struct iphdr *) skb_network_header(skb);</span>
<span class="p_del">-</span>
<span class="p_del">-		read_lock_bh(&amp;l2tp_ip_lock);</span>
<span class="p_del">-		sk = __l2tp_ip_bind_lookup(&amp;init_net, iph-&gt;daddr, 0, tunnel_id);</span>
<span class="p_del">-		read_unlock_bh(&amp;l2tp_ip_lock);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	iph = (struct iphdr *)skb_network_header(skb);</span>
 
<span class="p_del">-	if (sk == NULL)</span>
<span class="p_add">+	read_lock_bh(&amp;l2tp_ip_lock);</span>
<span class="p_add">+	sk = __l2tp_ip_bind_lookup(&amp;init_net, iph-&gt;daddr, 0, tunnel_id);</span>
<span class="p_add">+	if (!sk) {</span>
<span class="p_add">+		read_unlock_bh(&amp;l2tp_ip_lock);</span>
 		goto discard;
<span class="p_del">-</span>
<span class="p_add">+	}</span>
 	sock_hold(sk);
<span class="p_add">+	read_unlock_bh(&amp;l2tp_ip_lock);</span>
 
 	if (!xfrm4_policy_check(sk, XFRM_POLICY_IN, skb))
 		goto discard_put;
<span class="p_header">diff --git a/net/l2tp/l2tp_ppp.c b/net/l2tp/l2tp_ppp.c</span>
<span class="p_header">index d6dcff6303ec..c67e9f6243f1 100644</span>
<span class="p_header">--- a/net/l2tp/l2tp_ppp.c</span>
<span class="p_header">+++ b/net/l2tp/l2tp_ppp.c</span>
<span class="p_chunk">@@ -642,6 +642,7 @@</span> <span class="p_context"> static int pppol2tp_connect(struct socket *sock, struct sockaddr *uservaddr,</span>
 	u32 tunnel_id, peer_tunnel_id;
 	u32 session_id, peer_session_id;
 	bool drop_refcnt = false;
<span class="p_add">+	bool drop_tunnel = false;</span>
 	int ver = 2;
 	int fd;
 
<span class="p_chunk">@@ -685,7 +686,9 @@</span> <span class="p_context"> static int pppol2tp_connect(struct socket *sock, struct sockaddr *uservaddr,</span>
 	if (tunnel_id == 0)
 		goto end;
 
<span class="p_del">-	tunnel = l2tp_tunnel_find(sock_net(sk), tunnel_id);</span>
<span class="p_add">+	tunnel = l2tp_tunnel_get(sock_net(sk), tunnel_id);</span>
<span class="p_add">+	if (tunnel)</span>
<span class="p_add">+		drop_tunnel = true;</span>
 
 	/* Special case: create tunnel context if session_id and
 	 * peer_session_id is 0. Otherwise look up tunnel using supplied
<span class="p_chunk">@@ -818,6 +821,8 @@</span> <span class="p_context"> static int pppol2tp_connect(struct socket *sock, struct sockaddr *uservaddr,</span>
 end:
 	if (drop_refcnt)
 		l2tp_session_dec_refcount(session);
<span class="p_add">+	if (drop_tunnel)</span>
<span class="p_add">+		l2tp_tunnel_dec_refcount(tunnel);</span>
 	release_sock(sk);
 
 	return error;
<span class="p_chunk">@@ -997,6 +1002,9 @@</span> <span class="p_context"> static int pppol2tp_session_ioctl(struct l2tp_session *session,</span>
 	       session-&gt;name, cmd, arg);
 
 	sk = ps-&gt;sock;
<span class="p_add">+	if (!sk)</span>
<span class="p_add">+		return -EBADR;</span>
<span class="p_add">+</span>
 	sock_hold(sk);
 
 	switch (cmd) {
<span class="p_header">diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c</span>
<span class="p_header">index 2d44726d8a00..4f6392d71ea2 100644</span>
<span class="p_header">--- a/net/packet/af_packet.c</span>
<span class="p_header">+++ b/net/packet/af_packet.c</span>
<span class="p_chunk">@@ -2231,6 +2231,7 @@</span> <span class="p_context"> static int packet_snd(struct socket *sock,</span>
 	int offset = 0;
 	int vnet_hdr_len;
 	struct packet_sock *po = pkt_sk(sk);
<span class="p_add">+	bool has_vnet_hdr = false;</span>
 	unsigned short gso_type = 0;
 
 	/*
<span class="p_chunk">@@ -2263,6 +2264,7 @@</span> <span class="p_context"> static int packet_snd(struct socket *sock,</span>
 		reserve = dev-&gt;hard_header_len;
 	if (po-&gt;has_vnet_hdr) {
 		vnet_hdr_len = sizeof(vnet_hdr);
<span class="p_add">+		has_vnet_hdr = true;</span>
 
 		err = -EINVAL;
 		if (len &lt; vnet_hdr_len)
<span class="p_chunk">@@ -2354,7 +2356,7 @@</span> <span class="p_context"> static int packet_snd(struct socket *sock,</span>
 	skb-&gt;priority = sk-&gt;sk_priority;
 	skb-&gt;mark = sk-&gt;sk_mark;
 
<span class="p_del">-	if (po-&gt;has_vnet_hdr) {</span>
<span class="p_add">+	if (has_vnet_hdr) {</span>
 		if (vnet_hdr.flags &amp; VIRTIO_NET_HDR_F_NEEDS_CSUM) {
 			if (!skb_partial_csum_set(skb, vnet_hdr.csum_start,
 						  vnet_hdr.csum_offset)) {
<span class="p_header">diff --git a/net/sctp/sm_sideeffect.c b/net/sctp/sm_sideeffect.c</span>
<span class="p_header">index 6dca588b14af..dd01a502fe52 100644</span>
<span class="p_header">--- a/net/sctp/sm_sideeffect.c</span>
<span class="p_header">+++ b/net/sctp/sm_sideeffect.c</span>
<span class="p_chunk">@@ -1598,8 +1598,8 @@</span> <span class="p_context"> static int sctp_cmd_interpreter(sctp_event_t event_type,</span>
 		case SCTP_CMD_PROCESS_CTSN:
 			/* Dummy up a SACK for processing. */
 			sackh.cum_tsn_ack = cmd-&gt;obj.be32;
<span class="p_del">-			sackh.a_rwnd = asoc-&gt;peer.rwnd +</span>
<span class="p_del">-					asoc-&gt;outqueue.outstanding_bytes;</span>
<span class="p_add">+			sackh.a_rwnd = htonl(asoc-&gt;peer.rwnd +</span>
<span class="p_add">+					     asoc-&gt;outqueue.outstanding_bytes);</span>
 			sackh.num_gap_ack_blocks = 0;
 			sackh.num_dup_tsns = 0;
 			sctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_SACK,
<span class="p_header">diff --git a/net/xfrm/xfrm_user.c b/net/xfrm/xfrm_user.c</span>
<span class="p_header">index 963222e89dbe..6723bb2810e5 100644</span>
<span class="p_header">--- a/net/xfrm/xfrm_user.c</span>
<span class="p_header">+++ b/net/xfrm/xfrm_user.c</span>
<span class="p_chunk">@@ -1530,7 +1530,8 @@</span> <span class="p_context"> static int xfrm_dump_policy_done(struct netlink_callback *cb)</span>
 {
 	struct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &amp;cb-&gt;args[1];
 
<span class="p_del">-	xfrm_policy_walk_done(walk);</span>
<span class="p_add">+	if (cb-&gt;args[0])</span>
<span class="p_add">+		xfrm_policy_walk_done(walk);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/security/keys/encrypted-keys/encrypted.c b/security/keys/encrypted-keys/encrypted.c</span>
<span class="p_header">index 720eb8164d2b..b13db9642ebe 100644</span>
<span class="p_header">--- a/security/keys/encrypted-keys/encrypted.c</span>
<span class="p_header">+++ b/security/keys/encrypted-keys/encrypted.c</span>
<span class="p_chunk">@@ -315,6 +315,13 @@</span> <span class="p_context"> static struct key *request_user_key(const char *master_desc, u8 **master_key,</span>
 
 	down_read(&amp;ukey-&gt;sem);
 	upayload = rcu_dereference(ukey-&gt;payload.data);
<span class="p_add">+	if (!upayload) {</span>
<span class="p_add">+		/* key was revoked before we acquired its semaphore */</span>
<span class="p_add">+		up_read(&amp;ukey-&gt;sem);</span>
<span class="p_add">+		key_put(ukey);</span>
<span class="p_add">+		ukey = ERR_PTR(-EKEYREVOKED);</span>
<span class="p_add">+		goto error;</span>
<span class="p_add">+	}</span>
 	*master_key = upayload-&gt;data;
 	*master_keylen = upayload-&gt;datalen;
 error:
<span class="p_header">diff --git a/security/keys/internal.h b/security/keys/internal.h</span>
<span class="p_header">index c7a7caec4830..1f4b104e79e2 100644</span>
<span class="p_header">--- a/security/keys/internal.h</span>
<span class="p_header">+++ b/security/keys/internal.h</span>
<span class="p_chunk">@@ -124,7 +124,7 @@</span> <span class="p_context"> extern key_ref_t search_process_keyrings(struct key_type *type,</span>
 					 key_match_func_t match,
 					 const struct cred *cred);
 
<span class="p_del">-extern struct key *find_keyring_by_name(const char *name, bool skip_perm_check);</span>
<span class="p_add">+extern struct key *find_keyring_by_name(const char *name, bool uid_keyring);</span>
 
 extern int install_user_keyrings(void);
 extern int install_thread_keyring_to_cred(struct cred *);
<span class="p_header">diff --git a/security/keys/key.c b/security/keys/key.c</span>
<span class="p_header">index 04c809fb0add..1f5c2c53fa9d 100644</span>
<span class="p_header">--- a/security/keys/key.c</span>
<span class="p_header">+++ b/security/keys/key.c</span>
<span class="p_chunk">@@ -305,6 +305,8 @@</span> <span class="p_context"> struct key *key_alloc(struct key_type *type, const char *desc,</span>
 
 	if (!(flags &amp; KEY_ALLOC_NOT_IN_QUOTA))
 		key-&gt;flags |= 1 &lt;&lt; KEY_FLAG_IN_QUOTA;
<span class="p_add">+	if (flags &amp; KEY_ALLOC_UID_KEYRING)</span>
<span class="p_add">+		key-&gt;flags |= 1 &lt;&lt; KEY_FLAG_UID_KEYRING;</span>
 
 	memset(&amp;key-&gt;type_data, 0, sizeof(key-&gt;type_data));
 
<span class="p_header">diff --git a/security/keys/keyctl.c b/security/keys/keyctl.c</span>
<span class="p_header">index 41525338aa8d..659d1cbe08c9 100644</span>
<span class="p_header">--- a/security/keys/keyctl.c</span>
<span class="p_header">+++ b/security/keys/keyctl.c</span>
<span class="p_chunk">@@ -684,7 +684,7 @@</span> <span class="p_context"> long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)</span>
 	if (ret == 0)
 		goto can_read_key;
 	if (ret != -EACCES)
<span class="p_del">-		goto error;</span>
<span class="p_add">+		goto error2;</span>
 
 	/* we can&#39;t; see if it&#39;s searchable from this process&#39;s keyrings
 	 * - we automatically take account of the fact that it may be
<span class="p_chunk">@@ -1345,11 +1345,9 @@</span> <span class="p_context"> long keyctl_assume_authority(key_serial_t id)</span>
 	}
 
 	ret = keyctl_change_reqkey_auth(authkey);
<span class="p_del">-	if (ret &lt; 0)</span>
<span class="p_del">-		goto error;</span>
<span class="p_add">+	if (ret == 0)</span>
<span class="p_add">+		ret = authkey-&gt;serial;</span>
 	key_put(authkey);
<span class="p_del">-</span>
<span class="p_del">-	ret = authkey-&gt;serial;</span>
 error:
 	return ret;
 }
<span class="p_header">diff --git a/security/keys/keyring.c b/security/keys/keyring.c</span>
<span class="p_header">index 8f31d5f6cda5..4d01452b27eb 100644</span>
<span class="p_header">--- a/security/keys/keyring.c</span>
<span class="p_header">+++ b/security/keys/keyring.c</span>
<span class="p_chunk">@@ -550,15 +550,15 @@</span> <span class="p_context"> key_ref_t __keyring_search_one(key_ref_t keyring_ref,</span>
 /*
  * Find a keyring with the specified name.
  *
<span class="p_del">- * All named keyrings in the current user namespace are searched, provided they</span>
<span class="p_del">- * grant Search permission directly to the caller (unless this check is</span>
<span class="p_del">- * skipped).  Keyrings whose usage points have reached zero or who have been</span>
<span class="p_del">- * revoked are skipped.</span>
<span class="p_add">+ * Only keyrings that have nonzero refcount, are not revoked, and are owned by a</span>
<span class="p_add">+ * user in the current user namespace are considered.  If @uid_keyring is %true,</span>
<span class="p_add">+ * the keyring additionally must have been allocated as a user or user session</span>
<span class="p_add">+ * keyring; otherwise, it must grant Search permission directly to the caller.</span>
  *
  * Returns a pointer to the keyring with the keyring&#39;s refcount having being
  * incremented on success.  -ENOKEY is returned if a key could not be found.
  */
<span class="p_del">-struct key *find_keyring_by_name(const char *name, bool skip_perm_check)</span>
<span class="p_add">+struct key *find_keyring_by_name(const char *name, bool uid_keyring)</span>
 {
 	struct key *keyring;
 	int bucket;
<span class="p_chunk">@@ -586,10 +586,15 @@</span> <span class="p_context"> struct key *find_keyring_by_name(const char *name, bool skip_perm_check)</span>
 			if (strcmp(keyring-&gt;description, name) != 0)
 				continue;
 
<span class="p_del">-			if (!skip_perm_check &amp;&amp;</span>
<span class="p_del">-			    key_permission(make_key_ref(keyring, 0),</span>
<span class="p_del">-					   KEY_SEARCH) &lt; 0)</span>
<span class="p_del">-				continue;</span>
<span class="p_add">+			if (uid_keyring) {</span>
<span class="p_add">+				if (!test_bit(KEY_FLAG_UID_KEYRING,</span>
<span class="p_add">+					      &amp;keyring-&gt;flags))</span>
<span class="p_add">+					continue;</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				if (key_permission(make_key_ref(keyring, 0),</span>
<span class="p_add">+						   KEY_SEARCH) &lt; 0)</span>
<span class="p_add">+					continue;</span>
<span class="p_add">+			}</span>
 
 			/* we&#39;ve got a match but we might end up racing with
 			 * key_cleanup() if the keyring is currently &#39;dead&#39;
<span class="p_header">diff --git a/security/keys/process_keys.c b/security/keys/process_keys.c</span>
<span class="p_header">index fe5719f793da..7777cb8a93ab 100644</span>
<span class="p_header">--- a/security/keys/process_keys.c</span>
<span class="p_header">+++ b/security/keys/process_keys.c</span>
<span class="p_chunk">@@ -72,7 +72,9 @@</span> <span class="p_context"> int install_user_keyrings(void)</span>
 		uid_keyring = find_keyring_by_name(buf, true);
 		if (IS_ERR(uid_keyring)) {
 			uid_keyring = keyring_alloc(buf, user-&gt;uid, (gid_t) -1,
<span class="p_del">-						    cred, KEY_ALLOC_IN_QUOTA,</span>
<span class="p_add">+						    cred,</span>
<span class="p_add">+						    KEY_ALLOC_UID_KEYRING |</span>
<span class="p_add">+							KEY_ALLOC_IN_QUOTA,</span>
 						    NULL);
 			if (IS_ERR(uid_keyring)) {
 				ret = PTR_ERR(uid_keyring);
<span class="p_chunk">@@ -88,7 +90,10 @@</span> <span class="p_context"> int install_user_keyrings(void)</span>
 		if (IS_ERR(session_keyring)) {
 			session_keyring =
 				keyring_alloc(buf, user-&gt;uid, (gid_t) -1,
<span class="p_del">-					      cred, KEY_ALLOC_IN_QUOTA, NULL);</span>
<span class="p_add">+					      cred,</span>
<span class="p_add">+					      KEY_ALLOC_UID_KEYRING |</span>
<span class="p_add">+						  KEY_ALLOC_IN_QUOTA,</span>
<span class="p_add">+					      NULL);</span>
 			if (IS_ERR(session_keyring)) {
 				ret = PTR_ERR(session_keyring);
 				goto error_release;
<span class="p_header">diff --git a/security/keys/request_key.c b/security/keys/request_key.c</span>
<span class="p_header">index 82465328c39b..a5e32b6dd622 100644</span>
<span class="p_header">--- a/security/keys/request_key.c</span>
<span class="p_header">+++ b/security/keys/request_key.c</span>
<span class="p_chunk">@@ -267,11 +267,12 @@</span> <span class="p_context"> static int construct_key(struct key *key, const void *callout_info,</span>
  * The keyring selected is returned with an extra reference upon it which the
  * caller must release.
  */
<span class="p_del">-static void construct_get_dest_keyring(struct key **_dest_keyring)</span>
<span class="p_add">+static int construct_get_dest_keyring(struct key **_dest_keyring)</span>
 {
 	struct request_key_auth *rka;
 	const struct cred *cred = current_cred();
 	struct key *dest_keyring = *_dest_keyring, *authkey;
<span class="p_add">+	int ret;</span>
 
 	kenter(&quot;%p&quot;, dest_keyring);
 
<span class="p_chunk">@@ -280,6 +281,8 @@</span> <span class="p_context"> static void construct_get_dest_keyring(struct key **_dest_keyring)</span>
 		/* the caller supplied one */
 		key_get(dest_keyring);
 	} else {
<span class="p_add">+		bool do_perm_check = true;</span>
<span class="p_add">+</span>
 		/* use a default keyring; falling through the cases until we
 		 * find one that we actually have */
 		switch (cred-&gt;jit_keyring) {
<span class="p_chunk">@@ -294,8 +297,10 @@</span> <span class="p_context"> static void construct_get_dest_keyring(struct key **_dest_keyring)</span>
 					dest_keyring =
 						key_get(rka-&gt;dest_keyring);
 				up_read(&amp;authkey-&gt;sem);
<span class="p_del">-				if (dest_keyring)</span>
<span class="p_add">+				if (dest_keyring) {</span>
<span class="p_add">+					do_perm_check = false;</span>
 					break;
<span class="p_add">+				}</span>
 			}
 
 		case KEY_REQKEY_DEFL_THREAD_KEYRING:
<span class="p_chunk">@@ -330,11 +335,29 @@</span> <span class="p_context"> static void construct_get_dest_keyring(struct key **_dest_keyring)</span>
 		default:
 			BUG();
 		}
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Require Write permission on the keyring.  This is essential</span>
<span class="p_add">+		 * because the default keyring may be the session keyring, and</span>
<span class="p_add">+		 * joining a keyring only requires Search permission.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * However, this check is skipped for the &quot;requestor keyring&quot; so</span>
<span class="p_add">+		 * that /sbin/request-key can itself use request_key() to add</span>
<span class="p_add">+		 * keys to the original requestor&#39;s destination keyring.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (dest_keyring &amp;&amp; do_perm_check) {</span>
<span class="p_add">+			ret = key_permission(make_key_ref(dest_keyring, 1),</span>
<span class="p_add">+					     KEY_WRITE);</span>
<span class="p_add">+			if (ret) {</span>
<span class="p_add">+				key_put(dest_keyring);</span>
<span class="p_add">+				return ret;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
 	}
 
 	*_dest_keyring = dest_keyring;
 	kleave(&quot; [dk %d]&quot;, key_serial(dest_keyring));
<span class="p_del">-	return;</span>
<span class="p_add">+	return 0;</span>
 }
 
 /*
<span class="p_chunk">@@ -449,11 +472,15 @@</span> <span class="p_context"> static struct key *construct_key_and_link(struct key_type *type,</span>
 
 	kenter(&quot;&quot;);
 
<span class="p_del">-	user = key_user_lookup(current_fsuid(), current_user_ns());</span>
<span class="p_del">-	if (!user)</span>
<span class="p_del">-		return ERR_PTR(-ENOMEM);</span>
<span class="p_add">+	ret = construct_get_dest_keyring(&amp;dest_keyring);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto error;</span>
 
<span class="p_del">-	construct_get_dest_keyring(&amp;dest_keyring);</span>
<span class="p_add">+	user = key_user_lookup(current_fsuid(), current_user_ns());</span>
<span class="p_add">+	if (!user) {</span>
<span class="p_add">+		ret = -ENOMEM;</span>
<span class="p_add">+		goto error_put_dest_keyring;</span>
<span class="p_add">+	}</span>
 
 	ret = construct_alloc_key(type, description, dest_keyring, flags, user,
 				  &amp;key);
<span class="p_chunk">@@ -469,7 +496,7 @@</span> <span class="p_context"> static struct key *construct_key_and_link(struct key_type *type,</span>
 	} else if (ret == -EINPROGRESS) {
 		ret = 0;
 	} else {
<span class="p_del">-		goto couldnt_alloc_key;</span>
<span class="p_add">+		goto error_put_dest_keyring;</span>
 	}
 
 	key_put(dest_keyring);
<span class="p_chunk">@@ -479,8 +506,9 @@</span> <span class="p_context"> static struct key *construct_key_and_link(struct key_type *type,</span>
 construction_failed:
 	key_negate_and_link(key, key_negative_timeout, NULL, NULL);
 	key_put(key);
<span class="p_del">-couldnt_alloc_key:</span>
<span class="p_add">+error_put_dest_keyring:</span>
 	key_put(dest_keyring);
<span class="p_add">+error:</span>
 	kleave(&quot; = %d&quot;, ret);
 	return ERR_PTR(ret);
 }
<span class="p_header">diff --git a/security/keys/request_key_auth.c b/security/keys/request_key_auth.c</span>
<span class="p_header">index 60d4e3f5e4bb..40a06a30a9cf 100644</span>
<span class="p_header">--- a/security/keys/request_key_auth.c</span>
<span class="p_header">+++ b/security/keys/request_key_auth.c</span>
<span class="p_chunk">@@ -106,6 +106,18 @@</span> <span class="p_context"> static void request_key_auth_revoke(struct key *key)</span>
 	}
 }
 
<span class="p_add">+static void free_request_key_auth(struct request_key_auth *rka)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!rka)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	key_put(rka-&gt;target_key);</span>
<span class="p_add">+	key_put(rka-&gt;dest_keyring);</span>
<span class="p_add">+	if (rka-&gt;cred)</span>
<span class="p_add">+		put_cred(rka-&gt;cred);</span>
<span class="p_add">+	kfree(rka-&gt;callout_info);</span>
<span class="p_add">+	kfree(rka);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * Destroy an instantiation authorisation token key.
  */
<span class="p_chunk">@@ -115,15 +127,7 @@</span> <span class="p_context"> static void request_key_auth_destroy(struct key *key)</span>
 
 	kenter(&quot;{%d}&quot;, key-&gt;serial);
 
<span class="p_del">-	if (rka-&gt;cred) {</span>
<span class="p_del">-		put_cred(rka-&gt;cred);</span>
<span class="p_del">-		rka-&gt;cred = NULL;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	key_put(rka-&gt;target_key);</span>
<span class="p_del">-	key_put(rka-&gt;dest_keyring);</span>
<span class="p_del">-	kfree(rka-&gt;callout_info);</span>
<span class="p_del">-	kfree(rka);</span>
<span class="p_add">+	free_request_key_auth(rka);</span>
 }
 
 /*
<span class="p_chunk">@@ -137,22 +141,17 @@</span> <span class="p_context"> struct key *request_key_auth_new(struct key *target, const void *callout_info,</span>
 	const struct cred *cred = current-&gt;cred;
 	struct key *authkey = NULL;
 	char desc[20];
<span class="p_del">-	int ret;</span>
<span class="p_add">+	int ret = -ENOMEM;</span>
 
 	kenter(&quot;%d,&quot;, target-&gt;serial);
 
 	/* allocate a auth record */
<span class="p_del">-	rka = kmalloc(sizeof(*rka), GFP_KERNEL);</span>
<span class="p_del">-	if (!rka) {</span>
<span class="p_del">-		kleave(&quot; = -ENOMEM&quot;);</span>
<span class="p_del">-		return ERR_PTR(-ENOMEM);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	rka = kzalloc(sizeof(*rka), GFP_KERNEL);</span>
<span class="p_add">+	if (!rka)</span>
<span class="p_add">+		goto error;</span>
 	rka-&gt;callout_info = kmalloc(callout_len, GFP_KERNEL);
<span class="p_del">-	if (!rka-&gt;callout_info) {</span>
<span class="p_del">-		kleave(&quot; = -ENOMEM&quot;);</span>
<span class="p_del">-		kfree(rka);</span>
<span class="p_del">-		return ERR_PTR(-ENOMEM);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (!rka-&gt;callout_info)</span>
<span class="p_add">+		goto error_free_rka;</span>
 
 	/* see if the calling process is already servicing the key request of
 	 * another process */
<span class="p_chunk">@@ -162,8 +161,12 @@</span> <span class="p_context"> struct key *request_key_auth_new(struct key *target, const void *callout_info,</span>
 
 		/* if the auth key has been revoked, then the key we&#39;re
 		 * servicing is already instantiated */
<span class="p_del">-		if (test_bit(KEY_FLAG_REVOKED, &amp;cred-&gt;request_key_auth-&gt;flags))</span>
<span class="p_del">-			goto auth_key_revoked;</span>
<span class="p_add">+		if (test_bit(KEY_FLAG_REVOKED,</span>
<span class="p_add">+			     &amp;cred-&gt;request_key_auth-&gt;flags)) {</span>
<span class="p_add">+			up_read(&amp;cred-&gt;request_key_auth-&gt;sem);</span>
<span class="p_add">+			ret = -EKEYREVOKED;</span>
<span class="p_add">+			goto error_free_rka;</span>
<span class="p_add">+		}</span>
 
 		irka = cred-&gt;request_key_auth-&gt;payload.data;
 		rka-&gt;cred = get_cred(irka-&gt;cred);
<span class="p_chunk">@@ -191,32 +194,22 @@</span> <span class="p_context"> struct key *request_key_auth_new(struct key *target, const void *callout_info,</span>
 			    KEY_USR_VIEW, KEY_ALLOC_NOT_IN_QUOTA);
 	if (IS_ERR(authkey)) {
 		ret = PTR_ERR(authkey);
<span class="p_del">-		goto error_alloc;</span>
<span class="p_add">+		goto error_free_rka;</span>
 	}
 
 	/* construct the auth key */
 	ret = key_instantiate_and_link(authkey, rka, 0, NULL, NULL);
 	if (ret &lt; 0)
<span class="p_del">-		goto error_inst;</span>
<span class="p_add">+		goto error_put_authkey;</span>
 
 	kleave(&quot; = {%d,%d}&quot;, authkey-&gt;serial, atomic_read(&amp;authkey-&gt;usage));
 	return authkey;
 
<span class="p_del">-auth_key_revoked:</span>
<span class="p_del">-	up_read(&amp;cred-&gt;request_key_auth-&gt;sem);</span>
<span class="p_del">-	kfree(rka-&gt;callout_info);</span>
<span class="p_del">-	kfree(rka);</span>
<span class="p_del">-	kleave(&quot;= -EKEYREVOKED&quot;);</span>
<span class="p_del">-	return ERR_PTR(-EKEYREVOKED);</span>
<span class="p_del">-</span>
<span class="p_del">-error_inst:</span>
<span class="p_del">-	key_revoke(authkey);</span>
<span class="p_add">+error_put_authkey:</span>
 	key_put(authkey);
<span class="p_del">-error_alloc:</span>
<span class="p_del">-	key_put(rka-&gt;target_key);</span>
<span class="p_del">-	key_put(rka-&gt;dest_keyring);</span>
<span class="p_del">-	kfree(rka-&gt;callout_info);</span>
<span class="p_del">-	kfree(rka);</span>
<span class="p_add">+error_free_rka:</span>
<span class="p_add">+	free_request_key_auth(rka);</span>
<span class="p_add">+error:</span>
 	kleave(&quot;= %d&quot;, ret);
 	return ERR_PTR(ret);
 }
<span class="p_header">diff --git a/security/keys/trusted.c b/security/keys/trusted.c</span>
<span class="p_header">index 0ed5fdf238a2..c73462b5b867 100644</span>
<span class="p_header">--- a/security/keys/trusted.c</span>
<span class="p_header">+++ b/security/keys/trusted.c</span>
<span class="p_chunk">@@ -69,7 +69,7 @@</span> <span class="p_context"> static int TSS_sha1(const unsigned char *data, unsigned int datalen,</span>
 	}
 
 	ret = crypto_shash_digest(&amp;sdesc-&gt;shash, data, datalen, digest);
<span class="p_del">-	kfree(sdesc);</span>
<span class="p_add">+	kzfree(sdesc);</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -113,7 +113,7 @@</span> <span class="p_context"> static int TSS_rawhmac(unsigned char *digest, const unsigned char *key,</span>
 	if (!ret)
 		ret = crypto_shash_final(&amp;sdesc-&gt;shash, digest);
 out:
<span class="p_del">-	kfree(sdesc);</span>
<span class="p_add">+	kzfree(sdesc);</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -164,7 +164,7 @@</span> <span class="p_context"> static int TSS_authhmac(unsigned char *digest, const unsigned char *key,</span>
 				  paramdigest, TPM_NONCE_SIZE, h1,
 				  TPM_NONCE_SIZE, h2, 1, &amp;c, 0, 0);
 out:
<span class="p_del">-	kfree(sdesc);</span>
<span class="p_add">+	kzfree(sdesc);</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -245,7 +245,7 @@</span> <span class="p_context"> static int TSS_checkhmac1(unsigned char *buffer,</span>
 	if (memcmp(testhmac, authdata, SHA1_DIGEST_SIZE))
 		ret = -EINVAL;
 out:
<span class="p_del">-	kfree(sdesc);</span>
<span class="p_add">+	kzfree(sdesc);</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -346,7 +346,7 @@</span> <span class="p_context"> static int TSS_checkhmac2(unsigned char *buffer,</span>
 	if (memcmp(testhmac2, authdata2, SHA1_DIGEST_SIZE))
 		ret = -EINVAL;
 out:
<span class="p_del">-	kfree(sdesc);</span>
<span class="p_add">+	kzfree(sdesc);</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -396,7 +396,7 @@</span> <span class="p_context"> static int my_get_random(unsigned char *buf, int len)</span>
 		return -ENOMEM;
 	ret = tpm_get_random(tb, buf, len);
 
<span class="p_del">-	kfree(tb);</span>
<span class="p_add">+	kzfree(tb);</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -595,7 +595,7 @@</span> <span class="p_context"> static int tpm_seal(struct tpm_buf *tb, uint16_t keytype,</span>
 		*bloblen = storedsize;
 	}
 out:
<span class="p_del">-	kfree(td);</span>
<span class="p_add">+	kzfree(td);</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -709,7 +709,7 @@</span> <span class="p_context"> static int key_seal(struct trusted_key_payload *p,</span>
 	if (ret &lt; 0)
 		pr_info(&quot;trusted_key: srkseal failed (%d)\n&quot;, ret);
 
<span class="p_del">-	kfree(tb);</span>
<span class="p_add">+	kzfree(tb);</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -734,7 +734,7 @@</span> <span class="p_context"> static int key_unseal(struct trusted_key_payload *p,</span>
 		/* pull migratable flag out of sealed key */
 		p-&gt;migratable = p-&gt;key[--p-&gt;key_len];
 
<span class="p_del">-	kfree(tb);</span>
<span class="p_add">+	kzfree(tb);</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -990,12 +990,12 @@</span> <span class="p_context"> static int trusted_instantiate(struct key *key, const void *data,</span>
 	if (!ret &amp;&amp; options-&gt;pcrlock)
 		ret = pcrlock(options-&gt;pcrlock);
 out:
<span class="p_del">-	kfree(datablob);</span>
<span class="p_del">-	kfree(options);</span>
<span class="p_add">+	kzfree(datablob);</span>
<span class="p_add">+	kzfree(options);</span>
 	if (!ret)
 		rcu_assign_pointer(key-&gt;payload.data, payload);
 	else
<span class="p_del">-		kfree(payload);</span>
<span class="p_add">+		kzfree(payload);</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -1004,8 +1004,7 @@</span> <span class="p_context"> static void trusted_rcu_free(struct rcu_head *rcu)</span>
 	struct trusted_key_payload *p;
 
 	p = container_of(rcu, struct trusted_key_payload, rcu);
<span class="p_del">-	memset(p-&gt;key, 0, p-&gt;key_len);</span>
<span class="p_del">-	kfree(p);</span>
<span class="p_add">+	kzfree(p);</span>
 }
 
 /*
<span class="p_chunk">@@ -1043,7 +1042,7 @@</span> <span class="p_context"> static int trusted_update(struct key *key, const void *data, size_t datalen)</span>
 	ret = datablob_parse(datablob, new_p, new_o);
 	if (ret != Opt_update) {
 		ret = -EINVAL;
<span class="p_del">-		kfree(new_p);</span>
<span class="p_add">+		kzfree(new_p);</span>
 		goto out;
 	}
 	/* copy old key values, and reseal with new pcrs */
<span class="p_chunk">@@ -1056,22 +1055,22 @@</span> <span class="p_context"> static int trusted_update(struct key *key, const void *data, size_t datalen)</span>
 	ret = key_seal(new_p, new_o);
 	if (ret &lt; 0) {
 		pr_info(&quot;trusted_key: key_seal failed (%d)\n&quot;, ret);
<span class="p_del">-		kfree(new_p);</span>
<span class="p_add">+		kzfree(new_p);</span>
 		goto out;
 	}
 	if (new_o-&gt;pcrlock) {
 		ret = pcrlock(new_o-&gt;pcrlock);
 		if (ret &lt; 0) {
 			pr_info(&quot;trusted_key: pcrlock failed (%d)\n&quot;, ret);
<span class="p_del">-			kfree(new_p);</span>
<span class="p_add">+			kzfree(new_p);</span>
 			goto out;
 		}
 	}
 	rcu_assign_pointer(key-&gt;payload.data, new_p);
 	call_rcu(&amp;p-&gt;rcu, trusted_rcu_free);
 out:
<span class="p_del">-	kfree(datablob);</span>
<span class="p_del">-	kfree(new_o);</span>
<span class="p_add">+	kzfree(datablob);</span>
<span class="p_add">+	kzfree(new_o);</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -1090,34 +1089,30 @@</span> <span class="p_context"> static long trusted_read(const struct key *key, char __user *buffer,</span>
 	p = rcu_dereference_key(key);
 	if (!p)
 		return -EINVAL;
<span class="p_del">-	if (!buffer || buflen &lt;= 0)</span>
<span class="p_del">-		return 2 * p-&gt;blob_len;</span>
<span class="p_del">-	ascii_buf = kmalloc(2 * p-&gt;blob_len, GFP_KERNEL);</span>
<span class="p_del">-	if (!ascii_buf)</span>
<span class="p_del">-		return -ENOMEM;</span>
 
<span class="p_del">-	bufp = ascii_buf;</span>
<span class="p_del">-	for (i = 0; i &lt; p-&gt;blob_len; i++)</span>
<span class="p_del">-		bufp = hex_byte_pack(bufp, p-&gt;blob[i]);</span>
<span class="p_del">-	if ((copy_to_user(buffer, ascii_buf, 2 * p-&gt;blob_len)) != 0) {</span>
<span class="p_del">-		kfree(ascii_buf);</span>
<span class="p_del">-		return -EFAULT;</span>
<span class="p_add">+	if (buffer &amp;&amp; buflen &gt;= 2 * p-&gt;blob_len) {</span>
<span class="p_add">+		ascii_buf = kmalloc(2 * p-&gt;blob_len, GFP_KERNEL);</span>
<span class="p_add">+		if (!ascii_buf)</span>
<span class="p_add">+			return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+		bufp = ascii_buf;</span>
<span class="p_add">+		for (i = 0; i &lt; p-&gt;blob_len; i++)</span>
<span class="p_add">+			bufp = hex_byte_pack(bufp, p-&gt;blob[i]);</span>
<span class="p_add">+		if (copy_to_user(buffer, ascii_buf, 2 * p-&gt;blob_len) != 0) {</span>
<span class="p_add">+			kzfree(ascii_buf);</span>
<span class="p_add">+			return -EFAULT;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		kzfree(ascii_buf);</span>
 	}
<span class="p_del">-	kfree(ascii_buf);</span>
 	return 2 * p-&gt;blob_len;
 }
 
 /*
<span class="p_del">- * trusted_destroy - before freeing the key, clear the decrypted data</span>
<span class="p_add">+ * trusted_destroy - clear and free the key&#39;s payload</span>
  */
 static void trusted_destroy(struct key *key)
 {
<span class="p_del">-	struct trusted_key_payload *p = key-&gt;payload.data;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!p)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	memset(p-&gt;key, 0, p-&gt;key_len);</span>
<span class="p_del">-	kfree(key-&gt;payload.data);</span>
<span class="p_add">+	kzfree(key-&gt;payload.data);</span>
 }
 
 struct key_type key_type_trusted = {
<span class="p_header">diff --git a/security/selinux/hooks.c b/security/selinux/hooks.c</span>
<span class="p_header">index 4c6a34700d49..ad1cb35012af 100644</span>
<span class="p_header">--- a/security/selinux/hooks.c</span>
<span class="p_header">+++ b/security/selinux/hooks.c</span>
<span class="p_chunk">@@ -1845,7 +1845,7 @@</span> <span class="p_context"> static int selinux_ptrace_access_check(struct task_struct *child,</span>
 	if (rc)
 		return rc;
 
<span class="p_del">-	if (mode == PTRACE_MODE_READ) {</span>
<span class="p_add">+	if (mode &amp; PTRACE_MODE_READ) {</span>
 		u32 sid = current_sid();
 		u32 csid = task_sid(child);
 		return avc_has_perm(sid, csid, SECCLASS_FILE, FILE__READ, NULL);
<span class="p_header">diff --git a/security/smack/smack_lsm.c b/security/smack/smack_lsm.c</span>
<span class="p_header">index 774c159b242b..5e23bb80556e 100644</span>
<span class="p_header">--- a/security/smack/smack_lsm.c</span>
<span class="p_header">+++ b/security/smack/smack_lsm.c</span>
<span class="p_chunk">@@ -583,7 +583,7 @@</span> <span class="p_context"> static int smack_inode_init_security(struct inode *inode, struct inode *dir,</span>
 	}
 
 	if (len)
<span class="p_del">-		*len = strlen(isp) + 1;</span>
<span class="p_add">+		*len = strlen(isp);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -940,7 +940,7 @@</span> <span class="p_context"> static int smack_inode_removexattr(struct dentry *dentry, const char *name)</span>
  * @inode: the object
  * @name: attribute name
  * @buffer: where to put the result
<span class="p_del">- * @alloc: unused</span>
<span class="p_add">+ * @alloc: duplicate memory</span>
  *
  * Returns the size of the attribute or an error code
  */
<span class="p_chunk">@@ -953,43 +953,38 @@</span> <span class="p_context"> static int smack_inode_getsecurity(const struct inode *inode,</span>
 	struct super_block *sbp;
 	struct inode *ip = (struct inode *)inode;
 	char *isp;
<span class="p_del">-	int ilen;</span>
<span class="p_del">-	int rc = 0;</span>
 
<span class="p_del">-	if (strcmp(name, XATTR_SMACK_SUFFIX) == 0) {</span>
<span class="p_add">+	if (strcmp(name, XATTR_SMACK_SUFFIX) == 0)</span>
 		isp = smk_of_inode(inode);
<span class="p_del">-		ilen = strlen(isp) + 1;</span>
<span class="p_del">-		*buffer = isp;</span>
<span class="p_del">-		return ilen;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	else {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * The rest of the Smack xattrs are only on sockets.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		sbp = ip-&gt;i_sb;</span>
<span class="p_add">+		if (sbp-&gt;s_magic != SOCKFS_MAGIC)</span>
<span class="p_add">+			return -EOPNOTSUPP;</span>
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * The rest of the Smack xattrs are only on sockets.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	sbp = ip-&gt;i_sb;</span>
<span class="p_del">-	if (sbp-&gt;s_magic != SOCKFS_MAGIC)</span>
<span class="p_del">-		return -EOPNOTSUPP;</span>
<span class="p_add">+		sock = SOCKET_I(ip);</span>
<span class="p_add">+		if (sock == NULL || sock-&gt;sk == NULL)</span>
<span class="p_add">+			return -EOPNOTSUPP;</span>
 
<span class="p_del">-	sock = SOCKET_I(ip);</span>
<span class="p_del">-	if (sock == NULL || sock-&gt;sk == NULL)</span>
<span class="p_del">-		return -EOPNOTSUPP;</span>
<span class="p_del">-</span>
<span class="p_del">-	ssp = sock-&gt;sk-&gt;sk_security;</span>
<span class="p_add">+		ssp = sock-&gt;sk-&gt;sk_security;</span>
 
<span class="p_del">-	if (strcmp(name, XATTR_SMACK_IPIN) == 0)</span>
<span class="p_del">-		isp = ssp-&gt;smk_in;</span>
<span class="p_del">-	else if (strcmp(name, XATTR_SMACK_IPOUT) == 0)</span>
<span class="p_del">-		isp = ssp-&gt;smk_out;</span>
<span class="p_del">-	else</span>
<span class="p_del">-		return -EOPNOTSUPP;</span>
<span class="p_add">+		if (strcmp(name, XATTR_SMACK_IPIN) == 0)</span>
<span class="p_add">+			isp = ssp-&gt;smk_in;</span>
<span class="p_add">+		else if (strcmp(name, XATTR_SMACK_IPOUT) == 0)</span>
<span class="p_add">+			isp = ssp-&gt;smk_out;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			return -EOPNOTSUPP;</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	ilen = strlen(isp) + 1;</span>
<span class="p_del">-	if (rc == 0) {</span>
<span class="p_del">-		*buffer = isp;</span>
<span class="p_del">-		rc = ilen;</span>
<span class="p_add">+	if (alloc) {</span>
<span class="p_add">+		*buffer = kstrdup(isp, GFP_KERNEL);</span>
<span class="p_add">+		if (*buffer == NULL)</span>
<span class="p_add">+			return -ENOMEM;</span>
 	}
 
<span class="p_del">-	return rc;</span>
<span class="p_add">+	return strlen(isp);</span>
 }
 
 
<span class="p_header">diff --git a/sound/core/hrtimer.c b/sound/core/hrtimer.c</span>
<span class="p_header">index 14d483d6b3b0..834fa602fdd1 100644</span>
<span class="p_header">--- a/sound/core/hrtimer.c</span>
<span class="p_header">+++ b/sound/core/hrtimer.c</span>
<span class="p_chunk">@@ -145,6 +145,7 @@</span> <span class="p_context"> static int __init snd_hrtimer_init(void)</span>
 	timer-&gt;hw = hrtimer_hw;
 	timer-&gt;hw.resolution = resolution;
 	timer-&gt;hw.ticks = NANO_SEC / resolution;
<span class="p_add">+	timer-&gt;max_instances = 100; /* lower the limit */</span>
 
 	err = snd_timer_global_register(timer);
 	if (err &lt; 0) {
<span class="p_header">diff --git a/sound/core/seq/oss/seq_oss_midi.c b/sound/core/seq/oss/seq_oss_midi.c</span>
<span class="p_header">index 677dc84590c7..707f6ff690dc 100644</span>
<span class="p_header">--- a/sound/core/seq/oss/seq_oss_midi.c</span>
<span class="p_header">+++ b/sound/core/seq/oss/seq_oss_midi.c</span>
<span class="p_chunk">@@ -618,9 +618,7 @@</span> <span class="p_context"> send_midi_event(struct seq_oss_devinfo *dp, struct snd_seq_event *ev, struct seq</span>
 	if (!dp-&gt;timer-&gt;running)
 		len = snd_seq_oss_timer_start(dp-&gt;timer);
 	if (ev-&gt;type == SNDRV_SEQ_EVENT_SYSEX) {
<span class="p_del">-		if ((ev-&gt;flags &amp; SNDRV_SEQ_EVENT_LENGTH_MASK) == SNDRV_SEQ_EVENT_LENGTH_VARIABLE)</span>
<span class="p_del">-			snd_seq_oss_readq_puts(dp-&gt;readq, mdev-&gt;seq_device,</span>
<span class="p_del">-					       ev-&gt;data.ext.ptr, ev-&gt;data.ext.len);</span>
<span class="p_add">+		snd_seq_oss_readq_sysex(dp-&gt;readq, mdev-&gt;seq_device, ev);</span>
 	} else {
 		len = snd_midi_event_decode(mdev-&gt;coder, msg, sizeof(msg), ev);
 		if (len &gt; 0)
<span class="p_header">diff --git a/sound/core/seq/oss/seq_oss_readq.c b/sound/core/seq/oss/seq_oss_readq.c</span>
<span class="p_header">index 73661c4ab82a..7bbc61046d3a 100644</span>
<span class="p_header">--- a/sound/core/seq/oss/seq_oss_readq.c</span>
<span class="p_header">+++ b/sound/core/seq/oss/seq_oss_readq.c</span>
<span class="p_chunk">@@ -119,6 +119,35 @@</span> <span class="p_context"> snd_seq_oss_readq_puts(struct seq_oss_readq *q, int dev, unsigned char *data, in</span>
 	return 0;
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * put MIDI sysex bytes; the event buffer may be chained, thus it has</span>
<span class="p_add">+ * to be expanded via snd_seq_dump_var_event().</span>
<span class="p_add">+ */</span>
<span class="p_add">+struct readq_sysex_ctx {</span>
<span class="p_add">+	struct seq_oss_readq *readq;</span>
<span class="p_add">+	int dev;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static int readq_dump_sysex(void *ptr, void *buf, int count)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct readq_sysex_ctx *ctx = ptr;</span>
<span class="p_add">+</span>
<span class="p_add">+	return snd_seq_oss_readq_puts(ctx-&gt;readq, ctx-&gt;dev, buf, count);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int snd_seq_oss_readq_sysex(struct seq_oss_readq *q, int dev,</span>
<span class="p_add">+			    struct snd_seq_event *ev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct readq_sysex_ctx ctx = {</span>
<span class="p_add">+		.readq = q,</span>
<span class="p_add">+		.dev = dev</span>
<span class="p_add">+	};</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((ev-&gt;flags &amp; SNDRV_SEQ_EVENT_LENGTH_MASK) != SNDRV_SEQ_EVENT_LENGTH_VARIABLE)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	return snd_seq_dump_var_event(ev, readq_dump_sysex, &amp;ctx);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * copy an event to input queue:
  * return zero if enqueued
<span class="p_header">diff --git a/sound/core/seq/oss/seq_oss_readq.h b/sound/core/seq/oss/seq_oss_readq.h</span>
<span class="p_header">index f1463f1f449e..8d033ca2d23f 100644</span>
<span class="p_header">--- a/sound/core/seq/oss/seq_oss_readq.h</span>
<span class="p_header">+++ b/sound/core/seq/oss/seq_oss_readq.h</span>
<span class="p_chunk">@@ -44,6 +44,8 @@</span> <span class="p_context"> void snd_seq_oss_readq_delete(struct seq_oss_readq *q);</span>
 void snd_seq_oss_readq_clear(struct seq_oss_readq *readq);
 unsigned int snd_seq_oss_readq_poll(struct seq_oss_readq *readq, struct file *file, poll_table *wait);
 int snd_seq_oss_readq_puts(struct seq_oss_readq *readq, int dev, unsigned char *data, int len);
<span class="p_add">+int snd_seq_oss_readq_sysex(struct seq_oss_readq *q, int dev,</span>
<span class="p_add">+			    struct snd_seq_event *ev);</span>
 int snd_seq_oss_readq_put_event(struct seq_oss_readq *readq, union evrec *ev);
 int snd_seq_oss_readq_put_timestamp(struct seq_oss_readq *readq, unsigned long curt, int seq_mode);
 int snd_seq_oss_readq_pick(struct seq_oss_readq *q, union evrec *rec);
<span class="p_header">diff --git a/sound/core/seq/seq_clientmgr.c b/sound/core/seq/seq_clientmgr.c</span>
<span class="p_header">index 7b5a7902b7a2..c789f91b4c2a 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_clientmgr.c</span>
<span class="p_header">+++ b/sound/core/seq/seq_clientmgr.c</span>
<span class="p_chunk">@@ -676,7 +676,7 @@</span> <span class="p_context"> static int deliver_to_subscribers(struct snd_seq_client *client,</span>
 	if (atomic)
 		read_lock(&amp;grp-&gt;list_lock);
 	else
<span class="p_del">-		down_read(&amp;grp-&gt;list_mutex);</span>
<span class="p_add">+		down_read_nested(&amp;grp-&gt;list_mutex, hop);</span>
 	list_for_each_entry(subs, &amp;grp-&gt;list_head, src_list) {
 		/* both ports ready? */
 		if (atomic_read(&amp;subs-&gt;ref_count) != 2)
<span class="p_header">diff --git a/sound/core/seq/seq_virmidi.c b/sound/core/seq/seq_virmidi.c</span>
<span class="p_header">index 6b38e7c2641a..c90464d9e7fc 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_virmidi.c</span>
<span class="p_header">+++ b/sound/core/seq/seq_virmidi.c</span>
<span class="p_chunk">@@ -77,13 +77,17 @@</span> <span class="p_context"> static void snd_virmidi_init_event(struct snd_virmidi *vmidi,</span>
  * decode input event and put to read buffer of each opened file
  */
 static int snd_virmidi_dev_receive_event(struct snd_virmidi_dev *rdev,
<span class="p_del">-					 struct snd_seq_event *ev)</span>
<span class="p_add">+					 struct snd_seq_event *ev,</span>
<span class="p_add">+					 bool atomic)</span>
 {
 	struct snd_virmidi *vmidi;
 	unsigned char msg[4];
 	int len;
 
<span class="p_del">-	read_lock(&amp;rdev-&gt;filelist_lock);</span>
<span class="p_add">+	if (atomic)</span>
<span class="p_add">+		read_lock(&amp;rdev-&gt;filelist_lock);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		down_read(&amp;rdev-&gt;filelist_sem);</span>
 	list_for_each_entry(vmidi, &amp;rdev-&gt;filelist, list) {
 		if (!vmidi-&gt;trigger)
 			continue;
<span class="p_chunk">@@ -97,7 +101,10 @@</span> <span class="p_context"> static int snd_virmidi_dev_receive_event(struct snd_virmidi_dev *rdev,</span>
 				snd_rawmidi_receive(vmidi-&gt;substream, msg, len);
 		}
 	}
<span class="p_del">-	read_unlock(&amp;rdev-&gt;filelist_lock);</span>
<span class="p_add">+	if (atomic)</span>
<span class="p_add">+		read_unlock(&amp;rdev-&gt;filelist_lock);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		up_read(&amp;rdev-&gt;filelist_sem);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -115,7 +122,7 @@</span> <span class="p_context"> int snd_virmidi_receive(struct snd_rawmidi *rmidi, struct snd_seq_event *ev)</span>
 	struct snd_virmidi_dev *rdev;
 
 	rdev = rmidi-&gt;private_data;
<span class="p_del">-	return snd_virmidi_dev_receive_event(rdev, ev);</span>
<span class="p_add">+	return snd_virmidi_dev_receive_event(rdev, ev, true);</span>
 }
 #endif  /*  0  */
 
<span class="p_chunk">@@ -130,7 +137,7 @@</span> <span class="p_context"> static int snd_virmidi_event_input(struct snd_seq_event *ev, int direct,</span>
 	rdev = private_data;
 	if (!(rdev-&gt;flags &amp; SNDRV_VIRMIDI_USE))
 		return 0; /* ignored */
<span class="p_del">-	return snd_virmidi_dev_receive_event(rdev, ev);</span>
<span class="p_add">+	return snd_virmidi_dev_receive_event(rdev, ev, atomic);</span>
 }
 
 /*
<span class="p_chunk">@@ -209,7 +216,6 @@</span> <span class="p_context"> static int snd_virmidi_input_open(struct snd_rawmidi_substream *substream)</span>
 	struct snd_virmidi_dev *rdev = substream-&gt;rmidi-&gt;private_data;
 	struct snd_rawmidi_runtime *runtime = substream-&gt;runtime;
 	struct snd_virmidi *vmidi;
<span class="p_del">-	unsigned long flags;</span>
 
 	vmidi = kzalloc(sizeof(*vmidi), GFP_KERNEL);
 	if (vmidi == NULL)
<span class="p_chunk">@@ -223,9 +229,11 @@</span> <span class="p_context"> static int snd_virmidi_input_open(struct snd_rawmidi_substream *substream)</span>
 	vmidi-&gt;client = rdev-&gt;client;
 	vmidi-&gt;port = rdev-&gt;port;	
 	runtime-&gt;private_data = vmidi;
<span class="p_del">-	write_lock_irqsave(&amp;rdev-&gt;filelist_lock, flags);</span>
<span class="p_add">+	down_write(&amp;rdev-&gt;filelist_sem);</span>
<span class="p_add">+	write_lock_irq(&amp;rdev-&gt;filelist_lock);</span>
 	list_add_tail(&amp;vmidi-&gt;list, &amp;rdev-&gt;filelist);
<span class="p_del">-	write_unlock_irqrestore(&amp;rdev-&gt;filelist_lock, flags);</span>
<span class="p_add">+	write_unlock_irq(&amp;rdev-&gt;filelist_lock);</span>
<span class="p_add">+	up_write(&amp;rdev-&gt;filelist_sem);</span>
 	vmidi-&gt;rdev = rdev;
 	return 0;
 }
<span class="p_chunk">@@ -264,9 +272,11 @@</span> <span class="p_context"> static int snd_virmidi_input_close(struct snd_rawmidi_substream *substream)</span>
 	struct snd_virmidi_dev *rdev = substream-&gt;rmidi-&gt;private_data;
 	struct snd_virmidi *vmidi = substream-&gt;runtime-&gt;private_data;
 
<span class="p_add">+	down_write(&amp;rdev-&gt;filelist_sem);</span>
 	write_lock_irq(&amp;rdev-&gt;filelist_lock);
 	list_del(&amp;vmidi-&gt;list);
 	write_unlock_irq(&amp;rdev-&gt;filelist_lock);
<span class="p_add">+	up_write(&amp;rdev-&gt;filelist_sem);</span>
 	snd_midi_event_free(vmidi-&gt;parser);
 	substream-&gt;runtime-&gt;private_data = NULL;
 	kfree(vmidi);
<span class="p_chunk">@@ -520,6 +530,7 @@</span> <span class="p_context"> int snd_virmidi_new(struct snd_card *card, int device, struct snd_rawmidi **rrmi</span>
 	rdev-&gt;rmidi = rmidi;
 	rdev-&gt;device = device;
 	rdev-&gt;client = -1;
<span class="p_add">+	init_rwsem(&amp;rdev-&gt;filelist_sem);</span>
 	rwlock_init(&amp;rdev-&gt;filelist_lock);
 	INIT_LIST_HEAD(&amp;rdev-&gt;filelist);
 	rdev-&gt;seq_mode = SNDRV_VIRMIDI_SEQ_DISPATCH;
<span class="p_header">diff --git a/sound/core/timer.c b/sound/core/timer.c</span>
<span class="p_header">index 7754a37de7e9..69c801ac025a 100644</span>
<span class="p_header">--- a/sound/core/timer.c</span>
<span class="p_header">+++ b/sound/core/timer.c</span>
<span class="p_chunk">@@ -179,7 +179,7 @@</span> <span class="p_context"> static void snd_timer_request(struct snd_timer_id *tid)</span>
  *
  * call this with register_mutex down.
  */
<span class="p_del">-static void snd_timer_check_slave(struct snd_timer_instance *slave)</span>
<span class="p_add">+static int snd_timer_check_slave(struct snd_timer_instance *slave)</span>
 {
 	struct snd_timer *timer;
 	struct snd_timer_instance *master;
<span class="p_chunk">@@ -189,16 +189,21 @@</span> <span class="p_context"> static void snd_timer_check_slave(struct snd_timer_instance *slave)</span>
 		list_for_each_entry(master, &amp;timer-&gt;open_list_head, open_list) {
 			if (slave-&gt;slave_class == master-&gt;slave_class &amp;&amp;
 			    slave-&gt;slave_id == master-&gt;slave_id) {
<span class="p_add">+				if (master-&gt;timer-&gt;num_instances &gt;=</span>
<span class="p_add">+				    master-&gt;timer-&gt;max_instances)</span>
<span class="p_add">+					return -EBUSY;</span>
 				list_move_tail(&amp;slave-&gt;open_list,
 					       &amp;master-&gt;slave_list_head);
<span class="p_add">+				master-&gt;timer-&gt;num_instances++;</span>
 				spin_lock_irq(&amp;slave_active_lock);
 				slave-&gt;master = master;
 				slave-&gt;timer = master-&gt;timer;
 				spin_unlock_irq(&amp;slave_active_lock);
<span class="p_del">-				return;</span>
<span class="p_add">+				return 0;</span>
 			}
 		}
 	}
<span class="p_add">+	return 0;</span>
 }
 
 /*
<span class="p_chunk">@@ -207,7 +212,7 @@</span> <span class="p_context"> static void snd_timer_check_slave(struct snd_timer_instance *slave)</span>
  *
  * call this with register_mutex down.
  */
<span class="p_del">-static void snd_timer_check_master(struct snd_timer_instance *master)</span>
<span class="p_add">+static int snd_timer_check_master(struct snd_timer_instance *master)</span>
 {
 	struct snd_timer_instance *slave, *tmp;
 
<span class="p_chunk">@@ -215,7 +220,11 @@</span> <span class="p_context"> static void snd_timer_check_master(struct snd_timer_instance *master)</span>
 	list_for_each_entry_safe(slave, tmp, &amp;snd_timer_slave_list, open_list) {
 		if (slave-&gt;slave_class == master-&gt;slave_class &amp;&amp;
 		    slave-&gt;slave_id == master-&gt;slave_id) {
<span class="p_add">+			if (master-&gt;timer-&gt;num_instances &gt;=</span>
<span class="p_add">+			    master-&gt;timer-&gt;max_instances)</span>
<span class="p_add">+				return -EBUSY;</span>
 			list_move_tail(&amp;slave-&gt;open_list, &amp;master-&gt;slave_list_head);
<span class="p_add">+			master-&gt;timer-&gt;num_instances++;</span>
 			spin_lock_irq(&amp;slave_active_lock);
 			spin_lock(&amp;master-&gt;timer-&gt;lock);
 			slave-&gt;master = master;
<span class="p_chunk">@@ -227,8 +236,11 @@</span> <span class="p_context"> static void snd_timer_check_master(struct snd_timer_instance *master)</span>
 			spin_unlock_irq(&amp;slave_active_lock);
 		}
 	}
<span class="p_add">+	return 0;</span>
 }
 
<span class="p_add">+static int snd_timer_close_locked(struct snd_timer_instance *timeri);</span>
<span class="p_add">+</span>
 /*
  * open a timer instance
  * when opening a master, the slave id must be here given.
<span class="p_chunk">@@ -239,6 +251,7 @@</span> <span class="p_context"> int snd_timer_open(struct snd_timer_instance **ti,</span>
 {
 	struct snd_timer *timer;
 	struct snd_timer_instance *timeri = NULL;
<span class="p_add">+	int err;</span>
 
 	if (tid-&gt;dev_class == SNDRV_TIMER_CLASS_SLAVE) {
 		/* open a slave instance */
<span class="p_chunk">@@ -257,10 +270,14 @@</span> <span class="p_context"> int snd_timer_open(struct snd_timer_instance **ti,</span>
 		timeri-&gt;slave_id = tid-&gt;device;
 		timeri-&gt;flags |= SNDRV_TIMER_IFLG_SLAVE;
 		list_add_tail(&amp;timeri-&gt;open_list, &amp;snd_timer_slave_list);
<span class="p_del">-		snd_timer_check_slave(timeri);</span>
<span class="p_add">+		err = snd_timer_check_slave(timeri);</span>
<span class="p_add">+		if (err &lt; 0) {</span>
<span class="p_add">+			snd_timer_close_locked(timeri);</span>
<span class="p_add">+			timeri = NULL;</span>
<span class="p_add">+		}</span>
 		mutex_unlock(&amp;register_mutex);
 		*ti = timeri;
<span class="p_del">-		return 0;</span>
<span class="p_add">+		return err;</span>
 	}
 
 	/* open a master instance */
<span class="p_chunk">@@ -286,6 +303,10 @@</span> <span class="p_context"> int snd_timer_open(struct snd_timer_instance **ti,</span>
 			return -EBUSY;
 		}
 	}
<span class="p_add">+	if (timer-&gt;num_instances &gt;= timer-&gt;max_instances) {</span>
<span class="p_add">+		mutex_unlock(&amp;register_mutex);</span>
<span class="p_add">+		return -EBUSY;</span>
<span class="p_add">+	}</span>
 	timeri = snd_timer_instance_new(owner, timer);
 	if (!timeri) {
 		mutex_unlock(&amp;register_mutex);
<span class="p_chunk">@@ -307,44 +328,36 @@</span> <span class="p_context"> int snd_timer_open(struct snd_timer_instance **ti,</span>
 	}
 
 	list_add_tail(&amp;timeri-&gt;open_list, &amp;timer-&gt;open_list_head);
<span class="p_del">-	snd_timer_check_master(timeri);</span>
<span class="p_add">+	timer-&gt;num_instances++;</span>
<span class="p_add">+	err = snd_timer_check_master(timeri);</span>
<span class="p_add">+	if (err &lt; 0) {</span>
<span class="p_add">+		snd_timer_close_locked(timeri);</span>
<span class="p_add">+		timeri = NULL;</span>
<span class="p_add">+	}</span>
 	mutex_unlock(&amp;register_mutex);
 	*ti = timeri;
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return err;</span>
 }
 
 static int _snd_timer_stop(struct snd_timer_instance *timeri, int event);
 
 /*
  * close a timer instance
<span class="p_add">+ * call this with register_mutex down.</span>
  */
<span class="p_del">-int snd_timer_close(struct snd_timer_instance *timeri)</span>
<span class="p_add">+static int snd_timer_close_locked(struct snd_timer_instance *timeri)</span>
 {
 	struct snd_timer *timer = NULL;
 	struct snd_timer_instance *slave, *tmp;
 
<span class="p_del">-	if (snd_BUG_ON(!timeri))</span>
<span class="p_del">-		return -ENXIO;</span>
<span class="p_add">+	list_del(&amp;timeri-&gt;open_list);</span>
 
 	/* force to stop the timer */
 	snd_timer_stop(timeri);
 
<span class="p_del">-	if (timeri-&gt;flags &amp; SNDRV_TIMER_IFLG_SLAVE) {</span>
<span class="p_del">-		/* wait, until the active callback is finished */</span>
<span class="p_del">-		spin_lock_irq(&amp;slave_active_lock);</span>
<span class="p_del">-		while (timeri-&gt;flags &amp; SNDRV_TIMER_IFLG_CALLBACK) {</span>
<span class="p_del">-			spin_unlock_irq(&amp;slave_active_lock);</span>
<span class="p_del">-			udelay(10);</span>
<span class="p_del">-			spin_lock_irq(&amp;slave_active_lock);</span>
<span class="p_del">-		}</span>
<span class="p_del">-		spin_unlock_irq(&amp;slave_active_lock);</span>
<span class="p_del">-		mutex_lock(&amp;register_mutex);</span>
<span class="p_del">-		list_del(&amp;timeri-&gt;open_list);</span>
<span class="p_del">-		mutex_unlock(&amp;register_mutex);</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		timer = timeri-&gt;timer;</span>
<span class="p_del">-		if (snd_BUG_ON(!timer))</span>
<span class="p_del">-			goto out;</span>
<span class="p_add">+	timer = timeri-&gt;timer;</span>
<span class="p_add">+	if (timer) {</span>
<span class="p_add">+		timer-&gt;num_instances--;</span>
 		/* wait, until the active callback is finished */
 		spin_lock_irq(&amp;timer-&gt;lock);
 		while (timeri-&gt;flags &amp; SNDRV_TIMER_IFLG_CALLBACK) {
<span class="p_chunk">@@ -353,17 +366,14 @@</span> <span class="p_context"> int snd_timer_close(struct snd_timer_instance *timeri)</span>
 			spin_lock_irq(&amp;timer-&gt;lock);
 		}
 		spin_unlock_irq(&amp;timer-&gt;lock);
<span class="p_del">-		mutex_lock(&amp;register_mutex);</span>
<span class="p_del">-		list_del(&amp;timeri-&gt;open_list);</span>
<span class="p_del">-		if (list_empty(&amp;timer-&gt;open_list_head) &amp;&amp;</span>
<span class="p_del">-		    timer-&gt;hw.close)</span>
<span class="p_del">-			timer-&gt;hw.close(timer);</span>
<span class="p_add">+</span>
 		/* remove slave links */
 		spin_lock_irq(&amp;slave_active_lock);
 		spin_lock(&amp;timer-&gt;lock);
 		list_for_each_entry_safe(slave, tmp, &amp;timeri-&gt;slave_list_head,
 					 open_list) {
 			list_move_tail(&amp;slave-&gt;open_list, &amp;snd_timer_slave_list);
<span class="p_add">+			timer-&gt;num_instances--;</span>
 			slave-&gt;master = NULL;
 			slave-&gt;timer = NULL;
 			list_del_init(&amp;slave-&gt;ack_list);
<span class="p_chunk">@@ -371,18 +381,42 @@</span> <span class="p_context"> int snd_timer_close(struct snd_timer_instance *timeri)</span>
 		}
 		spin_unlock(&amp;timer-&gt;lock);
 		spin_unlock_irq(&amp;slave_active_lock);
<span class="p_del">-		mutex_unlock(&amp;register_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+		/* slave doesn&#39;t need to release timer resources below */</span>
<span class="p_add">+		if (timeri-&gt;flags &amp; SNDRV_TIMER_IFLG_SLAVE)</span>
<span class="p_add">+			timer = NULL;</span>
 	}
<span class="p_del">- out:</span>
<span class="p_add">+</span>
 	if (timeri-&gt;private_free)
 		timeri-&gt;private_free(timeri);
 	kfree(timeri-&gt;owner);
 	kfree(timeri);
<span class="p_del">-	if (timer)</span>
<span class="p_add">+</span>
<span class="p_add">+	if (timer) {</span>
<span class="p_add">+		if (list_empty(&amp;timer-&gt;open_list_head) &amp;&amp; timer-&gt;hw.close)</span>
<span class="p_add">+			timer-&gt;hw.close(timer);</span>
 		module_put(timer-&gt;module);
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * close a timer instance</span>
<span class="p_add">+ */</span>
<span class="p_add">+int snd_timer_close(struct snd_timer_instance *timeri)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (snd_BUG_ON(!timeri))</span>
<span class="p_add">+		return -ENXIO;</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;register_mutex);</span>
<span class="p_add">+	err = snd_timer_close_locked(timeri);</span>
<span class="p_add">+	mutex_unlock(&amp;register_mutex);</span>
<span class="p_add">+	return err;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 unsigned long snd_timer_resolution(struct snd_timer_instance *timeri)
 {
 	struct snd_timer * timer;
<span class="p_chunk">@@ -847,6 +881,7 @@</span> <span class="p_context"> int snd_timer_new(struct snd_card *card, char *id, struct snd_timer_id *tid,</span>
 	spin_lock_init(&amp;timer-&gt;lock);
 	tasklet_init(&amp;timer-&gt;task_queue, snd_timer_tasklet,
 		     (unsigned long)timer);
<span class="p_add">+	timer-&gt;max_instances = 1000; /* default limit per timer */</span>
 	if (card != NULL) {
 		timer-&gt;module = card-&gt;module;
 		err = snd_device_new(card, SNDRV_DEV_TIMER, timer, &amp;ops);
<span class="p_header">diff --git a/sound/core/timer_compat.c b/sound/core/timer_compat.c</span>
<span class="p_header">index 8e7eddf35c6a..bfd2b8dd3f8a 100644</span>
<span class="p_header">--- a/sound/core/timer_compat.c</span>
<span class="p_header">+++ b/sound/core/timer_compat.c</span>
<span class="p_chunk">@@ -97,7 +97,8 @@</span> <span class="p_context"> enum {</span>
 	SNDRV_TIMER_IOCTL_STATUS32 = _IOW(&#39;T&#39;, 0x14, struct snd_timer_status32),
 };
 
<span class="p_del">-static long snd_timer_user_ioctl_compat(struct file *file, unsigned int cmd, unsigned long arg)</span>
<span class="p_add">+static long __snd_timer_user_ioctl_compat(struct file *file, unsigned int cmd,</span>
<span class="p_add">+					  unsigned long arg)</span>
 {
 	void __user *argp = compat_ptr(arg);
 
<span class="p_chunk">@@ -118,7 +119,7 @@</span> <span class="p_context"> static long snd_timer_user_ioctl_compat(struct file *file, unsigned int cmd, uns</span>
 	case SNDRV_TIMER_IOCTL_PAUSE:
 	case SNDRV_TIMER_IOCTL_PAUSE_OLD:
 	case SNDRV_TIMER_IOCTL_NEXT_DEVICE:
<span class="p_del">-		return snd_timer_user_ioctl(file, cmd, (unsigned long)argp);</span>
<span class="p_add">+		return __snd_timer_user_ioctl(file, cmd, (unsigned long)argp);</span>
 	case SNDRV_TIMER_IOCTL_INFO32:
 		return snd_timer_user_info_compat(file, argp);
 	case SNDRV_TIMER_IOCTL_STATUS32:
<span class="p_chunk">@@ -126,3 +127,15 @@</span> <span class="p_context"> static long snd_timer_user_ioctl_compat(struct file *file, unsigned int cmd, uns</span>
 	}
 	return -ENOIOCTLCMD;
 }
<span class="p_add">+</span>
<span class="p_add">+static long snd_timer_user_ioctl_compat(struct file *file, unsigned int cmd,</span>
<span class="p_add">+					unsigned long arg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct snd_timer_user *tu = file-&gt;private_data;</span>
<span class="p_add">+	long ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;tu-&gt;ioctl_lock);</span>
<span class="p_add">+	ret = __snd_timer_user_ioctl_compat(file, cmd, arg);</span>
<span class="p_add">+	mutex_unlock(&amp;tu-&gt;ioctl_lock);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/sound/usb/caiaq/device.c b/sound/usb/caiaq/device.c</span>
<span class="p_header">index 88e3f8149e23..ce755a913137 100644</span>
<span class="p_header">--- a/sound/usb/caiaq/device.c</span>
<span class="p_header">+++ b/sound/usb/caiaq/device.c</span>
<span class="p_chunk">@@ -440,10 +440,12 @@</span> <span class="p_context"> static int __devinit init_card(struct snd_usb_caiaqdev *dev)</span>
 
 	err = snd_usb_caiaq_send_command(dev, EP1_CMD_GET_DEVICE_INFO, NULL, 0);
 	if (err)
<span class="p_del">-		return err;</span>
<span class="p_add">+		goto err_kill_urb;</span>
 
<span class="p_del">-	if (!wait_event_timeout(dev-&gt;ep1_wait_queue, dev-&gt;spec_received, HZ))</span>
<span class="p_del">-		return -ENODEV;</span>
<span class="p_add">+	if (!wait_event_timeout(dev-&gt;ep1_wait_queue, dev-&gt;spec_received, HZ)) {</span>
<span class="p_add">+		err = -ENODEV;</span>
<span class="p_add">+		goto err_kill_urb;</span>
<span class="p_add">+	}</span>
 
 	usb_string(usb_dev, usb_dev-&gt;descriptor.iManufacturer,
 		   dev-&gt;vendor_name, CAIAQ_USB_STR_LEN);
<span class="p_chunk">@@ -479,6 +481,10 @@</span> <span class="p_context"> static int __devinit init_card(struct snd_usb_caiaqdev *dev)</span>
 
 	setup_card(dev);
 	return 0;
<span class="p_add">+</span>
<span class="p_add">+ err_kill_urb:</span>
<span class="p_add">+	usb_kill_urb(&amp;dev-&gt;ep1_in_urb);</span>
<span class="p_add">+	return err;</span>
 }
 
 static int __devinit snd_probe(struct usb_interface *intf,
<span class="p_header">diff --git a/sound/usb/usx2y/usb_stream.c b/sound/usb/usx2y/usb_stream.c</span>
<span class="p_header">index 1e7a47a86605..ab7e14fe6fd9 100644</span>
<span class="p_header">--- a/sound/usb/usx2y/usb_stream.c</span>
<span class="p_header">+++ b/sound/usb/usx2y/usb_stream.c</span>
<span class="p_chunk">@@ -192,7 +192,8 @@</span> <span class="p_context"> struct usb_stream *usb_stream_new(struct usb_stream_kernel *sk,</span>
 	}
 
 	pg = get_order(read_size);
<span class="p_del">-	sk-&gt;s = (void *) __get_free_pages(GFP_KERNEL|__GFP_COMP|__GFP_ZERO, pg);</span>
<span class="p_add">+	sk-&gt;s = (void *) __get_free_pages(GFP_KERNEL|__GFP_COMP|__GFP_ZERO|</span>
<span class="p_add">+					  __GFP_NOWARN, pg);</span>
 	if (!sk-&gt;s) {
 		snd_printk(KERN_WARNING &quot;couldn&#39;t __get_free_pages()\n&quot;);
 		goto out;
<span class="p_chunk">@@ -212,7 +213,8 @@</span> <span class="p_context"> struct usb_stream *usb_stream_new(struct usb_stream_kernel *sk,</span>
 	pg = get_order(write_size);
 
 	sk-&gt;write_page =
<span class="p_del">-		(void *)__get_free_pages(GFP_KERNEL|__GFP_COMP|__GFP_ZERO, pg);</span>
<span class="p_add">+		(void *)__get_free_pages(GFP_KERNEL|__GFP_COMP|__GFP_ZERO|</span>
<span class="p_add">+					 __GFP_NOWARN, pg);</span>
 	if (!sk-&gt;write_page) {
 		snd_printk(KERN_WARNING &quot;couldn&#39;t __get_free_pages()\n&quot;);
 		usb_stream_free(sk);

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



