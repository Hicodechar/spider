
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[4.2.y-ckt,stable] Linux 4.2.8-ckt2 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [4.2.y-ckt,stable] Linux 4.2.8-ckt2</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=7718">Kamal Mostafa</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Jan. 20, 2016, 8:48 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1453322938-29619-2-git-send-email-kamal@canonical.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/8074211/mbox/"
   >mbox</a>
|
   <a href="/patch/8074211/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/8074211/">/patch/8074211/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork1.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork1.web.kernel.org (Postfix) with ESMTP id 9BFA29F440
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 20 Jan 2016 20:50:13 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id A36B62054E
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 20 Jan 2016 20:49:55 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id EC65E2055D
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 20 Jan 2016 20:49:36 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1758329AbcATUtc (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Wed, 20 Jan 2016 15:49:32 -0500
Received: from youngberry.canonical.com ([91.189.89.112]:38243 &quot;EHLO
	youngberry.canonical.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1754412AbcATUtI (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Wed, 20 Jan 2016 15:49:08 -0500
Received: from 1.general.kamal.us.vpn ([10.172.68.52] helo=fourier)
	by youngberry.canonical.com with esmtpsa
	(TLS1.0:DHE_RSA_AES_128_CBC_SHA1:16) (Exim 4.76)
	(envelope-from &lt;kamal@canonical.com&gt;)
	id 1aLzgd-0006w7-6J; Wed, 20 Jan 2016 20:49:04 +0000
Received: from kamal by fourier with local (Exim 4.82)
	(envelope-from &lt;kamal@whence.com&gt;)
	id 1aLzga-0007ib-D9; Wed, 20 Jan 2016 12:49:00 -0800
From: Kamal Mostafa &lt;kamal@canonical.com&gt;
To: linux-kernel@vger.kernel.org, stable@vger.kernel.org,
	kernel-team@lists.ubuntu.com
Cc: lwn@lwn.net
Subject: Re: [4.2.y-ckt stable] Linux 4.2.8-ckt2
Date: Wed, 20 Jan 2016 12:48:58 -0800
Message-Id: &lt;1453322938-29619-2-git-send-email-kamal@canonical.com&gt;
X-Mailer: git-send-email 1.9.1
In-Reply-To: &lt;1453322938-29619-1-git-send-email-kamal@canonical.com&gt;
References: &lt;1453322938-29619-1-git-send-email-kamal@canonical.com&gt;
X-Extended-Stable: 4.2
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-6.9 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7718">Kamal Mostafa</a> - Jan. 20, 2016, 8:48 p.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index f442df4..16da77c 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,7 +1,7 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 2
 SUBLEVEL = 8
<span class="p_del">-EXTRAVERSION = -ckt1</span>
<span class="p_add">+EXTRAVERSION = -ckt2</span>
 NAME = Hare&#39;s hurried rump
 
 # *DOCUMENTATION*
<span class="p_header">diff --git a/arch/arc/include/asm/unwind.h b/arch/arc/include/asm/unwind.h</span>
<span class="p_header">index 7ca628b..c11a25b 100644</span>
<span class="p_header">--- a/arch/arc/include/asm/unwind.h</span>
<span class="p_header">+++ b/arch/arc/include/asm/unwind.h</span>
<span class="p_chunk">@@ -112,7 +112,6 @@</span> <span class="p_context"> struct unwind_frame_info {</span>
 
 extern int arc_unwind(struct unwind_frame_info *frame);
 extern void arc_unwind_init(void);
<span class="p_del">-extern void arc_unwind_setup(void);</span>
 extern void *unwind_add_table(struct module *module, const void *table_start,
 			      unsigned long table_size);
 extern void unwind_remove_table(void *handle, int init_only);
<span class="p_chunk">@@ -152,9 +151,6 @@</span> <span class="p_context"> static inline void arc_unwind_init(void)</span>
 {
 }
 
<span class="p_del">-static inline void arc_unwind_setup(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-}</span>
 #define unwind_add_table(a, b, c)
 #define unwind_remove_table(a, b)
 
<span class="p_header">diff --git a/arch/arc/kernel/intc-arcv2.c b/arch/arc/kernel/intc-arcv2.c</span>
<span class="p_header">index 26c1568..0394f9f 100644</span>
<span class="p_header">--- a/arch/arc/kernel/intc-arcv2.c</span>
<span class="p_header">+++ b/arch/arc/kernel/intc-arcv2.c</span>
<span class="p_chunk">@@ -106,10 +106,21 @@</span> <span class="p_context"> static struct irq_chip arcv2_irq_chip = {</span>
 static int arcv2_irq_map(struct irq_domain *d, unsigned int irq,
 			 irq_hw_number_t hw)
 {
<span class="p_del">-	if (irq == TIMER0_IRQ || irq == IPI_IRQ)</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * core intc IRQs [16, 23]:</span>
<span class="p_add">+	 * Statically assigned always private-per-core (Timers, WDT, IPI, PCT)</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (hw &lt; 24) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * A subsequent request_percpu_irq() fails if percpu_devid is</span>
<span class="p_add">+		 * not set. That in turns sets NOAUTOEN, meaning each core needs</span>
<span class="p_add">+		 * to call enable_percpu_irq()</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		irq_set_percpu_devid(irq);</span>
 		irq_set_chip_and_handler(irq, &amp;arcv2_irq_chip, handle_percpu_irq);
<span class="p_del">-	else</span>
<span class="p_add">+	} else {</span>
 		irq_set_chip_and_handler(irq, &amp;arcv2_irq_chip, handle_level_irq);
<span class="p_add">+	}</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/arch/arc/kernel/setup.c b/arch/arc/kernel/setup.c</span>
<span class="p_header">index cabde9d..4940732 100644</span>
<span class="p_header">--- a/arch/arc/kernel/setup.c</span>
<span class="p_header">+++ b/arch/arc/kernel/setup.c</span>
<span class="p_chunk">@@ -432,7 +432,6 @@</span> <span class="p_context"> void __init setup_arch(char **cmdline_p)</span>
 #endif
 
 	arc_unwind_init();
<span class="p_del">-	arc_unwind_setup();</span>
 }
 
 static int __init customize_machine(void)
<span class="p_header">diff --git a/arch/arc/kernel/unwind.c b/arch/arc/kernel/unwind.c</span>
<span class="p_header">index 93c6ea5..cf2828a 100644</span>
<span class="p_header">--- a/arch/arc/kernel/unwind.c</span>
<span class="p_header">+++ b/arch/arc/kernel/unwind.c</span>
<span class="p_chunk">@@ -170,6 +170,23 @@</span> <span class="p_context"> static struct unwind_table *find_table(unsigned long pc)</span>
 
 static unsigned long read_pointer(const u8 **pLoc,
 				  const void *end, signed ptrType);
<span class="p_add">+static void init_unwind_hdr(struct unwind_table *table,</span>
<span class="p_add">+			    void *(*alloc) (unsigned long));</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * wrappers for header alloc (vs. calling one vs. other at call site)</span>
<span class="p_add">+ * to elide section mismatches warnings</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void *__init unw_hdr_alloc_early(unsigned long sz)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return __alloc_bootmem_nopanic(sz, sizeof(unsigned int),</span>
<span class="p_add">+				       MAX_DMA_ADDRESS);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void *unw_hdr_alloc(unsigned long sz)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return kmalloc(sz, GFP_KERNEL);</span>
<span class="p_add">+}</span>
 
 static void init_unwind_table(struct unwind_table *table, const char *name,
 			      const void *core_start, unsigned long core_size,
<span class="p_chunk">@@ -209,6 +226,8 @@</span> <span class="p_context"> void __init arc_unwind_init(void)</span>
 			  __start_unwind, __end_unwind - __start_unwind,
 			  NULL, 0);
 	  /*__start_unwind_hdr, __end_unwind_hdr - __start_unwind_hdr);*/
<span class="p_add">+</span>
<span class="p_add">+	init_unwind_hdr(&amp;root_table, unw_hdr_alloc_early);</span>
 }
 
 static const u32 bad_cie, not_fde;
<span class="p_chunk">@@ -241,8 +260,8 @@</span> <span class="p_context"> static void swap_eh_frame_hdr_table_entries(void *p1, void *p2, int size)</span>
 	e2-&gt;fde = v;
 }
 
<span class="p_del">-static void __init setup_unwind_table(struct unwind_table *table,</span>
<span class="p_del">-				      void *(*alloc) (unsigned long))</span>
<span class="p_add">+static void init_unwind_hdr(struct unwind_table *table,</span>
<span class="p_add">+			    void *(*alloc) (unsigned long))</span>
 {
 	const u8 *ptr;
 	unsigned long tableSize = table-&gt;size, hdrSize;
<span class="p_chunk">@@ -274,13 +293,13 @@</span> <span class="p_context"> static void __init setup_unwind_table(struct unwind_table *table,</span>
 		const u32 *cie = cie_for_fde(fde, table);
 		signed ptrType;
 
<span class="p_del">-		if (cie == &amp;not_fde)</span>
<span class="p_add">+		if (cie == &amp;not_fde)	/* only process FDE here */</span>
 			continue;
 		if (cie == NULL || cie == &amp;bad_cie)
<span class="p_del">-			return;</span>
<span class="p_add">+			continue;	/* say FDE-&gt;CIE.version != 1 */</span>
 		ptrType = fde_pointer_type(cie);
 		if (ptrType &lt; 0)
<span class="p_del">-			return;</span>
<span class="p_add">+			continue;</span>
 
 		ptr = (const u8 *)(fde + 2);
 		if (!read_pointer(&amp;ptr, (const u8 *)(fde + 1) + *fde,
<span class="p_chunk">@@ -300,9 +319,11 @@</span> <span class="p_context"> static void __init setup_unwind_table(struct unwind_table *table,</span>
 
 	hdrSize = 4 + sizeof(unsigned long) + sizeof(unsigned int)
 	    + 2 * n * sizeof(unsigned long);
<span class="p_add">+</span>
 	header = alloc(hdrSize);
 	if (!header)
 		return;
<span class="p_add">+</span>
 	header-&gt;version = 1;
 	header-&gt;eh_frame_ptr_enc = DW_EH_PE_abs | DW_EH_PE_native;
 	header-&gt;fde_count_enc = DW_EH_PE_abs | DW_EH_PE_data4;
<span class="p_chunk">@@ -322,6 +343,10 @@</span> <span class="p_context"> static void __init setup_unwind_table(struct unwind_table *table,</span>
 
 		if (fde[1] == 0xffffffff)
 			continue;	/* this is a CIE */
<span class="p_add">+</span>
<span class="p_add">+		if (*(u8 *)(cie + 2) != 1)</span>
<span class="p_add">+			continue;	/* FDE-&gt;CIE.version not supported */</span>
<span class="p_add">+</span>
 		ptr = (const u8 *)(fde + 2);
 		header-&gt;table[n].start = read_pointer(&amp;ptr,
 						      (const u8 *)(fde + 1) +
<span class="p_chunk">@@ -342,18 +367,6 @@</span> <span class="p_context"> static void __init setup_unwind_table(struct unwind_table *table,</span>
 	table-&gt;header = (const void *)header;
 }
 
<span class="p_del">-static void *__init balloc(unsigned long sz)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return __alloc_bootmem_nopanic(sz,</span>
<span class="p_del">-				       sizeof(unsigned int),</span>
<span class="p_del">-				       __pa(MAX_DMA_ADDRESS));</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void __init arc_unwind_setup(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	setup_unwind_table(&amp;root_table, balloc);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 #ifdef CONFIG_MODULES
 
 static struct unwind_table *last_table;
<span class="p_chunk">@@ -377,6 +390,8 @@</span> <span class="p_context"> void *unwind_add_table(struct module *module, const void *table_start,</span>
 			  table_start, table_size,
 			  NULL, 0);
 
<span class="p_add">+	init_unwind_hdr(table, unw_hdr_alloc);</span>
<span class="p_add">+</span>
 #ifdef UNWIND_DEBUG
 	unw_debug(&quot;Table added for [%s] %lx %lx\n&quot;,
 		module-&gt;name, table-&gt;core.pc, table-&gt;core.range);
<span class="p_chunk">@@ -439,6 +454,7 @@</span> <span class="p_context"> void unwind_remove_table(void *handle, int init_only)</span>
 	info.init_only = init_only;
 
 	unlink_table(&amp;info); /* XXX: SMP */
<span class="p_add">+	kfree(table-&gt;header);</span>
 	kfree(table);
 }
 
<span class="p_chunk">@@ -507,7 +523,8 @@</span> <span class="p_context"> static const u32 *cie_for_fde(const u32 *fde, const struct unwind_table *table)</span>
 
 	if (*cie &lt;= sizeof(*cie) + 4 || *cie &gt;= fde[1] - sizeof(*fde)
 	    || (*cie &amp; (sizeof(*cie) - 1))
<span class="p_del">-	    || (cie[1] != 0xffffffff))</span>
<span class="p_add">+	    || (cie[1] != 0xffffffff)</span>
<span class="p_add">+	    || ( *(u8 *)(cie + 2) != 1))   /* version 1 supported */</span>
 		return NULL;	/* this is not a (valid) CIE */
 	return cie;
 }
<span class="p_chunk">@@ -986,42 +1003,13 @@</span> <span class="p_context"> int arc_unwind(struct unwind_frame_info *frame)</span>
 							    (const u8 *)(fde +
 									 1) +
 							    *fde, ptrType);
<span class="p_del">-				if (pc &gt;= endLoc)</span>
<span class="p_add">+				if (pc &gt;= endLoc) {</span>
 					fde = NULL;
<span class="p_del">-			} else</span>
<span class="p_del">-				fde = NULL;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		if (fde == NULL) {</span>
<span class="p_del">-			for (fde = table-&gt;address, tableSize = table-&gt;size;</span>
<span class="p_del">-			     cie = NULL, tableSize &gt; sizeof(*fde)</span>
<span class="p_del">-			     &amp;&amp; tableSize - sizeof(*fde) &gt;= *fde;</span>
<span class="p_del">-			     tableSize -= sizeof(*fde) + *fde,</span>
<span class="p_del">-			     fde += 1 + *fde / sizeof(*fde)) {</span>
<span class="p_del">-				cie = cie_for_fde(fde, table);</span>
<span class="p_del">-				if (cie == &amp;bad_cie) {</span>
 					cie = NULL;
<span class="p_del">-					break;</span>
 				}
<span class="p_del">-				if (cie == NULL</span>
<span class="p_del">-				    || cie == &amp;not_fde</span>
<span class="p_del">-				    || (ptrType = fde_pointer_type(cie)) &lt; 0)</span>
<span class="p_del">-					continue;</span>
<span class="p_del">-				ptr = (const u8 *)(fde + 2);</span>
<span class="p_del">-				startLoc = read_pointer(&amp;ptr,</span>
<span class="p_del">-							(const u8 *)(fde + 1) +</span>
<span class="p_del">-							*fde, ptrType);</span>
<span class="p_del">-				if (!startLoc)</span>
<span class="p_del">-					continue;</span>
<span class="p_del">-				if (!(ptrType &amp; DW_EH_PE_indirect))</span>
<span class="p_del">-					ptrType &amp;=</span>
<span class="p_del">-					    DW_EH_PE_FORM | DW_EH_PE_signed;</span>
<span class="p_del">-				endLoc =</span>
<span class="p_del">-				    startLoc + read_pointer(&amp;ptr,</span>
<span class="p_del">-							    (const u8 *)(fde +</span>
<span class="p_del">-									 1) +</span>
<span class="p_del">-							    *fde, ptrType);</span>
<span class="p_del">-				if (pc &gt;= startLoc &amp;&amp; pc &lt; endLoc)</span>
<span class="p_del">-					break;</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				fde = NULL;</span>
<span class="p_add">+				cie = NULL;</span>
 			}
 		}
 	}
<span class="p_header">diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig</span>
<span class="p_header">index ede2526..9b063d8 100644</span>
<span class="p_header">--- a/arch/arm/Kconfig</span>
<span class="p_header">+++ b/arch/arm/Kconfig</span>
<span class="p_chunk">@@ -76,6 +76,8 @@</span> <span class="p_context"> config ARM</span>
 	select IRQ_FORCED_THREADING
 	select MODULES_USE_ELF_REL
 	select NO_BOOTMEM
<span class="p_add">+	select OF_EARLY_FLATTREE if OF</span>
<span class="p_add">+	select OF_RESERVED_MEM if OF</span>
 	select OLD_SIGACTION
 	select OLD_SIGSUSPEND3
 	select PERF_USE_VMALLOC
<span class="p_chunk">@@ -1828,8 +1830,6 @@</span> <span class="p_context"> config USE_OF</span>
 	bool &quot;Flattened Device Tree support&quot;
 	select IRQ_DOMAIN
 	select OF
<span class="p_del">-	select OF_EARLY_FLATTREE</span>
<span class="p_del">-	select OF_RESERVED_MEM</span>
 	help
 	  Include support for flattened device tree machine descriptions.
 
<span class="p_header">diff --git a/arch/arm/boot/dts/imx6q-gw5400-a.dts b/arch/arm/boot/dts/imx6q-gw5400-a.dts</span>
<span class="p_header">index 822ffb2..6c168dc 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx6q-gw5400-a.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx6q-gw5400-a.dts</span>
<span class="p_chunk">@@ -154,7 +154,7 @@</span> <span class="p_context"></span>
 &amp;fec {
 	pinctrl-names = &quot;default&quot;;
 	pinctrl-0 = &lt;&amp;pinctrl_enet&gt;;
<span class="p_del">-	phy-mode = &quot;rgmii&quot;;</span>
<span class="p_add">+	phy-mode = &quot;rgmii-id&quot;;</span>
 	phy-reset-gpios = &lt;&amp;gpio1 30 GPIO_ACTIVE_HIGH&gt;;
 	status = &quot;okay&quot;;
 };
<span class="p_header">diff --git a/arch/arm/boot/dts/imx6qdl-gw51xx.dtsi b/arch/arm/boot/dts/imx6qdl-gw51xx.dtsi</span>
<span class="p_header">index f2867c4..90496aa 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx6qdl-gw51xx.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx6qdl-gw51xx.dtsi</span>
<span class="p_chunk">@@ -94,7 +94,7 @@</span> <span class="p_context"></span>
 &amp;fec {
 	pinctrl-names = &quot;default&quot;;
 	pinctrl-0 = &lt;&amp;pinctrl_enet&gt;;
<span class="p_del">-	phy-mode = &quot;rgmii&quot;;</span>
<span class="p_add">+	phy-mode = &quot;rgmii-id&quot;;</span>
 	phy-reset-gpios = &lt;&amp;gpio1 30 GPIO_ACTIVE_LOW&gt;;
 	status = &quot;okay&quot;;
 };
<span class="p_header">diff --git a/arch/arm/boot/dts/imx6qdl-gw52xx.dtsi b/arch/arm/boot/dts/imx6qdl-gw52xx.dtsi</span>
<span class="p_header">index 4493f6e..0a6730b 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx6qdl-gw52xx.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx6qdl-gw52xx.dtsi</span>
<span class="p_chunk">@@ -154,7 +154,7 @@</span> <span class="p_context"></span>
 &amp;fec {
 	pinctrl-names = &quot;default&quot;;
 	pinctrl-0 = &lt;&amp;pinctrl_enet&gt;;
<span class="p_del">-	phy-mode = &quot;rgmii&quot;;</span>
<span class="p_add">+	phy-mode = &quot;rgmii-id&quot;;</span>
 	phy-reset-gpios = &lt;&amp;gpio1 30 GPIO_ACTIVE_LOW&gt;;
 	status = &quot;okay&quot;;
 };
<span class="p_header">diff --git a/arch/arm/boot/dts/imx6qdl-gw53xx.dtsi b/arch/arm/boot/dts/imx6qdl-gw53xx.dtsi</span>
<span class="p_header">index a857d12..c49183a 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx6qdl-gw53xx.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx6qdl-gw53xx.dtsi</span>
<span class="p_chunk">@@ -155,7 +155,7 @@</span> <span class="p_context"></span>
 &amp;fec {
 	pinctrl-names = &quot;default&quot;;
 	pinctrl-0 = &lt;&amp;pinctrl_enet&gt;;
<span class="p_del">-	phy-mode = &quot;rgmii&quot;;</span>
<span class="p_add">+	phy-mode = &quot;rgmii-id&quot;;</span>
 	phy-reset-gpios = &lt;&amp;gpio1 30 GPIO_ACTIVE_LOW&gt;;
 	status = &quot;okay&quot;;
 };
<span class="p_header">diff --git a/arch/arm/boot/dts/imx6qdl-gw54xx.dtsi b/arch/arm/boot/dts/imx6qdl-gw54xx.dtsi</span>
<span class="p_header">index 1afe338..0631f9f 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx6qdl-gw54xx.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx6qdl-gw54xx.dtsi</span>
<span class="p_chunk">@@ -145,7 +145,7 @@</span> <span class="p_context"></span>
 &amp;fec {
 	pinctrl-names = &quot;default&quot;;
 	pinctrl-0 = &lt;&amp;pinctrl_enet&gt;;
<span class="p_del">-	phy-mode = &quot;rgmii&quot;;</span>
<span class="p_add">+	phy-mode = &quot;rgmii-id&quot;;</span>
 	phy-reset-gpios = &lt;&amp;gpio1 30 GPIO_ACTIVE_LOW&gt;;
 	status = &quot;okay&quot;;
 };
<span class="p_header">diff --git a/arch/arm/boot/dts/kirkwood-ts219.dtsi b/arch/arm/boot/dts/kirkwood-ts219.dtsi</span>
<span class="p_header">index c56ab6b..0e46560 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/kirkwood-ts219.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/kirkwood-ts219.dtsi</span>
<span class="p_chunk">@@ -40,7 +40,7 @@</span> <span class="p_context"></span>
 		};
 		poweroff@12100 {
 			compatible = &quot;qnap,power-off&quot;;
<span class="p_del">-			reg = &lt;0x12000 0x100&gt;;</span>
<span class="p_add">+			reg = &lt;0x12100 0x100&gt;;</span>
 			clocks = &lt;&amp;gate_clk 7&gt;;
 		};
 		spi@10600 {
<span class="p_header">diff --git a/arch/arm/boot/dts/versatile-ab.dts b/arch/arm/boot/dts/versatile-ab.dts</span>
<span class="p_header">index 01f4019..3279bf1 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/versatile-ab.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/versatile-ab.dts</span>
<span class="p_chunk">@@ -110,7 +110,11 @@</span> <span class="p_context"></span>
 			interrupt-parent = &lt;&amp;vic&gt;;
 			interrupts = &lt;31&gt;; /* Cascaded to vic */
 			clear-mask = &lt;0xffffffff&gt;;
<span class="p_del">-			valid-mask = &lt;0xffc203f8&gt;;</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Valid interrupt lines mask according to</span>
<span class="p_add">+			 * table 4-36 page 4-50 of ARM DUI 0225D</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			valid-mask = &lt;0x0760031b&gt;;</span>
 		};
 
 		dma@10130000 {
<span class="p_chunk">@@ -266,8 +270,8 @@</span> <span class="p_context"></span>
 			};
 			mmc@5000 {
 				compatible = &quot;arm,pl180&quot;, &quot;arm,primecell&quot;;
<span class="p_del">-				reg = &lt; 0x5000 0x1000&gt;;</span>
<span class="p_del">-				interrupts-extended = &lt;&amp;vic 22 &amp;sic 2&gt;;</span>
<span class="p_add">+				reg = &lt;0x5000 0x1000&gt;;</span>
<span class="p_add">+				interrupts-extended = &lt;&amp;vic 22 &amp;sic 1&gt;;</span>
 				clocks = &lt;&amp;xtal24mhz&gt;, &lt;&amp;pclk&gt;;
 				clock-names = &quot;mclk&quot;, &quot;apb_pclk&quot;;
 			};
<span class="p_header">diff --git a/arch/arm/boot/dts/versatile-pb.dts b/arch/arm/boot/dts/versatile-pb.dts</span>
<span class="p_header">index b83137f..33a8eb2 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/versatile-pb.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/versatile-pb.dts</span>
<span class="p_chunk">@@ -5,6 +5,16 @@</span> <span class="p_context"></span>
 	compatible = &quot;arm,versatile-pb&quot;;
 
 	amba {
<span class="p_add">+		/* The Versatile PB is using more SIC IRQ lines than the AB */</span>
<span class="p_add">+		sic: intc@10003000 {</span>
<span class="p_add">+			clear-mask = &lt;0xffffffff&gt;;</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Valid interrupt lines mask according to</span>
<span class="p_add">+			 * figure 3-30 page 3-74 of ARM DUI 0224B</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			valid-mask = &lt;0x7fe003ff&gt;;</span>
<span class="p_add">+		};</span>
<span class="p_add">+</span>
 		gpio2: gpio@101e6000 {
 			compatible = &quot;arm,pl061&quot;, &quot;arm,primecell&quot;;
 			reg = &lt;0x101e6000 0x1000&gt;;
<span class="p_chunk">@@ -67,6 +77,13 @@</span> <span class="p_context"></span>
 		};
 
 		fpga {
<span class="p_add">+			mmc@5000 {</span>
<span class="p_add">+				/*</span>
<span class="p_add">+				 * Overrides the interrupt assignment from</span>
<span class="p_add">+				 * the Versatile AB board file.</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				interrupts-extended = &lt;&amp;sic 22 &amp;sic 23&gt;;</span>
<span class="p_add">+			};</span>
 			uart@9000 {
 				compatible = &quot;arm,pl011&quot;, &quot;arm,primecell&quot;;
 				reg = &lt;0x9000 0x1000&gt;;
<span class="p_chunk">@@ -86,7 +103,8 @@</span> <span class="p_context"></span>
 			mmc@b000 {
 				compatible = &quot;arm,pl180&quot;, &quot;arm,primecell&quot;;
 				reg = &lt;0xb000 0x1000&gt;;
<span class="p_del">-				interrupts-extended = &lt;&amp;vic 23 &amp;sic 2&gt;;</span>
<span class="p_add">+				interrupt-parent = &lt;&amp;sic&gt;;</span>
<span class="p_add">+				interrupts = &lt;1&gt;, &lt;2&gt;;</span>
 				clocks = &lt;&amp;xtal24mhz&gt;, &lt;&amp;pclk&gt;;
 				clock-names = &quot;mclk&quot;, &quot;apb_pclk&quot;;
 			};
<span class="p_header">diff --git a/arch/arm/boot/dts/vf610-colibri.dtsi b/arch/arm/boot/dts/vf610-colibri.dtsi</span>
<span class="p_header">index 19fe045..2d7eab7 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/vf610-colibri.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/vf610-colibri.dtsi</span>
<span class="p_chunk">@@ -18,8 +18,3 @@</span> <span class="p_context"></span>
 		reg = &lt;0x80000000 0x10000000&gt;;
 	};
 };
<span class="p_del">-</span>
<span class="p_del">-&amp;L2 {</span>
<span class="p_del">-	arm,data-latency = &lt;2 1 2&gt;;</span>
<span class="p_del">-	arm,tag-latency = &lt;3 2 3&gt;;</span>
<span class="p_del">-};</span>
<span class="p_header">diff --git a/arch/arm/boot/dts/vf610.dtsi b/arch/arm/boot/dts/vf610.dtsi</span>
<span class="p_header">index 5f8eb1b..58bc6e4 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/vf610.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/vf610.dtsi</span>
<span class="p_chunk">@@ -19,7 +19,7 @@</span> <span class="p_context"></span>
 		reg = &lt;0x40006000 0x1000&gt;;
 		cache-unified;
 		cache-level = &lt;2&gt;;
<span class="p_del">-		arm,data-latency = &lt;1 1 1&gt;;</span>
<span class="p_add">+		arm,data-latency = &lt;3 3 3&gt;;</span>
 		arm,tag-latency = &lt;2 2 2&gt;;
 	};
 };
<span class="p_header">diff --git a/arch/arm/boot/dts/vfxxx.dtsi b/arch/arm/boot/dts/vfxxx.dtsi</span>
<span class="p_header">index 4aa3351..a646cb9 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/vfxxx.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/vfxxx.dtsi</span>
<span class="p_chunk">@@ -158,7 +158,7 @@</span> <span class="p_context"></span>
 				interrupts = &lt;67 IRQ_TYPE_LEVEL_HIGH&gt;;
 				clocks = &lt;&amp;clks VF610_CLK_DSPI0&gt;;
 				clock-names = &quot;dspi&quot;;
<span class="p_del">-				spi-num-chipselects = &lt;5&gt;;</span>
<span class="p_add">+				spi-num-chipselects = &lt;6&gt;;</span>
 				status = &quot;disabled&quot;;
 			};
 
<span class="p_chunk">@@ -170,7 +170,7 @@</span> <span class="p_context"></span>
 				interrupts = &lt;68 IRQ_TYPE_LEVEL_HIGH&gt;;
 				clocks = &lt;&amp;clks VF610_CLK_DSPI1&gt;;
 				clock-names = &quot;dspi&quot;;
<span class="p_del">-				spi-num-chipselects = &lt;5&gt;;</span>
<span class="p_add">+				spi-num-chipselects = &lt;4&gt;;</span>
 				status = &quot;disabled&quot;;
 			};
 
<span class="p_header">diff --git a/arch/arm/boot/dts/wm8650.dtsi b/arch/arm/boot/dts/wm8650.dtsi</span>
<span class="p_header">index b1c59a7..e12213d 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/wm8650.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/wm8650.dtsi</span>
<span class="p_chunk">@@ -187,6 +187,15 @@</span> <span class="p_context"></span>
 			interrupts = &lt;43&gt;;
 		};
 
<span class="p_add">+		sdhc@d800a000 {</span>
<span class="p_add">+			compatible = &quot;wm,wm8505-sdhc&quot;;</span>
<span class="p_add">+			reg = &lt;0xd800a000 0x400&gt;;</span>
<span class="p_add">+			interrupts = &lt;20&gt;, &lt;21&gt;;</span>
<span class="p_add">+			clocks = &lt;&amp;clksdhc&gt;;</span>
<span class="p_add">+			bus-width = &lt;4&gt;;</span>
<span class="p_add">+			sdon-inverted;</span>
<span class="p_add">+		};</span>
<span class="p_add">+</span>
 		fb: fb@d8050800 {
 			compatible = &quot;wm,wm8505-fb&quot;;
 			reg = &lt;0xd8050800 0x200&gt;;
<span class="p_header">diff --git a/arch/arm/kernel/sys_oabi-compat.c b/arch/arm/kernel/sys_oabi-compat.c</span>
<span class="p_header">index b83f3b7..087acb5 100644</span>
<span class="p_header">--- a/arch/arm/kernel/sys_oabi-compat.c</span>
<span class="p_header">+++ b/arch/arm/kernel/sys_oabi-compat.c</span>
<span class="p_chunk">@@ -193,15 +193,44 @@</span> <span class="p_context"> struct oabi_flock64 {</span>
 	pid_t	l_pid;
 } __attribute__ ((packed,aligned(4)));
 
<span class="p_del">-asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,</span>
<span class="p_add">+static long do_locks(unsigned int fd, unsigned int cmd,</span>
 				 unsigned long arg)
 {
<span class="p_del">-	struct oabi_flock64 user;</span>
 	struct flock64 kernel;
<span class="p_del">-	mm_segment_t fs = USER_DS; /* initialized to kill a warning */</span>
<span class="p_del">-	unsigned long local_arg = arg;</span>
<span class="p_del">-	int ret;</span>
<span class="p_add">+	struct oabi_flock64 user;</span>
<span class="p_add">+	mm_segment_t fs;</span>
<span class="p_add">+	long ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (copy_from_user(&amp;user, (struct oabi_flock64 __user *)arg,</span>
<span class="p_add">+			   sizeof(user)))</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+	kernel.l_type	= user.l_type;</span>
<span class="p_add">+	kernel.l_whence	= user.l_whence;</span>
<span class="p_add">+	kernel.l_start	= user.l_start;</span>
<span class="p_add">+	kernel.l_len	= user.l_len;</span>
<span class="p_add">+	kernel.l_pid	= user.l_pid;</span>
<span class="p_add">+</span>
<span class="p_add">+	fs = get_fs();</span>
<span class="p_add">+	set_fs(KERNEL_DS);</span>
<span class="p_add">+	ret = sys_fcntl64(fd, cmd, (unsigned long)&amp;kernel);</span>
<span class="p_add">+	set_fs(fs);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!ret &amp;&amp; (cmd == F_GETLK64 || cmd == F_OFD_GETLK)) {</span>
<span class="p_add">+		user.l_type	= kernel.l_type;</span>
<span class="p_add">+		user.l_whence	= kernel.l_whence;</span>
<span class="p_add">+		user.l_start	= kernel.l_start;</span>
<span class="p_add">+		user.l_len	= kernel.l_len;</span>
<span class="p_add">+		user.l_pid	= kernel.l_pid;</span>
<span class="p_add">+		if (copy_to_user((struct oabi_flock64 __user *)arg,</span>
<span class="p_add">+				 &amp;user, sizeof(user)))</span>
<span class="p_add">+			ret = -EFAULT;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
 
<span class="p_add">+asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,</span>
<span class="p_add">+				 unsigned long arg)</span>
<span class="p_add">+{</span>
 	switch (cmd) {
 	case F_OFD_GETLK:
 	case F_OFD_SETLK:
<span class="p_chunk">@@ -209,39 +238,11 @@</span> <span class="p_context"> asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,</span>
 	case F_GETLK64:
 	case F_SETLK64:
 	case F_SETLKW64:
<span class="p_del">-		if (copy_from_user(&amp;user, (struct oabi_flock64 __user *)arg,</span>
<span class="p_del">-				   sizeof(user)))</span>
<span class="p_del">-			return -EFAULT;</span>
<span class="p_del">-		kernel.l_type	= user.l_type;</span>
<span class="p_del">-		kernel.l_whence	= user.l_whence;</span>
<span class="p_del">-		kernel.l_start	= user.l_start;</span>
<span class="p_del">-		kernel.l_len	= user.l_len;</span>
<span class="p_del">-		kernel.l_pid	= user.l_pid;</span>
<span class="p_del">-		local_arg = (unsigned long)&amp;kernel;</span>
<span class="p_del">-		fs = get_fs();</span>
<span class="p_del">-		set_fs(KERNEL_DS);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = sys_fcntl64(fd, cmd, local_arg);</span>
<span class="p_add">+		return do_locks(fd, cmd, arg);</span>
 
<span class="p_del">-	switch (cmd) {</span>
<span class="p_del">-	case F_GETLK64:</span>
<span class="p_del">-		if (!ret) {</span>
<span class="p_del">-			user.l_type	= kernel.l_type;</span>
<span class="p_del">-			user.l_whence	= kernel.l_whence;</span>
<span class="p_del">-			user.l_start	= kernel.l_start;</span>
<span class="p_del">-			user.l_len	= kernel.l_len;</span>
<span class="p_del">-			user.l_pid	= kernel.l_pid;</span>
<span class="p_del">-			if (copy_to_user((struct oabi_flock64 __user *)arg,</span>
<span class="p_del">-					 &amp;user, sizeof(user)))</span>
<span class="p_del">-				ret = -EFAULT;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	case F_SETLK64:</span>
<span class="p_del">-	case F_SETLKW64:</span>
<span class="p_del">-		set_fs(fs);</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		return sys_fcntl64(fd, cmd, arg);</span>
 	}
<span class="p_del">-</span>
<span class="p_del">-	return ret;</span>
 }
 
 struct oabi_epoll_event {
<span class="p_header">diff --git a/arch/arm/kvm/mmu.c b/arch/arm/kvm/mmu.c</span>
<span class="p_header">index 6984342..61d96a6 100644</span>
<span class="p_header">--- a/arch/arm/kvm/mmu.c</span>
<span class="p_header">+++ b/arch/arm/kvm/mmu.c</span>
<span class="p_chunk">@@ -98,6 +98,11 @@</span> <span class="p_context"> static void kvm_flush_dcache_pud(pud_t pud)</span>
 	__kvm_flush_dcache_pud(pud);
 }
 
<span class="p_add">+static bool kvm_is_device_pfn(unsigned long pfn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return !pfn_valid(pfn);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * stage2_dissolve_pmd() - clear and flush huge PMD entry
  * @kvm:	pointer to kvm structure.
<span class="p_chunk">@@ -213,7 +218,7 @@</span> <span class="p_context"> static void unmap_ptes(struct kvm *kvm, pmd_t *pmd,</span>
 			kvm_tlb_flush_vmid_ipa(kvm, addr);
 
 			/* No need to invalidate the cache for device mappings */
<span class="p_del">-			if ((pte_val(old_pte) &amp; PAGE_S2_DEVICE) != PAGE_S2_DEVICE)</span>
<span class="p_add">+			if (!kvm_is_device_pfn(pte_pfn(old_pte)))</span>
 				kvm_flush_dcache_pte(old_pte);
 
 			put_page(virt_to_page(pte));
<span class="p_chunk">@@ -305,8 +310,7 @@</span> <span class="p_context"> static void stage2_flush_ptes(struct kvm *kvm, pmd_t *pmd,</span>
 
 	pte = pte_offset_kernel(pmd, addr);
 	do {
<span class="p_del">-		if (!pte_none(*pte) &amp;&amp;</span>
<span class="p_del">-		    (pte_val(*pte) &amp; PAGE_S2_DEVICE) != PAGE_S2_DEVICE)</span>
<span class="p_add">+		if (!pte_none(*pte) &amp;&amp; !kvm_is_device_pfn(pte_pfn(*pte)))</span>
 			kvm_flush_dcache_pte(*pte);
 	} while (pte++, addr += PAGE_SIZE, addr != end);
 }
<span class="p_chunk">@@ -1037,11 +1041,6 @@</span> <span class="p_context"> static bool kvm_is_write_fault(struct kvm_vcpu *vcpu)</span>
 	return kvm_vcpu_dabt_iswrite(vcpu);
 }
 
<span class="p_del">-static bool kvm_is_device_pfn(unsigned long pfn)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return !pfn_valid(pfn);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /**
  * stage2_wp_ptes - write protect PMD range
  * @pmd:	pointer to pmd entry
<span class="p_header">diff --git a/arch/arm/mach-dove/include/mach/entry-macro.S b/arch/arm/mach-dove/include/mach/entry-macro.S</span>
<span class="p_header">index 72d622b..df1d44b 100644</span>
<span class="p_header">--- a/arch/arm/mach-dove/include/mach/entry-macro.S</span>
<span class="p_header">+++ b/arch/arm/mach-dove/include/mach/entry-macro.S</span>
<span class="p_chunk">@@ -18,13 +18,13 @@</span> <span class="p_context"></span>
 	@ check low interrupts
 	ldr	\irqstat, [\base, #IRQ_CAUSE_LOW_OFF]
 	ldr	\tmp, [\base, #IRQ_MASK_LOW_OFF]
<span class="p_del">-	mov	\irqnr, #31</span>
<span class="p_add">+	mov	\irqnr, #32</span>
 	ands	\irqstat, \irqstat, \tmp
 
 	@ if no low interrupts set, check high interrupts
 	ldreq	\irqstat, [\base, #IRQ_CAUSE_HIGH_OFF]
 	ldreq	\tmp, [\base, #IRQ_MASK_HIGH_OFF]
<span class="p_del">-	moveq	\irqnr, #63</span>
<span class="p_add">+	moveq	\irqnr, #64</span>
 	andeqs	\irqstat, \irqstat, \tmp
 
 	@ find first active interrupt source
<span class="p_header">diff --git a/arch/arm/mach-imx/gpc.c b/arch/arm/mach-imx/gpc.c</span>
<span class="p_header">index 8c4467f..af085d7 100644</span>
<span class="p_header">--- a/arch/arm/mach-imx/gpc.c</span>
<span class="p_header">+++ b/arch/arm/mach-imx/gpc.c</span>
<span class="p_chunk">@@ -176,6 +176,7 @@</span> <span class="p_context"> static struct irq_chip imx_gpc_chip = {</span>
 	.irq_unmask		= imx_gpc_irq_unmask,
 	.irq_retrigger		= irq_chip_retrigger_hierarchy,
 	.irq_set_wake		= imx_gpc_irq_set_wake,
<span class="p_add">+	.irq_set_type           = irq_chip_set_type_parent,</span>
 #ifdef CONFIG_SMP
 	.irq_set_affinity	= irq_chip_set_affinity_parent,
 #endif
<span class="p_header">diff --git a/arch/arm/mach-omap2/gpmc-onenand.c b/arch/arm/mach-omap2/gpmc-onenand.c</span>
<span class="p_header">index 17a6f75..7b76ce0 100644</span>
<span class="p_header">--- a/arch/arm/mach-omap2/gpmc-onenand.c</span>
<span class="p_header">+++ b/arch/arm/mach-omap2/gpmc-onenand.c</span>
<span class="p_chunk">@@ -149,8 +149,8 @@</span> <span class="p_context"> static int omap2_onenand_get_freq(struct omap_onenand_platform_data *cfg,</span>
 		freq = 104;
 		break;
 	default:
<span class="p_del">-		freq = 54;</span>
<span class="p_del">-		break;</span>
<span class="p_add">+		pr_err(&quot;onenand rate not detected, bad GPMC async timings?\n&quot;);</span>
<span class="p_add">+		freq = 0;</span>
 	}
 
 	return freq;
<span class="p_chunk">@@ -271,6 +271,11 @@</span> <span class="p_context"> static int omap2_onenand_setup_async(void __iomem *onenand_base)</span>
 	struct gpmc_timings t;
 	int ret;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Note that we need to keep sync_write set for the call to</span>
<span class="p_add">+	 * omap2_onenand_set_async_mode() to work to detect the onenand</span>
<span class="p_add">+	 * supported clock rate for the sync timings.</span>
<span class="p_add">+	 */</span>
 	if (gpmc_onenand_data-&gt;of_node) {
 		gpmc_read_settings_dt(gpmc_onenand_data-&gt;of_node,
 				      &amp;onenand_async);
<span class="p_chunk">@@ -281,12 +286,9 @@</span> <span class="p_context"> static int omap2_onenand_setup_async(void __iomem *onenand_base)</span>
 			else
 				gpmc_onenand_data-&gt;flags |= ONENAND_SYNC_READ;
 			onenand_async.sync_read = false;
<span class="p_del">-			onenand_async.sync_write = false;</span>
 		}
 	}
 
<span class="p_del">-	omap2_onenand_set_async_mode(onenand_base);</span>
<span class="p_del">-</span>
 	omap2_onenand_calc_async_timings(&amp;t);
 
 	ret = gpmc_cs_program_settings(gpmc_onenand_data-&gt;cs, &amp;onenand_async);
<span class="p_chunk">@@ -310,6 +312,8 @@</span> <span class="p_context"> static int omap2_onenand_setup_sync(void __iomem *onenand_base, int *freq_ptr)</span>
 	if (!freq) {
 		/* Very first call freq is not known */
 		freq = omap2_onenand_get_freq(gpmc_onenand_data, onenand_base);
<span class="p_add">+		if (!freq)</span>
<span class="p_add">+			return -ENODEV;</span>
 		set_onenand_cfg(onenand_base);
 	}
 
<span class="p_header">diff --git a/arch/arm/mach-orion5x/include/mach/entry-macro.S b/arch/arm/mach-orion5x/include/mach/entry-macro.S</span>
<span class="p_header">index 79eb502..73919a3 100644</span>
<span class="p_header">--- a/arch/arm/mach-orion5x/include/mach/entry-macro.S</span>
<span class="p_header">+++ b/arch/arm/mach-orion5x/include/mach/entry-macro.S</span>
<span class="p_chunk">@@ -21,5 +21,5 @@</span> <span class="p_context"></span>
 	@ find cause bits that are unmasked
 	ands	\irqstat, \irqstat, \tmp	@ clear Z flag if any
 	clzne	\irqnr,	\irqstat		@ calc irqnr
<span class="p_del">-	rsbne	\irqnr, \irqnr, #31</span>
<span class="p_add">+	rsbne	\irqnr, \irqnr, #32</span>
 	.endm
<span class="p_header">diff --git a/arch/arm/mm/context.c b/arch/arm/mm/context.c</span>
<span class="p_header">index 845769e..c8c8b9e 100644</span>
<span class="p_header">--- a/arch/arm/mm/context.c</span>
<span class="p_header">+++ b/arch/arm/mm/context.c</span>
<span class="p_chunk">@@ -165,13 +165,28 @@</span> <span class="p_context"> static void flush_context(unsigned int cpu)</span>
 		__flush_icache_all();
 }
 
<span class="p_del">-static int is_reserved_asid(u64 asid)</span>
<span class="p_add">+static bool check_update_reserved_asid(u64 asid, u64 newasid)</span>
 {
 	int cpu;
<span class="p_del">-	for_each_possible_cpu(cpu)</span>
<span class="p_del">-		if (per_cpu(reserved_asids, cpu) == asid)</span>
<span class="p_del">-			return 1;</span>
<span class="p_del">-	return 0;</span>
<span class="p_add">+	bool hit = false;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Iterate over the set of reserved ASIDs looking for a match.</span>
<span class="p_add">+	 * If we find one, then we can update our mm to use newasid</span>
<span class="p_add">+	 * (i.e. the same ASID in the current generation) but we can&#39;t</span>
<span class="p_add">+	 * exit the loop early, since we need to ensure that all copies</span>
<span class="p_add">+	 * of the old ASID are updated to reflect the mm. Failure to do</span>
<span class="p_add">+	 * so could result in us missing the reserved ASID in a future</span>
<span class="p_add">+	 * generation.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	for_each_possible_cpu(cpu) {</span>
<span class="p_add">+		if (per_cpu(reserved_asids, cpu) == asid) {</span>
<span class="p_add">+			hit = true;</span>
<span class="p_add">+			per_cpu(reserved_asids, cpu) = newasid;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return hit;</span>
 }
 
 static u64 new_context(struct mm_struct *mm, unsigned int cpu)
<span class="p_chunk">@@ -181,12 +196,14 @@</span> <span class="p_context"> static u64 new_context(struct mm_struct *mm, unsigned int cpu)</span>
 	u64 generation = atomic64_read(&amp;asid_generation);
 
 	if (asid != 0) {
<span class="p_add">+		u64 newasid = generation | (asid &amp; ~ASID_MASK);</span>
<span class="p_add">+</span>
 		/*
 		 * If our current ASID was active during a rollover, we
 		 * can continue to use it and this was just a false alarm.
 		 */
<span class="p_del">-		if (is_reserved_asid(asid))</span>
<span class="p_del">-			return generation | (asid &amp; ~ASID_MASK);</span>
<span class="p_add">+		if (check_update_reserved_asid(asid, newasid))</span>
<span class="p_add">+			return newasid;</span>
 
 		/*
 		 * We had a valid ASID in a previous life, so try to re-use
<span class="p_chunk">@@ -194,7 +211,7 @@</span> <span class="p_context"> static u64 new_context(struct mm_struct *mm, unsigned int cpu)</span>
 		 */
 		asid &amp;= ~ASID_MASK;
 		if (!__test_and_set_bit(asid, asid_map))
<span class="p_del">-			goto bump_gen;</span>
<span class="p_add">+			return newasid;</span>
 	}
 
 	/*
<span class="p_chunk">@@ -216,11 +233,8 @@</span> <span class="p_context"> static u64 new_context(struct mm_struct *mm, unsigned int cpu)</span>
 
 	__set_bit(asid, asid_map);
 	cur_idx = asid;
<span class="p_del">-</span>
<span class="p_del">-bump_gen:</span>
<span class="p_del">-	asid |= generation;</span>
 	cpumask_clear(mm_cpumask(mm));
<span class="p_del">-	return asid;</span>
<span class="p_add">+	return asid | generation;</span>
 }
 
 void check_and_switch_context(struct mm_struct *mm, struct task_struct *tsk)
<span class="p_header">diff --git a/arch/arm/mm/proc-v7.S b/arch/arm/mm/proc-v7.S</span>
<span class="p_header">index de2b246..8e1ea43 100644</span>
<span class="p_header">--- a/arch/arm/mm/proc-v7.S</span>
<span class="p_header">+++ b/arch/arm/mm/proc-v7.S</span>
<span class="p_chunk">@@ -95,7 +95,7 @@</span> <span class="p_context"> ENDPROC(cpu_v7_dcache_clean_area)</span>
 .equ	cpu_v7_suspend_size, 4 * 9
 #ifdef CONFIG_ARM_CPU_SUSPEND
 ENTRY(cpu_v7_do_suspend)
<span class="p_del">-	stmfd	sp!, {r4 - r10, lr}</span>
<span class="p_add">+	stmfd	sp!, {r4 - r11, lr}</span>
 	mrc	p15, 0, r4, c13, c0, 0	@ FCSE/PID
 	mrc	p15, 0, r5, c13, c0, 3	@ User r/o thread ID
 	stmia	r0!, {r4 - r5}
<span class="p_chunk">@@ -112,7 +112,7 @@</span> <span class="p_context"> ENTRY(cpu_v7_do_suspend)</span>
 	mrc	p15, 0, r9, c1, c0, 1	@ Auxiliary control register
 	mrc	p15, 0, r10, c1, c0, 2	@ Co-processor access control
 	stmia	r0, {r5 - r11}
<span class="p_del">-	ldmfd	sp!, {r4 - r10, pc}</span>
<span class="p_add">+	ldmfd	sp!, {r4 - r11, pc}</span>
 ENDPROC(cpu_v7_do_suspend)
 
 ENTRY(cpu_v7_do_resume)
<span class="p_header">diff --git a/arch/arm/net/bpf_jit_32.c b/arch/arm/net/bpf_jit_32.c</span>
<span class="p_header">index c011e22..8a84eb7 100644</span>
<span class="p_header">--- a/arch/arm/net/bpf_jit_32.c</span>
<span class="p_header">+++ b/arch/arm/net/bpf_jit_32.c</span>
<span class="p_chunk">@@ -182,19 +182,6 @@</span> <span class="p_context"> static inline int mem_words_used(struct jit_ctx *ctx)</span>
 	return fls(ctx-&gt;seen &amp; SEEN_MEM);
 }
 
<span class="p_del">-static inline bool is_load_to_a(u16 inst)</span>
<span class="p_del">-{</span>
<span class="p_del">-	switch (inst) {</span>
<span class="p_del">-	case BPF_LD | BPF_W | BPF_LEN:</span>
<span class="p_del">-	case BPF_LD | BPF_W | BPF_ABS:</span>
<span class="p_del">-	case BPF_LD | BPF_H | BPF_ABS:</span>
<span class="p_del">-	case BPF_LD | BPF_B | BPF_ABS:</span>
<span class="p_del">-		return true;</span>
<span class="p_del">-	default:</span>
<span class="p_del">-		return false;</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static void jit_fill_hole(void *area, unsigned int size)
 {
 	u32 *ptr;
<span class="p_chunk">@@ -206,7 +193,6 @@</span> <span class="p_context"> static void jit_fill_hole(void *area, unsigned int size)</span>
 static void build_prologue(struct jit_ctx *ctx)
 {
 	u16 reg_set = saved_regs(ctx);
<span class="p_del">-	u16 first_inst = ctx-&gt;skf-&gt;insns[0].code;</span>
 	u16 off;
 
 #ifdef CONFIG_FRAME_POINTER
<span class="p_chunk">@@ -236,7 +222,7 @@</span> <span class="p_context"> static void build_prologue(struct jit_ctx *ctx)</span>
 		emit(ARM_MOV_I(r_X, 0), ctx);
 
 	/* do not leak kernel data to userspace */
<span class="p_del">-	if ((first_inst != (BPF_RET | BPF_K)) &amp;&amp; !(is_load_to_a(first_inst)))</span>
<span class="p_add">+	if (bpf_needs_clear_a(&amp;ctx-&gt;skf-&gt;insns[0]))</span>
 		emit(ARM_MOV_I(r_A, 0), ctx);
 
 	/* stack space for the BPF_MEM words */
<span class="p_header">diff --git a/arch/arm64/include/asm/kvm_emulate.h b/arch/arm64/include/asm/kvm_emulate.h</span>
<span class="p_header">index 17e92f0..3ca894e 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/kvm_emulate.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/kvm_emulate.h</span>
<span class="p_chunk">@@ -99,11 +99,13 @@</span> <span class="p_context"> static inline void vcpu_set_thumb(struct kvm_vcpu *vcpu)</span>
 	*vcpu_cpsr(vcpu) |= COMPAT_PSR_T_BIT;
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * vcpu_reg should always be passed a register number coming from a</span>
<span class="p_add">+ * read of ESR_EL2. Otherwise, it may give the wrong result on AArch32</span>
<span class="p_add">+ * with banked registers.</span>
<span class="p_add">+ */</span>
 static inline unsigned long *vcpu_reg(const struct kvm_vcpu *vcpu, u8 reg_num)
 {
<span class="p_del">-	if (vcpu_mode_is_32bit(vcpu))</span>
<span class="p_del">-		return vcpu_reg32(vcpu, reg_num);</span>
<span class="p_del">-</span>
 	return (unsigned long *)&amp;vcpu_gp_regs(vcpu)-&gt;regs.regs[reg_num];
 }
 
<span class="p_header">diff --git a/arch/arm64/kernel/suspend.c b/arch/arm64/kernel/suspend.c</span>
<span class="p_header">index 44ca414..dd6ad81 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/suspend.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/suspend.c</span>
<span class="p_chunk">@@ -1,3 +1,4 @@</span> <span class="p_context"></span>
<span class="p_add">+#include &lt;linux/ftrace.h&gt;</span>
 #include &lt;linux/percpu.h&gt;
 #include &lt;linux/slab.h&gt;
 #include &lt;asm/cacheflush.h&gt;
<span class="p_chunk">@@ -71,6 +72,13 @@</span> <span class="p_context"> int cpu_suspend(unsigned long arg, int (*fn)(unsigned long))</span>
 	local_dbg_save(flags);
 
 	/*
<span class="p_add">+	 * Function graph tracer state gets incosistent when the kernel</span>
<span class="p_add">+	 * calls functions that never return (aka suspend finishers) hence</span>
<span class="p_add">+	 * disable graph tracing during their execution.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	pause_graph_tracing();</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
 	 * mm context saved on the stack, it will be restored when
 	 * the cpu comes out of reset through the identity mapped
 	 * page tables, so that the thread address space is properly
<span class="p_chunk">@@ -111,6 +119,8 @@</span> <span class="p_context"> int cpu_suspend(unsigned long arg, int (*fn)(unsigned long))</span>
 			hw_breakpoint_restore(NULL);
 	}
 
<span class="p_add">+	unpause_graph_tracing();</span>
<span class="p_add">+</span>
 	/*
 	 * Restore pstate flags. OS lock and mdscr have been already
 	 * restored, so from this point onwards, debugging is fully
<span class="p_header">diff --git a/arch/arm64/kvm/inject_fault.c b/arch/arm64/kvm/inject_fault.c</span>
<span class="p_header">index 85c5715..648112e 100644</span>
<span class="p_header">--- a/arch/arm64/kvm/inject_fault.c</span>
<span class="p_header">+++ b/arch/arm64/kvm/inject_fault.c</span>
<span class="p_chunk">@@ -48,7 +48,7 @@</span> <span class="p_context"> static void prepare_fault32(struct kvm_vcpu *vcpu, u32 mode, u32 vect_offset)</span>
 
 	/* Note: These now point to the banked copies */
 	*vcpu_spsr(vcpu) = new_spsr_value;
<span class="p_del">-	*vcpu_reg(vcpu, 14) = *vcpu_pc(vcpu) + return_offset;</span>
<span class="p_add">+	*vcpu_reg32(vcpu, 14) = *vcpu_pc(vcpu) + return_offset;</span>
 
 	/* Branch to exception vector */
 	if (sctlr &amp; (1 &lt;&lt; 13))
<span class="p_header">diff --git a/arch/arm64/mm/mmu.c b/arch/arm64/mm/mmu.c</span>
<span class="p_header">index a4ede4e..6a0dc30 100644</span>
<span class="p_header">--- a/arch/arm64/mm/mmu.c</span>
<span class="p_header">+++ b/arch/arm64/mm/mmu.c</span>
<span class="p_chunk">@@ -308,8 +308,8 @@</span> <span class="p_context"> static void __init __map_memblock(phys_addr_t start, phys_addr_t end)</span>
 	 * for now. This will get more fine grained later once all memory
 	 * is mapped
 	 */
<span class="p_del">-	unsigned long kernel_x_start = round_down(__pa(_stext), SECTION_SIZE);</span>
<span class="p_del">-	unsigned long kernel_x_end = round_up(__pa(__init_end), SECTION_SIZE);</span>
<span class="p_add">+	unsigned long kernel_x_start = round_down(__pa(_stext), SWAPPER_BLOCK_SIZE);</span>
<span class="p_add">+	unsigned long kernel_x_end = round_up(__pa(__init_end), SWAPPER_BLOCK_SIZE);</span>
 
 	if (end &lt; kernel_x_start) {
 		create_mapping(start, __phys_to_virt(start),
<span class="p_chunk">@@ -397,18 +397,18 @@</span> <span class="p_context"> void __init fixup_executable(void)</span>
 {
 #ifdef CONFIG_DEBUG_RODATA
 	/* now that we are actually fully mapped, make the start/end more fine grained */
<span class="p_del">-	if (!IS_ALIGNED((unsigned long)_stext, SECTION_SIZE)) {</span>
<span class="p_add">+	if (!IS_ALIGNED((unsigned long)_stext, SWAPPER_BLOCK_SIZE)) {</span>
 		unsigned long aligned_start = round_down(__pa(_stext),
<span class="p_del">-							SECTION_SIZE);</span>
<span class="p_add">+							 SWAPPER_BLOCK_SIZE);</span>
 
 		create_mapping(aligned_start, __phys_to_virt(aligned_start),
 				__pa(_stext) - aligned_start,
 				PAGE_KERNEL);
 	}
 
<span class="p_del">-	if (!IS_ALIGNED((unsigned long)__init_end, SECTION_SIZE)) {</span>
<span class="p_add">+	if (!IS_ALIGNED((unsigned long)__init_end, SWAPPER_BLOCK_SIZE)) {</span>
 		unsigned long aligned_end = round_up(__pa(__init_end),
<span class="p_del">-							SECTION_SIZE);</span>
<span class="p_add">+							  SWAPPER_BLOCK_SIZE);</span>
 		create_mapping(__pa(__init_end), (unsigned long)__init_end,
 				aligned_end - __pa(__init_end),
 				PAGE_KERNEL);
<span class="p_header">diff --git a/arch/mips/include/asm/uaccess.h b/arch/mips/include/asm/uaccess.h</span>
<span class="p_header">index 5305d69..3f959c0 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/uaccess.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/uaccess.h</span>
<span class="p_chunk">@@ -1384,7 +1384,7 @@</span> <span class="p_context"> static inline long strlen_user(const char __user *s)</span>
 		might_fault();
 		__asm__ __volatile__(
 			&quot;move\t$4, %1\n\t&quot;
<span class="p_del">-			__MODULE_JAL(__strlen_kernel_asm)</span>
<span class="p_add">+			__MODULE_JAL(__strlen_user_asm)</span>
 			&quot;move\t%0, $2&quot;
 			: &quot;=r&quot; (res)
 			: &quot;r&quot; (s)
<span class="p_header">diff --git a/arch/mips/kernel/cps-vec.S b/arch/mips/kernel/cps-vec.S</span>
<span class="p_header">index 209ded1..763d8b7 100644</span>
<span class="p_header">--- a/arch/mips/kernel/cps-vec.S</span>
<span class="p_header">+++ b/arch/mips/kernel/cps-vec.S</span>
<span class="p_chunk">@@ -229,7 +229,6 @@</span> <span class="p_context"> LEAF(mips_cps_core_init)</span>
 	has_mt	t0, 3f
 
 	.set	push
<span class="p_del">-	.set	mips64r2</span>
 	.set	mt
 
 	/* Only allow 1 TC per VPE to execute... */
<span class="p_chunk">@@ -348,7 +347,6 @@</span> <span class="p_context"> LEAF(mips_cps_boot_vpes)</span>
 	 nop
 
 	.set	push
<span class="p_del">-	.set	mips64r2</span>
 	.set	mt
 
 1:	/* Enter VPE configuration state */
<span class="p_header">diff --git a/arch/mips/net/bpf_jit.c b/arch/mips/net/bpf_jit.c</span>
<span class="p_header">index 0c4a133..26e947d 100644</span>
<span class="p_header">--- a/arch/mips/net/bpf_jit.c</span>
<span class="p_header">+++ b/arch/mips/net/bpf_jit.c</span>
<span class="p_chunk">@@ -521,19 +521,6 @@</span> <span class="p_context"> static inline u16 align_sp(unsigned int num)</span>
 	return num;
 }
 
<span class="p_del">-static bool is_load_to_a(u16 inst)</span>
<span class="p_del">-{</span>
<span class="p_del">-	switch (inst) {</span>
<span class="p_del">-	case BPF_LD | BPF_W | BPF_LEN:</span>
<span class="p_del">-	case BPF_LD | BPF_W | BPF_ABS:</span>
<span class="p_del">-	case BPF_LD | BPF_H | BPF_ABS:</span>
<span class="p_del">-	case BPF_LD | BPF_B | BPF_ABS:</span>
<span class="p_del">-		return true;</span>
<span class="p_del">-	default:</span>
<span class="p_del">-		return false;</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static void save_bpf_jit_regs(struct jit_ctx *ctx, unsigned offset)
 {
 	int i = 0, real_off = 0;
<span class="p_chunk">@@ -614,7 +601,6 @@</span> <span class="p_context"> static unsigned int get_stack_depth(struct jit_ctx *ctx)</span>
 
 static void build_prologue(struct jit_ctx *ctx)
 {
<span class="p_del">-	u16 first_inst = ctx-&gt;skf-&gt;insns[0].code;</span>
 	int sp_off;
 
 	/* Calculate the total offset for the stack pointer */
<span class="p_chunk">@@ -641,7 +627,7 @@</span> <span class="p_context"> static void build_prologue(struct jit_ctx *ctx)</span>
 		emit_jit_reg_move(r_X, r_zero, ctx);
 
 	/* Do not leak kernel data to userspace */
<span class="p_del">-	if ((first_inst != (BPF_RET | BPF_K)) &amp;&amp; !(is_load_to_a(first_inst)))</span>
<span class="p_add">+	if (bpf_needs_clear_a(&amp;ctx-&gt;skf-&gt;insns[0]))</span>
 		emit_jit_reg_move(r_A, r_zero, ctx);
 }
 
<span class="p_header">diff --git a/arch/parisc/include/uapi/asm/mman.h b/arch/parisc/include/uapi/asm/mman.h</span>
<span class="p_header">index 294d251..2ae13ce5 100644</span>
<span class="p_header">--- a/arch/parisc/include/uapi/asm/mman.h</span>
<span class="p_header">+++ b/arch/parisc/include/uapi/asm/mman.h</span>
<span class="p_chunk">@@ -46,16 +46,6 @@</span> <span class="p_context"></span>
 #define MADV_DONTFORK	10		/* don&#39;t inherit across fork */
 #define MADV_DOFORK	11		/* do inherit across fork */
 
<span class="p_del">-/* The range 12-64 is reserved for page size specification. */</span>
<span class="p_del">-#define MADV_4K_PAGES   12              /* Use 4K pages  */</span>
<span class="p_del">-#define MADV_16K_PAGES  14              /* Use 16K pages */</span>
<span class="p_del">-#define MADV_64K_PAGES  16              /* Use 64K pages */</span>
<span class="p_del">-#define MADV_256K_PAGES 18              /* Use 256K pages */</span>
<span class="p_del">-#define MADV_1M_PAGES   20              /* Use 1 Megabyte pages */</span>
<span class="p_del">-#define MADV_4M_PAGES   22              /* Use 4 Megabyte pages */</span>
<span class="p_del">-#define MADV_16M_PAGES  24              /* Use 16 Megabyte pages */</span>
<span class="p_del">-#define MADV_64M_PAGES  26              /* Use 64 Megabyte pages */</span>
<span class="p_del">-</span>
 #define MADV_MERGEABLE   65		/* KSM may merge identical pages */
 #define MADV_UNMERGEABLE 66		/* KSM may not merge identical pages */
 
<span class="p_header">diff --git a/arch/parisc/kernel/signal.c b/arch/parisc/kernel/signal.c</span>
<span class="p_header">index dc1ea79..2264f68 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/signal.c</span>
<span class="p_header">+++ b/arch/parisc/kernel/signal.c</span>
<span class="p_chunk">@@ -435,6 +435,55 @@</span> <span class="p_context"> handle_signal(struct ksignal *ksig, struct pt_regs *regs, int in_syscall)</span>
 		regs-&gt;gr[28]);
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Check how the syscall number gets loaded into %r20 within</span>
<span class="p_add">+ * the delay branch in userspace and adjust as needed.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+static void check_syscallno_in_delay_branch(struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 opcode, source_reg;</span>
<span class="p_add">+	u32 __user *uaddr;</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Usually we don&#39;t have to restore %r20 (the system call number)</span>
<span class="p_add">+	 * because it gets loaded in the delay slot of the branch external</span>
<span class="p_add">+	 * instruction via the ldi instruction.</span>
<span class="p_add">+	 * In some cases a register-to-register copy instruction might have</span>
<span class="p_add">+	 * been used instead, in which case we need to copy the syscall</span>
<span class="p_add">+	 * number into the source register before returning to userspace.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
<span class="p_add">+	/* A syscall is just a branch, so all we have to do is fiddle the</span>
<span class="p_add">+	 * return pointer so that the ble instruction gets executed again.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	regs-&gt;gr[31] -= 8; /* delayed branching */</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Get assembler opcode of code in delay branch */</span>
<span class="p_add">+	uaddr = (unsigned int *) ((regs-&gt;gr[31] &amp; ~3) + 4);</span>
<span class="p_add">+	err = get_user(opcode, uaddr);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Check if delay branch uses &quot;ldi int,%r20&quot; */</span>
<span class="p_add">+	if ((opcode &amp; 0xffff0000) == 0x34140000)</span>
<span class="p_add">+		return;	/* everything ok, just return */</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Check if delay branch uses &quot;nop&quot; */</span>
<span class="p_add">+	if (opcode == INSN_NOP)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Check if delay branch uses &quot;copy %rX,%r20&quot; */</span>
<span class="p_add">+	if ((opcode &amp; 0xffe0ffff) == 0x08000254) {</span>
<span class="p_add">+		source_reg = (opcode &gt;&gt; 16) &amp; 31;</span>
<span class="p_add">+		regs-&gt;gr[source_reg] = regs-&gt;gr[20];</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_warn(&quot;syscall restart: %s (pid %d): unexpected opcode 0x%08x\n&quot;,</span>
<span class="p_add">+		current-&gt;comm, task_pid_nr(current), opcode);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline void
 syscall_restart(struct pt_regs *regs, struct k_sigaction *ka)
 {
<span class="p_chunk">@@ -457,10 +506,7 @@</span> <span class="p_context"> syscall_restart(struct pt_regs *regs, struct k_sigaction *ka)</span>
 		}
 		/* fallthrough */
 	case -ERESTARTNOINTR:
<span class="p_del">-		/* A syscall is just a branch, so all</span>
<span class="p_del">-		 * we have to do is fiddle the return pointer.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		regs-&gt;gr[31] -= 8; /* delayed branching */</span>
<span class="p_add">+		check_syscallno_in_delay_branch(regs);</span>
 		break;
 	}
 }
<span class="p_chunk">@@ -510,15 +556,9 @@</span> <span class="p_context"> insert_restart_trampoline(struct pt_regs *regs)</span>
 	}
 	case -ERESTARTNOHAND:
 	case -ERESTARTSYS:
<span class="p_del">-	case -ERESTARTNOINTR: {</span>
<span class="p_del">-		/* Hooray for delayed branching.  We don&#39;t</span>
<span class="p_del">-		 * have to restore %r20 (the system call</span>
<span class="p_del">-		 * number) because it gets loaded in the delay</span>
<span class="p_del">-		 * slot of the branch external instruction.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		regs-&gt;gr[31] -= 8;</span>
<span class="p_add">+	case -ERESTARTNOINTR:</span>
<span class="p_add">+		check_syscallno_in_delay_branch(regs);</span>
 		return;
<span class="p_del">-	}</span>
 	default:
 		break;
 	}
<span class="p_header">diff --git a/arch/powerpc/include/asm/reg.h b/arch/powerpc/include/asm/reg.h</span>
<span class="p_header">index af56b5c..f4f99f0 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/reg.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/reg.h</span>
<span class="p_chunk">@@ -108,6 +108,7 @@</span> <span class="p_context"></span>
 #define MSR_TS_T	__MASK(MSR_TS_T_LG)	/*  Transaction Transactional */
 #define MSR_TS_MASK	(MSR_TS_T | MSR_TS_S)   /* Transaction State bits */
 #define MSR_TM_ACTIVE(x) (((x) &amp; MSR_TS_MASK) != 0) /* Transaction active? */
<span class="p_add">+#define MSR_TM_RESV(x) (((x) &amp; MSR_TS_MASK) == MSR_TS_MASK) /* Reserved */</span>
 #define MSR_TM_TRANSACTIONAL(x)	(((x) &amp; MSR_TS_MASK) == MSR_TS_T)
 #define MSR_TM_SUSPENDED(x)	(((x) &amp; MSR_TS_MASK) == MSR_TS_S)
 
<span class="p_header">diff --git a/arch/powerpc/kernel/process.c b/arch/powerpc/kernel/process.c</span>
<span class="p_header">index 64e6e9d..ca783f9 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/process.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/process.c</span>
<span class="p_chunk">@@ -551,6 +551,24 @@</span> <span class="p_context"> static void tm_reclaim_thread(struct thread_struct *thr,</span>
 		msr_diff &amp;= MSR_FP | MSR_VEC | MSR_VSX | MSR_FE0 | MSR_FE1;
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Use the current MSR TM suspended bit to track if we have</span>
<span class="p_add">+	 * checkpointed state outstanding.</span>
<span class="p_add">+	 * On signal delivery, we&#39;d normally reclaim the checkpointed</span>
<span class="p_add">+	 * state to obtain stack pointer (see:get_tm_stackpointer()).</span>
<span class="p_add">+	 * This will then directly return to userspace without going</span>
<span class="p_add">+	 * through __switch_to(). However, if the stack frame is bad,</span>
<span class="p_add">+	 * we need to exit this thread which calls __switch_to() which</span>
<span class="p_add">+	 * will again attempt to reclaim the already saved tm state.</span>
<span class="p_add">+	 * Hence we need to check that we&#39;ve not already reclaimed</span>
<span class="p_add">+	 * this state.</span>
<span class="p_add">+	 * We do this using the current MSR, rather tracking it in</span>
<span class="p_add">+	 * some specific thread_struct bit, as it has the additional</span>
<span class="p_add">+	 * benifit of checking for a potential TM bad thing exception.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!MSR_TM_SUSPENDED(mfmsr()))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	tm_reclaim(thr, thr-&gt;regs-&gt;msr, cause);
 
 	/* Having done the reclaim, we now have the checkpointed
<span class="p_header">diff --git a/arch/powerpc/kernel/signal_32.c b/arch/powerpc/kernel/signal_32.c</span>
<span class="p_header">index da50e0c..7356c33 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/signal_32.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/signal_32.c</span>
<span class="p_chunk">@@ -875,6 +875,15 @@</span> <span class="p_context"> static long restore_tm_user_regs(struct pt_regs *regs,</span>
 		return 1;
 #endif /* CONFIG_SPE */
 
<span class="p_add">+	/* Get the top half of the MSR from the user context */</span>
<span class="p_add">+	if (__get_user(msr_hi, &amp;tm_sr-&gt;mc_gregs[PT_MSR]))</span>
<span class="p_add">+		return 1;</span>
<span class="p_add">+	msr_hi &lt;&lt;= 32;</span>
<span class="p_add">+	/* If TM bits are set to the reserved value, it&#39;s an invalid context */</span>
<span class="p_add">+	if (MSR_TM_RESV(msr_hi))</span>
<span class="p_add">+		return 1;</span>
<span class="p_add">+	/* Pull in the MSR TM bits from the user context */</span>
<span class="p_add">+	regs-&gt;msr = (regs-&gt;msr &amp; ~MSR_TS_MASK) | (msr_hi &amp; MSR_TS_MASK);</span>
 	/* Now, recheckpoint.  This loads up all of the checkpointed (older)
 	 * registers, including FP and V[S]Rs.  After recheckpointing, the
 	 * transactional versions should be loaded.
<span class="p_chunk">@@ -884,11 +893,6 @@</span> <span class="p_context"> static long restore_tm_user_regs(struct pt_regs *regs,</span>
 	current-&gt;thread.tm_texasr |= TEXASR_FS;
 	/* This loads the checkpointed FP/VEC state, if used */
 	tm_recheckpoint(&amp;current-&gt;thread, msr);
<span class="p_del">-	/* Get the top half of the MSR */</span>
<span class="p_del">-	if (__get_user(msr_hi, &amp;tm_sr-&gt;mc_gregs[PT_MSR]))</span>
<span class="p_del">-		return 1;</span>
<span class="p_del">-	/* Pull in MSR TM from user context */</span>
<span class="p_del">-	regs-&gt;msr = (regs-&gt;msr &amp; ~MSR_TS_MASK) | ((msr_hi&lt;&lt;32) &amp; MSR_TS_MASK);</span>
 
 	/* This loads the speculative FP/VEC state, if used */
 	if (msr &amp; MSR_FP) {
<span class="p_header">diff --git a/arch/powerpc/kernel/signal_64.c b/arch/powerpc/kernel/signal_64.c</span>
<span class="p_header">index c7c24d2..164fd64 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/signal_64.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/signal_64.c</span>
<span class="p_chunk">@@ -427,6 +427,10 @@</span> <span class="p_context"> static long restore_tm_sigcontexts(struct pt_regs *regs,</span>
 
 	/* get MSR separately, transfer the LE bit if doing signal return */
 	err |= __get_user(msr, &amp;sc-&gt;gp_regs[PT_MSR]);
<span class="p_add">+	/* Don&#39;t allow reserved mode. */</span>
<span class="p_add">+	if (MSR_TM_RESV(msr))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	/* pull in MSR TM from user context */
 	regs-&gt;msr = (regs-&gt;msr &amp; ~MSR_TS_MASK) | (msr &amp; MSR_TS_MASK);
 
<span class="p_header">diff --git a/arch/powerpc/kvm/book3s_hv.c b/arch/powerpc/kvm/book3s_hv.c</span>
<span class="p_header">index a9f753f..a27294e 100644</span>
<span class="p_header">--- a/arch/powerpc/kvm/book3s_hv.c</span>
<span class="p_header">+++ b/arch/powerpc/kvm/book3s_hv.c</span>
<span class="p_chunk">@@ -210,6 +210,12 @@</span> <span class="p_context"> static void kvmppc_core_vcpu_put_hv(struct kvm_vcpu *vcpu)</span>
 
 static void kvmppc_set_msr_hv(struct kvm_vcpu *vcpu, u64 msr)
 {
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Check for illegal transactional state bit combination</span>
<span class="p_add">+	 * and if we find it, force the TS field to a safe state.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if ((msr &amp; MSR_TS_MASK) == MSR_TS_MASK)</span>
<span class="p_add">+		msr &amp;= ~MSR_TS_MASK;</span>
 	vcpu-&gt;arch.shregs.msr = msr;
 	kvmppc_end_cede(vcpu);
 }
<span class="p_header">diff --git a/arch/powerpc/net/bpf_jit_comp.c b/arch/powerpc/net/bpf_jit_comp.c</span>
<span class="p_header">index 17cea18..264c473 100644</span>
<span class="p_header">--- a/arch/powerpc/net/bpf_jit_comp.c</span>
<span class="p_header">+++ b/arch/powerpc/net/bpf_jit_comp.c</span>
<span class="p_chunk">@@ -78,18 +78,9 @@</span> <span class="p_context"> static void bpf_jit_build_prologue(struct bpf_prog *fp, u32 *image,</span>
 		PPC_LI(r_X, 0);
 	}
 
<span class="p_del">-	switch (filter[0].code) {</span>
<span class="p_del">-	case BPF_RET | BPF_K:</span>
<span class="p_del">-	case BPF_LD | BPF_W | BPF_LEN:</span>
<span class="p_del">-	case BPF_LD | BPF_W | BPF_ABS:</span>
<span class="p_del">-	case BPF_LD | BPF_H | BPF_ABS:</span>
<span class="p_del">-	case BPF_LD | BPF_B | BPF_ABS:</span>
<span class="p_del">-		/* first instruction sets A register (or is RET &#39;constant&#39;) */</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	default:</span>
<span class="p_del">-		/* make sure we dont leak kernel information to user */</span>
<span class="p_add">+	/* make sure we dont leak kernel information to user */</span>
<span class="p_add">+	if (bpf_needs_clear_a(&amp;filter[0]))</span>
 		PPC_LI(r_A, 0);
<span class="p_del">-	}</span>
 }
 
 static void bpf_jit_build_epilogue(u32 *image, struct codegen_context *ctx)
<span class="p_header">diff --git a/arch/powerpc/platforms/powernv/opal-irqchip.c b/arch/powerpc/platforms/powernv/opal-irqchip.c</span>
<span class="p_header">index e2e7d75..ccabec5 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/powernv/opal-irqchip.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/powernv/opal-irqchip.c</span>
<span class="p_chunk">@@ -43,11 +43,34 @@</span> <span class="p_context"> static unsigned int opal_irq_count;</span>
 static unsigned int *opal_irqs;
 
 static void opal_handle_irq_work(struct irq_work *work);
<span class="p_del">-static __be64 last_outstanding_events;</span>
<span class="p_add">+static u64 last_outstanding_events;</span>
 static struct irq_work opal_event_irq_work = {
 	.func = opal_handle_irq_work,
 };
 
<span class="p_add">+void opal_handle_events(uint64_t events)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int virq, hwirq = 0;</span>
<span class="p_add">+	u64 mask = opal_event_irqchip.mask;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!in_irq() &amp;&amp; (events &amp; mask)) {</span>
<span class="p_add">+		last_outstanding_events = events;</span>
<span class="p_add">+		irq_work_queue(&amp;opal_event_irq_work);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	while (events &amp; mask) {</span>
<span class="p_add">+		hwirq = fls64(events) - 1;</span>
<span class="p_add">+		if (BIT_ULL(hwirq) &amp; mask) {</span>
<span class="p_add">+			virq = irq_find_mapping(opal_event_irqchip.domain,</span>
<span class="p_add">+						hwirq);</span>
<span class="p_add">+			if (virq)</span>
<span class="p_add">+				generic_handle_irq(virq);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		events &amp;= ~BIT_ULL(hwirq);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void opal_event_mask(struct irq_data *d)
 {
 	clear_bit(d-&gt;hwirq, &amp;opal_event_irqchip.mask);
<span class="p_chunk">@@ -55,9 +78,21 @@</span> <span class="p_context"> static void opal_event_mask(struct irq_data *d)</span>
 
 static void opal_event_unmask(struct irq_data *d)
 {
<span class="p_add">+	__be64 events;</span>
<span class="p_add">+</span>
 	set_bit(d-&gt;hwirq, &amp;opal_event_irqchip.mask);
 
<span class="p_del">-	opal_poll_events(&amp;last_outstanding_events);</span>
<span class="p_add">+	opal_poll_events(&amp;events);</span>
<span class="p_add">+	last_outstanding_events = be64_to_cpu(events);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We can&#39;t just handle the events now with opal_handle_events().</span>
<span class="p_add">+	 * If we did we would deadlock when opal_event_unmask() is called from</span>
<span class="p_add">+	 * handle_level_irq() with the irq descriptor lock held, because</span>
<span class="p_add">+	 * calling opal_handle_events() would call generic_handle_irq() and</span>
<span class="p_add">+	 * then handle_level_irq() which would try to take the descriptor lock</span>
<span class="p_add">+	 * again. Instead queue the events for later.</span>
<span class="p_add">+	 */</span>
 	if (last_outstanding_events &amp; opal_event_irqchip.mask)
 		/* Need to retrigger the interrupt */
 		irq_work_queue(&amp;opal_event_irq_work);
<span class="p_chunk">@@ -96,29 +131,6 @@</span> <span class="p_context"> static int opal_event_map(struct irq_domain *d, unsigned int irq,</span>
 	return 0;
 }
 
<span class="p_del">-void opal_handle_events(uint64_t events)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int virq, hwirq = 0;</span>
<span class="p_del">-	u64 mask = opal_event_irqchip.mask;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!in_irq() &amp;&amp; (events &amp; mask)) {</span>
<span class="p_del">-		last_outstanding_events = events;</span>
<span class="p_del">-		irq_work_queue(&amp;opal_event_irq_work);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	while (events &amp; mask) {</span>
<span class="p_del">-		hwirq = fls64(events) - 1;</span>
<span class="p_del">-		if (BIT_ULL(hwirq) &amp; mask) {</span>
<span class="p_del">-			virq = irq_find_mapping(opal_event_irqchip.domain,</span>
<span class="p_del">-						hwirq);</span>
<span class="p_del">-			if (virq)</span>
<span class="p_del">-				generic_handle_irq(virq);</span>
<span class="p_del">-		}</span>
<span class="p_del">-		events &amp;= ~BIT_ULL(hwirq);</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static irqreturn_t opal_interrupt(int irq, void *data)
 {
 	__be64 events;
<span class="p_chunk">@@ -131,7 +143,7 @@</span> <span class="p_context"> static irqreturn_t opal_interrupt(int irq, void *data)</span>
 
 static void opal_handle_irq_work(struct irq_work *work)
 {
<span class="p_del">-	opal_handle_events(be64_to_cpu(last_outstanding_events));</span>
<span class="p_add">+	opal_handle_events(last_outstanding_events);</span>
 }
 
 static int opal_event_match(struct irq_domain *h, struct device_node *node)
<span class="p_header">diff --git a/arch/powerpc/platforms/powernv/opal.c b/arch/powerpc/platforms/powernv/opal.c</span>
<span class="p_header">index f084afa..c368323 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/powernv/opal.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/powernv/opal.c</span>
<span class="p_chunk">@@ -278,7 +278,7 @@</span> <span class="p_context"> static void opal_handle_message(void)</span>
 
 	/* Sanity check */
 	if (type &gt;= OPAL_MSG_TYPE_MAX) {
<span class="p_del">-		pr_warning(&quot;%s: Unknown message type: %u\n&quot;, __func__, type);</span>
<span class="p_add">+		pr_warn_once(&quot;%s: Unknown message type: %u\n&quot;, __func__, type);</span>
 		return;
 	}
 	opal_message_do_notify(type, (void *)&amp;msg);
<span class="p_header">diff --git a/arch/s390/kernel/dis.c b/arch/s390/kernel/dis.c</span>
<span class="p_header">index 8140d10..6e72961 100644</span>
<span class="p_header">--- a/arch/s390/kernel/dis.c</span>
<span class="p_header">+++ b/arch/s390/kernel/dis.c</span>
<span class="p_chunk">@@ -1920,16 +1920,23 @@</span> <span class="p_context"> static int print_insn(char *buffer, unsigned char *code, unsigned long addr)</span>
 			}
 			if (separator)
 				ptr += sprintf(ptr, &quot;%c&quot;, separator);
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Use four &#39;%&#39; characters below because of the</span>
<span class="p_add">+			 * following two conversions:</span>
<span class="p_add">+			 *</span>
<span class="p_add">+			 *  1) sprintf: %%%%r -&gt; %%r</span>
<span class="p_add">+			 *  2) printk : %%r   -&gt; %r</span>
<span class="p_add">+			 */</span>
 			if (operand-&gt;flags &amp; OPERAND_GPR)
<span class="p_del">-				ptr += sprintf(ptr, &quot;%%r%i&quot;, value);</span>
<span class="p_add">+				ptr += sprintf(ptr, &quot;%%%%r%i&quot;, value);</span>
 			else if (operand-&gt;flags &amp; OPERAND_FPR)
<span class="p_del">-				ptr += sprintf(ptr, &quot;%%f%i&quot;, value);</span>
<span class="p_add">+				ptr += sprintf(ptr, &quot;%%%%f%i&quot;, value);</span>
 			else if (operand-&gt;flags &amp; OPERAND_AR)
<span class="p_del">-				ptr += sprintf(ptr, &quot;%%a%i&quot;, value);</span>
<span class="p_add">+				ptr += sprintf(ptr, &quot;%%%%a%i&quot;, value);</span>
 			else if (operand-&gt;flags &amp; OPERAND_CR)
<span class="p_del">-				ptr += sprintf(ptr, &quot;%%c%i&quot;, value);</span>
<span class="p_add">+				ptr += sprintf(ptr, &quot;%%%%c%i&quot;, value);</span>
 			else if (operand-&gt;flags &amp; OPERAND_VR)
<span class="p_del">-				ptr += sprintf(ptr, &quot;%%v%i&quot;, value);</span>
<span class="p_add">+				ptr += sprintf(ptr, &quot;%%%%v%i&quot;, value);</span>
 			else if (operand-&gt;flags &amp; OPERAND_PCREL)
 				ptr += sprintf(ptr, &quot;%lx&quot;, (signed int) value
 								      + addr);
<span class="p_header">diff --git a/arch/sh/include/uapi/asm/unistd_64.h b/arch/sh/include/uapi/asm/unistd_64.h</span>
<span class="p_header">index e6820c8..47ebd5b 100644</span>
<span class="p_header">--- a/arch/sh/include/uapi/asm/unistd_64.h</span>
<span class="p_header">+++ b/arch/sh/include/uapi/asm/unistd_64.h</span>
<span class="p_chunk">@@ -278,7 +278,7 @@</span> <span class="p_context"></span>
 #define __NR_fsetxattr		256
 #define __NR_getxattr		257
 #define __NR_lgetxattr		258
<span class="p_del">-#define __NR_fgetxattr		269</span>
<span class="p_add">+#define __NR_fgetxattr		259</span>
 #define __NR_listxattr		260
 #define __NR_llistxattr		261
 #define __NR_flistxattr		262
<span class="p_header">diff --git a/arch/sparc/net/bpf_jit_comp.c b/arch/sparc/net/bpf_jit_comp.c</span>
<span class="p_header">index 7931eee..8109e92 100644</span>
<span class="p_header">--- a/arch/sparc/net/bpf_jit_comp.c</span>
<span class="p_header">+++ b/arch/sparc/net/bpf_jit_comp.c</span>
<span class="p_chunk">@@ -420,22 +420,9 @@</span> <span class="p_context"> void bpf_jit_compile(struct bpf_prog *fp)</span>
 		}
 		emit_reg_move(O7, r_saved_O7);
 
<span class="p_del">-		switch (filter[0].code) {</span>
<span class="p_del">-		case BPF_RET | BPF_K:</span>
<span class="p_del">-		case BPF_LD | BPF_W | BPF_LEN:</span>
<span class="p_del">-		case BPF_LD | BPF_W | BPF_ABS:</span>
<span class="p_del">-		case BPF_LD | BPF_H | BPF_ABS:</span>
<span class="p_del">-		case BPF_LD | BPF_B | BPF_ABS:</span>
<span class="p_del">-			/* The first instruction sets the A register (or is</span>
<span class="p_del">-			 * a &quot;RET &#39;constant&#39;&quot;)</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		default:</span>
<span class="p_del">-			/* Make sure we dont leak kernel information to the</span>
<span class="p_del">-			 * user.</span>
<span class="p_del">-			 */</span>
<span class="p_add">+		/* Make sure we dont leak kernel information to the user. */</span>
<span class="p_add">+		if (bpf_needs_clear_a(&amp;filter[0]))</span>
 			emit_clear(r_A); /* A = 0 */
<span class="p_del">-		}</span>
 
 		for (i = 0; i &lt; flen; i++) {
 			unsigned int K = filter[i].k;
<span class="p_header">diff --git a/arch/tile/Kconfig b/arch/tile/Kconfig</span>
<span class="p_header">index 9def1f5..bd2b4cf 100644</span>
<span class="p_header">--- a/arch/tile/Kconfig</span>
<span class="p_header">+++ b/arch/tile/Kconfig</span>
<span class="p_chunk">@@ -175,8 +175,6 @@</span> <span class="p_context"> config NR_CPUS</span>
 	  smaller kernel memory footprint results from using a smaller
 	  value on chips with fewer tiles.
 
<span class="p_del">-if TILEGX</span>
<span class="p_del">-</span>
 choice
 	prompt &quot;Kernel page size&quot;
 	default PAGE_SIZE_64KB
<span class="p_chunk">@@ -187,8 +185,11 @@</span> <span class="p_context"> choice</span>
 	  connections, etc., it may be better to select 16KB, which uses
 	  memory more efficiently at some cost in TLB performance.
 
<span class="p_del">-	  Note that this option is TILE-Gx specific; currently</span>
<span class="p_del">-	  TILEPro page size is set by rebuilding the hypervisor.</span>
<span class="p_add">+	  Note that for TILEPro, you must also rebuild the hypervisor</span>
<span class="p_add">+	  with a matching page size.</span>
<span class="p_add">+</span>
<span class="p_add">+config PAGE_SIZE_4KB</span>
<span class="p_add">+	bool &quot;4KB&quot; if TILEPRO</span>
 
 config PAGE_SIZE_16KB
 	bool &quot;16KB&quot;
<span class="p_chunk">@@ -198,8 +199,6 @@</span> <span class="p_context"> config PAGE_SIZE_64KB</span>
 
 endchoice
 
<span class="p_del">-endif</span>
<span class="p_del">-</span>
 source &quot;kernel/Kconfig.hz&quot;
 
 config KEXEC
<span class="p_header">diff --git a/arch/tile/include/asm/page.h b/arch/tile/include/asm/page.h</span>
<span class="p_header">index a213a8d..8eca6a0 100644</span>
<span class="p_header">--- a/arch/tile/include/asm/page.h</span>
<span class="p_header">+++ b/arch/tile/include/asm/page.h</span>
<span class="p_chunk">@@ -20,15 +20,17 @@</span> <span class="p_context"></span>
 #include &lt;arch/chip.h&gt;
 
 /* PAGE_SHIFT and HPAGE_SHIFT determine the page sizes. */
<span class="p_del">-#if defined(CONFIG_PAGE_SIZE_16KB)</span>
<span class="p_add">+#if defined(CONFIG_PAGE_SIZE_4KB)  /* tilepro only */</span>
<span class="p_add">+#define PAGE_SHIFT	12</span>
<span class="p_add">+#define CTX_PAGE_FLAG	HV_CTX_PG_SM_4K</span>
<span class="p_add">+#elif defined(CONFIG_PAGE_SIZE_16KB)</span>
 #define PAGE_SHIFT	14
 #define CTX_PAGE_FLAG	HV_CTX_PG_SM_16K
 #elif defined(CONFIG_PAGE_SIZE_64KB)
 #define PAGE_SHIFT	16
 #define CTX_PAGE_FLAG	HV_CTX_PG_SM_64K
 #else
<span class="p_del">-#define PAGE_SHIFT	HV_LOG2_DEFAULT_PAGE_SIZE_SMALL</span>
<span class="p_del">-#define CTX_PAGE_FLAG	0</span>
<span class="p_add">+#error Page size not specified in Kconfig</span>
 #endif
 #define HPAGE_SHIFT	HV_LOG2_DEFAULT_PAGE_SIZE_LARGE
 
<span class="p_header">diff --git a/arch/x86/include/asm/paravirt.h b/arch/x86/include/asm/paravirt.h</span>
<span class="p_header">index d143bfa..d0791ac 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/paravirt.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/paravirt.h</span>
<span class="p_chunk">@@ -19,6 +19,12 @@</span> <span class="p_context"> static inline int paravirt_enabled(void)</span>
 	return pv_info.paravirt_enabled;
 }
 
<span class="p_add">+static inline int paravirt_has_feature(unsigned int feature)</span>
<span class="p_add">+{</span>
<span class="p_add">+	WARN_ON_ONCE(!pv_info.paravirt_enabled);</span>
<span class="p_add">+	return (pv_info.features &amp; feature);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline void load_sp0(struct tss_struct *tss,
 			     struct thread_struct *thread)
 {
<span class="p_header">diff --git a/arch/x86/include/asm/paravirt_types.h b/arch/x86/include/asm/paravirt_types.h</span>
<span class="p_header">index a6b8f9f..af3b3b7 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/paravirt_types.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/paravirt_types.h</span>
<span class="p_chunk">@@ -70,9 +70,14 @@</span> <span class="p_context"> struct pv_info {</span>
 #endif
 
 	int paravirt_enabled;
<span class="p_add">+	unsigned int features;	  /* valid only if paravirt_enabled is set */</span>
 	const char *name;
 };
 
<span class="p_add">+#define paravirt_has(x) paravirt_has_feature(PV_SUPPORTED_##x)</span>
<span class="p_add">+/* Supported features */</span>
<span class="p_add">+#define PV_SUPPORTED_RTC        (1&lt;&lt;0)</span>
<span class="p_add">+</span>
 struct pv_init_ops {
 	/*
 	 * Patch may replace one of the defined code sequences with
<span class="p_header">diff --git a/arch/x86/include/asm/processor.h b/arch/x86/include/asm/processor.h</span>
<span class="p_header">index 944f178..9b3bb51 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/processor.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/processor.h</span>
<span class="p_chunk">@@ -478,6 +478,7 @@</span> <span class="p_context"> static inline unsigned long current_top_of_stack(void)</span>
 #else
 #define __cpuid			native_cpuid
 #define paravirt_enabled()	0
<span class="p_add">+#define paravirt_has(x) 	0</span>
 
 static inline void load_sp0(struct tss_struct *tss,
 			    struct thread_struct *thread)
<span class="p_header">diff --git a/arch/x86/kernel/cpu/mcheck/mce.c b/arch/x86/kernel/cpu/mcheck/mce.c</span>
<span class="p_header">index df919ff..32ec29d 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/mcheck/mce.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/mcheck/mce.c</span>
<span class="p_chunk">@@ -1055,6 +1055,17 @@</span> <span class="p_context"> void do_machine_check(struct pt_regs *regs, long error_code)</span>
 	int flags = MF_ACTION_REQUIRED;
 	int lmce = 0;
 
<span class="p_add">+	/* If this CPU is offline, just bail out. */</span>
<span class="p_add">+	if (cpu_is_offline(smp_processor_id())) {</span>
<span class="p_add">+		u64 mcgstatus;</span>
<span class="p_add">+</span>
<span class="p_add">+		mcgstatus = mce_rdmsrl(MSR_IA32_MCG_STATUS);</span>
<span class="p_add">+		if (mcgstatus &amp; MCG_STATUS_RIPV) {</span>
<span class="p_add">+			mce_wrmsrl(MSR_IA32_MCG_STATUS, 0);</span>
<span class="p_add">+			return;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	prev_state = ist_enter(regs);
 
 	this_cpu_inc(mce_exception_count);
<span class="p_header">diff --git a/arch/x86/kernel/rtc.c b/arch/x86/kernel/rtc.c</span>
<span class="p_header">index cd96852..4af8d06 100644</span>
<span class="p_header">--- a/arch/x86/kernel/rtc.c</span>
<span class="p_header">+++ b/arch/x86/kernel/rtc.c</span>
<span class="p_chunk">@@ -200,6 +200,9 @@</span> <span class="p_context"> static __init int add_rtc_cmos(void)</span>
 	}
 #endif
 
<span class="p_add">+	if (paravirt_enabled() &amp;&amp; !paravirt_has(RTC))</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	platform_device_register(&amp;rtc_device);
 	dev_info(&amp;rtc_device.dev,
 		 &quot;registered platform RTC device (no PNP device found)\n&quot;);
<span class="p_header">diff --git a/arch/x86/kernel/signal.c b/arch/x86/kernel/signal.c</span>
<span class="p_header">index 71820c4..ce10cbc 100644</span>
<span class="p_header">--- a/arch/x86/kernel/signal.c</span>
<span class="p_header">+++ b/arch/x86/kernel/signal.c</span>
<span class="p_chunk">@@ -685,12 +685,15 @@</span> <span class="p_context"> handle_signal(struct ksignal *ksig, struct pt_regs *regs)</span>
 	signal_setup_done(failed, ksig, stepping);
 }
 
<span class="p_del">-#ifdef CONFIG_X86_32</span>
<span class="p_del">-#define NR_restart_syscall	__NR_restart_syscall</span>
<span class="p_del">-#else /* !CONFIG_X86_32 */</span>
<span class="p_del">-#define NR_restart_syscall	\</span>
<span class="p_del">-	test_thread_flag(TIF_IA32) ? __NR_ia32_restart_syscall : __NR_restart_syscall</span>
<span class="p_del">-#endif /* CONFIG_X86_32 */</span>
<span class="p_add">+static inline unsigned long get_nr_restart_syscall(const struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+#if defined(CONFIG_X86_32) || !defined(CONFIG_X86_64)</span>
<span class="p_add">+	return __NR_restart_syscall;</span>
<span class="p_add">+#else /* !CONFIG_X86_32 &amp;&amp; CONFIG_X86_64 */</span>
<span class="p_add">+	return test_thread_flag(TIF_IA32) ? __NR_ia32_restart_syscall :</span>
<span class="p_add">+		__NR_restart_syscall | (regs-&gt;orig_ax &amp; __X32_SYSCALL_BIT);</span>
<span class="p_add">+#endif /* CONFIG_X86_32 || !CONFIG_X86_64 */</span>
<span class="p_add">+}</span>
 
 /*
  * Note that &#39;init&#39; is a special process: it doesn&#39;t get signals it doesn&#39;t
<span class="p_chunk">@@ -719,7 +722,7 @@</span> <span class="p_context"> static void do_signal(struct pt_regs *regs)</span>
 			break;
 
 		case -ERESTART_RESTARTBLOCK:
<span class="p_del">-			regs-&gt;ax = NR_restart_syscall;</span>
<span class="p_add">+			regs-&gt;ax = get_nr_restart_syscall(regs);</span>
 			regs-&gt;ip -= 2;
 			break;
 		}
<span class="p_header">diff --git a/arch/x86/kvm/cpuid.h b/arch/x86/kvm/cpuid.h</span>
<span class="p_header">index dd05b9c..aea5b04 100644</span>
<span class="p_header">--- a/arch/x86/kvm/cpuid.h</span>
<span class="p_header">+++ b/arch/x86/kvm/cpuid.h</span>
<span class="p_chunk">@@ -38,6 +38,14 @@</span> <span class="p_context"> static inline bool guest_cpuid_has_xsave(struct kvm_vcpu *vcpu)</span>
 	return best &amp;&amp; (best-&gt;ecx &amp; bit(X86_FEATURE_XSAVE));
 }
 
<span class="p_add">+static inline bool guest_cpuid_has_mtrr(struct kvm_vcpu *vcpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct kvm_cpuid_entry2 *best;</span>
<span class="p_add">+</span>
<span class="p_add">+	best = kvm_find_cpuid_entry(vcpu, 1, 0);</span>
<span class="p_add">+	return best &amp;&amp; (best-&gt;edx &amp; bit(X86_FEATURE_MTRR));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline bool guest_cpuid_has_tsc_adjust(struct kvm_vcpu *vcpu)
 {
 	struct kvm_cpuid_entry2 *best;
<span class="p_header">diff --git a/arch/x86/kvm/i8254.c b/arch/x86/kvm/i8254.c</span>
<span class="p_header">index f90952f..a5b5997 100644</span>
<span class="p_header">--- a/arch/x86/kvm/i8254.c</span>
<span class="p_header">+++ b/arch/x86/kvm/i8254.c</span>
<span class="p_chunk">@@ -418,6 +418,7 @@</span> <span class="p_context"> void kvm_pit_load_count(struct kvm *kvm, int channel, u32 val, int hpet_legacy_s</span>
 	u8 saved_mode;
 	if (hpet_legacy_start) {
 		/* save existing mode for later reenablement */
<span class="p_add">+		WARN_ON(channel != 0);</span>
 		saved_mode = kvm-&gt;arch.vpit-&gt;pit_state.channels[0].mode;
 		kvm-&gt;arch.vpit-&gt;pit_state.channels[0].mode = 0xff; /* disable timer */
 		pit_load_count(kvm, channel, val);
<span class="p_header">diff --git a/arch/x86/kvm/mtrr.c b/arch/x86/kvm/mtrr.c</span>
<span class="p_header">index 9e8bf13..3f8c732 100644</span>
<span class="p_header">--- a/arch/x86/kvm/mtrr.c</span>
<span class="p_header">+++ b/arch/x86/kvm/mtrr.c</span>
<span class="p_chunk">@@ -120,14 +120,22 @@</span> <span class="p_context"> static u8 mtrr_default_type(struct kvm_mtrr *mtrr_state)</span>
 	return mtrr_state-&gt;deftype &amp; IA32_MTRR_DEF_TYPE_TYPE_MASK;
 }
 
<span class="p_del">-static u8 mtrr_disabled_type(void)</span>
<span class="p_add">+static u8 mtrr_disabled_type(struct kvm_vcpu *vcpu)</span>
 {
 	/*
 	 * Intel SDM 11.11.2.2: all MTRRs are disabled when
 	 * IA32_MTRR_DEF_TYPE.E bit is cleared, and the UC
 	 * memory type is applied to all of physical memory.
<span class="p_add">+	 *</span>
<span class="p_add">+	 * However, virtual machines can be run with CPUID such that</span>
<span class="p_add">+	 * there are no MTRRs.  In that case, the firmware will never</span>
<span class="p_add">+	 * enable MTRRs and it is obviously undesirable to run the</span>
<span class="p_add">+	 * guest entirely with UC memory and we use WB.</span>
 	 */
<span class="p_del">-	return MTRR_TYPE_UNCACHABLE;</span>
<span class="p_add">+	if (guest_cpuid_has_mtrr(vcpu))</span>
<span class="p_add">+		return MTRR_TYPE_UNCACHABLE;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		return MTRR_TYPE_WRBACK;</span>
 }
 
 /*
<span class="p_chunk">@@ -267,7 +275,7 @@</span> <span class="p_context"> static int fixed_mtrr_addr_to_seg(u64 addr)</span>
 
 	for (seg = 0; seg &lt; seg_num; seg++) {
 		mtrr_seg = &amp;fixed_seg_table[seg];
<span class="p_del">-		if (mtrr_seg-&gt;start &gt;= addr &amp;&amp; addr &lt; mtrr_seg-&gt;end)</span>
<span class="p_add">+		if (mtrr_seg-&gt;start &lt;= addr &amp;&amp; addr &lt; mtrr_seg-&gt;end)</span>
 			return seg;
 	}
 
<span class="p_chunk">@@ -300,7 +308,6 @@</span> <span class="p_context"> static void var_mtrr_range(struct kvm_mtrr_range *range, u64 *start, u64 *end)</span>
 	*start = range-&gt;base &amp; PAGE_MASK;
 
 	mask = range-&gt;mask &amp; PAGE_MASK;
<span class="p_del">-	mask |= ~0ULL &lt;&lt; boot_cpu_data.x86_phys_bits;</span>
 
 	/* This cannot overflow because writing to the reserved bits of
 	 * variable MTRRs causes a #GP.
<span class="p_chunk">@@ -356,10 +363,14 @@</span> <span class="p_context"> static void set_var_mtrr_msr(struct kvm_vcpu *vcpu, u32 msr, u64 data)</span>
 	if (var_mtrr_range_is_valid(cur))
 		list_del(&amp;mtrr_state-&gt;var_ranges[index].node);
 
<span class="p_add">+	/* Extend the mask with all 1 bits to the left, since those</span>
<span class="p_add">+	 * bits must implicitly be 0.  The bits are then cleared</span>
<span class="p_add">+	 * when reading them.</span>
<span class="p_add">+	 */</span>
 	if (!is_mtrr_mask)
 		cur-&gt;base = data;
 	else
<span class="p_del">-		cur-&gt;mask = data;</span>
<span class="p_add">+		cur-&gt;mask = data | (-1LL &lt;&lt; cpuid_maxphyaddr(vcpu));</span>
 
 	/* add it to the list if it&#39;s enabled. */
 	if (var_mtrr_range_is_valid(cur)) {
<span class="p_chunk">@@ -426,6 +437,8 @@</span> <span class="p_context"> int kvm_mtrr_get_msr(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)</span>
 			*pdata = vcpu-&gt;arch.mtrr_state.var_ranges[index].base;
 		else
 			*pdata = vcpu-&gt;arch.mtrr_state.var_ranges[index].mask;
<span class="p_add">+</span>
<span class="p_add">+		*pdata &amp;= (1ULL &lt;&lt; cpuid_maxphyaddr(vcpu)) - 1;</span>
 	}
 
 	return 0;
<span class="p_chunk">@@ -670,7 +683,7 @@</span> <span class="p_context"> u8 kvm_mtrr_get_guest_memory_type(struct kvm_vcpu *vcpu, gfn_t gfn)</span>
 	}
 
 	if (iter.mtrr_disabled)
<span class="p_del">-		return mtrr_disabled_type();</span>
<span class="p_add">+		return mtrr_disabled_type(vcpu);</span>
 
 	/* not contained in any MTRRs. */
 	if (type == -1)
<span class="p_header">diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c</span>
<span class="p_header">index a0d40d7..d022b73 100644</span>
<span class="p_header">--- a/arch/x86/kvm/x86.c</span>
<span class="p_header">+++ b/arch/x86/kvm/x86.c</span>
<span class="p_chunk">@@ -3679,7 +3679,8 @@</span> <span class="p_context"> static int kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)</span>
 	       sizeof(kvm-&gt;arch.vpit-&gt;pit_state.channels));
 	kvm-&gt;arch.vpit-&gt;pit_state.flags = ps-&gt;flags;
 	for (i = 0; i &lt; 3; i++)
<span class="p_del">-		kvm_pit_load_count(kvm, i, kvm-&gt;arch.vpit-&gt;pit_state.channels[i].count, start);</span>
<span class="p_add">+		kvm_pit_load_count(kvm, i, kvm-&gt;arch.vpit-&gt;pit_state.channels[i].count,</span>
<span class="p_add">+				   start &amp;&amp; i == 0);</span>
 	mutex_unlock(&amp;kvm-&gt;arch.vpit-&gt;pit_state.lock);
 	return r;
 }
<span class="p_header">diff --git a/arch/x86/lguest/boot.c b/arch/x86/lguest/boot.c</span>
<span class="p_header">index f2dc08c..5c4792e 100644</span>
<span class="p_header">--- a/arch/x86/lguest/boot.c</span>
<span class="p_header">+++ b/arch/x86/lguest/boot.c</span>
<span class="p_chunk">@@ -1419,6 +1419,7 @@</span> <span class="p_context"> __init void lguest_init(void)</span>
 	pv_info.kernel_rpl = 1;
 	/* Everyone except Xen runs with this set. */
 	pv_info.shared_kernel_pmd = 1;
<span class="p_add">+	pv_info.features = 0;</span>
 
 	/*
 	 * We set up all the lguest overrides for sensitive operations.  These
<span class="p_header">diff --git a/arch/x86/mm/mpx.c b/arch/x86/mm/mpx.c</span>
<span class="p_header">index c28f618..27f8393 100644</span>
<span class="p_header">--- a/arch/x86/mm/mpx.c</span>
<span class="p_header">+++ b/arch/x86/mm/mpx.c</span>
<span class="p_chunk">@@ -138,19 +138,19 @@</span> <span class="p_context"> static int get_reg_offset(struct insn *insn, struct pt_regs *regs,</span>
 	switch (type) {
 	case REG_TYPE_RM:
 		regno = X86_MODRM_RM(insn-&gt;modrm.value);
<span class="p_del">-		if (X86_REX_B(insn-&gt;rex_prefix.value) == 1)</span>
<span class="p_add">+		if (X86_REX_B(insn-&gt;rex_prefix.value))</span>
 			regno += 8;
 		break;
 
 	case REG_TYPE_INDEX:
 		regno = X86_SIB_INDEX(insn-&gt;sib.value);
<span class="p_del">-		if (X86_REX_X(insn-&gt;rex_prefix.value) == 1)</span>
<span class="p_add">+		if (X86_REX_X(insn-&gt;rex_prefix.value))</span>
 			regno += 8;
 		break;
 
 	case REG_TYPE_BASE:
 		regno = X86_SIB_BASE(insn-&gt;sib.value);
<span class="p_del">-		if (X86_REX_B(insn-&gt;rex_prefix.value) == 1)</span>
<span class="p_add">+		if (X86_REX_B(insn-&gt;rex_prefix.value))</span>
 			regno += 8;
 		break;
 
<span class="p_header">diff --git a/arch/x86/xen/enlighten.c b/arch/x86/xen/enlighten.c</span>
<span class="p_header">index 3cebc65..f83c0ba 100644</span>
<span class="p_header">--- a/arch/x86/xen/enlighten.c</span>
<span class="p_header">+++ b/arch/x86/xen/enlighten.c</span>
<span class="p_chunk">@@ -1186,7 +1186,7 @@</span> <span class="p_context"> static const struct pv_info xen_info __initconst = {</span>
 #ifdef CONFIG_X86_64
 	.extra_user_64bit_cs = FLAT_USER_CS64,
 #endif
<span class="p_del">-</span>
<span class="p_add">+	.features = 0,</span>
 	.name = &quot;Xen&quot;,
 };
 
<span class="p_chunk">@@ -1528,6 +1528,8 @@</span> <span class="p_context"> asmlinkage __visible void __init xen_start_kernel(void)</span>
 
 	/* Install Xen paravirt ops */
 	pv_info = xen_info;
<span class="p_add">+	if (xen_initial_domain())</span>
<span class="p_add">+		pv_info.features |= PV_SUPPORTED_RTC;</span>
 	pv_init_ops = xen_init_ops;
 	pv_apic_ops = xen_apic_ops;
 	if (!xen_pvh_domain()) {
<span class="p_header">diff --git a/block/blk-core.c b/block/blk-core.c</span>
<span class="p_header">index 1955ed3..4a9b995 100644</span>
<span class="p_header">--- a/block/blk-core.c</span>
<span class="p_header">+++ b/block/blk-core.c</span>
<span class="p_chunk">@@ -2023,7 +2023,8 @@</span> <span class="p_context"> void submit_bio(int rw, struct bio *bio)</span>
 EXPORT_SYMBOL(submit_bio);
 
 /**
<span class="p_del">- * blk_rq_check_limits - Helper function to check a request for the queue limit</span>
<span class="p_add">+ * blk_cloned_rq_check_limits - Helper function to check a cloned request</span>
<span class="p_add">+ *                              for new the queue limits</span>
  * @q:  the queue
  * @rq: the request being checked
  *
<span class="p_chunk">@@ -2034,20 +2035,13 @@</span> <span class="p_context"> EXPORT_SYMBOL(submit_bio);</span>
  *    after it is inserted to @q, it should be checked against @q before
  *    the insertion using this generic function.
  *
<span class="p_del">- *    This function should also be useful for request stacking drivers</span>
<span class="p_del">- *    in some cases below, so export this function.</span>
  *    Request stacking drivers like request-based dm may change the queue
<span class="p_del">- *    limits while requests are in the queue (e.g. dm&#39;s table swapping).</span>
<span class="p_del">- *    Such request stacking drivers should check those requests against</span>
<span class="p_del">- *    the new queue limits again when they dispatch those requests,</span>
<span class="p_del">- *    although such checkings are also done against the old queue limits</span>
<span class="p_del">- *    when submitting requests.</span>
<span class="p_add">+ *    limits when retrying requests on other queues. Those requests need</span>
<span class="p_add">+ *    to be checked against the new queue limits again during dispatch.</span>
  */
<span class="p_del">-int blk_rq_check_limits(struct request_queue *q, struct request *rq)</span>
<span class="p_add">+static int blk_cloned_rq_check_limits(struct request_queue *q,</span>
<span class="p_add">+				      struct request *rq)</span>
 {
<span class="p_del">-	if (!rq_mergeable(rq))</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-</span>
 	if (blk_rq_sectors(rq) &gt; blk_queue_get_max_sectors(q, rq-&gt;cmd_flags)) {
 		printk(KERN_ERR &quot;%s: over max size limit.\n&quot;, __func__);
 		return -EIO;
<span class="p_chunk">@@ -2067,7 +2061,6 @@</span> <span class="p_context"> int blk_rq_check_limits(struct request_queue *q, struct request *rq)</span>
 
 	return 0;
 }
<span class="p_del">-EXPORT_SYMBOL_GPL(blk_rq_check_limits);</span>
 
 /**
  * blk_insert_cloned_request - Helper for stacking drivers to submit a request
<span class="p_chunk">@@ -2079,7 +2072,7 @@</span> <span class="p_context"> int blk_insert_cloned_request(struct request_queue *q, struct request *rq)</span>
 	unsigned long flags;
 	int where = ELEVATOR_INSERT_BACK;
 
<span class="p_del">-	if (blk_rq_check_limits(q, rq))</span>
<span class="p_add">+	if (blk_cloned_rq_check_limits(q, rq))</span>
 		return -EIO;
 
 	if (rq-&gt;rq_disk &amp;&amp;
<span class="p_chunk">@@ -3280,6 +3273,9 @@</span> <span class="p_context"> int blk_pre_runtime_suspend(struct request_queue *q)</span>
 {
 	int ret = 0;
 
<span class="p_add">+	if (!q-&gt;dev)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
 	spin_lock_irq(q-&gt;queue_lock);
 	if (q-&gt;nr_pending) {
 		ret = -EBUSY;
<span class="p_chunk">@@ -3307,6 +3303,9 @@</span> <span class="p_context"> EXPORT_SYMBOL(blk_pre_runtime_suspend);</span>
  */
 void blk_post_runtime_suspend(struct request_queue *q, int err)
 {
<span class="p_add">+	if (!q-&gt;dev)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	spin_lock_irq(q-&gt;queue_lock);
 	if (!err) {
 		q-&gt;rpm_status = RPM_SUSPENDED;
<span class="p_chunk">@@ -3331,6 +3330,9 @@</span> <span class="p_context"> EXPORT_SYMBOL(blk_post_runtime_suspend);</span>
  */
 void blk_pre_runtime_resume(struct request_queue *q)
 {
<span class="p_add">+	if (!q-&gt;dev)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	spin_lock_irq(q-&gt;queue_lock);
 	q-&gt;rpm_status = RPM_RESUMING;
 	spin_unlock_irq(q-&gt;queue_lock);
<span class="p_chunk">@@ -3353,6 +3355,9 @@</span> <span class="p_context"> EXPORT_SYMBOL(blk_pre_runtime_resume);</span>
  */
 void blk_post_runtime_resume(struct request_queue *q, int err)
 {
<span class="p_add">+	if (!q-&gt;dev)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	spin_lock_irq(q-&gt;queue_lock);
 	if (!err) {
 		q-&gt;rpm_status = RPM_ACTIVE;
<span class="p_header">diff --git a/block/blk-mq.c b/block/blk-mq.c</span>
<span class="p_header">index 4d6ff52..0990d4c 100644</span>
<span class="p_header">--- a/block/blk-mq.c</span>
<span class="p_header">+++ b/block/blk-mq.c</span>
<span class="p_chunk">@@ -1300,15 +1300,16 @@</span> <span class="p_context"> static void blk_mq_make_request(struct request_queue *q, struct bio *bio)</span>
 		blk_mq_bio_to_request(rq, bio);
 
 		/*
<span class="p_del">-		 * we do limited pluging. If bio can be merged, do merge.</span>
<span class="p_add">+		 * We do limited pluging. If the bio can be merged, do that.</span>
 		 * Otherwise the existing request in the plug list will be
 		 * issued. So the plug list will have one request at most
 		 */
 		if (plug) {
 			/*
 			 * The plug list might get flushed before this. If that
<span class="p_del">-			 * happens, same_queue_rq is invalid and plug list is empty</span>
<span class="p_del">-			 **/</span>
<span class="p_add">+			 * happens, same_queue_rq is invalid and plug list is</span>
<span class="p_add">+			 * empty</span>
<span class="p_add">+			 */</span>
 			if (same_queue_rq &amp;&amp; !list_empty(&amp;plug-&gt;mq_list)) {
 				old_rq = same_queue_rq;
 				list_del_init(&amp;old_rq-&gt;queuelist);
<span class="p_chunk">@@ -1382,12 +1383,15 @@</span> <span class="p_context"> static void blk_sq_make_request(struct request_queue *q, struct bio *bio)</span>
 		blk_mq_bio_to_request(rq, bio);
 		if (list_empty(&amp;plug-&gt;mq_list))
 			trace_block_plug(q);
<span class="p_del">-		else if (request_count &gt;= BLK_MAX_REQUEST_COUNT) {</span>
<span class="p_add">+</span>
<span class="p_add">+		blk_mq_put_ctx(data.ctx);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (request_count &gt;= BLK_MAX_REQUEST_COUNT) {</span>
 			blk_flush_plug_list(plug, false);
 			trace_block_plug(q);
 		}
<span class="p_add">+</span>
 		list_add_tail(&amp;rq-&gt;queuelist, &amp;plug-&gt;mq_list);
<span class="p_del">-		blk_mq_put_ctx(data.ctx);</span>
 		return;
 	}
 
<span class="p_header">diff --git a/block/partitions/mac.c b/block/partitions/mac.c</span>
<span class="p_header">index c2c48ec..621317a 100644</span>
<span class="p_header">--- a/block/partitions/mac.c</span>
<span class="p_header">+++ b/block/partitions/mac.c</span>
<span class="p_chunk">@@ -32,7 +32,7 @@</span> <span class="p_context"> int mac_partition(struct parsed_partitions *state)</span>
 	Sector sect;
 	unsigned char *data;
 	int slot, blocks_in_map;
<span class="p_del">-	unsigned secsize;</span>
<span class="p_add">+	unsigned secsize, datasize, partoffset;</span>
 #ifdef CONFIG_PPC_PMAC
 	int found_root = 0;
 	int found_root_goodness = 0;
<span class="p_chunk">@@ -50,10 +50,14 @@</span> <span class="p_context"> int mac_partition(struct parsed_partitions *state)</span>
 	}
 	secsize = be16_to_cpu(md-&gt;block_size);
 	put_dev_sector(sect);
<span class="p_del">-	data = read_part_sector(state, secsize/512, &amp;sect);</span>
<span class="p_add">+	datasize = round_down(secsize, 512);</span>
<span class="p_add">+	data = read_part_sector(state, datasize / 512, &amp;sect);</span>
 	if (!data)
 		return -1;
<span class="p_del">-	part = (struct mac_partition *) (data + secsize%512);</span>
<span class="p_add">+	partoffset = secsize % 512;</span>
<span class="p_add">+	if (partoffset + sizeof(*part) &gt; datasize)</span>
<span class="p_add">+		return -1;</span>
<span class="p_add">+	part = (struct mac_partition *) (data + partoffset);</span>
 	if (be16_to_cpu(part-&gt;signature) != MAC_PARTITION_MAGIC) {
 		put_dev_sector(sect);
 		return 0;		/* not a MacOS disk */
<span class="p_header">diff --git a/crypto/ablkcipher.c b/crypto/ablkcipher.c</span>
<span class="p_header">index b4ffc5b..e5b5721 100644</span>
<span class="p_header">--- a/crypto/ablkcipher.c</span>
<span class="p_header">+++ b/crypto/ablkcipher.c</span>
<span class="p_chunk">@@ -277,12 +277,12 @@</span> <span class="p_context"> static int ablkcipher_walk_first(struct ablkcipher_request *req,</span>
 	if (WARN_ON_ONCE(in_irq()))
 		return -EDEADLK;
 
<span class="p_add">+	walk-&gt;iv = req-&gt;info;</span>
 	walk-&gt;nbytes = walk-&gt;total;
 	if (unlikely(!walk-&gt;total))
 		return 0;
 
 	walk-&gt;iv_buffer = NULL;
<span class="p_del">-	walk-&gt;iv = req-&gt;info;</span>
 	if (unlikely(((unsigned long)walk-&gt;iv &amp; alignmask))) {
 		int err = ablkcipher_copy_iv(walk, tfm, alignmask);
 
<span class="p_header">diff --git a/crypto/async_tx/async_memcpy.c b/crypto/async_tx/async_memcpy.c</span>
<span class="p_header">index f8c0b8d..88bc8e6 100644</span>
<span class="p_header">--- a/crypto/async_tx/async_memcpy.c</span>
<span class="p_header">+++ b/crypto/async_tx/async_memcpy.c</span>
<span class="p_chunk">@@ -53,7 +53,7 @@</span> <span class="p_context"> async_memcpy(struct page *dest, struct page *src, unsigned int dest_offset,</span>
 	struct dmaengine_unmap_data *unmap = NULL;
 
 	if (device)
<span class="p_del">-		unmap = dmaengine_get_unmap_data(device-&gt;dev, 2, GFP_NOIO);</span>
<span class="p_add">+		unmap = dmaengine_get_unmap_data(device-&gt;dev, 2, GFP_NOWAIT);</span>
 
 	if (unmap &amp;&amp; is_dma_copy_aligned(device, src_offset, dest_offset, len)) {
 		unsigned long dma_prep_flags = 0;
<span class="p_header">diff --git a/crypto/async_tx/async_pq.c b/crypto/async_tx/async_pq.c</span>
<span class="p_header">index 5d355e0..c0748bb 100644</span>
<span class="p_header">--- a/crypto/async_tx/async_pq.c</span>
<span class="p_header">+++ b/crypto/async_tx/async_pq.c</span>
<span class="p_chunk">@@ -188,7 +188,7 @@</span> <span class="p_context"> async_gen_syndrome(struct page **blocks, unsigned int offset, int disks,</span>
 	BUG_ON(disks &gt; 255 || !(P(blocks, disks) || Q(blocks, disks)));
 
 	if (device)
<span class="p_del">-		unmap = dmaengine_get_unmap_data(device-&gt;dev, disks, GFP_NOIO);</span>
<span class="p_add">+		unmap = dmaengine_get_unmap_data(device-&gt;dev, disks, GFP_NOWAIT);</span>
 
 	/* XORing P/Q is only implemented in software */
 	if (unmap &amp;&amp; !(submit-&gt;flags &amp; ASYNC_TX_PQ_XOR_DST) &amp;&amp;
<span class="p_chunk">@@ -307,7 +307,7 @@</span> <span class="p_context"> async_syndrome_val(struct page **blocks, unsigned int offset, int disks,</span>
 	BUG_ON(disks &lt; 4);
 
 	if (device)
<span class="p_del">-		unmap = dmaengine_get_unmap_data(device-&gt;dev, disks, GFP_NOIO);</span>
<span class="p_add">+		unmap = dmaengine_get_unmap_data(device-&gt;dev, disks, GFP_NOWAIT);</span>
 
 	if (unmap &amp;&amp; disks &lt;= dma_maxpq(device, 0) &amp;&amp;
 	    is_dma_pq_aligned(device, offset, 0, len)) {
<span class="p_header">diff --git a/crypto/async_tx/async_raid6_recov.c b/crypto/async_tx/async_raid6_recov.c</span>
<span class="p_header">index 934a849..8fab627 100644</span>
<span class="p_header">--- a/crypto/async_tx/async_raid6_recov.c</span>
<span class="p_header">+++ b/crypto/async_tx/async_raid6_recov.c</span>
<span class="p_chunk">@@ -41,7 +41,7 @@</span> <span class="p_context"> async_sum_product(struct page *dest, struct page **srcs, unsigned char *coef,</span>
 	u8 *a, *b, *c;
 
 	if (dma)
<span class="p_del">-		unmap = dmaengine_get_unmap_data(dma-&gt;dev, 3, GFP_NOIO);</span>
<span class="p_add">+		unmap = dmaengine_get_unmap_data(dma-&gt;dev, 3, GFP_NOWAIT);</span>
 
 	if (unmap) {
 		struct device *dev = dma-&gt;dev;
<span class="p_chunk">@@ -105,7 +105,7 @@</span> <span class="p_context"> async_mult(struct page *dest, struct page *src, u8 coef, size_t len,</span>
 	u8 *d, *s;
 
 	if (dma)
<span class="p_del">-		unmap = dmaengine_get_unmap_data(dma-&gt;dev, 3, GFP_NOIO);</span>
<span class="p_add">+		unmap = dmaengine_get_unmap_data(dma-&gt;dev, 3, GFP_NOWAIT);</span>
 
 	if (unmap) {
 		dma_addr_t dma_dest[2];
<span class="p_header">diff --git a/crypto/async_tx/async_xor.c b/crypto/async_tx/async_xor.c</span>
<span class="p_header">index e1bce26..da75777 100644</span>
<span class="p_header">--- a/crypto/async_tx/async_xor.c</span>
<span class="p_header">+++ b/crypto/async_tx/async_xor.c</span>
<span class="p_chunk">@@ -182,7 +182,7 @@</span> <span class="p_context"> async_xor(struct page *dest, struct page **src_list, unsigned int offset,</span>
 	BUG_ON(src_cnt &lt;= 1);
 
 	if (device)
<span class="p_del">-		unmap = dmaengine_get_unmap_data(device-&gt;dev, src_cnt+1, GFP_NOIO);</span>
<span class="p_add">+		unmap = dmaengine_get_unmap_data(device-&gt;dev, src_cnt+1, GFP_NOWAIT);</span>
 
 	if (unmap &amp;&amp; is_dma_xor_aligned(device, offset, 0, len)) {
 		struct dma_async_tx_descriptor *tx;
<span class="p_chunk">@@ -278,7 +278,7 @@</span> <span class="p_context"> async_xor_val(struct page *dest, struct page **src_list, unsigned int offset,</span>
 	BUG_ON(src_cnt &lt;= 1);
 
 	if (device)
<span class="p_del">-		unmap = dmaengine_get_unmap_data(device-&gt;dev, src_cnt, GFP_NOIO);</span>
<span class="p_add">+		unmap = dmaengine_get_unmap_data(device-&gt;dev, src_cnt, GFP_NOWAIT);</span>
 
 	if (unmap &amp;&amp; src_cnt &lt;= device-&gt;max_xor &amp;&amp;
 	    is_dma_xor_aligned(device, offset, 0, len)) {
<span class="p_header">diff --git a/crypto/blkcipher.c b/crypto/blkcipher.c</span>
<span class="p_header">index 11b9814..8cc1622 100644</span>
<span class="p_header">--- a/crypto/blkcipher.c</span>
<span class="p_header">+++ b/crypto/blkcipher.c</span>
<span class="p_chunk">@@ -326,12 +326,12 @@</span> <span class="p_context"> static int blkcipher_walk_first(struct blkcipher_desc *desc,</span>
 	if (WARN_ON_ONCE(in_irq()))
 		return -EDEADLK;
 
<span class="p_add">+	walk-&gt;iv = desc-&gt;info;</span>
 	walk-&gt;nbytes = walk-&gt;total;
 	if (unlikely(!walk-&gt;total))
 		return 0;
 
 	walk-&gt;buffer = NULL;
<span class="p_del">-	walk-&gt;iv = desc-&gt;info;</span>
 	if (unlikely(((unsigned long)walk-&gt;iv &amp; walk-&gt;alignmask))) {
 		int err = blkcipher_copy_iv(walk);
 		if (err)
<span class="p_header">diff --git a/drivers/ata/ahci_mvebu.c b/drivers/ata/ahci_mvebu.c</span>
<span class="p_header">index 8490d37..f7a7fa8 100644</span>
<span class="p_header">--- a/drivers/ata/ahci_mvebu.c</span>
<span class="p_header">+++ b/drivers/ata/ahci_mvebu.c</span>
<span class="p_chunk">@@ -62,6 +62,7 @@</span> <span class="p_context"> static void ahci_mvebu_regret_option(struct ahci_host_priv *hpriv)</span>
 	writel(0x80, hpriv-&gt;mmio + AHCI_VENDOR_SPECIFIC_0_DATA);
 }
 
<span class="p_add">+#ifdef CONFIG_PM_SLEEP</span>
 static int ahci_mvebu_suspend(struct platform_device *pdev, pm_message_t state)
 {
 	return ahci_platform_suspend_host(&amp;pdev-&gt;dev);
<span class="p_chunk">@@ -81,6 +82,10 @@</span> <span class="p_context"> static int ahci_mvebu_resume(struct platform_device *pdev)</span>
 
 	return ahci_platform_resume_host(&amp;pdev-&gt;dev);
 }
<span class="p_add">+#else</span>
<span class="p_add">+#define ahci_mvebu_suspend NULL</span>
<span class="p_add">+#define ahci_mvebu_resume NULL</span>
<span class="p_add">+#endif</span>
 
 static const struct ata_port_info ahci_mvebu_port_info = {
 	.flags	   = AHCI_FLAG_COMMON,
<span class="p_header">diff --git a/drivers/ata/libahci.c b/drivers/ata/libahci.c</span>
<span class="p_header">index d256a66..98c482a 100644</span>
<span class="p_header">--- a/drivers/ata/libahci.c</span>
<span class="p_header">+++ b/drivers/ata/libahci.c</span>
<span class="p_chunk">@@ -1266,6 +1266,15 @@</span> <span class="p_context"> static int ahci_exec_polled_cmd(struct ata_port *ap, int pmp,</span>
 	ata_tf_to_fis(tf, pmp, is_cmd, fis);
 	ahci_fill_cmd_slot(pp, 0, cmd_fis_len | flags | (pmp &lt;&lt; 12));
 
<span class="p_add">+	/* set port value for softreset of Port Multiplier */</span>
<span class="p_add">+	if (pp-&gt;fbs_enabled &amp;&amp; pp-&gt;fbs_last_dev != pmp) {</span>
<span class="p_add">+		tmp = readl(port_mmio + PORT_FBS);</span>
<span class="p_add">+		tmp &amp;= ~(PORT_FBS_DEV_MASK | PORT_FBS_DEC);</span>
<span class="p_add">+		tmp |= pmp &lt;&lt; PORT_FBS_DEV_OFFSET;</span>
<span class="p_add">+		writel(tmp, port_mmio + PORT_FBS);</span>
<span class="p_add">+		pp-&gt;fbs_last_dev = pmp;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* issue &amp; wait */
 	writel(1, port_mmio + PORT_CMD_ISSUE);
 
<span class="p_header">diff --git a/drivers/ata/sata_sil.c b/drivers/ata/sata_sil.c</span>
<span class="p_header">index dea6edc..29bcff0 100644</span>
<span class="p_header">--- a/drivers/ata/sata_sil.c</span>
<span class="p_header">+++ b/drivers/ata/sata_sil.c</span>
<span class="p_chunk">@@ -630,6 +630,9 @@</span> <span class="p_context"> static void sil_dev_config(struct ata_device *dev)</span>
 	unsigned int n, quirks = 0;
 	unsigned char model_num[ATA_ID_PROD_LEN + 1];
 
<span class="p_add">+	/* This controller doesn&#39;t support trim */</span>
<span class="p_add">+	dev-&gt;horkage |= ATA_HORKAGE_NOTRIM;</span>
<span class="p_add">+</span>
 	ata_id_c_string(dev-&gt;id, model_num, ATA_ID_PROD, sizeof(model_num));
 
 	for (n = 0; sil_blacklist[n].product; n++)
<span class="p_header">diff --git a/drivers/base/memory.c b/drivers/base/memory.c</span>
<span class="p_header">index 2804aed..25425d3 100644</span>
<span class="p_header">--- a/drivers/base/memory.c</span>
<span class="p_header">+++ b/drivers/base/memory.c</span>
<span class="p_chunk">@@ -303,6 +303,10 @@</span> <span class="p_context"> static int memory_subsys_offline(struct device *dev)</span>
 	if (mem-&gt;state == MEM_OFFLINE)
 		return 0;
 
<span class="p_add">+	/* Can&#39;t offline block with non-present sections */</span>
<span class="p_add">+	if (mem-&gt;section_count != sections_per_block)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	return memory_block_change_state(mem, MEM_OFFLINE, MEM_ONLINE);
 }
 
<span class="p_header">diff --git a/drivers/base/power/domain.c b/drivers/base/power/domain.c</span>
<span class="p_header">index 0ee43c1..6e5ac0a 100644</span>
<span class="p_header">--- a/drivers/base/power/domain.c</span>
<span class="p_header">+++ b/drivers/base/power/domain.c</span>
<span class="p_chunk">@@ -2216,10 +2216,10 @@</span> <span class="p_context"> int genpd_dev_pm_attach(struct device *dev)</span>
 	}
 
 	pd = of_genpd_get_from_provider(&amp;pd_args);
<span class="p_add">+	of_node_put(pd_args.np);</span>
 	if (IS_ERR(pd)) {
 		dev_dbg(dev, &quot;%s() failed to find PM domain: %ld\n&quot;,
 			__func__, PTR_ERR(pd));
<span class="p_del">-		of_node_put(dev-&gt;of_node);</span>
 		return PTR_ERR(pd);
 	}
 
<span class="p_chunk">@@ -2237,7 +2237,6 @@</span> <span class="p_context"> int genpd_dev_pm_attach(struct device *dev)</span>
 	if (ret &lt; 0) {
 		dev_err(dev, &quot;failed to add to PM domain %s: %d&quot;,
 			pd-&gt;name, ret);
<span class="p_del">-		of_node_put(dev-&gt;of_node);</span>
 		return ret;
 	}
 
<span class="p_header">diff --git a/drivers/block/xen-blkback/blkback.c b/drivers/block/xen-blkback/blkback.c</span>
<span class="p_header">index 954c002..9caf93c 100644</span>
<span class="p_header">--- a/drivers/block/xen-blkback/blkback.c</span>
<span class="p_header">+++ b/drivers/block/xen-blkback/blkback.c</span>
<span class="p_chunk">@@ -950,6 +950,8 @@</span> <span class="p_context"> static int xen_blkbk_parse_indirect(struct blkif_request *req,</span>
 		goto unmap;
 
 	for (n = 0, i = 0; n &lt; nseg; n++) {
<span class="p_add">+		uint8_t first_sect, last_sect;</span>
<span class="p_add">+</span>
 		if ((n % SEGS_PER_INDIRECT_FRAME) == 0) {
 			/* Map indirect segments */
 			if (segments)
<span class="p_chunk">@@ -957,15 +959,18 @@</span> <span class="p_context"> static int xen_blkbk_parse_indirect(struct blkif_request *req,</span>
 			segments = kmap_atomic(pages[n/SEGS_PER_INDIRECT_FRAME]-&gt;page);
 		}
 		i = n % SEGS_PER_INDIRECT_FRAME;
<span class="p_add">+</span>
 		pending_req-&gt;segments[n]-&gt;gref = segments[i].gref;
<span class="p_del">-		seg[n].nsec = segments[i].last_sect -</span>
<span class="p_del">-			segments[i].first_sect + 1;</span>
<span class="p_del">-		seg[n].offset = (segments[i].first_sect &lt;&lt; 9);</span>
<span class="p_del">-		if ((segments[i].last_sect &gt;= (PAGE_SIZE &gt;&gt; 9)) ||</span>
<span class="p_del">-		    (segments[i].last_sect &lt; segments[i].first_sect)) {</span>
<span class="p_add">+</span>
<span class="p_add">+		first_sect = READ_ONCE(segments[i].first_sect);</span>
<span class="p_add">+		last_sect = READ_ONCE(segments[i].last_sect);</span>
<span class="p_add">+		if (last_sect &gt;= (PAGE_SIZE &gt;&gt; 9) || last_sect &lt; first_sect) {</span>
 			rc = -EINVAL;
 			goto unmap;
 		}
<span class="p_add">+</span>
<span class="p_add">+		seg[n].nsec = last_sect - first_sect + 1;</span>
<span class="p_add">+		seg[n].offset = first_sect &lt;&lt; 9;</span>
 		preq-&gt;nr_sects += seg[n].nsec;
 	}
 
<span class="p_header">diff --git a/drivers/block/xen-blkback/common.h b/drivers/block/xen-blkback/common.h</span>
<span class="p_header">index 45a044a..619bd60 100644</span>
<span class="p_header">--- a/drivers/block/xen-blkback/common.h</span>
<span class="p_header">+++ b/drivers/block/xen-blkback/common.h</span>
<span class="p_chunk">@@ -399,8 +399,8 @@</span> <span class="p_context"> static inline void blkif_get_x86_32_req(struct blkif_request *dst,</span>
 					struct blkif_x86_32_request *src)
 {
 	int i, n = BLKIF_MAX_SEGMENTS_PER_REQUEST, j;
<span class="p_del">-	dst-&gt;operation = src-&gt;operation;</span>
<span class="p_del">-	switch (src-&gt;operation) {</span>
<span class="p_add">+	dst-&gt;operation = READ_ONCE(src-&gt;operation);</span>
<span class="p_add">+	switch (dst-&gt;operation) {</span>
 	case BLKIF_OP_READ:
 	case BLKIF_OP_WRITE:
 	case BLKIF_OP_WRITE_BARRIER:
<span class="p_chunk">@@ -447,8 +447,8 @@</span> <span class="p_context"> static inline void blkif_get_x86_64_req(struct blkif_request *dst,</span>
 					struct blkif_x86_64_request *src)
 {
 	int i, n = BLKIF_MAX_SEGMENTS_PER_REQUEST, j;
<span class="p_del">-	dst-&gt;operation = src-&gt;operation;</span>
<span class="p_del">-	switch (src-&gt;operation) {</span>
<span class="p_add">+	dst-&gt;operation = READ_ONCE(src-&gt;operation);</span>
<span class="p_add">+	switch (dst-&gt;operation) {</span>
 	case BLKIF_OP_READ:
 	case BLKIF_OP_WRITE:
 	case BLKIF_OP_WRITE_BARRIER:
<span class="p_header">diff --git a/drivers/char/ipmi/ipmi_si_intf.c b/drivers/char/ipmi/ipmi_si_intf.c</span>
<span class="p_header">index 8a45e92..0522270 100644</span>
<span class="p_header">--- a/drivers/char/ipmi/ipmi_si_intf.c</span>
<span class="p_header">+++ b/drivers/char/ipmi/ipmi_si_intf.c</span>
<span class="p_chunk">@@ -404,18 +404,42 @@</span> <span class="p_context"> static enum si_sm_result start_next_msg(struct smi_info *smi_info)</span>
 	return rv;
 }
 
<span class="p_del">-static void start_check_enables(struct smi_info *smi_info)</span>
<span class="p_add">+static void smi_mod_timer(struct smi_info *smi_info, unsigned long new_val)</span>
<span class="p_add">+{</span>
<span class="p_add">+	smi_info-&gt;last_timeout_jiffies = jiffies;</span>
<span class="p_add">+	mod_timer(&amp;smi_info-&gt;si_timer, new_val);</span>
<span class="p_add">+	smi_info-&gt;timer_running = true;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Start a new message and (re)start the timer and thread.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void start_new_msg(struct smi_info *smi_info, unsigned char *msg,</span>
<span class="p_add">+			  unsigned int size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	smi_mod_timer(smi_info, jiffies + SI_TIMEOUT_JIFFIES);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (smi_info-&gt;thread)</span>
<span class="p_add">+		wake_up_process(smi_info-&gt;thread);</span>
<span class="p_add">+</span>
<span class="p_add">+	smi_info-&gt;handlers-&gt;start_transaction(smi_info-&gt;si_sm, msg, size);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void start_check_enables(struct smi_info *smi_info, bool start_timer)</span>
 {
 	unsigned char msg[2];
 
 	msg[0] = (IPMI_NETFN_APP_REQUEST &lt;&lt; 2);
 	msg[1] = IPMI_GET_BMC_GLOBAL_ENABLES_CMD;
 
<span class="p_del">-	smi_info-&gt;handlers-&gt;start_transaction(smi_info-&gt;si_sm, msg, 2);</span>
<span class="p_add">+	if (start_timer)</span>
<span class="p_add">+		start_new_msg(smi_info, msg, 2);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		smi_info-&gt;handlers-&gt;start_transaction(smi_info-&gt;si_sm, msg, 2);</span>
 	smi_info-&gt;si_state = SI_CHECKING_ENABLES;
 }
 
<span class="p_del">-static void start_clear_flags(struct smi_info *smi_info)</span>
<span class="p_add">+static void start_clear_flags(struct smi_info *smi_info, bool start_timer)</span>
 {
 	unsigned char msg[3];
 
<span class="p_chunk">@@ -424,7 +448,10 @@</span> <span class="p_context"> static void start_clear_flags(struct smi_info *smi_info)</span>
 	msg[1] = IPMI_CLEAR_MSG_FLAGS_CMD;
 	msg[2] = WDT_PRE_TIMEOUT_INT;
 
<span class="p_del">-	smi_info-&gt;handlers-&gt;start_transaction(smi_info-&gt;si_sm, msg, 3);</span>
<span class="p_add">+	if (start_timer)</span>
<span class="p_add">+		start_new_msg(smi_info, msg, 3);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		smi_info-&gt;handlers-&gt;start_transaction(smi_info-&gt;si_sm, msg, 3);</span>
 	smi_info-&gt;si_state = SI_CLEARING_FLAGS;
 }
 
<span class="p_chunk">@@ -434,10 +461,8 @@</span> <span class="p_context"> static void start_getting_msg_queue(struct smi_info *smi_info)</span>
 	smi_info-&gt;curr_msg-&gt;data[1] = IPMI_GET_MSG_CMD;
 	smi_info-&gt;curr_msg-&gt;data_size = 2;
 
<span class="p_del">-	smi_info-&gt;handlers-&gt;start_transaction(</span>
<span class="p_del">-		smi_info-&gt;si_sm,</span>
<span class="p_del">-		smi_info-&gt;curr_msg-&gt;data,</span>
<span class="p_del">-		smi_info-&gt;curr_msg-&gt;data_size);</span>
<span class="p_add">+	start_new_msg(smi_info, smi_info-&gt;curr_msg-&gt;data,</span>
<span class="p_add">+		      smi_info-&gt;curr_msg-&gt;data_size);</span>
 	smi_info-&gt;si_state = SI_GETTING_MESSAGES;
 }
 
<span class="p_chunk">@@ -447,20 +472,11 @@</span> <span class="p_context"> static void start_getting_events(struct smi_info *smi_info)</span>
 	smi_info-&gt;curr_msg-&gt;data[1] = IPMI_READ_EVENT_MSG_BUFFER_CMD;
 	smi_info-&gt;curr_msg-&gt;data_size = 2;
 
<span class="p_del">-	smi_info-&gt;handlers-&gt;start_transaction(</span>
<span class="p_del">-		smi_info-&gt;si_sm,</span>
<span class="p_del">-		smi_info-&gt;curr_msg-&gt;data,</span>
<span class="p_del">-		smi_info-&gt;curr_msg-&gt;data_size);</span>
<span class="p_add">+	start_new_msg(smi_info, smi_info-&gt;curr_msg-&gt;data,</span>
<span class="p_add">+		      smi_info-&gt;curr_msg-&gt;data_size);</span>
 	smi_info-&gt;si_state = SI_GETTING_EVENTS;
 }
 
<span class="p_del">-static void smi_mod_timer(struct smi_info *smi_info, unsigned long new_val)</span>
<span class="p_del">-{</span>
<span class="p_del">-	smi_info-&gt;last_timeout_jiffies = jiffies;</span>
<span class="p_del">-	mod_timer(&amp;smi_info-&gt;si_timer, new_val);</span>
<span class="p_del">-	smi_info-&gt;timer_running = true;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /*
  * When we have a situtaion where we run out of memory and cannot
  * allocate messages, we just leave them in the BMC and run the system
<span class="p_chunk">@@ -470,11 +486,11 @@</span> <span class="p_context"> static void smi_mod_timer(struct smi_info *smi_info, unsigned long new_val)</span>
  * Note that we cannot just use disable_irq(), since the interrupt may
  * be shared.
  */
<span class="p_del">-static inline bool disable_si_irq(struct smi_info *smi_info)</span>
<span class="p_add">+static inline bool disable_si_irq(struct smi_info *smi_info, bool start_timer)</span>
 {
 	if ((smi_info-&gt;irq) &amp;&amp; (!smi_info-&gt;interrupt_disabled)) {
 		smi_info-&gt;interrupt_disabled = true;
<span class="p_del">-		start_check_enables(smi_info);</span>
<span class="p_add">+		start_check_enables(smi_info, start_timer);</span>
 		return true;
 	}
 	return false;
<span class="p_chunk">@@ -484,7 +500,7 @@</span> <span class="p_context"> static inline bool enable_si_irq(struct smi_info *smi_info)</span>
 {
 	if ((smi_info-&gt;irq) &amp;&amp; (smi_info-&gt;interrupt_disabled)) {
 		smi_info-&gt;interrupt_disabled = false;
<span class="p_del">-		start_check_enables(smi_info);</span>
<span class="p_add">+		start_check_enables(smi_info, true);</span>
 		return true;
 	}
 	return false;
<span class="p_chunk">@@ -502,7 +518,7 @@</span> <span class="p_context"> static struct ipmi_smi_msg *alloc_msg_handle_irq(struct smi_info *smi_info)</span>
 
 	msg = ipmi_alloc_smi_msg();
 	if (!msg) {
<span class="p_del">-		if (!disable_si_irq(smi_info))</span>
<span class="p_add">+		if (!disable_si_irq(smi_info, true))</span>
 			smi_info-&gt;si_state = SI_NORMAL;
 	} else if (enable_si_irq(smi_info)) {
 		ipmi_free_smi_msg(msg);
<span class="p_chunk">@@ -518,7 +534,7 @@</span> <span class="p_context"> static void handle_flags(struct smi_info *smi_info)</span>
 		/* Watchdog pre-timeout */
 		smi_inc_stat(smi_info, watchdog_pretimeouts);
 
<span class="p_del">-		start_clear_flags(smi_info);</span>
<span class="p_add">+		start_clear_flags(smi_info, true);</span>
 		smi_info-&gt;msg_flags &amp;= ~WDT_PRE_TIMEOUT_INT;
 		if (smi_info-&gt;intf)
 			ipmi_smi_watchdog_pretimeout(smi_info-&gt;intf);
<span class="p_chunk">@@ -870,8 +886,7 @@</span> <span class="p_context"> static enum si_sm_result smi_event_handler(struct smi_info *smi_info,</span>
 			msg[0] = (IPMI_NETFN_APP_REQUEST &lt;&lt; 2);
 			msg[1] = IPMI_GET_MSG_FLAGS_CMD;
 
<span class="p_del">-			smi_info-&gt;handlers-&gt;start_transaction(</span>
<span class="p_del">-				smi_info-&gt;si_sm, msg, 2);</span>
<span class="p_add">+			start_new_msg(smi_info, msg, 2);</span>
 			smi_info-&gt;si_state = SI_GETTING_FLAGS;
 			goto restart;
 		}
<span class="p_chunk">@@ -901,7 +916,7 @@</span> <span class="p_context"> static enum si_sm_result smi_event_handler(struct smi_info *smi_info,</span>
 		 * disable and messages disabled.
 		 */
 		if (smi_info-&gt;supports_event_msg_buff || smi_info-&gt;irq) {
<span class="p_del">-			start_check_enables(smi_info);</span>
<span class="p_add">+			start_check_enables(smi_info, true);</span>
 		} else {
 			smi_info-&gt;curr_msg = alloc_msg_handle_irq(smi_info);
 			if (!smi_info-&gt;curr_msg)
<span class="p_chunk">@@ -1203,14 +1218,14 @@</span> <span class="p_context"> static int smi_start_processing(void       *send_info,</span>
 
 	new_smi-&gt;intf = intf;
 
<span class="p_del">-	/* Try to claim any interrupts. */</span>
<span class="p_del">-	if (new_smi-&gt;irq_setup)</span>
<span class="p_del">-		new_smi-&gt;irq_setup(new_smi);</span>
<span class="p_del">-</span>
 	/* Set up the timer that drives the interface. */
 	setup_timer(&amp;new_smi-&gt;si_timer, smi_timeout, (long)new_smi);
 	smi_mod_timer(new_smi, jiffies + SI_TIMEOUT_JIFFIES);
 
<span class="p_add">+	/* Try to claim any interrupts. */</span>
<span class="p_add">+	if (new_smi-&gt;irq_setup)</span>
<span class="p_add">+		new_smi-&gt;irq_setup(new_smi);</span>
<span class="p_add">+</span>
 	/*
 	 * Check if the user forcefully enabled the daemon.
 	 */
<span class="p_chunk">@@ -3515,7 +3530,7 @@</span> <span class="p_context"> static int try_smi_init(struct smi_info *new_smi)</span>
 	 * Start clearing the flags before we enable interrupts or the
 	 * timer to avoid racing with the timer.
 	 */
<span class="p_del">-	start_clear_flags(new_smi);</span>
<span class="p_add">+	start_clear_flags(new_smi, false);</span>
 
 	/*
 	 * IRQ is defined to be set when non-zero.  req_events will
<span class="p_chunk">@@ -3817,7 +3832,7 @@</span> <span class="p_context"> static void cleanup_one_si(struct smi_info *to_clean)</span>
 		poll(to_clean);
 		schedule_timeout_uninterruptible(1);
 	}
<span class="p_del">-	disable_si_irq(to_clean);</span>
<span class="p_add">+	disable_si_irq(to_clean, false);</span>
 	while (to_clean-&gt;curr_msg || (to_clean-&gt;si_state != SI_NORMAL)) {
 		poll(to_clean);
 		schedule_timeout_uninterruptible(1);
<span class="p_header">diff --git a/drivers/crypto/nx/nx-aes-ccm.c b/drivers/crypto/nx/nx-aes-ccm.c</span>
<span class="p_header">index e4311ce..a1d0848 100644</span>
<span class="p_header">--- a/drivers/crypto/nx/nx-aes-ccm.c</span>
<span class="p_header">+++ b/drivers/crypto/nx/nx-aes-ccm.c</span>
<span class="p_chunk">@@ -412,7 +412,7 @@</span> <span class="p_context"> static int ccm_nx_decrypt(struct aead_request   *req,</span>
 		processed += to_process;
 	} while (processed &lt; nbytes);
 
<span class="p_del">-	rc = memcmp(csbcpb-&gt;cpb.aes_ccm.out_pat_or_mac, priv-&gt;oauth_tag,</span>
<span class="p_add">+	rc = crypto_memneq(csbcpb-&gt;cpb.aes_ccm.out_pat_or_mac, priv-&gt;oauth_tag,</span>
 		    authsize) ? -EBADMSG : 0;
 out:
 	spin_unlock_irqrestore(&amp;nx_ctx-&gt;lock, irq_flags);
<span class="p_header">diff --git a/drivers/crypto/nx/nx-aes-gcm.c b/drivers/crypto/nx/nx-aes-gcm.c</span>
<span class="p_header">index 92c993f..1c478bc 100644</span>
<span class="p_header">--- a/drivers/crypto/nx/nx-aes-gcm.c</span>
<span class="p_header">+++ b/drivers/crypto/nx/nx-aes-gcm.c</span>
<span class="p_chunk">@@ -414,7 +414,7 @@</span> <span class="p_context"> mac:</span>
 			itag, req-&gt;src, req-&gt;assoclen + nbytes,
 			crypto_aead_authsize(crypto_aead_reqtfm(req)),
 			SCATTERWALK_FROM_SG);
<span class="p_del">-		rc = memcmp(itag, otag,</span>
<span class="p_add">+		rc = crypto_memneq(itag, otag,</span>
 			    crypto_aead_authsize(crypto_aead_reqtfm(req))) ?
 		     -EBADMSG : 0;
 	}
<span class="p_header">diff --git a/drivers/crypto/qat/qat_common/adf_ctl_drv.c b/drivers/crypto/qat/qat_common/adf_ctl_drv.c</span>
<span class="p_header">index e056b9e..0f1d10c 100644</span>
<span class="p_header">--- a/drivers/crypto/qat/qat_common/adf_ctl_drv.c</span>
<span class="p_header">+++ b/drivers/crypto/qat/qat_common/adf_ctl_drv.c</span>
<span class="p_chunk">@@ -198,7 +198,7 @@</span> <span class="p_context"> static int adf_copy_key_value_data(struct adf_accel_dev *accel_dev,</span>
 			goto out_err;
 		}
 
<span class="p_del">-		params_head = section_head-&gt;params;</span>
<span class="p_add">+		params_head = section.params;</span>
 
 		while (params_head) {
 			if (copy_from_user(&amp;key_val, (void __user *)params_head,
<span class="p_header">diff --git a/drivers/crypto/talitos.c b/drivers/crypto/talitos.c</span>
<span class="p_header">index 83aca95..95606c1 100644</span>
<span class="p_header">--- a/drivers/crypto/talitos.c</span>
<span class="p_header">+++ b/drivers/crypto/talitos.c</span>
<span class="p_chunk">@@ -1025,7 +1025,7 @@</span> <span class="p_context"> static void ipsec_esp_decrypt_swauth_done(struct device *dev,</span>
 			icvdata = &amp;edesc-&gt;link_tbl[0];
 
 		sg = sg_last(req-&gt;dst, edesc-&gt;dst_nents ? : 1);
<span class="p_del">-		err = memcmp(icvdata, (char *)sg_virt(sg) + sg-&gt;length -</span>
<span class="p_add">+		err = crypto_memneq(icvdata, (char *)sg_virt(sg) + sg-&gt;length -</span>
 			     ctx-&gt;authsize, ctx-&gt;authsize) ? -EBADMSG : 0;
 	}
 
<span class="p_header">diff --git a/drivers/dma/at_xdmac.c b/drivers/dma/at_xdmac.c</span>
<span class="p_header">index da7917a..c01cdec 100644</span>
<span class="p_header">--- a/drivers/dma/at_xdmac.c</span>
<span class="p_header">+++ b/drivers/dma/at_xdmac.c</span>
<span class="p_chunk">@@ -156,7 +156,7 @@</span> <span class="p_context"></span>
 #define		AT_XDMAC_CC_WRIP	(0x1 &lt;&lt; 23)	/* Write in Progress (read only) */
 #define			AT_XDMAC_CC_WRIP_DONE		(0x0 &lt;&lt; 23)
 #define			AT_XDMAC_CC_WRIP_IN_PROGRESS	(0x1 &lt;&lt; 23)
<span class="p_del">-#define		AT_XDMAC_CC_PERID(i)	(0x7f &amp; (h) &lt;&lt; 24)	/* Channel Peripheral Identifier */</span>
<span class="p_add">+#define		AT_XDMAC_CC_PERID(i)	(0x7f &amp; (i) &lt;&lt; 24)	/* Channel Peripheral Identifier */</span>
 #define AT_XDMAC_CDS_MSP	0x2C	/* Channel Data Stride Memory Set Pattern */
 #define AT_XDMAC_CSUS		0x30	/* Channel Source Microblock Stride */
 #define AT_XDMAC_CDUS		0x34	/* Channel Destination Microblock Stride */
<span class="p_chunk">@@ -1086,6 +1086,7 @@</span> <span class="p_context"> at_xdmac_prep_dma_memcpy(struct dma_chan *chan, dma_addr_t dest, dma_addr_t src,</span>
 		/* Check remaining length and change data width if needed. */
 		dwidth = at_xdmac_align_width(chan,
 					      src_addr | dst_addr | xfer_size);
<span class="p_add">+		chan_cc &amp;= ~AT_XDMAC_CC_DWIDTH_MASK;</span>
 		chan_cc |= AT_XDMAC_CC_DWIDTH(dwidth);
 
 		ublen = xfer_size &gt;&gt; dwidth;
<span class="p_header">diff --git a/drivers/dma/bcm2835-dma.c b/drivers/dma/bcm2835-dma.c</span>
<span class="p_header">index c92d6a7..996c4b0 100644</span>
<span class="p_header">--- a/drivers/dma/bcm2835-dma.c</span>
<span class="p_header">+++ b/drivers/dma/bcm2835-dma.c</span>
<span class="p_chunk">@@ -31,6 +31,7 @@</span> <span class="p_context"></span>
  */
 #include &lt;linux/dmaengine.h&gt;
 #include &lt;linux/dma-mapping.h&gt;
<span class="p_add">+#include &lt;linux/dmapool.h&gt;</span>
 #include &lt;linux/err.h&gt;
 #include &lt;linux/init.h&gt;
 #include &lt;linux/interrupt.h&gt;
<span class="p_chunk">@@ -62,6 +63,11 @@</span> <span class="p_context"> struct bcm2835_dma_cb {</span>
 	uint32_t pad[2];
 };
 
<span class="p_add">+struct bcm2835_cb_entry {</span>
<span class="p_add">+	struct bcm2835_dma_cb *cb;</span>
<span class="p_add">+	dma_addr_t paddr;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 struct bcm2835_chan {
 	struct virt_dma_chan vc;
 	struct list_head node;
<span class="p_chunk">@@ -72,18 +78,18 @@</span> <span class="p_context"> struct bcm2835_chan {</span>
 
 	int ch;
 	struct bcm2835_desc *desc;
<span class="p_add">+	struct dma_pool *cb_pool;</span>
 
 	void __iomem *chan_base;
 	int irq_number;
 };
 
 struct bcm2835_desc {
<span class="p_add">+	struct bcm2835_chan *c;</span>
 	struct virt_dma_desc vd;
 	enum dma_transfer_direction dir;
 
<span class="p_del">-	unsigned int control_block_size;</span>
<span class="p_del">-	struct bcm2835_dma_cb *control_block_base;</span>
<span class="p_del">-	dma_addr_t control_block_base_phys;</span>
<span class="p_add">+	struct bcm2835_cb_entry *cb_list;</span>
 
 	unsigned int frames;
 	size_t size;
<span class="p_chunk">@@ -143,10 +149,13 @@</span> <span class="p_context"> static inline struct bcm2835_desc *to_bcm2835_dma_desc(</span>
 static void bcm2835_dma_desc_free(struct virt_dma_desc *vd)
 {
 	struct bcm2835_desc *desc = container_of(vd, struct bcm2835_desc, vd);
<span class="p_del">-	dma_free_coherent(desc-&gt;vd.tx.chan-&gt;device-&gt;dev,</span>
<span class="p_del">-			desc-&gt;control_block_size,</span>
<span class="p_del">-			desc-&gt;control_block_base,</span>
<span class="p_del">-			desc-&gt;control_block_base_phys);</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; desc-&gt;frames; i++)</span>
<span class="p_add">+		dma_pool_free(desc-&gt;c-&gt;cb_pool, desc-&gt;cb_list[i].cb,</span>
<span class="p_add">+			      desc-&gt;cb_list[i].paddr);</span>
<span class="p_add">+</span>
<span class="p_add">+	kfree(desc-&gt;cb_list);</span>
 	kfree(desc);
 }
 
<span class="p_chunk">@@ -199,7 +208,7 @@</span> <span class="p_context"> static void bcm2835_dma_start_desc(struct bcm2835_chan *c)</span>
 
 	c-&gt;desc = d = to_bcm2835_dma_desc(&amp;vd-&gt;tx);
 
<span class="p_del">-	writel(d-&gt;control_block_base_phys, c-&gt;chan_base + BCM2835_DMA_ADDR);</span>
<span class="p_add">+	writel(d-&gt;cb_list[0].paddr, c-&gt;chan_base + BCM2835_DMA_ADDR);</span>
 	writel(BCM2835_DMA_ACTIVE, c-&gt;chan_base + BCM2835_DMA_CS);
 }
 
<span class="p_chunk">@@ -232,9 +241,16 @@</span> <span class="p_context"> static irqreturn_t bcm2835_dma_callback(int irq, void *data)</span>
 static int bcm2835_dma_alloc_chan_resources(struct dma_chan *chan)
 {
 	struct bcm2835_chan *c = to_bcm2835_dma_chan(chan);
<span class="p_add">+	struct device *dev = c-&gt;vc.chan.device-&gt;dev;</span>
<span class="p_add">+</span>
<span class="p_add">+	dev_dbg(dev, &quot;Allocating DMA channel %d\n&quot;, c-&gt;ch);</span>
 
<span class="p_del">-	dev_dbg(c-&gt;vc.chan.device-&gt;dev,</span>
<span class="p_del">-			&quot;Allocating DMA channel %d\n&quot;, c-&gt;ch);</span>
<span class="p_add">+	c-&gt;cb_pool = dma_pool_create(dev_name(dev), dev,</span>
<span class="p_add">+				     sizeof(struct bcm2835_dma_cb), 0, 0);</span>
<span class="p_add">+	if (!c-&gt;cb_pool) {</span>
<span class="p_add">+		dev_err(dev, &quot;unable to allocate descriptor pool\n&quot;);</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	}</span>
 
 	return request_irq(c-&gt;irq_number,
 			bcm2835_dma_callback, 0, &quot;DMA IRQ&quot;, c);
<span class="p_chunk">@@ -246,6 +262,7 @@</span> <span class="p_context"> static void bcm2835_dma_free_chan_resources(struct dma_chan *chan)</span>
 
 	vchan_free_chan_resources(&amp;c-&gt;vc);
 	free_irq(c-&gt;irq_number, c);
<span class="p_add">+	dma_pool_destroy(c-&gt;cb_pool);</span>
 
 	dev_dbg(c-&gt;vc.chan.device-&gt;dev, &quot;Freeing DMA channel %u\n&quot;, c-&gt;ch);
 }
<span class="p_chunk">@@ -261,8 +278,7 @@</span> <span class="p_context"> static size_t bcm2835_dma_desc_size_pos(struct bcm2835_desc *d, dma_addr_t addr)</span>
 	size_t size;
 
 	for (size = i = 0; i &lt; d-&gt;frames; i++) {
<span class="p_del">-		struct bcm2835_dma_cb *control_block =</span>
<span class="p_del">-			&amp;d-&gt;control_block_base[i];</span>
<span class="p_add">+		struct bcm2835_dma_cb *control_block = d-&gt;cb_list[i].cb;</span>
 		size_t this_size = control_block-&gt;length;
 		dma_addr_t dma;
 
<span class="p_chunk">@@ -343,6 +359,7 @@</span> <span class="p_context"> static struct dma_async_tx_descriptor *bcm2835_dma_prep_dma_cyclic(</span>
 	dma_addr_t dev_addr;
 	unsigned int es, sync_type;
 	unsigned int frame;
<span class="p_add">+	int i;</span>
 
 	/* Grab configuration */
 	if (!is_slave_direction(direction)) {
<span class="p_chunk">@@ -374,27 +391,31 @@</span> <span class="p_context"> static struct dma_async_tx_descriptor *bcm2835_dma_prep_dma_cyclic(</span>
 	if (!d)
 		return NULL;
 
<span class="p_add">+	d-&gt;c = c;</span>
 	d-&gt;dir = direction;
 	d-&gt;frames = buf_len / period_len;
 
<span class="p_del">-	/* Allocate memory for control blocks */</span>
<span class="p_del">-	d-&gt;control_block_size = d-&gt;frames * sizeof(struct bcm2835_dma_cb);</span>
<span class="p_del">-	d-&gt;control_block_base = dma_zalloc_coherent(chan-&gt;device-&gt;dev,</span>
<span class="p_del">-			d-&gt;control_block_size, &amp;d-&gt;control_block_base_phys,</span>
<span class="p_del">-			GFP_NOWAIT);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!d-&gt;control_block_base) {</span>
<span class="p_add">+	d-&gt;cb_list = kcalloc(d-&gt;frames, sizeof(*d-&gt;cb_list), GFP_KERNEL);</span>
<span class="p_add">+	if (!d-&gt;cb_list) {</span>
 		kfree(d);
 		return NULL;
 	}
<span class="p_add">+	/* Allocate memory for control blocks */</span>
<span class="p_add">+	for (i = 0; i &lt; d-&gt;frames; i++) {</span>
<span class="p_add">+		struct bcm2835_cb_entry *cb_entry = &amp;d-&gt;cb_list[i];</span>
<span class="p_add">+</span>
<span class="p_add">+		cb_entry-&gt;cb = dma_pool_zalloc(c-&gt;cb_pool, GFP_ATOMIC,</span>
<span class="p_add">+					       &amp;cb_entry-&gt;paddr);</span>
<span class="p_add">+		if (!cb_entry-&gt;cb)</span>
<span class="p_add">+			goto error_cb;</span>
<span class="p_add">+	}</span>
 
 	/*
 	 * Iterate over all frames, create a control block
 	 * for each frame and link them together.
 	 */
 	for (frame = 0; frame &lt; d-&gt;frames; frame++) {
<span class="p_del">-		struct bcm2835_dma_cb *control_block =</span>
<span class="p_del">-			&amp;d-&gt;control_block_base[frame];</span>
<span class="p_add">+		struct bcm2835_dma_cb *control_block = d-&gt;cb_list[frame].cb;</span>
 
 		/* Setup adresses */
 		if (d-&gt;dir == DMA_DEV_TO_MEM) {
<span class="p_chunk">@@ -428,12 +449,21 @@</span> <span class="p_context"> static struct dma_async_tx_descriptor *bcm2835_dma_prep_dma_cyclic(</span>
 		 * This DMA engine driver currently only supports cyclic DMA.
 		 * Therefore, wrap around at number of frames.
 		 */
<span class="p_del">-		control_block-&gt;next = d-&gt;control_block_base_phys +</span>
<span class="p_del">-			sizeof(struct bcm2835_dma_cb)</span>
<span class="p_del">-			* ((frame + 1) % d-&gt;frames);</span>
<span class="p_add">+		control_block-&gt;next = d-&gt;cb_list[((frame + 1) % d-&gt;frames)].paddr;</span>
 	}
 
 	return vchan_tx_prep(&amp;c-&gt;vc, &amp;d-&gt;vd, flags);
<span class="p_add">+error_cb:</span>
<span class="p_add">+	i--;</span>
<span class="p_add">+	for (; i &gt;= 0; i--) {</span>
<span class="p_add">+		struct bcm2835_cb_entry *cb_entry = &amp;d-&gt;cb_list[i];</span>
<span class="p_add">+</span>
<span class="p_add">+		dma_pool_free(c-&gt;cb_pool, cb_entry-&gt;cb, cb_entry-&gt;paddr);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	kfree(d-&gt;cb_list);</span>
<span class="p_add">+	kfree(d);</span>
<span class="p_add">+	return NULL;</span>
 }
 
 static int bcm2835_dma_slave_config(struct dma_chan *chan,
<span class="p_header">diff --git a/drivers/firmware/dmi_scan.c b/drivers/firmware/dmi_scan.c</span>
<span class="p_header">index ac1ce4a..0e08e66 100644</span>
<span class="p_header">--- a/drivers/firmware/dmi_scan.c</span>
<span class="p_header">+++ b/drivers/firmware/dmi_scan.c</span>
<span class="p_chunk">@@ -521,6 +521,7 @@</span> <span class="p_context"> static int __init dmi_present(const u8 *buf)</span>
 			dmi_ver = smbios_ver;
 		else
 			dmi_ver = (buf[14] &amp; 0xF0) &lt;&lt; 4 | (buf[14] &amp; 0x0F);
<span class="p_add">+		dmi_ver &lt;&lt;= 8;</span>
 		dmi_num = get_unaligned_le16(buf + 12);
 		dmi_len = get_unaligned_le16(buf + 6);
 		dmi_base = get_unaligned_le32(buf + 8);
<span class="p_chunk">@@ -528,15 +529,14 @@</span> <span class="p_context"> static int __init dmi_present(const u8 *buf)</span>
 		if (dmi_walk_early(dmi_decode) == 0) {
 			if (smbios_ver) {
 				pr_info(&quot;SMBIOS %d.%d present.\n&quot;,
<span class="p_del">-				       dmi_ver &gt;&gt; 8, dmi_ver &amp; 0xFF);</span>
<span class="p_add">+					dmi_ver &gt;&gt; 16, (dmi_ver &gt;&gt; 8) &amp; 0xFF);</span>
 			} else {
 				smbios_entry_point_size = 15;
 				memcpy(smbios_entry_point, buf,
 				       smbios_entry_point_size);
 				pr_info(&quot;Legacy DMI %d.%d present.\n&quot;,
<span class="p_del">-				       dmi_ver &gt;&gt; 8, dmi_ver &amp; 0xFF);</span>
<span class="p_add">+					dmi_ver &gt;&gt; 16, (dmi_ver &gt;&gt; 8) &amp; 0xFF);</span>
 			}
<span class="p_del">-			dmi_ver &lt;&lt;= 8;</span>
 			dmi_format_ids(dmi_ids_string, sizeof(dmi_ids_string));
 			printk(KERN_DEBUG &quot;DMI: %s\n&quot;, dmi_ids_string);
 			return 0;
<span class="p_header">diff --git a/drivers/gpio/gpio-omap.c b/drivers/gpio/gpio-omap.c</span>
<span class="p_header">index 61a731f..5dc94b4 100644</span>
<span class="p_header">--- a/drivers/gpio/gpio-omap.c</span>
<span class="p_header">+++ b/drivers/gpio/gpio-omap.c</span>
<span class="p_chunk">@@ -1118,8 +1118,6 @@</span> <span class="p_context"> static int omap_gpio_chip_init(struct gpio_bank *bank, struct irq_chip *irqc)</span>
 	/* MPUIO is a bit different, reading IRQ status clears it */
 	if (bank-&gt;is_mpuio) {
 		irqc-&gt;irq_ack = dummy_irq_chip.irq_ack;
<span class="p_del">-		irqc-&gt;irq_mask = irq_gc_mask_set_bit;</span>
<span class="p_del">-		irqc-&gt;irq_unmask = irq_gc_mask_clr_bit;</span>
 		if (!bank-&gt;regs-&gt;wkup_en)
 			irqc-&gt;irq_set_wake = NULL;
 	}
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_gem.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_gem.c</span>
<span class="p_header">index 4afc507..35f5e3d 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_gem.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_gem.c</span>
<span class="p_chunk">@@ -241,8 +241,9 @@</span> <span class="p_context"> int amdgpu_gem_userptr_ioctl(struct drm_device *dev, void *data,</span>
 	    AMDGPU_GEM_USERPTR_REGISTER))
 		return -EINVAL;
 
<span class="p_del">-	if (!(args-&gt;flags &amp; AMDGPU_GEM_USERPTR_ANONONLY) ||</span>
<span class="p_del">-		   !(args-&gt;flags &amp; AMDGPU_GEM_USERPTR_REGISTER)) {</span>
<span class="p_add">+	if (!(args-&gt;flags &amp; AMDGPU_GEM_USERPTR_READONLY) &amp;&amp; (</span>
<span class="p_add">+	     !(args-&gt;flags &amp; AMDGPU_GEM_USERPTR_ANONONLY) ||</span>
<span class="p_add">+	     !(args-&gt;flags &amp; AMDGPU_GEM_USERPTR_REGISTER))) {</span>
 
 		/* if we want to write to it we must require anonymous
 		   memory and install a MMU notifier */
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/gmc_v7_0.c b/drivers/gpu/drm/amd/amdgpu/gmc_v7_0.c</span>
<span class="p_header">index ae37fce..c735b86 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/gmc_v7_0.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/gmc_v7_0.c</span>
<span class="p_chunk">@@ -474,6 +474,7 @@</span> <span class="p_context"> static int gmc_v7_0_gart_enable(struct amdgpu_device *adev)</span>
 	tmp = REG_SET_FIELD(tmp, VM_L2_CNTL, ENABLE_L2_PDE0_CACHE_LRU_UPDATE_BY_WRITE, 1);
 	tmp = REG_SET_FIELD(tmp, VM_L2_CNTL, EFFECTIVE_L2_QUEUE_SIZE, 7);
 	tmp = REG_SET_FIELD(tmp, VM_L2_CNTL, CONTEXT1_IDENTITY_ACCESS_MODE, 1);
<span class="p_add">+	tmp = REG_SET_FIELD(tmp, VM_L2_CNTL, ENABLE_DEFAULT_PAGE_OUT_TO_SYSTEM_MEMORY, 1);</span>
 	WREG32(mmVM_L2_CNTL, tmp);
 	tmp = REG_SET_FIELD(0, VM_L2_CNTL2, INVALIDATE_ALL_L1_TLBS, 1);
 	tmp = REG_SET_FIELD(tmp, VM_L2_CNTL2, INVALIDATE_L2_CACHE, 1);
<span class="p_chunk">@@ -485,7 +486,7 @@</span> <span class="p_context"> static int gmc_v7_0_gart_enable(struct amdgpu_device *adev)</span>
 	WREG32(mmVM_L2_CNTL3, tmp);
 	/* setup context0 */
 	WREG32(mmVM_CONTEXT0_PAGE_TABLE_START_ADDR, adev-&gt;mc.gtt_start &gt;&gt; 12);
<span class="p_del">-	WREG32(mmVM_CONTEXT0_PAGE_TABLE_END_ADDR, (adev-&gt;mc.gtt_end &gt;&gt; 12) - 1);</span>
<span class="p_add">+	WREG32(mmVM_CONTEXT0_PAGE_TABLE_END_ADDR, adev-&gt;mc.gtt_end &gt;&gt; 12);</span>
 	WREG32(mmVM_CONTEXT0_PAGE_TABLE_BASE_ADDR, adev-&gt;gart.table_addr &gt;&gt; 12);
 	WREG32(mmVM_CONTEXT0_PROTECTION_FAULT_DEFAULT_ADDR,
 			(u32)(adev-&gt;dummy_page.addr &gt;&gt; 12));
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/gmc_v8_0.c b/drivers/gpu/drm/amd/amdgpu/gmc_v8_0.c</span>
<span class="p_header">index 8135963..e41ff6a 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/gmc_v8_0.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/gmc_v8_0.c</span>
<span class="p_chunk">@@ -563,6 +563,7 @@</span> <span class="p_context"> static int gmc_v8_0_gart_enable(struct amdgpu_device *adev)</span>
 	tmp = REG_SET_FIELD(tmp, VM_L2_CNTL, ENABLE_L2_PDE0_CACHE_LRU_UPDATE_BY_WRITE, 1);
 	tmp = REG_SET_FIELD(tmp, VM_L2_CNTL, EFFECTIVE_L2_QUEUE_SIZE, 7);
 	tmp = REG_SET_FIELD(tmp, VM_L2_CNTL, CONTEXT1_IDENTITY_ACCESS_MODE, 1);
<span class="p_add">+	tmp = REG_SET_FIELD(tmp, VM_L2_CNTL, ENABLE_DEFAULT_PAGE_OUT_TO_SYSTEM_MEMORY, 1);</span>
 	WREG32(mmVM_L2_CNTL, tmp);
 	tmp = RREG32(mmVM_L2_CNTL2);
 	tmp = REG_SET_FIELD(tmp, VM_L2_CNTL2, INVALIDATE_ALL_L1_TLBS, 1);
<span class="p_chunk">@@ -590,7 +591,7 @@</span> <span class="p_context"> static int gmc_v8_0_gart_enable(struct amdgpu_device *adev)</span>
 	WREG32(mmVM_L2_CNTL4, tmp);
 	/* setup context0 */
 	WREG32(mmVM_CONTEXT0_PAGE_TABLE_START_ADDR, adev-&gt;mc.gtt_start &gt;&gt; 12);
<span class="p_del">-	WREG32(mmVM_CONTEXT0_PAGE_TABLE_END_ADDR, (adev-&gt;mc.gtt_end &gt;&gt; 12) - 1);</span>
<span class="p_add">+	WREG32(mmVM_CONTEXT0_PAGE_TABLE_END_ADDR, adev-&gt;mc.gtt_end &gt;&gt; 12);</span>
 	WREG32(mmVM_CONTEXT0_PAGE_TABLE_BASE_ADDR, adev-&gt;gart.table_addr &gt;&gt; 12);
 	WREG32(mmVM_CONTEXT0_PROTECTION_FAULT_DEFAULT_ADDR,
 			(u32)(adev-&gt;dummy_page.addr &gt;&gt; 12));
<span class="p_header">diff --git a/drivers/gpu/drm/drm_drv.c b/drivers/gpu/drm/drm_drv.c</span>
<span class="p_header">index b7bf4ce..572998d 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_drv.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_drv.c</span>
<span class="p_chunk">@@ -163,6 +163,11 @@</span> <span class="p_context"> int drm_setmaster_ioctl(struct drm_device *dev, void *data,</span>
 		goto out_unlock;
 	}
 
<span class="p_add">+	if (!file_priv-&gt;allowed_master) {</span>
<span class="p_add">+		ret = drm_new_set_master(dev, file_priv);</span>
<span class="p_add">+		goto out_unlock;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	file_priv-&gt;minor-&gt;master = drm_master_get(file_priv-&gt;master);
 	file_priv-&gt;is_master = 1;
 	if (dev-&gt;driver-&gt;master_set) {
<span class="p_header">diff --git a/drivers/gpu/drm/drm_fops.c b/drivers/gpu/drm/drm_fops.c</span>
<span class="p_header">index c59ce4d..6b5625e 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_fops.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_fops.c</span>
<span class="p_chunk">@@ -126,6 +126,60 @@</span> <span class="p_context"> static int drm_cpu_valid(void)</span>
 }
 
 /**
<span class="p_add">+ * drm_new_set_master - Allocate a new master object and become master for the</span>
<span class="p_add">+ * associated master realm.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * @dev: The associated device.</span>
<span class="p_add">+ * @fpriv: File private identifying the client.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This function must be called with dev::struct_mutex held.</span>
<span class="p_add">+ * Returns negative error code on failure. Zero on success.</span>
<span class="p_add">+ */</span>
<span class="p_add">+int drm_new_set_master(struct drm_device *dev, struct drm_file *fpriv)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct drm_master *old_master;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	lockdep_assert_held_once(&amp;dev-&gt;master_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* create a new master */</span>
<span class="p_add">+	fpriv-&gt;minor-&gt;master = drm_master_create(fpriv-&gt;minor);</span>
<span class="p_add">+	if (!fpriv-&gt;minor-&gt;master)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* take another reference for the copy in the local file priv */</span>
<span class="p_add">+	old_master = fpriv-&gt;master;</span>
<span class="p_add">+	fpriv-&gt;master = drm_master_get(fpriv-&gt;minor-&gt;master);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (dev-&gt;driver-&gt;master_create) {</span>
<span class="p_add">+		ret = dev-&gt;driver-&gt;master_create(dev, fpriv-&gt;master);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			goto out_err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (dev-&gt;driver-&gt;master_set) {</span>
<span class="p_add">+		ret = dev-&gt;driver-&gt;master_set(dev, fpriv, true);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			goto out_err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	fpriv-&gt;is_master = 1;</span>
<span class="p_add">+	fpriv-&gt;allowed_master = 1;</span>
<span class="p_add">+	fpriv-&gt;authenticated = 1;</span>
<span class="p_add">+	if (old_master)</span>
<span class="p_add">+		drm_master_put(&amp;old_master);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+out_err:</span>
<span class="p_add">+	/* drop both references and restore old master on failure */</span>
<span class="p_add">+	drm_master_put(&amp;fpriv-&gt;minor-&gt;master);</span>
<span class="p_add">+	drm_master_put(&amp;fpriv-&gt;master);</span>
<span class="p_add">+	fpriv-&gt;master = old_master;</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
  * Called whenever a process opens /dev/drm.
  *
  * \param filp file pointer.
<span class="p_chunk">@@ -189,35 +243,9 @@</span> <span class="p_context"> static int drm_open_helper(struct file *filp, struct drm_minor *minor)</span>
 	mutex_lock(&amp;dev-&gt;master_mutex);
 	if (drm_is_primary_client(priv) &amp;&amp; !priv-&gt;minor-&gt;master) {
 		/* create a new master */
<span class="p_del">-		priv-&gt;minor-&gt;master = drm_master_create(priv-&gt;minor);</span>
<span class="p_del">-		if (!priv-&gt;minor-&gt;master) {</span>
<span class="p_del">-			ret = -ENOMEM;</span>
<span class="p_add">+		ret = drm_new_set_master(dev, priv);</span>
<span class="p_add">+		if (ret)</span>
 			goto out_close;
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		priv-&gt;is_master = 1;</span>
<span class="p_del">-		/* take another reference for the copy in the local file priv */</span>
<span class="p_del">-		priv-&gt;master = drm_master_get(priv-&gt;minor-&gt;master);</span>
<span class="p_del">-		priv-&gt;authenticated = 1;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (dev-&gt;driver-&gt;master_create) {</span>
<span class="p_del">-			ret = dev-&gt;driver-&gt;master_create(dev, priv-&gt;master);</span>
<span class="p_del">-			if (ret) {</span>
<span class="p_del">-				/* drop both references if this fails */</span>
<span class="p_del">-				drm_master_put(&amp;priv-&gt;minor-&gt;master);</span>
<span class="p_del">-				drm_master_put(&amp;priv-&gt;master);</span>
<span class="p_del">-				goto out_close;</span>
<span class="p_del">-			}</span>
<span class="p_del">-		}</span>
<span class="p_del">-		if (dev-&gt;driver-&gt;master_set) {</span>
<span class="p_del">-			ret = dev-&gt;driver-&gt;master_set(dev, priv, true);</span>
<span class="p_del">-			if (ret) {</span>
<span class="p_del">-				/* drop both references if this fails */</span>
<span class="p_del">-				drm_master_put(&amp;priv-&gt;minor-&gt;master);</span>
<span class="p_del">-				drm_master_put(&amp;priv-&gt;master);</span>
<span class="p_del">-				goto out_close;</span>
<span class="p_del">-			}</span>
<span class="p_del">-		}</span>
 	} else if (drm_is_primary_client(priv)) {
 		/* get a reference to the master */
 		priv-&gt;master = drm_master_get(priv-&gt;minor-&gt;master);
<span class="p_header">diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c</span>
<span class="p_header">index 04203c0..d0149c4 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_probe_helper.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_probe_helper.c</span>
<span class="p_chunk">@@ -195,7 +195,8 @@</span> <span class="p_context"> static int drm_helper_probe_single_connector_modes_merge_bits(struct drm_connect</span>
 		mode_flags |= DRM_MODE_FLAG_3D_MASK;
 
 	list_for_each_entry(mode, &amp;connector-&gt;modes, head) {
<span class="p_del">-		mode-&gt;status = drm_mode_validate_basic(mode);</span>
<span class="p_add">+		if (mode-&gt;status == MODE_OK)</span>
<span class="p_add">+			mode-&gt;status = drm_mode_validate_basic(mode);</span>
 
 		if (mode-&gt;status == MODE_OK)
 			mode-&gt;status = drm_mode_validate_size(mode, maxX, maxY);
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_drv.h b/drivers/gpu/drm/i915/i915_drv.h</span>
<span class="p_header">index e1df8feb..f4e2f54 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_drv.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_drv.h</span>
<span class="p_chunk">@@ -2119,8 +2119,17 @@</span> <span class="p_context"> struct drm_i915_gem_request {</span>
 	struct drm_i915_private *i915;
 	struct intel_engine_cs *ring;
 
<span class="p_del">-	/** GEM sequence number associated with this request. */</span>
<span class="p_del">-	uint32_t seqno;</span>
<span class="p_add">+	 /** GEM sequence number associated with the previous request,</span>
<span class="p_add">+	  * when the HWS breadcrumb is equal to this the GPU is processing</span>
<span class="p_add">+	  * this request.</span>
<span class="p_add">+	  */</span>
<span class="p_add">+	u32 previous_seqno;</span>
<span class="p_add">+</span>
<span class="p_add">+	 /** GEM sequence number associated with this request,</span>
<span class="p_add">+	  * when the HWS breadcrumb is equal or greater than this the GPU</span>
<span class="p_add">+	  * has finished processing this request.</span>
<span class="p_add">+	  */</span>
<span class="p_add">+	u32 seqno;</span>
 
 	/** Position in the ringbuffer of the start of the request */
 	u32 head;
<span class="p_chunk">@@ -2797,15 +2806,17 @@</span> <span class="p_context"> i915_seqno_passed(uint32_t seq1, uint32_t seq2)</span>
 	return (int32_t)(seq1 - seq2) &gt;= 0;
 }
 
<span class="p_add">+static inline bool i915_gem_request_started(struct drm_i915_gem_request *req,</span>
<span class="p_add">+					   bool lazy_coherency)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 seqno = req-&gt;ring-&gt;get_seqno(req-&gt;ring, lazy_coherency);</span>
<span class="p_add">+	return i915_seqno_passed(seqno, req-&gt;previous_seqno);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline bool i915_gem_request_completed(struct drm_i915_gem_request *req,
 					      bool lazy_coherency)
 {
<span class="p_del">-	u32 seqno;</span>
<span class="p_del">-</span>
<span class="p_del">-	BUG_ON(req == NULL);</span>
<span class="p_del">-</span>
<span class="p_del">-	seqno = req-&gt;ring-&gt;get_seqno(req-&gt;ring, lazy_coherency);</span>
<span class="p_del">-</span>
<span class="p_add">+	u32 seqno = req-&gt;ring-&gt;get_seqno(req-&gt;ring, lazy_coherency);</span>
 	return i915_seqno_passed(seqno, req-&gt;seqno);
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_gem.c b/drivers/gpu/drm/i915/i915_gem.c</span>
<span class="p_header">index 52b446b..da7653c 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_gem.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_gem.c</span>
<span class="p_chunk">@@ -1174,23 +1174,74 @@</span> <span class="p_context"> static bool missed_irq(struct drm_i915_private *dev_priv,</span>
 	return test_bit(ring-&gt;id, &amp;dev_priv-&gt;gpu_error.missed_irq_rings);
 }
 
<span class="p_del">-static int __i915_spin_request(struct drm_i915_gem_request *req)</span>
<span class="p_add">+static unsigned long local_clock_us(unsigned *cpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long t;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Cheaply and approximately convert from nanoseconds to microseconds.</span>
<span class="p_add">+	 * The result and subsequent calculations are also defined in the same</span>
<span class="p_add">+	 * approximate microseconds units. The principal source of timing</span>
<span class="p_add">+	 * error here is from the simple truncation.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Note that local_clock() is only defined wrt to the current CPU;</span>
<span class="p_add">+	 * the comparisons are no longer valid if we switch CPUs. Instead of</span>
<span class="p_add">+	 * blocking preemption for the entire busywait, we can detect the CPU</span>
<span class="p_add">+	 * switch and use that as indicator of system load and a reason to</span>
<span class="p_add">+	 * stop busywaiting, see busywait_stop().</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	*cpu = get_cpu();</span>
<span class="p_add">+	t = local_clock() &gt;&gt; 10;</span>
<span class="p_add">+	put_cpu();</span>
<span class="p_add">+</span>
<span class="p_add">+	return t;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static bool busywait_stop(unsigned long timeout, unsigned cpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned this_cpu;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (time_after(local_clock_us(&amp;this_cpu), timeout))</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+</span>
<span class="p_add">+	return this_cpu != cpu;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int __i915_spin_request(struct drm_i915_gem_request *req, int state)</span>
 {
 	unsigned long timeout;
<span class="p_add">+	unsigned cpu;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* When waiting for high frequency requests, e.g. during synchronous</span>
<span class="p_add">+	 * rendering split between the CPU and GPU, the finite amount of time</span>
<span class="p_add">+	 * required to set up the irq and wait upon it limits the response</span>
<span class="p_add">+	 * rate. By busywaiting on the request completion for a short while we</span>
<span class="p_add">+	 * can service the high frequency waits as quick as possible. However,</span>
<span class="p_add">+	 * if it is a slow request, we want to sleep as quickly as possible.</span>
<span class="p_add">+	 * The tradeoff between waiting and sleeping is roughly the time it</span>
<span class="p_add">+	 * takes to sleep on a request, on the order of a microsecond.</span>
<span class="p_add">+	 */</span>
 
<span class="p_del">-	if (i915_gem_request_get_ring(req)-&gt;irq_refcount)</span>
<span class="p_add">+	if (req-&gt;ring-&gt;irq_refcount)</span>
 		return -EBUSY;
 
<span class="p_del">-	timeout = jiffies + 1;</span>
<span class="p_add">+	/* Only spin if we know the GPU is processing this request */</span>
<span class="p_add">+	if (!i915_gem_request_started(req, true))</span>
<span class="p_add">+		return -EAGAIN;</span>
<span class="p_add">+</span>
<span class="p_add">+	timeout = local_clock_us(&amp;cpu) + 5;</span>
 	while (!need_resched()) {
 		if (i915_gem_request_completed(req, true))
 			return 0;
 
<span class="p_del">-		if (time_after_eq(jiffies, timeout))</span>
<span class="p_add">+		if (signal_pending_state(state, current))</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (busywait_stop(timeout, cpu))</span>
 			break;
 
 		cpu_relax_lowlatency();
 	}
<span class="p_add">+</span>
 	if (i915_gem_request_completed(req, false))
 		return 0;
 
<span class="p_chunk">@@ -1225,6 +1276,7 @@</span> <span class="p_context"> int __i915_wait_request(struct drm_i915_gem_request *req,</span>
 	struct drm_i915_private *dev_priv = dev-&gt;dev_private;
 	const bool irq_test_in_progress =
 		ACCESS_ONCE(dev_priv-&gt;gpu_error.test_irq_rings) &amp; intel_ring_flag(ring);
<span class="p_add">+	int state = interruptible ? TASK_INTERRUPTIBLE : TASK_UNINTERRUPTIBLE;</span>
 	DEFINE_WAIT(wait);
 	unsigned long timeout_expire;
 	s64 before, now;
<span class="p_chunk">@@ -1249,7 +1301,7 @@</span> <span class="p_context"> int __i915_wait_request(struct drm_i915_gem_request *req,</span>
 	before = ktime_get_raw_ns();
 
 	/* Optimistic spin for the next jiffie before touching IRQs */
<span class="p_del">-	ret = __i915_spin_request(req);</span>
<span class="p_add">+	ret = __i915_spin_request(req, state);</span>
 	if (ret == 0)
 		goto out;
 
<span class="p_chunk">@@ -1261,8 +1313,7 @@</span> <span class="p_context"> int __i915_wait_request(struct drm_i915_gem_request *req,</span>
 	for (;;) {
 		struct timer_list timer;
 
<span class="p_del">-		prepare_to_wait(&amp;ring-&gt;irq_queue, &amp;wait,</span>
<span class="p_del">-				interruptible ? TASK_INTERRUPTIBLE : TASK_UNINTERRUPTIBLE);</span>
<span class="p_add">+		prepare_to_wait(&amp;ring-&gt;irq_queue, &amp;wait, state);</span>
 
 		/* We need to check whether any gpu reset happened in between
 		 * the caller grabbing the seqno and now ... */
<span class="p_chunk">@@ -1280,7 +1331,7 @@</span> <span class="p_context"> int __i915_wait_request(struct drm_i915_gem_request *req,</span>
 			break;
 		}
 
<span class="p_del">-		if (interruptible &amp;&amp; signal_pending(current)) {</span>
<span class="p_add">+		if (signal_pending_state(state, current)) {</span>
 			ret = -ERESTARTSYS;
 			break;
 		}
<span class="p_chunk">@@ -2548,6 +2599,7 @@</span> <span class="p_context"> int __i915_add_request(struct intel_engine_cs *ring,</span>
 	}
 
 	request-&gt;emitted_jiffies = jiffies;
<span class="p_add">+	request-&gt;previous_seqno = ring-&gt;last_submitted_seqno;</span>
 	ring-&gt;last_submitted_seqno = request-&gt;seqno;
 	list_add_tail(&amp;request-&gt;list, &amp;ring-&gt;request_list);
 	request-&gt;file_priv = NULL;
<span class="p_chunk">@@ -4048,6 +4100,7 @@</span> <span class="p_context"> int i915_gem_get_caching_ioctl(struct drm_device *dev, void *data,</span>
 int i915_gem_set_caching_ioctl(struct drm_device *dev, void *data,
 			       struct drm_file *file)
 {
<span class="p_add">+	struct drm_i915_private *dev_priv = dev-&gt;dev_private;</span>
 	struct drm_i915_gem_caching *args = data;
 	struct drm_i915_gem_object *obj;
 	enum i915_cache_level level;
<span class="p_chunk">@@ -4067,9 +4120,11 @@</span> <span class="p_context"> int i915_gem_set_caching_ioctl(struct drm_device *dev, void *data,</span>
 		return -EINVAL;
 	}
 
<span class="p_add">+	intel_runtime_pm_get(dev_priv);</span>
<span class="p_add">+</span>
 	ret = i915_mutex_lock_interruptible(dev);
 	if (ret)
<span class="p_del">-		return ret;</span>
<span class="p_add">+		goto rpm_put;</span>
 
 	obj = to_intel_bo(drm_gem_object_lookup(dev, file, args-&gt;handle));
 	if (&amp;obj-&gt;base == NULL) {
<span class="p_chunk">@@ -4082,6 +4137,9 @@</span> <span class="p_context"> int i915_gem_set_caching_ioctl(struct drm_device *dev, void *data,</span>
 	drm_gem_object_unreference(&amp;obj-&gt;base);
 unlock:
 	mutex_unlock(&amp;dev-&gt;struct_mutex);
<span class="p_add">+rpm_put:</span>
<span class="p_add">+	intel_runtime_pm_put(dev_priv);</span>
<span class="p_add">+</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_gem_tiling.c b/drivers/gpu/drm/i915/i915_gem_tiling.c</span>
<span class="p_header">index d19c9db..f19bd4f 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_gem_tiling.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_gem_tiling.c</span>
<span class="p_chunk">@@ -180,11 +180,10 @@</span> <span class="p_context"> i915_gem_detect_bit_6_swizzle(struct drm_device *dev)</span>
 		}
 
 		/* check for L-shaped memory aka modified enhanced addressing */
<span class="p_del">-		if (IS_GEN4(dev)) {</span>
<span class="p_del">-			uint32_t ddc2 = I915_READ(DCC2);</span>
<span class="p_del">-</span>
<span class="p_del">-			if (!(ddc2 &amp; DCC2_MODIFIED_ENHANCED_DISABLE))</span>
<span class="p_del">-				dev_priv-&gt;quirks |= QUIRK_PIN_SWIZZLED_PAGES;</span>
<span class="p_add">+		if (IS_GEN4(dev) &amp;&amp;</span>
<span class="p_add">+		    !(I915_READ(DCC2) &amp; DCC2_MODIFIED_ENHANCED_DISABLE)) {</span>
<span class="p_add">+			swizzle_x = I915_BIT_6_SWIZZLE_UNKNOWN;</span>
<span class="p_add">+			swizzle_y = I915_BIT_6_SWIZZLE_UNKNOWN;</span>
 		}
 
 		if (dcc == 0xffffffff) {
<span class="p_chunk">@@ -213,16 +212,35 @@</span> <span class="p_context"> i915_gem_detect_bit_6_swizzle(struct drm_device *dev)</span>
 		 * matching, which was the case for the swizzling required in
 		 * the table above, or from the 1-ch value being less than
 		 * the minimum size of a rank.
<span class="p_add">+		 *</span>
<span class="p_add">+		 * Reports indicate that the swizzling actually</span>
<span class="p_add">+		 * varies depending upon page placement inside the</span>
<span class="p_add">+		 * channels, i.e. we see swizzled pages where the</span>
<span class="p_add">+		 * banks of memory are paired and unswizzled on the</span>
<span class="p_add">+		 * uneven portion, so leave that as unknown.</span>
 		 */
<span class="p_del">-		if (I915_READ16(C0DRB3) != I915_READ16(C1DRB3)) {</span>
<span class="p_del">-			swizzle_x = I915_BIT_6_SWIZZLE_NONE;</span>
<span class="p_del">-			swizzle_y = I915_BIT_6_SWIZZLE_NONE;</span>
<span class="p_del">-		} else {</span>
<span class="p_add">+		if (I915_READ16(C0DRB3) == I915_READ16(C1DRB3)) {</span>
 			swizzle_x = I915_BIT_6_SWIZZLE_9_10;
 			swizzle_y = I915_BIT_6_SWIZZLE_9;
 		}
 	}
 
<span class="p_add">+	if (swizzle_x == I915_BIT_6_SWIZZLE_UNKNOWN ||</span>
<span class="p_add">+	    swizzle_y == I915_BIT_6_SWIZZLE_UNKNOWN) {</span>
<span class="p_add">+		/* Userspace likes to explode if it sees unknown swizzling,</span>
<span class="p_add">+		 * so lie. We will finish the lie when reporting through</span>
<span class="p_add">+		 * the get-tiling-ioctl by reporting the physical swizzle</span>
<span class="p_add">+		 * mode as unknown instead.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * As we don&#39;t strictly know what the swizzling is, it may be</span>
<span class="p_add">+		 * bit17 dependent, and so we need to also prevent the pages</span>
<span class="p_add">+		 * from being moved.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		dev_priv-&gt;quirks |= QUIRK_PIN_SWIZZLED_PAGES;</span>
<span class="p_add">+		swizzle_x = I915_BIT_6_SWIZZLE_NONE;</span>
<span class="p_add">+		swizzle_y = I915_BIT_6_SWIZZLE_NONE;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	dev_priv-&gt;mm.bit_6_swizzle_x = swizzle_x;
 	dev_priv-&gt;mm.bit_6_swizzle_y = swizzle_y;
 }
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_display.c b/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_header">index 8a6da7f..05bf98d 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_chunk">@@ -14265,16 +14265,17 @@</span> <span class="p_context"> static int intel_framebuffer_init(struct drm_device *dev,</span>
 static struct drm_framebuffer *
 intel_user_framebuffer_create(struct drm_device *dev,
 			      struct drm_file *filp,
<span class="p_del">-			      struct drm_mode_fb_cmd2 *mode_cmd)</span>
<span class="p_add">+			      struct drm_mode_fb_cmd2 *user_mode_cmd)</span>
 {
 	struct drm_i915_gem_object *obj;
<span class="p_add">+	struct drm_mode_fb_cmd2 mode_cmd = *user_mode_cmd;</span>
 
 	obj = to_intel_bo(drm_gem_object_lookup(dev, filp,
<span class="p_del">-						mode_cmd-&gt;handles[0]));</span>
<span class="p_add">+						mode_cmd.handles[0]));</span>
 	if (&amp;obj-&gt;base == NULL)
 		return ERR_PTR(-ENOENT);
 
<span class="p_del">-	return intel_framebuffer_create(dev, mode_cmd, obj);</span>
<span class="p_add">+	return intel_framebuffer_create(dev, &amp;mode_cmd, obj);</span>
 }
 
 #ifndef CONFIG_DRM_I915_FBDEV
<span class="p_chunk">@@ -14584,6 +14585,9 @@</span> <span class="p_context"> static struct intel_quirk intel_quirks[] = {</span>
 	/* Apple Macbook 2,1 (Core 2 T7400) */
 	{ 0x27a2, 0x8086, 0x7270, quirk_backlight_present },
 
<span class="p_add">+	/* Apple Macbook 4,1 */</span>
<span class="p_add">+	{ 0x2a02, 0x106b, 0x00a1, quirk_backlight_present },</span>
<span class="p_add">+</span>
 	/* Toshiba CB35 Chromebook (Celeron 2955U) */
 	{ 0x0a06, 0x1179, 0x0a88, quirk_backlight_present },
 
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_dp.c b/drivers/gpu/drm/i915/intel_dp.c</span>
<span class="p_header">index ca2d923..da3c653 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_dp.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_dp.c</span>
<span class="p_chunk">@@ -4947,7 +4947,8 @@</span> <span class="p_context"> intel_dp_hpd_pulse(struct intel_digital_port *intel_dig_port, bool long_hpd)</span>
 	enum intel_display_power_domain power_domain;
 	enum irqreturn ret = IRQ_NONE;
 
<span class="p_del">-	if (intel_dig_port-&gt;base.type != INTEL_OUTPUT_EDP)</span>
<span class="p_add">+	if (intel_dig_port-&gt;base.type != INTEL_OUTPUT_EDP &amp;&amp;</span>
<span class="p_add">+	    intel_dig_port-&gt;base.type != INTEL_OUTPUT_HDMI)</span>
 		intel_dig_port-&gt;base.type = INTEL_OUTPUT_DISPLAYPORT;
 
 	if (long_hpd &amp;&amp; intel_dig_port-&gt;base.type == INTEL_OUTPUT_EDP) {
<span class="p_header">diff --git a/drivers/gpu/drm/imx/ipuv3-crtc.c b/drivers/gpu/drm/imx/ipuv3-crtc.c</span>
<span class="p_header">index 7bc8301..7ce1df0 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/imx/ipuv3-crtc.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/imx/ipuv3-crtc.c</span>
<span class="p_chunk">@@ -212,7 +212,8 @@</span> <span class="p_context"> static void ipu_crtc_handle_pageflip(struct ipu_crtc *ipu_crtc)</span>
 
 	spin_lock_irqsave(&amp;drm-&gt;event_lock, flags);
 	if (ipu_crtc-&gt;page_flip_event)
<span class="p_del">-		drm_send_vblank_event(drm, -1, ipu_crtc-&gt;page_flip_event);</span>
<span class="p_add">+		drm_crtc_send_vblank_event(&amp;ipu_crtc-&gt;base,</span>
<span class="p_add">+					   ipu_crtc-&gt;page_flip_event);</span>
 	ipu_crtc-&gt;page_flip_event = NULL;
 	imx_drm_crtc_vblank_put(ipu_crtc-&gt;imx_crtc);
 	spin_unlock_irqrestore(&amp;drm-&gt;event_lock, flags);
<span class="p_header">diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/fan.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/fan.c</span>
<span class="p_header">index 8dba70d..e089752 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/fan.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/fan.c</span>
<span class="p_chunk">@@ -83,6 +83,7 @@</span> <span class="p_context"> nvbios_fan_parse(struct nvkm_bios *bios, struct nvbios_therm_fan *fan)</span>
 			fan-&gt;type = NVBIOS_THERM_FAN_UNK;
 		}
 
<span class="p_add">+		fan-&gt;fan_mode = NVBIOS_THERM_FAN_LINEAR;</span>
 		fan-&gt;min_duty = nv_ro08(bios, data + 0x02);
 		fan-&gt;max_duty = nv_ro08(bios, data + 0x03);
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/cik.c b/drivers/gpu/drm/radeon/cik.c</span>
<span class="p_header">index 248953d..05d43a0 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/cik.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/cik.c</span>
<span class="p_chunk">@@ -4173,11 +4173,7 @@</span> <span class="p_context"> void cik_ring_ib_execute(struct radeon_device *rdev, struct radeon_ib *ib)</span>
 	control |= ib-&gt;length_dw | (vm_id &lt;&lt; 24);
 
 	radeon_ring_write(ring, header);
<span class="p_del">-	radeon_ring_write(ring,</span>
<span class="p_del">-#ifdef __BIG_ENDIAN</span>
<span class="p_del">-			  (2 &lt;&lt; 0) |</span>
<span class="p_del">-#endif</span>
<span class="p_del">-			  (ib-&gt;gpu_addr &amp; 0xFFFFFFFC));</span>
<span class="p_add">+	radeon_ring_write(ring, (ib-&gt;gpu_addr &amp; 0xFFFFFFFC));</span>
 	radeon_ring_write(ring, upper_32_bits(ib-&gt;gpu_addr) &amp; 0xFFFF);
 	radeon_ring_write(ring, control);
 }
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_object.c b/drivers/gpu/drm/radeon/radeon_object.c</span>
<span class="p_header">index 6763627..6e88c1b0 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_object.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_object.c</span>
<span class="p_chunk">@@ -221,6 +221,12 @@</span> <span class="p_context"> int radeon_bo_create(struct radeon_device *rdev,</span>
 	if (!(rdev-&gt;flags &amp; RADEON_IS_PCIE))
 		bo-&gt;flags &amp;= ~(RADEON_GEM_GTT_WC | RADEON_GEM_GTT_UC);
 
<span class="p_add">+	/* Write-combined CPU mappings of GTT cause GPU hangs with RV6xx</span>
<span class="p_add">+	 * See https://bugs.freedesktop.org/show_bug.cgi?id=91268</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (rdev-&gt;family &gt;= CHIP_RV610 &amp;&amp; rdev-&gt;family &lt;= CHIP_RV635)</span>
<span class="p_add">+		bo-&gt;flags &amp;= ~(RADEON_GEM_GTT_WC | RADEON_GEM_GTT_UC);</span>
<span class="p_add">+</span>
 #ifdef CONFIG_X86_32
 	/* XXX: Write-combined CPU mappings of GTT seem broken on 32-bit
 	 * See https://bugs.freedesktop.org/show_bug.cgi?id=84627
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_pm.c b/drivers/gpu/drm/radeon/radeon_pm.c</span>
<span class="p_header">index 9176432..6e012f0 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_pm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_pm.c</span>
<span class="p_chunk">@@ -1547,8 +1547,7 @@</span> <span class="p_context"> int radeon_pm_late_init(struct radeon_device *rdev)</span>
 				ret = device_create_file(rdev-&gt;dev, &amp;dev_attr_power_method);
 				if (ret)
 					DRM_ERROR(&quot;failed to create device file for power method\n&quot;);
<span class="p_del">-				if (!ret)</span>
<span class="p_del">-					rdev-&gt;pm.sysfs_initialized = true;</span>
<span class="p_add">+				rdev-&gt;pm.sysfs_initialized = true;</span>
 			}
 
 			mutex_lock(&amp;rdev-&gt;pm.mutex);
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_vce.c b/drivers/gpu/drm/radeon/radeon_vce.c</span>
<span class="p_header">index 574f62b..7eb1ae7 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_vce.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_vce.c</span>
<span class="p_chunk">@@ -361,31 +361,31 @@</span> <span class="p_context"> int radeon_vce_get_create_msg(struct radeon_device *rdev, int ring,</span>
 
 	/* stitch together an VCE create msg */
 	ib.length_dw = 0;
<span class="p_del">-	ib.ptr[ib.length_dw++] = 0x0000000c; /* len */</span>
<span class="p_del">-	ib.ptr[ib.length_dw++] = 0x00000001; /* session cmd */</span>
<span class="p_del">-	ib.ptr[ib.length_dw++] = handle;</span>
<span class="p_del">-</span>
<span class="p_del">-	ib.ptr[ib.length_dw++] = 0x00000030; /* len */</span>
<span class="p_del">-	ib.ptr[ib.length_dw++] = 0x01000001; /* create cmd */</span>
<span class="p_del">-	ib.ptr[ib.length_dw++] = 0x00000000;</span>
<span class="p_del">-	ib.ptr[ib.length_dw++] = 0x00000042;</span>
<span class="p_del">-	ib.ptr[ib.length_dw++] = 0x0000000a;</span>
<span class="p_del">-	ib.ptr[ib.length_dw++] = 0x00000001;</span>
<span class="p_del">-	ib.ptr[ib.length_dw++] = 0x00000080;</span>
<span class="p_del">-	ib.ptr[ib.length_dw++] = 0x00000060;</span>
<span class="p_del">-	ib.ptr[ib.length_dw++] = 0x00000100;</span>
<span class="p_del">-	ib.ptr[ib.length_dw++] = 0x00000100;</span>
<span class="p_del">-	ib.ptr[ib.length_dw++] = 0x0000000c;</span>
<span class="p_del">-	ib.ptr[ib.length_dw++] = 0x00000000;</span>
<span class="p_del">-</span>
<span class="p_del">-	ib.ptr[ib.length_dw++] = 0x00000014; /* len */</span>
<span class="p_del">-	ib.ptr[ib.length_dw++] = 0x05000005; /* feedback buffer */</span>
<span class="p_del">-	ib.ptr[ib.length_dw++] = upper_32_bits(dummy);</span>
<span class="p_del">-	ib.ptr[ib.length_dw++] = dummy;</span>
<span class="p_del">-	ib.ptr[ib.length_dw++] = 0x00000001;</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(0x0000000c); /* len */</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(0x00000001); /* session cmd */</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(handle);</span>
<span class="p_add">+</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(0x00000030); /* len */</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(0x01000001); /* create cmd */</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(0x00000000);</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(0x00000042);</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(0x0000000a);</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(0x00000001);</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(0x00000080);</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(0x00000060);</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(0x00000100);</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(0x00000100);</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(0x0000000c);</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(0x00000000);</span>
<span class="p_add">+</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(0x00000014); /* len */</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(0x05000005); /* feedback buffer */</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(upper_32_bits(dummy));</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(dummy);</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(0x00000001);</span>
 
 	for (i = ib.length_dw; i &lt; ib_size_dw; ++i)
<span class="p_del">-		ib.ptr[i] = 0x0;</span>
<span class="p_add">+		ib.ptr[i] = cpu_to_le32(0x0);</span>
 
 	r = radeon_ib_schedule(rdev, &amp;ib, NULL, false);
 	if (r) {
<span class="p_chunk">@@ -428,21 +428,21 @@</span> <span class="p_context"> int radeon_vce_get_destroy_msg(struct radeon_device *rdev, int ring,</span>
 
 	/* stitch together an VCE destroy msg */
 	ib.length_dw = 0;
<span class="p_del">-	ib.ptr[ib.length_dw++] = 0x0000000c; /* len */</span>
<span class="p_del">-	ib.ptr[ib.length_dw++] = 0x00000001; /* session cmd */</span>
<span class="p_del">-	ib.ptr[ib.length_dw++] = handle;</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(0x0000000c); /* len */</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(0x00000001); /* session cmd */</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(handle);</span>
 
<span class="p_del">-	ib.ptr[ib.length_dw++] = 0x00000014; /* len */</span>
<span class="p_del">-	ib.ptr[ib.length_dw++] = 0x05000005; /* feedback buffer */</span>
<span class="p_del">-	ib.ptr[ib.length_dw++] = upper_32_bits(dummy);</span>
<span class="p_del">-	ib.ptr[ib.length_dw++] = dummy;</span>
<span class="p_del">-	ib.ptr[ib.length_dw++] = 0x00000001;</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(0x00000014); /* len */</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(0x05000005); /* feedback buffer */</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(upper_32_bits(dummy));</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(dummy);</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(0x00000001);</span>
 
<span class="p_del">-	ib.ptr[ib.length_dw++] = 0x00000008; /* len */</span>
<span class="p_del">-	ib.ptr[ib.length_dw++] = 0x02000001; /* destroy cmd */</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(0x00000008); /* len */</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(0x02000001); /* destroy cmd */</span>
 
 	for (i = ib.length_dw; i &lt; ib_size_dw; ++i)
<span class="p_del">-		ib.ptr[i] = 0x0;</span>
<span class="p_add">+		ib.ptr[i] = cpu_to_le32(0x0);</span>
 
 	r = radeon_ib_schedule(rdev, &amp;ib, NULL, false);
 	if (r) {
<span class="p_chunk">@@ -699,12 +699,12 @@</span> <span class="p_context"> bool radeon_vce_semaphore_emit(struct radeon_device *rdev,</span>
 {
 	uint64_t addr = semaphore-&gt;gpu_addr;
 
<span class="p_del">-	radeon_ring_write(ring, VCE_CMD_SEMAPHORE);</span>
<span class="p_del">-	radeon_ring_write(ring, (addr &gt;&gt; 3) &amp; 0x000FFFFF);</span>
<span class="p_del">-	radeon_ring_write(ring, (addr &gt;&gt; 23) &amp; 0x000FFFFF);</span>
<span class="p_del">-	radeon_ring_write(ring, 0x01003000 | (emit_wait ? 1 : 0));</span>
<span class="p_add">+	radeon_ring_write(ring, cpu_to_le32(VCE_CMD_SEMAPHORE));</span>
<span class="p_add">+	radeon_ring_write(ring, cpu_to_le32((addr &gt;&gt; 3) &amp; 0x000FFFFF));</span>
<span class="p_add">+	radeon_ring_write(ring, cpu_to_le32((addr &gt;&gt; 23) &amp; 0x000FFFFF));</span>
<span class="p_add">+	radeon_ring_write(ring, cpu_to_le32(0x01003000 | (emit_wait ? 1 : 0)));</span>
 	if (!emit_wait)
<span class="p_del">-		radeon_ring_write(ring, VCE_CMD_END);</span>
<span class="p_add">+		radeon_ring_write(ring, cpu_to_le32(VCE_CMD_END));</span>
 
 	return true;
 }
<span class="p_chunk">@@ -719,10 +719,10 @@</span> <span class="p_context"> bool radeon_vce_semaphore_emit(struct radeon_device *rdev,</span>
 void radeon_vce_ib_execute(struct radeon_device *rdev, struct radeon_ib *ib)
 {
 	struct radeon_ring *ring = &amp;rdev-&gt;ring[ib-&gt;ring];
<span class="p_del">-	radeon_ring_write(ring, VCE_CMD_IB);</span>
<span class="p_del">-	radeon_ring_write(ring, ib-&gt;gpu_addr);</span>
<span class="p_del">-	radeon_ring_write(ring, upper_32_bits(ib-&gt;gpu_addr));</span>
<span class="p_del">-	radeon_ring_write(ring, ib-&gt;length_dw);</span>
<span class="p_add">+	radeon_ring_write(ring, cpu_to_le32(VCE_CMD_IB));</span>
<span class="p_add">+	radeon_ring_write(ring, cpu_to_le32(ib-&gt;gpu_addr));</span>
<span class="p_add">+	radeon_ring_write(ring, cpu_to_le32(upper_32_bits(ib-&gt;gpu_addr)));</span>
<span class="p_add">+	radeon_ring_write(ring, cpu_to_le32(ib-&gt;length_dw));</span>
 }
 
 /**
<span class="p_chunk">@@ -738,12 +738,12 @@</span> <span class="p_context"> void radeon_vce_fence_emit(struct radeon_device *rdev,</span>
 	struct radeon_ring *ring = &amp;rdev-&gt;ring[fence-&gt;ring];
 	uint64_t addr = rdev-&gt;fence_drv[fence-&gt;ring].gpu_addr;
 
<span class="p_del">-	radeon_ring_write(ring, VCE_CMD_FENCE);</span>
<span class="p_del">-	radeon_ring_write(ring, addr);</span>
<span class="p_del">-	radeon_ring_write(ring, upper_32_bits(addr));</span>
<span class="p_del">-	radeon_ring_write(ring, fence-&gt;seq);</span>
<span class="p_del">-	radeon_ring_write(ring, VCE_CMD_TRAP);</span>
<span class="p_del">-	radeon_ring_write(ring, VCE_CMD_END);</span>
<span class="p_add">+	radeon_ring_write(ring, cpu_to_le32(VCE_CMD_FENCE));</span>
<span class="p_add">+	radeon_ring_write(ring, cpu_to_le32(addr));</span>
<span class="p_add">+	radeon_ring_write(ring, cpu_to_le32(upper_32_bits(addr)));</span>
<span class="p_add">+	radeon_ring_write(ring, cpu_to_le32(fence-&gt;seq));</span>
<span class="p_add">+	radeon_ring_write(ring, cpu_to_le32(VCE_CMD_TRAP));</span>
<span class="p_add">+	radeon_ring_write(ring, cpu_to_le32(VCE_CMD_END));</span>
 }
 
 /**
<span class="p_chunk">@@ -765,7 +765,7 @@</span> <span class="p_context"> int radeon_vce_ring_test(struct radeon_device *rdev, struct radeon_ring *ring)</span>
 			  ring-&gt;idx, r);
 		return r;
 	}
<span class="p_del">-	radeon_ring_write(ring, VCE_CMD_END);</span>
<span class="p_add">+	radeon_ring_write(ring, cpu_to_le32(VCE_CMD_END));</span>
 	radeon_ring_unlock_commit(rdev, ring, false);
 
 	for (i = 0; i &lt; rdev-&gt;usec_timeout; i++) {
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/rv730_dpm.c b/drivers/gpu/drm/radeon/rv730_dpm.c</span>
<span class="p_header">index 3f5e1cf..d37ba2c 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/rv730_dpm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/rv730_dpm.c</span>
<span class="p_chunk">@@ -464,7 +464,7 @@</span> <span class="p_context"> void rv730_stop_dpm(struct radeon_device *rdev)</span>
 	result = rv770_send_msg_to_smc(rdev, PPSMC_MSG_TwoLevelsDisabled);
 
 	if (result != PPSMC_Result_OK)
<span class="p_del">-		DRM_ERROR(&quot;Could not force DPM to low\n&quot;);</span>
<span class="p_add">+		DRM_DEBUG(&quot;Could not force DPM to low\n&quot;);</span>
 
 	WREG32_P(GENERAL_PWRMGT, 0, ~GLOBAL_PWRMGT_EN);
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/rv770_dpm.c b/drivers/gpu/drm/radeon/rv770_dpm.c</span>
<span class="p_header">index b9c7707..e830c89 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/rv770_dpm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/rv770_dpm.c</span>
<span class="p_chunk">@@ -193,7 +193,7 @@</span> <span class="p_context"> void rv770_stop_dpm(struct radeon_device *rdev)</span>
 	result = rv770_send_msg_to_smc(rdev, PPSMC_MSG_TwoLevelsDisabled);
 
 	if (result != PPSMC_Result_OK)
<span class="p_del">-		DRM_ERROR(&quot;Could not force DPM to low.\n&quot;);</span>
<span class="p_add">+		DRM_DEBUG(&quot;Could not force DPM to low.\n&quot;);</span>
 
 	WREG32_P(GENERAL_PWRMGT, 0, ~GLOBAL_PWRMGT_EN);
 
<span class="p_chunk">@@ -1418,7 +1418,7 @@</span> <span class="p_context"> int rv770_resume_smc(struct radeon_device *rdev)</span>
 int rv770_set_sw_state(struct radeon_device *rdev)
 {
 	if (rv770_send_msg_to_smc(rdev, PPSMC_MSG_SwitchToSwState) != PPSMC_Result_OK)
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+		DRM_DEBUG(&quot;rv770_set_sw_state failed\n&quot;);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/rockchip/rockchip_drm_gem.c b/drivers/gpu/drm/rockchip/rockchip_drm_gem.c</span>
<span class="p_header">index eba5f8a..2d1daac 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/rockchip/rockchip_drm_gem.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/rockchip/rockchip_drm_gem.c</span>
<span class="p_chunk">@@ -67,6 +67,7 @@</span> <span class="p_context"> static int rockchip_drm_gem_object_mmap(struct drm_gem_object *obj,</span>
 	 * VM_PFNMAP flag that was set by drm_gem_mmap_obj()/drm_gem_mmap().
 	 */
 	vma-&gt;vm_flags &amp;= ~VM_PFNMAP;
<span class="p_add">+	vma-&gt;vm_pgoff = 0;</span>
 
 	ret = dma_mmap_attrs(drm-&gt;dev, vma, rk_obj-&gt;kvaddr, rk_obj-&gt;dma_addr,
 			     obj-&gt;size, &amp;rk_obj-&gt;dma_attrs);
<span class="p_header">diff --git a/drivers/gpu/drm/ttm/ttm_lock.c b/drivers/gpu/drm/ttm/ttm_lock.c</span>
<span class="p_header">index 6a95454..f154fb1 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/ttm/ttm_lock.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/ttm/ttm_lock.c</span>
<span class="p_chunk">@@ -180,7 +180,7 @@</span> <span class="p_context"> int ttm_write_lock(struct ttm_lock *lock, bool interruptible)</span>
 			spin_unlock(&amp;lock-&gt;lock);
 		}
 	} else
<span class="p_del">-		wait_event(lock-&gt;queue, __ttm_read_lock(lock));</span>
<span class="p_add">+		wait_event(lock-&gt;queue, __ttm_write_lock(lock));</span>
 
 	return ret;
 }
<span class="p_header">diff --git a/drivers/gpu/drm/virtio/virtgpu_display.c b/drivers/gpu/drm/virtio/virtgpu_display.c</span>
<span class="p_header">index 4e160ef..54b70f1 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/virtio/virtgpu_display.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/virtio/virtgpu_display.c</span>
<span class="p_chunk">@@ -361,7 +361,7 @@</span> <span class="p_context"> static const struct drm_connector_funcs virtio_gpu_connector_funcs = {</span>
 	.save = virtio_gpu_conn_save,
 	.restore = virtio_gpu_conn_restore,
 	.detect = virtio_gpu_conn_detect,
<span class="p_del">-	.fill_modes = drm_helper_probe_single_connector_modes,</span>
<span class="p_add">+	.fill_modes = drm_helper_probe_single_connector_modes_nomerge,</span>
 	.destroy = virtio_gpu_conn_destroy,
 	.reset = drm_atomic_helper_connector_reset,
 	.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,
<span class="p_header">diff --git a/drivers/gpu/vga/vgaarb.c b/drivers/gpu/vga/vgaarb.c</span>
<span class="p_header">index 7bcbf86..17cd475 100644</span>
<span class="p_header">--- a/drivers/gpu/vga/vgaarb.c</span>
<span class="p_header">+++ b/drivers/gpu/vga/vgaarb.c</span>
<span class="p_chunk">@@ -394,8 +394,10 @@</span> <span class="p_context"> int vga_get(struct pci_dev *pdev, unsigned int rsrc, int interruptible)</span>
 		set_current_state(interruptible ?
 				  TASK_INTERRUPTIBLE :
 				  TASK_UNINTERRUPTIBLE);
<span class="p_del">-		if (signal_pending(current)) {</span>
<span class="p_del">-			rc = -EINTR;</span>
<span class="p_add">+		if (interruptible &amp;&amp; signal_pending(current)) {</span>
<span class="p_add">+			__set_current_state(TASK_RUNNING);</span>
<span class="p_add">+			remove_wait_queue(&amp;vga_wait_queue, &amp;wait);</span>
<span class="p_add">+			rc = -ERESTARTSYS;</span>
 			break;
 		}
 		schedule();
<span class="p_header">diff --git a/drivers/i2c/busses/i2c-designware-core.c b/drivers/i2c/busses/i2c-designware-core.c</span>
<span class="p_header">index 6f19a33..75b1ffd 100644</span>
<span class="p_header">--- a/drivers/i2c/busses/i2c-designware-core.c</span>
<span class="p_header">+++ b/drivers/i2c/busses/i2c-designware-core.c</span>
<span class="p_chunk">@@ -811,6 +811,12 @@</span> <span class="p_context"> irqreturn_t i2c_dw_isr(int this_irq, void *dev_id)</span>
 tx_aborted:
 	if ((stat &amp; (DW_IC_INTR_TX_ABRT | DW_IC_INTR_STOP_DET)) || dev-&gt;msg_err)
 		complete(&amp;dev-&gt;cmd_complete);
<span class="p_add">+	else if (unlikely(dev-&gt;accessor_flags &amp; ACCESS_INTR_MASK)) {</span>
<span class="p_add">+		/* workaround to trigger pending interrupt */</span>
<span class="p_add">+		stat = dw_readl(dev, DW_IC_INTR_MASK);</span>
<span class="p_add">+		i2c_dw_disable_int(dev);</span>
<span class="p_add">+		dw_writel(dev, stat, DW_IC_INTR_MASK);</span>
<span class="p_add">+	}</span>
 
 	return IRQ_HANDLED;
 }
<span class="p_header">diff --git a/drivers/i2c/busses/i2c-designware-core.h b/drivers/i2c/busses/i2c-designware-core.h</span>
<span class="p_header">index 9630222..808ef6a 100644</span>
<span class="p_header">--- a/drivers/i2c/busses/i2c-designware-core.h</span>
<span class="p_header">+++ b/drivers/i2c/busses/i2c-designware-core.h</span>
<span class="p_chunk">@@ -111,6 +111,7 @@</span> <span class="p_context"> struct dw_i2c_dev {</span>
 
 #define ACCESS_SWAP		0x00000001
 #define ACCESS_16BIT		0x00000002
<span class="p_add">+#define ACCESS_INTR_MASK	0x00000004</span>
 
 extern u32 dw_readl(struct dw_i2c_dev *dev, int offset);
 extern void dw_writel(struct dw_i2c_dev *dev, u32 b, int offset);
<span class="p_header">diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c</span>
<span class="p_header">index 472b882..13a7f10 100644</span>
<span class="p_header">--- a/drivers/i2c/busses/i2c-designware-platdrv.c</span>
<span class="p_header">+++ b/drivers/i2c/busses/i2c-designware-platdrv.c</span>
<span class="p_chunk">@@ -111,29 +111,13 @@</span> <span class="p_context"> static int dw_i2c_acpi_configure(struct platform_device *pdev)</span>
 	dw_i2c_acpi_params(pdev, &quot;FMCN&quot;, &amp;dev-&gt;fs_hcnt, &amp;dev-&gt;fs_lcnt,
 			   &amp;dev-&gt;sda_hold_time);
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Provide a way for Designware I2C host controllers that are not</span>
<span class="p_del">-	 * based on Intel LPSS to specify their input clock frequency via</span>
<span class="p_del">-	 * id-&gt;driver_data.</span>
<span class="p_del">-	 */</span>
 	id = acpi_match_device(pdev-&gt;dev.driver-&gt;acpi_match_table, &amp;pdev-&gt;dev);
 	if (id &amp;&amp; id-&gt;driver_data)
<span class="p_del">-		clk_register_fixed_rate(&amp;pdev-&gt;dev, dev_name(&amp;pdev-&gt;dev), NULL,</span>
<span class="p_del">-					CLK_IS_ROOT, id-&gt;driver_data);</span>
<span class="p_add">+		dev-&gt;accessor_flags |= (u32)id-&gt;driver_data;</span>
 
 	return 0;
 }
 
<span class="p_del">-static void dw_i2c_acpi_unconfigure(struct platform_device *pdev)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct dw_i2c_dev *dev = platform_get_drvdata(pdev);</span>
<span class="p_del">-	const struct acpi_device_id *id;</span>
<span class="p_del">-</span>
<span class="p_del">-	id = acpi_match_device(pdev-&gt;dev.driver-&gt;acpi_match_table, &amp;pdev-&gt;dev);</span>
<span class="p_del">-	if (id &amp;&amp; id-&gt;driver_data)</span>
<span class="p_del">-		clk_unregister(dev-&gt;clk);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static const struct acpi_device_id dw_i2c_acpi_match[] = {
 	{ &quot;INT33C2&quot;, 0 },
 	{ &quot;INT33C3&quot;, 0 },
<span class="p_chunk">@@ -141,7 +125,7 @@</span> <span class="p_context"> static const struct acpi_device_id dw_i2c_acpi_match[] = {</span>
 	{ &quot;INT3433&quot;, 0 },
 	{ &quot;80860F41&quot;, 0 },
 	{ &quot;808622C1&quot;, 0 },
<span class="p_del">-	{ &quot;AMD0010&quot;, 133 * 1000 * 1000 },</span>
<span class="p_add">+	{ &quot;AMD0010&quot;, ACCESS_INTR_MASK },</span>
 	{ }
 };
 MODULE_DEVICE_TABLE(acpi, dw_i2c_acpi_match);
<span class="p_chunk">@@ -150,7 +134,6 @@</span> <span class="p_context"> static inline int dw_i2c_acpi_configure(struct platform_device *pdev)</span>
 {
 	return -ENODEV;
 }
<span class="p_del">-static inline void dw_i2c_acpi_unconfigure(struct platform_device *pdev) { }</span>
 #endif
 
 static int dw_i2c_probe(struct platform_device *pdev)
<span class="p_chunk">@@ -306,9 +289,6 @@</span> <span class="p_context"> static int dw_i2c_remove(struct platform_device *pdev)</span>
 	pm_runtime_put_sync(&amp;pdev-&gt;dev);
 	pm_runtime_disable(&amp;pdev-&gt;dev);
 
<span class="p_del">-	if (has_acpi_companion(&amp;pdev-&gt;dev))</span>
<span class="p_del">-		dw_i2c_acpi_unconfigure(pdev);</span>
<span class="p_del">-</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/i2c/busses/i2c-mv64xxx.c b/drivers/i2c/busses/i2c-mv64xxx.c</span>
<span class="p_header">index 5801227..43207f5 100644</span>
<span class="p_header">--- a/drivers/i2c/busses/i2c-mv64xxx.c</span>
<span class="p_header">+++ b/drivers/i2c/busses/i2c-mv64xxx.c</span>
<span class="p_chunk">@@ -146,6 +146,8 @@</span> <span class="p_context"> struct mv64xxx_i2c_data {</span>
 	bool			errata_delay;
 	struct reset_control	*rstc;
 	bool			irq_clear_inverted;
<span class="p_add">+	/* Clk div is 2 to the power n, not 2 to the power n + 1 */</span>
<span class="p_add">+	bool			clk_n_base_0;</span>
 };
 
 static struct mv64xxx_i2c_regs mv64xxx_i2c_regs_mv64xxx = {
<span class="p_chunk">@@ -757,25 +759,29 @@</span> <span class="p_context"> MODULE_DEVICE_TABLE(of, mv64xxx_i2c_of_match_table);</span>
 #ifdef CONFIG_OF
 #ifdef CONFIG_HAVE_CLK
 static int
<span class="p_del">-mv64xxx_calc_freq(const int tclk, const int n, const int m)</span>
<span class="p_add">+mv64xxx_calc_freq(struct mv64xxx_i2c_data *drv_data,</span>
<span class="p_add">+		  const int tclk, const int n, const int m)</span>
 {
<span class="p_del">-	return tclk / (10 * (m + 1) * (2 &lt;&lt; n));</span>
<span class="p_add">+	if (drv_data-&gt;clk_n_base_0)</span>
<span class="p_add">+		return tclk / (10 * (m + 1) * (1 &lt;&lt; n));</span>
<span class="p_add">+	else</span>
<span class="p_add">+		return tclk / (10 * (m + 1) * (2 &lt;&lt; n));</span>
 }
 
 static bool
<span class="p_del">-mv64xxx_find_baud_factors(const u32 req_freq, const u32 tclk, u32 *best_n,</span>
<span class="p_del">-			  u32 *best_m)</span>
<span class="p_add">+mv64xxx_find_baud_factors(struct mv64xxx_i2c_data *drv_data,</span>
<span class="p_add">+			  const u32 req_freq, const u32 tclk)</span>
 {
 	int freq, delta, best_delta = INT_MAX;
 	int m, n;
 
 	for (n = 0; n &lt;= 7; n++)
 		for (m = 0; m &lt;= 15; m++) {
<span class="p_del">-			freq = mv64xxx_calc_freq(tclk, n, m);</span>
<span class="p_add">+			freq = mv64xxx_calc_freq(drv_data, tclk, n, m);</span>
 			delta = req_freq - freq;
 			if (delta &gt;= 0 &amp;&amp; delta &lt; best_delta) {
<span class="p_del">-				*best_m = m;</span>
<span class="p_del">-				*best_n = n;</span>
<span class="p_add">+				drv_data-&gt;freq_m = m;</span>
<span class="p_add">+				drv_data-&gt;freq_n = n;</span>
 				best_delta = delta;
 			}
 			if (best_delta == 0)
<span class="p_chunk">@@ -813,8 +819,11 @@</span> <span class="p_context"> mv64xxx_of_config(struct mv64xxx_i2c_data *drv_data,</span>
 	if (of_property_read_u32(np, &quot;clock-frequency&quot;, &amp;bus_freq))
 		bus_freq = 100000; /* 100kHz by default */
 
<span class="p_del">-	if (!mv64xxx_find_baud_factors(bus_freq, tclk,</span>
<span class="p_del">-				       &amp;drv_data-&gt;freq_n, &amp;drv_data-&gt;freq_m)) {</span>
<span class="p_add">+	if (of_device_is_compatible(np, &quot;allwinner,sun4i-a10-i2c&quot;) ||</span>
<span class="p_add">+	    of_device_is_compatible(np, &quot;allwinner,sun6i-a31-i2c&quot;))</span>
<span class="p_add">+		drv_data-&gt;clk_n_base_0 = true;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!mv64xxx_find_baud_factors(drv_data, bus_freq, tclk)) {</span>
 		rc = -EINVAL;
 		goto out;
 	}
<span class="p_header">diff --git a/drivers/i2c/busses/i2c-rcar.c b/drivers/i2c/busses/i2c-rcar.c</span>
<span class="p_header">index d8b5a8f..3191dd9 100644</span>
<span class="p_header">--- a/drivers/i2c/busses/i2c-rcar.c</span>
<span class="p_header">+++ b/drivers/i2c/busses/i2c-rcar.c</span>
<span class="p_chunk">@@ -575,7 +575,7 @@</span> <span class="p_context"> static int rcar_reg_slave(struct i2c_client *slave)</span>
 	if (slave-&gt;flags &amp; I2C_CLIENT_TEN)
 		return -EAFNOSUPPORT;
 
<span class="p_del">-	pm_runtime_forbid(rcar_i2c_priv_to_dev(priv));</span>
<span class="p_add">+	pm_runtime_get_sync(rcar_i2c_priv_to_dev(priv));</span>
 
 	priv-&gt;slave = slave;
 	rcar_i2c_write(priv, ICSAR, slave-&gt;addr);
<span class="p_chunk">@@ -597,7 +597,7 @@</span> <span class="p_context"> static int rcar_unreg_slave(struct i2c_client *slave)</span>
 
 	priv-&gt;slave = NULL;
 
<span class="p_del">-	pm_runtime_allow(rcar_i2c_priv_to_dev(priv));</span>
<span class="p_add">+	pm_runtime_put(rcar_i2c_priv_to_dev(priv));</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/i2c/busses/i2c-rk3x.c b/drivers/i2c/busses/i2c-rk3x.c</span>
<span class="p_header">index 72e97e30..9c4efd3 100644</span>
<span class="p_header">--- a/drivers/i2c/busses/i2c-rk3x.c</span>
<span class="p_header">+++ b/drivers/i2c/busses/i2c-rk3x.c</span>
<span class="p_chunk">@@ -907,7 +907,7 @@</span> <span class="p_context"> static int rk3x_i2c_probe(struct platform_device *pdev)</span>
 				 &amp;i2c-&gt;scl_fall_ns))
 		i2c-&gt;scl_fall_ns = 300;
 	if (of_property_read_u32(pdev-&gt;dev.of_node, &quot;i2c-sda-falling-time-ns&quot;,
<span class="p_del">-				 &amp;i2c-&gt;scl_fall_ns))</span>
<span class="p_add">+				 &amp;i2c-&gt;sda_fall_ns))</span>
 		i2c-&gt;sda_fall_ns = i2c-&gt;scl_fall_ns;
 
 	strlcpy(i2c-&gt;adap.name, &quot;rk3x-i2c&quot;, sizeof(i2c-&gt;adap.name));
<span class="p_header">diff --git a/drivers/iio/adc/ad7793.c b/drivers/iio/adc/ad7793.c</span>
<span class="p_header">index b84922a..710aee8 100644</span>
<span class="p_header">--- a/drivers/iio/adc/ad7793.c</span>
<span class="p_header">+++ b/drivers/iio/adc/ad7793.c</span>
<span class="p_chunk">@@ -101,7 +101,7 @@</span> <span class="p_context"></span>
 #define AD7795_CH_AIN1M_AIN1M	8 /* AIN1(-) - AIN1(-) */
 
 /* ID Register Bit Designations (AD7793_REG_ID) */
<span class="p_del">-#define AD7785_ID		0xB</span>
<span class="p_add">+#define AD7785_ID		0x3</span>
 #define AD7792_ID		0xA
 #define AD7793_ID		0xB
 #define AD7794_ID		0xF
<span class="p_header">diff --git a/drivers/iio/adc/qcom-spmi-vadc.c b/drivers/iio/adc/qcom-spmi-vadc.c</span>
<span class="p_header">index 0c4618b..c2babe5 100644</span>
<span class="p_header">--- a/drivers/iio/adc/qcom-spmi-vadc.c</span>
<span class="p_header">+++ b/drivers/iio/adc/qcom-spmi-vadc.c</span>
<span class="p_chunk">@@ -839,8 +839,10 @@</span> <span class="p_context"> static int vadc_get_dt_data(struct vadc_priv *vadc, struct device_node *node)</span>
 
 	for_each_available_child_of_node(node, child) {
 		ret = vadc_get_dt_channel_data(vadc-&gt;dev, &amp;prop, child);
<span class="p_del">-		if (ret)</span>
<span class="p_add">+		if (ret) {</span>
<span class="p_add">+			of_node_put(child);</span>
 			return ret;
<span class="p_add">+		}</span>
 
 		vadc-&gt;chan_props[index] = prop;
 
<span class="p_header">diff --git a/drivers/iio/adc/vf610_adc.c b/drivers/iio/adc/vf610_adc.c</span>
<span class="p_header">index 819632b..c16b58f 100644</span>
<span class="p_header">--- a/drivers/iio/adc/vf610_adc.c</span>
<span class="p_header">+++ b/drivers/iio/adc/vf610_adc.c</span>
<span class="p_chunk">@@ -98,6 +98,13 @@</span> <span class="p_context"></span>
 #define VF610_ADC_CALF			0x2
 #define VF610_ADC_TIMEOUT		msecs_to_jiffies(100)
 
<span class="p_add">+/* V at 25C of 696 mV */</span>
<span class="p_add">+#define VF610_VTEMP25_3V0		950</span>
<span class="p_add">+/* V at 25C of 699 mV */</span>
<span class="p_add">+#define VF610_VTEMP25_3V3		867</span>
<span class="p_add">+/* Typical sensor slope coefficient at all temperatures */</span>
<span class="p_add">+#define VF610_TEMP_SLOPE_COEFF		1840</span>
<span class="p_add">+</span>
 enum clk_sel {
 	VF610_ADCIOC_BUSCLK_SET,
 	VF610_ADCIOC_ALTCLK_SET,
<span class="p_chunk">@@ -173,6 +180,8 @@</span> <span class="p_context"> static inline void vf610_adc_calculate_rates(struct vf610_adc *info)</span>
 		adc_feature-&gt;clk_div = 8;
 	}
 
<span class="p_add">+	adck_rate = ipg_rate / adc_feature-&gt;clk_div;</span>
<span class="p_add">+</span>
 	/*
 	 * Calculate ADC sample frequencies
 	 * Sample time unit is ADCK cycles. ADCK clk source is ipg clock,
<span class="p_chunk">@@ -184,7 +193,6 @@</span> <span class="p_context"> static inline void vf610_adc_calculate_rates(struct vf610_adc *info)</span>
 	 * BCT (Base Conversion Time): fixed to 25 ADCK cycles for 12 bit mode
 	 * LSTAdder(Long Sample Time): fixed to 3 ADCK cycles
 	 */
<span class="p_del">-	adck_rate = ipg_rate / info-&gt;adc_feature.clk_div;</span>
 	for (i = 0; i &lt; ARRAY_SIZE(vf610_hw_avgs); i++)
 		info-&gt;sample_freq_avail[i] =
 			adck_rate / (6 + vf610_hw_avgs[i] * (25 + 3));
<span class="p_chunk">@@ -569,11 +577,13 @@</span> <span class="p_context"> static int vf610_read_raw(struct iio_dev *indio_dev,</span>
 			break;
 		case IIO_TEMP:
 			/*
<span class="p_del">-			* Calculate in degree Celsius times 1000</span>
<span class="p_del">-			* Using sensor slope of 1.84 mV/C and</span>
<span class="p_del">-			* V at 25C of 696 mV</span>
<span class="p_del">-			*/</span>
<span class="p_del">-			*val = 25000 - ((int)info-&gt;value - 864) * 1000000 / 1840;</span>
<span class="p_add">+			 * Calculate in degree Celsius times 1000</span>
<span class="p_add">+			 * Using the typical sensor slope of 1.84 mV/C</span>
<span class="p_add">+			 * and VREFH_ADC at 3.3V, V at 25C of 699 mV</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			*val = 25000 - ((int)info-&gt;value - VF610_VTEMP25_3V3) *</span>
<span class="p_add">+					1000000 / VF610_TEMP_SLOPE_COEFF;</span>
<span class="p_add">+</span>
 			break;
 		default:
 			mutex_unlock(&amp;indio_dev-&gt;mlock);
<span class="p_header">diff --git a/drivers/iio/adc/xilinx-xadc-core.c b/drivers/iio/adc/xilinx-xadc-core.c</span>
<span class="p_header">index ce93bd8..95c0b3d 100644</span>
<span class="p_header">--- a/drivers/iio/adc/xilinx-xadc-core.c</span>
<span class="p_header">+++ b/drivers/iio/adc/xilinx-xadc-core.c</span>
<span class="p_chunk">@@ -857,6 +857,7 @@</span> <span class="p_context"> static int xadc_read_raw(struct iio_dev *indio_dev,</span>
 			case XADC_REG_VCCINT:
 			case XADC_REG_VCCAUX:
 			case XADC_REG_VREFP:
<span class="p_add">+			case XADC_REG_VREFN:</span>
 			case XADC_REG_VCCBRAM:
 			case XADC_REG_VCCPINT:
 			case XADC_REG_VCCPAUX:
<span class="p_header">diff --git a/drivers/iio/dac/ad5064.c b/drivers/iio/dac/ad5064.c</span>
<span class="p_header">index f03b92f..aac16fe 100644</span>
<span class="p_header">--- a/drivers/iio/dac/ad5064.c</span>
<span class="p_header">+++ b/drivers/iio/dac/ad5064.c</span>
<span class="p_chunk">@@ -113,12 +113,16 @@</span> <span class="p_context"> enum ad5064_type {</span>
 	ID_AD5065,
 	ID_AD5628_1,
 	ID_AD5628_2,
<span class="p_add">+	ID_AD5629_1,</span>
<span class="p_add">+	ID_AD5629_2,</span>
 	ID_AD5648_1,
 	ID_AD5648_2,
 	ID_AD5666_1,
 	ID_AD5666_2,
 	ID_AD5668_1,
 	ID_AD5668_2,
<span class="p_add">+	ID_AD5669_1,</span>
<span class="p_add">+	ID_AD5669_2,</span>
 };
 
 static int ad5064_write(struct ad5064_state *st, unsigned int cmd,
<span class="p_chunk">@@ -291,7 +295,7 @@</span> <span class="p_context"> static const struct iio_chan_spec_ext_info ad5064_ext_info[] = {</span>
 	{ },
 };
 
<span class="p_del">-#define AD5064_CHANNEL(chan, addr, bits) {			\</span>
<span class="p_add">+#define AD5064_CHANNEL(chan, addr, bits, _shift) {		\</span>
 	.type = IIO_VOLTAGE,					\
 	.indexed = 1,						\
 	.output = 1,						\
<span class="p_chunk">@@ -303,36 +307,39 @@</span> <span class="p_context"> static const struct iio_chan_spec_ext_info ad5064_ext_info[] = {</span>
 		.sign = &#39;u&#39;,					\
 		.realbits = (bits),				\
 		.storagebits = 16,				\
<span class="p_del">-		.shift = 20 - bits,				\</span>
<span class="p_add">+		.shift = (_shift),				\</span>
 	},							\
 	.ext_info = ad5064_ext_info,				\
 }
 
<span class="p_del">-#define DECLARE_AD5064_CHANNELS(name, bits) \</span>
<span class="p_add">+#define DECLARE_AD5064_CHANNELS(name, bits, shift) \</span>
 const struct iio_chan_spec name[] = { \
<span class="p_del">-	AD5064_CHANNEL(0, 0, bits), \</span>
<span class="p_del">-	AD5064_CHANNEL(1, 1, bits), \</span>
<span class="p_del">-	AD5064_CHANNEL(2, 2, bits), \</span>
<span class="p_del">-	AD5064_CHANNEL(3, 3, bits), \</span>
<span class="p_del">-	AD5064_CHANNEL(4, 4, bits), \</span>
<span class="p_del">-	AD5064_CHANNEL(5, 5, bits), \</span>
<span class="p_del">-	AD5064_CHANNEL(6, 6, bits), \</span>
<span class="p_del">-	AD5064_CHANNEL(7, 7, bits), \</span>
<span class="p_add">+	AD5064_CHANNEL(0, 0, bits, shift), \</span>
<span class="p_add">+	AD5064_CHANNEL(1, 1, bits, shift), \</span>
<span class="p_add">+	AD5064_CHANNEL(2, 2, bits, shift), \</span>
<span class="p_add">+	AD5064_CHANNEL(3, 3, bits, shift), \</span>
<span class="p_add">+	AD5064_CHANNEL(4, 4, bits, shift), \</span>
<span class="p_add">+	AD5064_CHANNEL(5, 5, bits, shift), \</span>
<span class="p_add">+	AD5064_CHANNEL(6, 6, bits, shift), \</span>
<span class="p_add">+	AD5064_CHANNEL(7, 7, bits, shift), \</span>
 }
 
<span class="p_del">-#define DECLARE_AD5065_CHANNELS(name, bits) \</span>
<span class="p_add">+#define DECLARE_AD5065_CHANNELS(name, bits, shift) \</span>
 const struct iio_chan_spec name[] = { \
<span class="p_del">-	AD5064_CHANNEL(0, 0, bits), \</span>
<span class="p_del">-	AD5064_CHANNEL(1, 3, bits), \</span>
<span class="p_add">+	AD5064_CHANNEL(0, 0, bits, shift), \</span>
<span class="p_add">+	AD5064_CHANNEL(1, 3, bits, shift), \</span>
 }
 
<span class="p_del">-static DECLARE_AD5064_CHANNELS(ad5024_channels, 12);</span>
<span class="p_del">-static DECLARE_AD5064_CHANNELS(ad5044_channels, 14);</span>
<span class="p_del">-static DECLARE_AD5064_CHANNELS(ad5064_channels, 16);</span>
<span class="p_add">+static DECLARE_AD5064_CHANNELS(ad5024_channels, 12, 8);</span>
<span class="p_add">+static DECLARE_AD5064_CHANNELS(ad5044_channels, 14, 6);</span>
<span class="p_add">+static DECLARE_AD5064_CHANNELS(ad5064_channels, 16, 4);</span>
 
<span class="p_del">-static DECLARE_AD5065_CHANNELS(ad5025_channels, 12);</span>
<span class="p_del">-static DECLARE_AD5065_CHANNELS(ad5045_channels, 14);</span>
<span class="p_del">-static DECLARE_AD5065_CHANNELS(ad5065_channels, 16);</span>
<span class="p_add">+static DECLARE_AD5065_CHANNELS(ad5025_channels, 12, 8);</span>
<span class="p_add">+static DECLARE_AD5065_CHANNELS(ad5045_channels, 14, 6);</span>
<span class="p_add">+static DECLARE_AD5065_CHANNELS(ad5065_channels, 16, 4);</span>
<span class="p_add">+</span>
<span class="p_add">+static DECLARE_AD5064_CHANNELS(ad5629_channels, 12, 4);</span>
<span class="p_add">+static DECLARE_AD5064_CHANNELS(ad5669_channels, 16, 0);</span>
 
 static const struct ad5064_chip_info ad5064_chip_info_tbl[] = {
 	[ID_AD5024] = {
<span class="p_chunk">@@ -382,6 +389,18 @@</span> <span class="p_context"> static const struct ad5064_chip_info ad5064_chip_info_tbl[] = {</span>
 		.channels = ad5024_channels,
 		.num_channels = 8,
 	},
<span class="p_add">+	[ID_AD5629_1] = {</span>
<span class="p_add">+		.shared_vref = true,</span>
<span class="p_add">+		.internal_vref = 2500000,</span>
<span class="p_add">+		.channels = ad5629_channels,</span>
<span class="p_add">+		.num_channels = 8,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	[ID_AD5629_2] = {</span>
<span class="p_add">+		.shared_vref = true,</span>
<span class="p_add">+		.internal_vref = 5000000,</span>
<span class="p_add">+		.channels = ad5629_channels,</span>
<span class="p_add">+		.num_channels = 8,</span>
<span class="p_add">+	},</span>
 	[ID_AD5648_1] = {
 		.shared_vref = true,
 		.internal_vref = 2500000,
<span class="p_chunk">@@ -418,6 +437,18 @@</span> <span class="p_context"> static const struct ad5064_chip_info ad5064_chip_info_tbl[] = {</span>
 		.channels = ad5064_channels,
 		.num_channels = 8,
 	},
<span class="p_add">+	[ID_AD5669_1] = {</span>
<span class="p_add">+		.shared_vref = true,</span>
<span class="p_add">+		.internal_vref = 2500000,</span>
<span class="p_add">+		.channels = ad5669_channels,</span>
<span class="p_add">+		.num_channels = 8,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	[ID_AD5669_2] = {</span>
<span class="p_add">+		.shared_vref = true,</span>
<span class="p_add">+		.internal_vref = 5000000,</span>
<span class="p_add">+		.channels = ad5669_channels,</span>
<span class="p_add">+		.num_channels = 8,</span>
<span class="p_add">+	},</span>
 };
 
 static inline unsigned int ad5064_num_vref(struct ad5064_state *st)
<span class="p_chunk">@@ -598,10 +629,16 @@</span> <span class="p_context"> static int ad5064_i2c_write(struct ad5064_state *st, unsigned int cmd,</span>
 	unsigned int addr, unsigned int val)
 {
 	struct i2c_client *i2c = to_i2c_client(st-&gt;dev);
<span class="p_add">+	int ret;</span>
 
 	st-&gt;data.i2c[0] = (cmd &lt;&lt; 4) | addr;
 	put_unaligned_be16(val, &amp;st-&gt;data.i2c[1]);
<span class="p_del">-	return i2c_master_send(i2c, st-&gt;data.i2c, 3);</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = i2c_master_send(i2c, st-&gt;data.i2c, 3);</span>
<span class="p_add">+	if (ret &lt; 0)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
 }
 
 static int ad5064_i2c_probe(struct i2c_client *i2c,
<span class="p_chunk">@@ -617,12 +654,12 @@</span> <span class="p_context"> static int ad5064_i2c_remove(struct i2c_client *i2c)</span>
 }
 
 static const struct i2c_device_id ad5064_i2c_ids[] = {
<span class="p_del">-	{&quot;ad5629-1&quot;, ID_AD5628_1},</span>
<span class="p_del">-	{&quot;ad5629-2&quot;, ID_AD5628_2},</span>
<span class="p_del">-	{&quot;ad5629-3&quot;, ID_AD5628_2}, /* similar enough to ad5629-2 */</span>
<span class="p_del">-	{&quot;ad5669-1&quot;, ID_AD5668_1},</span>
<span class="p_del">-	{&quot;ad5669-2&quot;, ID_AD5668_2},</span>
<span class="p_del">-	{&quot;ad5669-3&quot;, ID_AD5668_2}, /* similar enough to ad5669-2 */</span>
<span class="p_add">+	{&quot;ad5629-1&quot;, ID_AD5629_1},</span>
<span class="p_add">+	{&quot;ad5629-2&quot;, ID_AD5629_2},</span>
<span class="p_add">+	{&quot;ad5629-3&quot;, ID_AD5629_2}, /* similar enough to ad5629-2 */</span>
<span class="p_add">+	{&quot;ad5669-1&quot;, ID_AD5669_1},</span>
<span class="p_add">+	{&quot;ad5669-2&quot;, ID_AD5669_2},</span>
<span class="p_add">+	{&quot;ad5669-3&quot;, ID_AD5669_2}, /* similar enough to ad5669-2 */</span>
 	{}
 };
 MODULE_DEVICE_TABLE(i2c, ad5064_i2c_ids);
<span class="p_header">diff --git a/drivers/iio/humidity/si7020.c b/drivers/iio/humidity/si7020.c</span>
<span class="p_header">index fa3b809..1b6935d 100644</span>
<span class="p_header">--- a/drivers/iio/humidity/si7020.c</span>
<span class="p_header">+++ b/drivers/iio/humidity/si7020.c</span>
<span class="p_chunk">@@ -50,10 +50,10 @@</span> <span class="p_context"> static int si7020_read_raw(struct iio_dev *indio_dev,</span>
 
 	switch (mask) {
 	case IIO_CHAN_INFO_RAW:
<span class="p_del">-		ret = i2c_smbus_read_word_data(*client,</span>
<span class="p_del">-					       chan-&gt;type == IIO_TEMP ?</span>
<span class="p_del">-					       SI7020CMD_TEMP_HOLD :</span>
<span class="p_del">-					       SI7020CMD_RH_HOLD);</span>
<span class="p_add">+		ret = i2c_smbus_read_word_swapped(*client,</span>
<span class="p_add">+						  chan-&gt;type == IIO_TEMP ?</span>
<span class="p_add">+						  SI7020CMD_TEMP_HOLD :</span>
<span class="p_add">+						  SI7020CMD_RH_HOLD);</span>
 		if (ret &lt; 0)
 			return ret;
 		*val = ret &gt;&gt; 2;
<span class="p_header">diff --git a/drivers/iio/industrialio-buffer.c b/drivers/iio/industrialio-buffer.c</span>
<span class="p_header">index b3fda9e..ccb7747 100644</span>
<span class="p_header">--- a/drivers/iio/industrialio-buffer.c</span>
<span class="p_header">+++ b/drivers/iio/industrialio-buffer.c</span>
<span class="p_chunk">@@ -289,7 +289,7 @@</span> <span class="p_context"> static int iio_scan_mask_set(struct iio_dev *indio_dev,</span>
 	if (trialmask == NULL)
 		return -ENOMEM;
 	if (!indio_dev-&gt;masklength) {
<span class="p_del">-		WARN_ON(&quot;Trying to set scanmask prior to registering buffer\n&quot;);</span>
<span class="p_add">+		WARN(1, &quot;Trying to set scanmask prior to registering buffer\n&quot;);</span>
 		goto err_invalid_mask;
 	}
 	bitmap_copy(trialmask, buffer-&gt;scan_mask, indio_dev-&gt;masklength);
<span class="p_header">diff --git a/drivers/iio/industrialio-core.c b/drivers/iio/industrialio-core.c</span>
<span class="p_header">index 3524b0d..30e116b 100644</span>
<span class="p_header">--- a/drivers/iio/industrialio-core.c</span>
<span class="p_header">+++ b/drivers/iio/industrialio-core.c</span>
<span class="p_chunk">@@ -637,7 +637,7 @@</span> <span class="p_context"> int __iio_device_attr_init(struct device_attribute *dev_attr,</span>
 			break;
 		case IIO_SEPARATE:
 			if (!chan-&gt;indexed) {
<span class="p_del">-				WARN_ON(&quot;Differential channels must be indexed\n&quot;);</span>
<span class="p_add">+				WARN(1, &quot;Differential channels must be indexed\n&quot;);</span>
 				ret = -EINVAL;
 				goto error_free_full_postfix;
 			}
<span class="p_header">diff --git a/drivers/infiniband/ulp/srp/ib_srp.c b/drivers/infiniband/ulp/srp/ib_srp.c</span>
<span class="p_header">index ffda44f..bdcb72e 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/srp/ib_srp.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/srp/ib_srp.c</span>
<span class="p_chunk">@@ -496,7 +496,7 @@</span> <span class="p_context"> static int srp_create_ch_ib(struct srp_rdma_ch *ch)</span>
 	struct ib_qp *qp;
 	struct ib_fmr_pool *fmr_pool = NULL;
 	struct srp_fr_pool *fr_pool = NULL;
<span class="p_del">-	const int m = 1 + dev-&gt;use_fast_reg;</span>
<span class="p_add">+	const int m = dev-&gt;use_fast_reg ? 3 : 1;</span>
 	struct ib_cq_init_attr cq_attr = {};
 	int ret;
 
<span class="p_chunk">@@ -996,16 +996,16 @@</span> <span class="p_context"> static int srp_connect_ch(struct srp_rdma_ch *ch, bool multich)</span>
 
 	ret = srp_lookup_path(ch);
 	if (ret)
<span class="p_del">-		return ret;</span>
<span class="p_add">+		goto out;</span>
 
 	while (1) {
 		init_completion(&amp;ch-&gt;done);
 		ret = srp_send_req(ch, multich);
 		if (ret)
<span class="p_del">-			return ret;</span>
<span class="p_add">+			goto out;</span>
 		ret = wait_for_completion_interruptible(&amp;ch-&gt;done);
 		if (ret &lt; 0)
<span class="p_del">-			return ret;</span>
<span class="p_add">+			goto out;</span>
 
 		/*
 		 * The CM event handling code will set status to
<span class="p_chunk">@@ -1013,15 +1013,16 @@</span> <span class="p_context"> static int srp_connect_ch(struct srp_rdma_ch *ch, bool multich)</span>
 		 * back, or SRP_DLID_REDIRECT if we get a lid/qp
 		 * redirect REJ back.
 		 */
<span class="p_del">-		switch (ch-&gt;status) {</span>
<span class="p_add">+		ret = ch-&gt;status;</span>
<span class="p_add">+		switch (ret) {</span>
 		case 0:
 			ch-&gt;connected = true;
<span class="p_del">-			return 0;</span>
<span class="p_add">+			goto out;</span>
 
 		case SRP_PORT_REDIRECT:
 			ret = srp_lookup_path(ch);
 			if (ret)
<span class="p_del">-				return ret;</span>
<span class="p_add">+				goto out;</span>
 			break;
 
 		case SRP_DLID_REDIRECT:
<span class="p_chunk">@@ -1030,13 +1031,16 @@</span> <span class="p_context"> static int srp_connect_ch(struct srp_rdma_ch *ch, bool multich)</span>
 		case SRP_STALE_CONN:
 			shost_printk(KERN_ERR, target-&gt;scsi_host, PFX
 				     &quot;giving up on stale connection\n&quot;);
<span class="p_del">-			ch-&gt;status = -ECONNRESET;</span>
<span class="p_del">-			return ch-&gt;status;</span>
<span class="p_add">+			ret = -ECONNRESET;</span>
<span class="p_add">+			goto out;</span>
 
 		default:
<span class="p_del">-			return ch-&gt;status;</span>
<span class="p_add">+			goto out;</span>
 		}
 	}
<span class="p_add">+</span>
<span class="p_add">+out:</span>
<span class="p_add">+	return ret &lt;= 0 ? ret : -ENODEV;</span>
 }
 
 static int srp_inv_rkey(struct srp_rdma_ch *ch, u32 rkey)
<span class="p_header">diff --git a/drivers/irqchip/irq-versatile-fpga.c b/drivers/irqchip/irq-versatile-fpga.c</span>
<span class="p_header">index 888111b..18822f0 100644</span>
<span class="p_header">--- a/drivers/irqchip/irq-versatile-fpga.c</span>
<span class="p_header">+++ b/drivers/irqchip/irq-versatile-fpga.c</span>
<span class="p_chunk">@@ -210,7 +210,12 @@</span> <span class="p_context"> int __init fpga_irq_of_init(struct device_node *node,</span>
 		parent_irq = -1;
 	}
 
<span class="p_add">+#ifdef CONFIG_ARCH_VERSATILE</span>
<span class="p_add">+	fpga_irq_init(base, node-&gt;name, IRQ_SIC_START, parent_irq, valid_mask,</span>
<span class="p_add">+				  node);</span>
<span class="p_add">+#else</span>
 	fpga_irq_init(base, node-&gt;name, 0, parent_irq, valid_mask, node);
<span class="p_add">+#endif</span>
 
 	writel(clear_mask, base + IRQ_ENABLE_CLEAR);
 	writel(clear_mask, base + FIQ_ENABLE_CLEAR);
<span class="p_header">diff --git a/drivers/isdn/gigaset/ser-gigaset.c b/drivers/isdn/gigaset/ser-gigaset.c</span>
<span class="p_header">index 375be50..10c81ca 100644</span>
<span class="p_header">--- a/drivers/isdn/gigaset/ser-gigaset.c</span>
<span class="p_header">+++ b/drivers/isdn/gigaset/ser-gigaset.c</span>
<span class="p_chunk">@@ -370,19 +370,23 @@</span> <span class="p_context"> static void gigaset_freecshw(struct cardstate *cs)</span>
 	tasklet_kill(&amp;cs-&gt;write_tasklet);
 	if (!cs-&gt;hw.ser)
 		return;
<span class="p_del">-	dev_set_drvdata(&amp;cs-&gt;hw.ser-&gt;dev.dev, NULL);</span>
 	platform_device_unregister(&amp;cs-&gt;hw.ser-&gt;dev);
<span class="p_del">-	kfree(cs-&gt;hw.ser);</span>
<span class="p_del">-	cs-&gt;hw.ser = NULL;</span>
 }
 
 static void gigaset_device_release(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
<span class="p_add">+	struct cardstate *cs = dev_get_drvdata(dev);</span>
 
 	/* adapted from platform_device_release() in drivers/base/platform.c */
 	kfree(dev-&gt;platform_data);
 	kfree(pdev-&gt;resource);
<span class="p_add">+</span>
<span class="p_add">+	if (!cs)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	dev_set_drvdata(dev, NULL);</span>
<span class="p_add">+	kfree(cs-&gt;hw.ser);</span>
<span class="p_add">+	cs-&gt;hw.ser = NULL;</span>
 }
 
 /*
<span class="p_header">diff --git a/drivers/isdn/hardware/mISDN/mISDNipac.c b/drivers/isdn/hardware/mISDN/mISDNipac.c</span>
<span class="p_header">index a77eea5..cb428b9 100644</span>
<span class="p_header">--- a/drivers/isdn/hardware/mISDN/mISDNipac.c</span>
<span class="p_header">+++ b/drivers/isdn/hardware/mISDN/mISDNipac.c</span>
<span class="p_chunk">@@ -1170,7 +1170,7 @@</span> <span class="p_context"> mISDNipac_irq(struct ipac_hw *ipac, int maxloop)</span>
 
 	if (ipac-&gt;type &amp; IPAC_TYPE_IPACX) {
 		ista = ReadIPAC(ipac, ISACX_ISTA);
<span class="p_del">-		while (ista &amp;&amp; cnt--) {</span>
<span class="p_add">+		while (ista &amp;&amp; --cnt) {</span>
 			pr_debug(&quot;%s: ISTA %02x\n&quot;, ipac-&gt;name, ista);
 			if (ista &amp; IPACX__ICA)
 				ipac_irq(&amp;ipac-&gt;hscx[0], ista);
<span class="p_chunk">@@ -1182,7 +1182,7 @@</span> <span class="p_context"> mISDNipac_irq(struct ipac_hw *ipac, int maxloop)</span>
 		}
 	} else if (ipac-&gt;type &amp; IPAC_TYPE_IPAC) {
 		ista = ReadIPAC(ipac, IPAC_ISTA);
<span class="p_del">-		while (ista &amp;&amp; cnt--) {</span>
<span class="p_add">+		while (ista &amp;&amp; --cnt) {</span>
 			pr_debug(&quot;%s: ISTA %02x\n&quot;, ipac-&gt;name, ista);
 			if (ista &amp; (IPAC__ICD | IPAC__EXD)) {
 				istad = ReadISAC(isac, ISAC_ISTA);
<span class="p_chunk">@@ -1200,7 +1200,7 @@</span> <span class="p_context"> mISDNipac_irq(struct ipac_hw *ipac, int maxloop)</span>
 			ista = ReadIPAC(ipac, IPAC_ISTA);
 		}
 	} else if (ipac-&gt;type &amp; IPAC_TYPE_HSCX) {
<span class="p_del">-		while (cnt) {</span>
<span class="p_add">+		while (--cnt) {</span>
 			ista = ReadIPAC(ipac, IPAC_ISTAB + ipac-&gt;hscx[1].off);
 			pr_debug(&quot;%s: B2 ISTA %02x\n&quot;, ipac-&gt;name, ista);
 			if (ista)
<span class="p_chunk">@@ -1211,7 +1211,6 @@</span> <span class="p_context"> mISDNipac_irq(struct ipac_hw *ipac, int maxloop)</span>
 				mISDNisac_irq(isac, istad);
 			if (0 == (ista | istad))
 				break;
<span class="p_del">-			cnt--;</span>
 		}
 	}
 	if (cnt &gt; maxloop) /* only for ISAC/HSCX without PCI IRQ test */
<span class="p_header">diff --git a/drivers/isdn/hisax/config.c b/drivers/isdn/hisax/config.c</span>
<span class="p_header">index b33f53b..bf04d2a 100644</span>
<span class="p_header">--- a/drivers/isdn/hisax/config.c</span>
<span class="p_header">+++ b/drivers/isdn/hisax/config.c</span>
<span class="p_chunk">@@ -1896,7 +1896,7 @@</span> <span class="p_context"> static void EChannel_proc_rcv(struct hisax_d_if *d_if)</span>
 				ptr--;
 				*ptr++ = &#39;\n&#39;;
 				*ptr = 0;
<span class="p_del">-				HiSax_putstatus(cs, NULL, &quot;%s&quot;, cs-&gt;dlog);</span>
<span class="p_add">+				HiSax_putstatus(cs, NULL, cs-&gt;dlog);</span>
 			} else
 				HiSax_putstatus(cs, &quot;LogEcho: &quot;,
 						&quot;warning Frame too big (%d)&quot;,
<span class="p_header">diff --git a/drivers/isdn/hisax/hfc_pci.c b/drivers/isdn/hisax/hfc_pci.c</span>
<span class="p_header">index 4a48255..90449e1 100644</span>
<span class="p_header">--- a/drivers/isdn/hisax/hfc_pci.c</span>
<span class="p_header">+++ b/drivers/isdn/hisax/hfc_pci.c</span>
<span class="p_chunk">@@ -901,7 +901,7 @@</span> <span class="p_context"> Begin:</span>
 					ptr--;
 					*ptr++ = &#39;\n&#39;;
 					*ptr = 0;
<span class="p_del">-					HiSax_putstatus(cs, NULL, &quot;%s&quot;, cs-&gt;dlog);</span>
<span class="p_add">+					HiSax_putstatus(cs, NULL, cs-&gt;dlog);</span>
 				} else
 					HiSax_putstatus(cs, &quot;LogEcho: &quot;, &quot;warning Frame too big (%d)&quot;, total - 3);
 			}
<span class="p_header">diff --git a/drivers/isdn/hisax/hfc_sx.c b/drivers/isdn/hisax/hfc_sx.c</span>
<span class="p_header">index b1fad81..13b2151 100644</span>
<span class="p_header">--- a/drivers/isdn/hisax/hfc_sx.c</span>
<span class="p_header">+++ b/drivers/isdn/hisax/hfc_sx.c</span>
<span class="p_chunk">@@ -674,7 +674,7 @@</span> <span class="p_context"> receive_emsg(struct IsdnCardState *cs)</span>
 					ptr--;
 					*ptr++ = &#39;\n&#39;;
 					*ptr = 0;
<span class="p_del">-					HiSax_putstatus(cs, NULL, &quot;%s&quot;, cs-&gt;dlog);</span>
<span class="p_add">+					HiSax_putstatus(cs, NULL, cs-&gt;dlog);</span>
 				} else
 					HiSax_putstatus(cs, &quot;LogEcho: &quot;, &quot;warning Frame too big (%d)&quot;, skb-&gt;len);
 			}
<span class="p_header">diff --git a/drivers/isdn/hisax/q931.c b/drivers/isdn/hisax/q931.c</span>
<span class="p_header">index b420f8b..ba4beb2 100644</span>
<span class="p_header">--- a/drivers/isdn/hisax/q931.c</span>
<span class="p_header">+++ b/drivers/isdn/hisax/q931.c</span>
<span class="p_chunk">@@ -1179,7 +1179,7 @@</span> <span class="p_context"> LogFrame(struct IsdnCardState *cs, u_char *buf, int size)</span>
 		dp--;
 		*dp++ = &#39;\n&#39;;
 		*dp = 0;
<span class="p_del">-		HiSax_putstatus(cs, NULL, &quot;%s&quot;, cs-&gt;dlog);</span>
<span class="p_add">+		HiSax_putstatus(cs, NULL, cs-&gt;dlog);</span>
 	} else
 		HiSax_putstatus(cs, &quot;LogFrame: &quot;, &quot;warning Frame too big (%d)&quot;, size);
 }
<span class="p_chunk">@@ -1246,7 +1246,7 @@</span> <span class="p_context"> dlogframe(struct IsdnCardState *cs, struct sk_buff *skb, int dir)</span>
 	}
 	if (finish) {
 		*dp = 0;
<span class="p_del">-		HiSax_putstatus(cs, NULL, &quot;%s&quot;, cs-&gt;dlog);</span>
<span class="p_add">+		HiSax_putstatus(cs, NULL, cs-&gt;dlog);</span>
 		return;
 	}
 	if ((0xfe &amp; buf[0]) == PROTO_DIS_N0) {	/* 1TR6 */
<span class="p_chunk">@@ -1509,5 +1509,5 @@</span> <span class="p_context"> dlogframe(struct IsdnCardState *cs, struct sk_buff *skb, int dir)</span>
 		dp += sprintf(dp, &quot;Unknown protocol %x!&quot;, buf[0]);
 	}
 	*dp = 0;
<span class="p_del">-	HiSax_putstatus(cs, NULL, &quot;%s&quot;, cs-&gt;dlog);</span>
<span class="p_add">+	HiSax_putstatus(cs, NULL, cs-&gt;dlog);</span>
 }
<span class="p_header">diff --git a/drivers/md/dm-crypt.c b/drivers/md/dm-crypt.c</span>
<span class="p_header">index 0d28c5b..282d400 100644</span>
<span class="p_header">--- a/drivers/md/dm-crypt.c</span>
<span class="p_header">+++ b/drivers/md/dm-crypt.c</span>
<span class="p_chunk">@@ -112,7 +112,8 @@</span> <span class="p_context"> struct iv_tcw_private {</span>
  * and encrypts / decrypts at the same time.
  */
 enum flags { DM_CRYPT_SUSPENDED, DM_CRYPT_KEY_VALID,
<span class="p_del">-	     DM_CRYPT_SAME_CPU, DM_CRYPT_NO_OFFLOAD };</span>
<span class="p_add">+	     DM_CRYPT_SAME_CPU, DM_CRYPT_NO_OFFLOAD,</span>
<span class="p_add">+	     DM_CRYPT_EXIT_THREAD};</span>
 
 /*
  * The fields in here must be read only after initialization.
<span class="p_chunk">@@ -1203,20 +1204,18 @@</span> <span class="p_context"> continue_locked:</span>
 		if (!RB_EMPTY_ROOT(&amp;cc-&gt;write_tree))
 			goto pop_from_list;
 
<span class="p_add">+		if (unlikely(test_bit(DM_CRYPT_EXIT_THREAD, &amp;cc-&gt;flags))) {</span>
<span class="p_add">+			spin_unlock_irq(&amp;cc-&gt;write_thread_wait.lock);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		__set_current_state(TASK_INTERRUPTIBLE);
 		__add_wait_queue(&amp;cc-&gt;write_thread_wait, &amp;wait);
 
 		spin_unlock_irq(&amp;cc-&gt;write_thread_wait.lock);
 
<span class="p_del">-		if (unlikely(kthread_should_stop())) {</span>
<span class="p_del">-			set_task_state(current, TASK_RUNNING);</span>
<span class="p_del">-			remove_wait_queue(&amp;cc-&gt;write_thread_wait, &amp;wait);</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
 		schedule();
 
<span class="p_del">-		set_task_state(current, TASK_RUNNING);</span>
 		spin_lock_irq(&amp;cc-&gt;write_thread_wait.lock);
 		__remove_wait_queue(&amp;cc-&gt;write_thread_wait, &amp;wait);
 		goto continue_locked;
<span class="p_chunk">@@ -1531,8 +1530,13 @@</span> <span class="p_context"> static void crypt_dtr(struct dm_target *ti)</span>
 	if (!cc)
 		return;
 
<span class="p_del">-	if (cc-&gt;write_thread)</span>
<span class="p_add">+	if (cc-&gt;write_thread) {</span>
<span class="p_add">+		spin_lock_irq(&amp;cc-&gt;write_thread_wait.lock);</span>
<span class="p_add">+		set_bit(DM_CRYPT_EXIT_THREAD, &amp;cc-&gt;flags);</span>
<span class="p_add">+		wake_up_locked(&amp;cc-&gt;write_thread_wait);</span>
<span class="p_add">+		spin_unlock_irq(&amp;cc-&gt;write_thread_wait.lock);</span>
 		kthread_stop(cc-&gt;write_thread);
<span class="p_add">+	}</span>
 
 	if (cc-&gt;io_queue)
 		destroy_workqueue(cc-&gt;io_queue);
<span class="p_header">diff --git a/drivers/md/dm-thin-metadata.c b/drivers/md/dm-thin-metadata.c</span>
<span class="p_header">index 6ba47cf..4479e90 100644</span>
<span class="p_header">--- a/drivers/md/dm-thin-metadata.c</span>
<span class="p_header">+++ b/drivers/md/dm-thin-metadata.c</span>
<span class="p_chunk">@@ -1203,6 +1203,12 @@</span> <span class="p_context"> static int __reserve_metadata_snap(struct dm_pool_metadata *pmd)</span>
 	dm_block_t held_root;
 
 	/*
<span class="p_add">+	 * We commit to ensure the btree roots which we increment in a</span>
<span class="p_add">+	 * moment are up to date.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	__commit_transaction(pmd);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
 	 * Copy the superblock.
 	 */
 	dm_sm_inc_block(pmd-&gt;metadata_sm, THIN_SUPERBLOCK_LOCATION);
<span class="p_chunk">@@ -1530,7 +1536,7 @@</span> <span class="p_context"> static int __remove(struct dm_thin_device *td, dm_block_t block)</span>
 static int __remove_range(struct dm_thin_device *td, dm_block_t begin, dm_block_t end)
 {
 	int r;
<span class="p_del">-	unsigned count;</span>
<span class="p_add">+	unsigned count, total_count = 0;</span>
 	struct dm_pool_metadata *pmd = td-&gt;pmd;
 	dm_block_t keys[1] = { td-&gt;id };
 	__le64 value;
<span class="p_chunk">@@ -1553,11 +1559,29 @@</span> <span class="p_context"> static int __remove_range(struct dm_thin_device *td, dm_block_t begin, dm_block_</span>
 	if (r)
 		return r;
 
<span class="p_del">-	r = dm_btree_remove_leaves(&amp;pmd-&gt;bl_info, mapping_root, &amp;begin, end, &amp;mapping_root, &amp;count);</span>
<span class="p_del">-	if (r)</span>
<span class="p_del">-		return r;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Remove leaves stops at the first unmapped entry, so we have to</span>
<span class="p_add">+	 * loop round finding mapped ranges.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	while (begin &lt; end) {</span>
<span class="p_add">+		r = dm_btree_lookup_next(&amp;pmd-&gt;bl_info, mapping_root, &amp;begin, &amp;begin, &amp;value);</span>
<span class="p_add">+		if (r == -ENODATA)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (r)</span>
<span class="p_add">+			return r;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (begin &gt;= end)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
<span class="p_add">+		r = dm_btree_remove_leaves(&amp;pmd-&gt;bl_info, mapping_root, &amp;begin, end, &amp;mapping_root, &amp;count);</span>
<span class="p_add">+		if (r)</span>
<span class="p_add">+			return r;</span>
<span class="p_add">+</span>
<span class="p_add">+		total_count += count;</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	td-&gt;mapped_blocks -= count;</span>
<span class="p_add">+	td-&gt;mapped_blocks -= total_count;</span>
 	td-&gt;changed = 1;
 
 	/*
<span class="p_header">diff --git a/drivers/md/dm-thin.c b/drivers/md/dm-thin.c</span>
<span class="p_header">index 493c38e..3efdddb 100644</span>
<span class="p_header">--- a/drivers/md/dm-thin.c</span>
<span class="p_header">+++ b/drivers/md/dm-thin.c</span>
<span class="p_chunk">@@ -2487,6 +2487,7 @@</span> <span class="p_context"> static void set_pool_mode(struct pool *pool, enum pool_mode new_mode)</span>
 	case PM_WRITE:
 		if (old_mode != new_mode)
 			notify_of_pool_mode_change(pool, &quot;write&quot;);
<span class="p_add">+		pool-&gt;pf.error_if_no_space = pt-&gt;requested_pf.error_if_no_space;</span>
 		dm_pool_metadata_read_write(pool-&gt;pmd);
 		pool-&gt;process_bio = process_bio;
 		pool-&gt;process_discard = process_discard_bio;
<span class="p_chunk">@@ -4333,10 +4334,9 @@</span> <span class="p_context"> static void thin_io_hints(struct dm_target *ti, struct queue_limits *limits)</span>
 {
 	struct thin_c *tc = ti-&gt;private;
 	struct pool *pool = tc-&gt;pool;
<span class="p_del">-	struct queue_limits *pool_limits = dm_get_queue_limits(pool-&gt;pool_md);</span>
 
<span class="p_del">-	if (!pool_limits-&gt;discard_granularity)</span>
<span class="p_del">-		return; /* pool&#39;s discard support is disabled */</span>
<span class="p_add">+	if (!pool-&gt;pf.discard_enabled)</span>
<span class="p_add">+		return;</span>
 
 	limits-&gt;discard_granularity = pool-&gt;sectors_per_block &lt;&lt; SECTOR_SHIFT;
 	limits-&gt;max_discard_sectors = 2048 * 1024 * 16; /* 16G */
<span class="p_header">diff --git a/drivers/md/md.c b/drivers/md/md.c</span>
<span class="p_header">index 95e7b72..3d49672 100644</span>
<span class="p_header">--- a/drivers/md/md.c</span>
<span class="p_header">+++ b/drivers/md/md.c</span>
<span class="p_chunk">@@ -4235,8 +4235,7 @@</span> <span class="p_context"> action_store(struct mddev *mddev, const char *page, size_t len)</span>
 			}
 			mddev_unlock(mddev);
 		}
<span class="p_del">-	} else if (test_bit(MD_RECOVERY_RUNNING, &amp;mddev-&gt;recovery) ||</span>
<span class="p_del">-		   test_bit(MD_RECOVERY_NEEDED, &amp;mddev-&gt;recovery))</span>
<span class="p_add">+	} else if (test_bit(MD_RECOVERY_RUNNING, &amp;mddev-&gt;recovery))</span>
 		return -EBUSY;
 	else if (cmd_match(page, &quot;resync&quot;))
 		clear_bit(MD_RECOVERY_FROZEN, &amp;mddev-&gt;recovery);
<span class="p_chunk">@@ -4249,8 +4248,12 @@</span> <span class="p_context"> action_store(struct mddev *mddev, const char *page, size_t len)</span>
 			return -EINVAL;
 		err = mddev_lock(mddev);
 		if (!err) {
<span class="p_del">-			clear_bit(MD_RECOVERY_FROZEN, &amp;mddev-&gt;recovery);</span>
<span class="p_del">-			err = mddev-&gt;pers-&gt;start_reshape(mddev);</span>
<span class="p_add">+			if (test_bit(MD_RECOVERY_RUNNING, &amp;mddev-&gt;recovery))</span>
<span class="p_add">+				err =  -EBUSY;</span>
<span class="p_add">+			else {</span>
<span class="p_add">+				clear_bit(MD_RECOVERY_FROZEN, &amp;mddev-&gt;recovery);</span>
<span class="p_add">+				err = mddev-&gt;pers-&gt;start_reshape(mddev);</span>
<span class="p_add">+			}</span>
 			mddev_unlock(mddev);
 		}
 		if (err)
<span class="p_header">diff --git a/drivers/md/persistent-data/dm-btree.c b/drivers/md/persistent-data/dm-btree.c</span>
<span class="p_header">index d6e4703..5cb4068 100644</span>
<span class="p_header">--- a/drivers/md/persistent-data/dm-btree.c</span>
<span class="p_header">+++ b/drivers/md/persistent-data/dm-btree.c</span>
<span class="p_chunk">@@ -63,6 +63,11 @@</span> <span class="p_context"> int lower_bound(struct btree_node *n, uint64_t key)</span>
 	return bsearch(n, key, 0);
 }
 
<span class="p_add">+static int upper_bound(struct btree_node *n, uint64_t key)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return bsearch(n, key, 1);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void inc_children(struct dm_transaction_manager *tm, struct btree_node *n,
 		  struct dm_btree_value_type *vt)
 {
<span class="p_chunk">@@ -250,6 +255,16 @@</span> <span class="p_context"> static void pop_frame(struct del_stack *s)</span>
 	dm_tm_unlock(s-&gt;tm, f-&gt;b);
 }
 
<span class="p_add">+static void unlock_all_frames(struct del_stack *s)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct frame *f;</span>
<span class="p_add">+</span>
<span class="p_add">+	while (unprocessed_frames(s)) {</span>
<span class="p_add">+		f = s-&gt;spine + s-&gt;top--;</span>
<span class="p_add">+		dm_tm_unlock(s-&gt;tm, f-&gt;b);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int dm_btree_del(struct dm_btree_info *info, dm_block_t root)
 {
 	int r;
<span class="p_chunk">@@ -306,9 +321,13 @@</span> <span class="p_context"> int dm_btree_del(struct dm_btree_info *info, dm_block_t root)</span>
 			pop_frame(s);
 		}
 	}
<span class="p_del">-</span>
 out:
<span class="p_add">+	if (r) {</span>
<span class="p_add">+		/* cleanup all frames of del_stack */</span>
<span class="p_add">+		unlock_all_frames(s);</span>
<span class="p_add">+	}</span>
 	kfree(s);
<span class="p_add">+</span>
 	return r;
 }
 EXPORT_SYMBOL_GPL(dm_btree_del);
<span class="p_chunk">@@ -390,6 +409,82 @@</span> <span class="p_context"> int dm_btree_lookup(struct dm_btree_info *info, dm_block_t root,</span>
 }
 EXPORT_SYMBOL_GPL(dm_btree_lookup);
 
<span class="p_add">+static int dm_btree_lookup_next_single(struct dm_btree_info *info, dm_block_t root,</span>
<span class="p_add">+				       uint64_t key, uint64_t *rkey, void *value_le)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int r, i;</span>
<span class="p_add">+	uint32_t flags, nr_entries;</span>
<span class="p_add">+	struct dm_block *node;</span>
<span class="p_add">+	struct btree_node *n;</span>
<span class="p_add">+</span>
<span class="p_add">+	r = bn_read_lock(info, root, &amp;node);</span>
<span class="p_add">+	if (r)</span>
<span class="p_add">+		return r;</span>
<span class="p_add">+</span>
<span class="p_add">+	n = dm_block_data(node);</span>
<span class="p_add">+	flags = le32_to_cpu(n-&gt;header.flags);</span>
<span class="p_add">+	nr_entries = le32_to_cpu(n-&gt;header.nr_entries);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (flags &amp; INTERNAL_NODE) {</span>
<span class="p_add">+		i = lower_bound(n, key);</span>
<span class="p_add">+		if (i &lt; 0 || i &gt;= nr_entries) {</span>
<span class="p_add">+			r = -ENODATA;</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		r = dm_btree_lookup_next_single(info, value64(n, i), key, rkey, value_le);</span>
<span class="p_add">+		if (r == -ENODATA &amp;&amp; i &lt; (nr_entries - 1)) {</span>
<span class="p_add">+			i++;</span>
<span class="p_add">+			r = dm_btree_lookup_next_single(info, value64(n, i), key, rkey, value_le);</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		i = upper_bound(n, key);</span>
<span class="p_add">+		if (i &lt; 0 || i &gt;= nr_entries) {</span>
<span class="p_add">+			r = -ENODATA;</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		*rkey = le64_to_cpu(n-&gt;keys[i]);</span>
<span class="p_add">+		memcpy(value_le, value_ptr(n, i), info-&gt;value_type.size);</span>
<span class="p_add">+	}</span>
<span class="p_add">+out:</span>
<span class="p_add">+	dm_tm_unlock(info-&gt;tm, node);</span>
<span class="p_add">+	return r;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int dm_btree_lookup_next(struct dm_btree_info *info, dm_block_t root,</span>
<span class="p_add">+			 uint64_t *keys, uint64_t *rkey, void *value_le)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned level;</span>
<span class="p_add">+	int r = -ENODATA;</span>
<span class="p_add">+	__le64 internal_value_le;</span>
<span class="p_add">+	struct ro_spine spine;</span>
<span class="p_add">+</span>
<span class="p_add">+	init_ro_spine(&amp;spine, info);</span>
<span class="p_add">+	for (level = 0; level &lt; info-&gt;levels - 1u; level++) {</span>
<span class="p_add">+		r = btree_lookup_raw(&amp;spine, root, keys[level],</span>
<span class="p_add">+				     lower_bound, rkey,</span>
<span class="p_add">+				     &amp;internal_value_le, sizeof(uint64_t));</span>
<span class="p_add">+		if (r)</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (*rkey != keys[level]) {</span>
<span class="p_add">+			r = -ENODATA;</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		root = le64_to_cpu(internal_value_le);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	r = dm_btree_lookup_next_single(info, root, keys[level], rkey, value_le);</span>
<span class="p_add">+out:</span>
<span class="p_add">+	exit_ro_spine(&amp;spine);</span>
<span class="p_add">+	return r;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(dm_btree_lookup_next);</span>
<span class="p_add">+</span>
 /*
  * Splits a node by creating a sibling node and shifting half the nodes
  * contents across.  Assumes there is a parent node, and it has room for
<span class="p_chunk">@@ -471,8 +566,10 @@</span> <span class="p_context"> static int btree_split_sibling(struct shadow_spine *s, dm_block_t root,</span>
 
 	r = insert_at(sizeof(__le64), pn, parent_index + 1,
 		      le64_to_cpu(rn-&gt;keys[0]), &amp;location);
<span class="p_del">-	if (r)</span>
<span class="p_add">+	if (r) {</span>
<span class="p_add">+		unlock_block(s-&gt;info, right);</span>
 		return r;
<span class="p_add">+	}</span>
 
 	if (key &lt; le64_to_cpu(rn-&gt;keys[0])) {
 		unlock_block(s-&gt;info, right);
<span class="p_header">diff --git a/drivers/md/persistent-data/dm-btree.h b/drivers/md/persistent-data/dm-btree.h</span>
<span class="p_header">index 11d8cf7..c74301f 100644</span>
<span class="p_header">--- a/drivers/md/persistent-data/dm-btree.h</span>
<span class="p_header">+++ b/drivers/md/persistent-data/dm-btree.h</span>
<span class="p_chunk">@@ -110,6 +110,13 @@</span> <span class="p_context"> int dm_btree_lookup(struct dm_btree_info *info, dm_block_t root,</span>
 		    uint64_t *keys, void *value_le);
 
 /*
<span class="p_add">+ * Tries to find the first key where the bottom level key is &gt;= to that</span>
<span class="p_add">+ * given.  Useful for skipping empty sections of the btree.</span>
<span class="p_add">+ */</span>
<span class="p_add">+int dm_btree_lookup_next(struct dm_btree_info *info, dm_block_t root,</span>
<span class="p_add">+			 uint64_t *keys, uint64_t *rkey, void *value_le);</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * Insertion (or overwrite an existing value).  O(ln(n))
  */
 int dm_btree_insert(struct dm_btree_info *info, dm_block_t root,
<span class="p_chunk">@@ -135,9 +142,10 @@</span> <span class="p_context"> int dm_btree_remove(struct dm_btree_info *info, dm_block_t root,</span>
 		    uint64_t *keys, dm_block_t *new_root);
 
 /*
<span class="p_del">- * Removes values between &#39;keys&#39; and keys2, where keys2 is keys with the</span>
<span class="p_del">- * final key replaced with &#39;end_key&#39;.  &#39;end_key&#39; is the one-past-the-end</span>
<span class="p_del">- * value.  &#39;keys&#39; may be altered.</span>
<span class="p_add">+ * Removes a _contiguous_ run of values starting from &#39;keys&#39; and not</span>
<span class="p_add">+ * reaching keys2 (where keys2 is keys with the final key replaced with</span>
<span class="p_add">+ * &#39;end_key&#39;).  &#39;end_key&#39; is the one-past-the-end value.  &#39;keys&#39; may be</span>
<span class="p_add">+ * altered.</span>
  */
 int dm_btree_remove_leaves(struct dm_btree_info *info, dm_block_t root,
 			   uint64_t *keys, uint64_t end_key,
<span class="p_header">diff --git a/drivers/md/persistent-data/dm-space-map-metadata.c b/drivers/md/persistent-data/dm-space-map-metadata.c</span>
<span class="p_header">index 5309129..fca6dbc 100644</span>
<span class="p_header">--- a/drivers/md/persistent-data/dm-space-map-metadata.c</span>
<span class="p_header">+++ b/drivers/md/persistent-data/dm-space-map-metadata.c</span>
<span class="p_chunk">@@ -136,7 +136,7 @@</span> <span class="p_context"> static int brb_push(struct bop_ring_buffer *brb,</span>
 	return 0;
 }
 
<span class="p_del">-static int brb_pop(struct bop_ring_buffer *brb, struct block_op *result)</span>
<span class="p_add">+static int brb_peek(struct bop_ring_buffer *brb, struct block_op *result)</span>
 {
 	struct block_op *bop;
 
<span class="p_chunk">@@ -147,6 +147,17 @@</span> <span class="p_context"> static int brb_pop(struct bop_ring_buffer *brb, struct block_op *result)</span>
 	result-&gt;type = bop-&gt;type;
 	result-&gt;block = bop-&gt;block;
 
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int brb_pop(struct bop_ring_buffer *brb)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct block_op *bop;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (brb_empty(brb))</span>
<span class="p_add">+		return -ENODATA;</span>
<span class="p_add">+</span>
<span class="p_add">+	bop = brb-&gt;bops + brb-&gt;begin;</span>
 	brb-&gt;begin = brb_next(brb, brb-&gt;begin);
 
 	return 0;
<span class="p_chunk">@@ -211,7 +222,7 @@</span> <span class="p_context"> static int apply_bops(struct sm_metadata *smm)</span>
 	while (!brb_empty(&amp;smm-&gt;uncommitted)) {
 		struct block_op bop;
 
<span class="p_del">-		r = brb_pop(&amp;smm-&gt;uncommitted, &amp;bop);</span>
<span class="p_add">+		r = brb_peek(&amp;smm-&gt;uncommitted, &amp;bop);</span>
 		if (r) {
 			DMERR(&quot;bug in bop ring buffer&quot;);
 			break;
<span class="p_chunk">@@ -220,6 +231,8 @@</span> <span class="p_context"> static int apply_bops(struct sm_metadata *smm)</span>
 		r = commit_bop(smm, &amp;bop);
 		if (r)
 			break;
<span class="p_add">+</span>
<span class="p_add">+		brb_pop(&amp;smm-&gt;uncommitted);</span>
 	}
 
 	return r;
<span class="p_chunk">@@ -683,7 +696,6 @@</span> <span class="p_context"> static struct dm_space_map bootstrap_ops = {</span>
 static int sm_metadata_extend(struct dm_space_map *sm, dm_block_t extra_blocks)
 {
 	int r, i;
<span class="p_del">-	enum allocation_event ev;</span>
 	struct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);
 	dm_block_t old_len = smm-&gt;ll.nr_blocks;
 
<span class="p_chunk">@@ -705,11 +717,12 @@</span> <span class="p_context"> static int sm_metadata_extend(struct dm_space_map *sm, dm_block_t extra_blocks)</span>
 	 * allocate any new blocks.
 	 */
 	do {
<span class="p_del">-		for (i = old_len; !r &amp;&amp; i &lt; smm-&gt;begin; i++) {</span>
<span class="p_del">-			r = sm_ll_inc(&amp;smm-&gt;ll, i, &amp;ev);</span>
<span class="p_del">-			if (r)</span>
<span class="p_del">-				goto out;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		for (i = old_len; !r &amp;&amp; i &lt; smm-&gt;begin; i++)</span>
<span class="p_add">+			r = add_bop(smm, BOP_INC, i);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (r)</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+</span>
 		old_len = smm-&gt;begin;
 
 		r = apply_bops(smm);
<span class="p_chunk">@@ -754,7 +767,6 @@</span> <span class="p_context"> int dm_sm_metadata_create(struct dm_space_map *sm,</span>
 {
 	int r;
 	dm_block_t i;
<span class="p_del">-	enum allocation_event ev;</span>
 	struct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);
 
 	smm-&gt;begin = superblock + 1;
<span class="p_chunk">@@ -782,7 +794,7 @@</span> <span class="p_context"> int dm_sm_metadata_create(struct dm_space_map *sm,</span>
 	 * allocated blocks that they were built from.
 	 */
 	for (i = superblock; !r &amp;&amp; i &lt; smm-&gt;begin; i++)
<span class="p_del">-		r = sm_ll_inc(&amp;smm-&gt;ll, i, &amp;ev);</span>
<span class="p_add">+		r = add_bop(smm, BOP_INC, i);</span>
 
 	if (r)
 		return r;
<span class="p_header">diff --git a/drivers/md/raid10.c b/drivers/md/raid10.c</span>
<span class="p_header">index d4b70d9..3bcbdb7 100644</span>
<span class="p_header">--- a/drivers/md/raid10.c</span>
<span class="p_header">+++ b/drivers/md/raid10.c</span>
<span class="p_chunk">@@ -2052,6 +2052,8 @@</span> <span class="p_context"> static void sync_request_write(struct mddev *mddev, struct r10bio *r10_bio)</span>
 
 	first = i;
 	fbio = r10_bio-&gt;devs[i].bio;
<span class="p_add">+	fbio-&gt;bi_iter.bi_size = r10_bio-&gt;sectors &lt;&lt; 9;</span>
<span class="p_add">+	fbio-&gt;bi_iter.bi_idx = 0;</span>
 
 	vcnt = (r10_bio-&gt;sectors + (PAGE_SIZE &gt;&gt; 9) - 1) &gt;&gt; (PAGE_SHIFT - 9);
 	/* now find blocks with errors */
<span class="p_chunk">@@ -2095,7 +2097,7 @@</span> <span class="p_context"> static void sync_request_write(struct mddev *mddev, struct r10bio *r10_bio)</span>
 		bio_reset(tbio);
 
 		tbio-&gt;bi_vcnt = vcnt;
<span class="p_del">-		tbio-&gt;bi_iter.bi_size = r10_bio-&gt;sectors &lt;&lt; 9;</span>
<span class="p_add">+		tbio-&gt;bi_iter.bi_size = fbio-&gt;bi_iter.bi_size;</span>
 		tbio-&gt;bi_rw = WRITE;
 		tbio-&gt;bi_private = r10_bio;
 		tbio-&gt;bi_iter.bi_sector = r10_bio-&gt;devs[i].addr;
<span class="p_header">diff --git a/drivers/media/pci/ivtv/ivtv-driver.c b/drivers/media/pci/ivtv/ivtv-driver.c</span>
<span class="p_header">index 8616fa8..c2e60b4 100644</span>
<span class="p_header">--- a/drivers/media/pci/ivtv/ivtv-driver.c</span>
<span class="p_header">+++ b/drivers/media/pci/ivtv/ivtv-driver.c</span>
<span class="p_chunk">@@ -805,11 +805,11 @@</span> <span class="p_context"> static void ivtv_init_struct2(struct ivtv *itv)</span>
 {
 	int i;
 
<span class="p_del">-	for (i = 0; i &lt; IVTV_CARD_MAX_VIDEO_INPUTS - 1; i++)</span>
<span class="p_add">+	for (i = 0; i &lt; IVTV_CARD_MAX_VIDEO_INPUTS; i++)</span>
 		if (itv-&gt;card-&gt;video_inputs[i].video_type == 0)
 			break;
 	itv-&gt;nof_inputs = i;
<span class="p_del">-	for (i = 0; i &lt; IVTV_CARD_MAX_AUDIO_INPUTS - 1; i++)</span>
<span class="p_add">+	for (i = 0; i &lt; IVTV_CARD_MAX_AUDIO_INPUTS; i++)</span>
 		if (itv-&gt;card-&gt;audio_inputs[i].audio_type == 0)
 			break;
 	itv-&gt;nof_audio_inputs = i;
<span class="p_header">diff --git a/drivers/media/usb/airspy/airspy.c b/drivers/media/usb/airspy/airspy.c</span>
<span class="p_header">index 4069234..a50750c 100644</span>
<span class="p_header">--- a/drivers/media/usb/airspy/airspy.c</span>
<span class="p_header">+++ b/drivers/media/usb/airspy/airspy.c</span>
<span class="p_chunk">@@ -132,7 +132,7 @@</span> <span class="p_context"> struct airspy {</span>
 	int            urbs_submitted;
 
 	/* USB control message buffer */
<span class="p_del">-	#define BUF_SIZE 24</span>
<span class="p_add">+	#define BUF_SIZE 128</span>
 	u8 buf[BUF_SIZE];
 
 	/* Current configuration */
<span class="p_header">diff --git a/drivers/misc/cxl/native.c b/drivers/misc/cxl/native.c</span>
<span class="p_header">index 8339eb2..b703559 100644</span>
<span class="p_header">--- a/drivers/misc/cxl/native.c</span>
<span class="p_header">+++ b/drivers/misc/cxl/native.c</span>
<span class="p_chunk">@@ -434,6 +434,7 @@</span> <span class="p_context"> static u64 calculate_sr(struct cxl_context *ctx)</span>
 {
 	u64 sr = 0;
 
<span class="p_add">+	set_endian(sr);</span>
 	if (ctx-&gt;master)
 		sr |= CXL_PSL_SR_An_MP;
 	if (mfspr(SPRN_LPCR) &amp; LPCR_TC)
<span class="p_chunk">@@ -443,7 +444,6 @@</span> <span class="p_context"> static u64 calculate_sr(struct cxl_context *ctx)</span>
 		sr |= CXL_PSL_SR_An_HV;
 	} else {
 		sr |= CXL_PSL_SR_An_PR | CXL_PSL_SR_An_R;
<span class="p_del">-		set_endian(sr);</span>
 		sr &amp;= ~(CXL_PSL_SR_An_HV);
 		if (!test_tsk_thread_flag(current, TIF_32BIT))
 			sr |= CXL_PSL_SR_An_SF;
<span class="p_header">diff --git a/drivers/mmc/card/block.c b/drivers/mmc/card/block.c</span>
<span class="p_header">index a1b820f..88c4e08 100644</span>
<span class="p_header">--- a/drivers/mmc/card/block.c</span>
<span class="p_header">+++ b/drivers/mmc/card/block.c</span>
<span class="p_chunk">@@ -62,8 +62,7 @@</span> <span class="p_context"> MODULE_ALIAS(&quot;mmc:block&quot;);</span>
 #define MMC_SANITIZE_REQ_TIMEOUT 240000
 #define MMC_EXTRACT_INDEX_FROM_ARG(x) ((x &amp; 0x00FF0000) &gt;&gt; 16)
 
<span class="p_del">-#define mmc_req_rel_wr(req)	(((req-&gt;cmd_flags &amp; REQ_FUA) || \</span>
<span class="p_del">-				  (req-&gt;cmd_flags &amp; REQ_META)) &amp;&amp; \</span>
<span class="p_add">+#define mmc_req_rel_wr(req)	((req-&gt;cmd_flags &amp; REQ_FUA) &amp;&amp; \</span>
 				  (rq_data_dir(req) == WRITE))
 #define PACKED_CMD_VER	0x01
 #define PACKED_CMD_WR	0x02
<span class="p_chunk">@@ -1377,13 +1376,9 @@</span> <span class="p_context"> static void mmc_blk_rw_rq_prep(struct mmc_queue_req *mqrq,</span>
 
 	/*
 	 * Reliable writes are used to implement Forced Unit Access and
<span class="p_del">-	 * REQ_META accesses, and are supported only on MMCs.</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * XXX: this really needs a good explanation of why REQ_META</span>
<span class="p_del">-	 * is treated special.</span>
<span class="p_add">+	 * are supported only on MMCs.</span>
 	 */
<span class="p_del">-	bool do_rel_wr = ((req-&gt;cmd_flags &amp; REQ_FUA) ||</span>
<span class="p_del">-			  (req-&gt;cmd_flags &amp; REQ_META)) &amp;&amp;</span>
<span class="p_add">+	bool do_rel_wr = (req-&gt;cmd_flags &amp; REQ_FUA) &amp;&amp;</span>
 		(rq_data_dir(req) == WRITE) &amp;&amp;
 		(md-&gt;flags &amp; MMC_BLK_REL_WR);
 
<span class="p_header">diff --git a/drivers/mmc/core/mmc.c b/drivers/mmc/core/mmc.c</span>
<span class="p_header">index f6cd995..748eddf 100644</span>
<span class="p_header">--- a/drivers/mmc/core/mmc.c</span>
<span class="p_header">+++ b/drivers/mmc/core/mmc.c</span>
<span class="p_chunk">@@ -1040,9 +1040,24 @@</span> <span class="p_context"> static int mmc_select_hs_ddr(struct mmc_card *card)</span>
 	return err;
 }
 
<span class="p_add">+/* Caller must hold re-tuning */</span>
<span class="p_add">+static int mmc_switch_status(struct mmc_card *card)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 status;</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = mmc_send_status(card, &amp;status);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	return mmc_switch_status_error(card-&gt;host, status);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int mmc_select_hs400(struct mmc_card *card)
 {
 	struct mmc_host *host = card-&gt;host;
<span class="p_add">+	bool send_status = true;</span>
<span class="p_add">+	unsigned int max_dtr;</span>
 	int err = 0;
 	u8 val;
 
<span class="p_chunk">@@ -1053,25 +1068,36 @@</span> <span class="p_context"> static int mmc_select_hs400(struct mmc_card *card)</span>
 	      host-&gt;ios.bus_width == MMC_BUS_WIDTH_8))
 		return 0;
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Before switching to dual data rate operation for HS400,</span>
<span class="p_del">-	 * it is required to convert from HS200 mode to HS mode.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	mmc_set_timing(card-&gt;host, MMC_TIMING_MMC_HS);</span>
<span class="p_del">-	mmc_set_bus_speed(card);</span>
<span class="p_add">+	if (host-&gt;caps &amp; MMC_CAP_WAIT_WHILE_BUSY)</span>
<span class="p_add">+		send_status = false;</span>
 
<span class="p_add">+	/* Reduce frequency to HS frequency */</span>
<span class="p_add">+	max_dtr = card-&gt;ext_csd.hs_max_dtr;</span>
<span class="p_add">+	mmc_set_clock(host, max_dtr);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Switch card to HS mode */</span>
 	val = EXT_CSD_TIMING_HS |
 	      card-&gt;drive_strength &lt;&lt; EXT_CSD_DRV_STR_SHIFT;
 	err = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
 			   EXT_CSD_HS_TIMING, val,
 			   card-&gt;ext_csd.generic_cmd6_time,
<span class="p_del">-			   true, true, true);</span>
<span class="p_add">+			   true, send_status, true);</span>
 	if (err) {
 		pr_err(&quot;%s: switch to high-speed from hs200 failed, err:%d\n&quot;,
 			mmc_hostname(host), err);
 		return err;
 	}
 
<span class="p_add">+	/* Set host controller to HS timing */</span>
<span class="p_add">+	mmc_set_timing(card-&gt;host, MMC_TIMING_MMC_HS);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!send_status) {</span>
<span class="p_add">+		err = mmc_switch_status(card);</span>
<span class="p_add">+		if (err)</span>
<span class="p_add">+			goto out_err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Switch card to DDR */</span>
 	err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
 			 EXT_CSD_BUS_WIDTH,
 			 EXT_CSD_DDR_BUS_WIDTH_8,
<span class="p_chunk">@@ -1082,22 +1108,35 @@</span> <span class="p_context"> static int mmc_select_hs400(struct mmc_card *card)</span>
 		return err;
 	}
 
<span class="p_add">+	/* Switch card to HS400 */</span>
 	val = EXT_CSD_TIMING_HS400 |
 	      card-&gt;drive_strength &lt;&lt; EXT_CSD_DRV_STR_SHIFT;
 	err = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
 			   EXT_CSD_HS_TIMING, val,
 			   card-&gt;ext_csd.generic_cmd6_time,
<span class="p_del">-			   true, true, true);</span>
<span class="p_add">+			   true, send_status, true);</span>
 	if (err) {
 		pr_err(&quot;%s: switch to hs400 failed, err:%d\n&quot;,
 			 mmc_hostname(host), err);
 		return err;
 	}
 
<span class="p_add">+	/* Set host controller to HS400 timing and frequency */</span>
 	mmc_set_timing(host, MMC_TIMING_MMC_HS400);
 	mmc_set_bus_speed(card);
 
<span class="p_add">+	if (!send_status) {</span>
<span class="p_add">+		err = mmc_switch_status(card);</span>
<span class="p_add">+		if (err)</span>
<span class="p_add">+			goto out_err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return 0;
<span class="p_add">+</span>
<span class="p_add">+out_err:</span>
<span class="p_add">+	pr_err(&quot;%s: %s failed, error %d\n&quot;, mmc_hostname(card-&gt;host),</span>
<span class="p_add">+	       __func__, err);</span>
<span class="p_add">+	return err;</span>
 }
 
 int mmc_hs200_to_hs400(struct mmc_card *card)
<span class="p_chunk">@@ -1105,19 +1144,6 @@</span> <span class="p_context"> int mmc_hs200_to_hs400(struct mmc_card *card)</span>
 	return mmc_select_hs400(card);
 }
 
<span class="p_del">-/* Caller must hold re-tuning */</span>
<span class="p_del">-static int mmc_switch_status(struct mmc_card *card)</span>
<span class="p_del">-{</span>
<span class="p_del">-	u32 status;</span>
<span class="p_del">-	int err;</span>
<span class="p_del">-</span>
<span class="p_del">-	err = mmc_send_status(card, &amp;status);</span>
<span class="p_del">-	if (err)</span>
<span class="p_del">-		return err;</span>
<span class="p_del">-</span>
<span class="p_del">-	return mmc_switch_status_error(card-&gt;host, status);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 int mmc_hs400_to_hs200(struct mmc_card *card)
 {
 	struct mmc_host *host = card-&gt;host;
<span class="p_chunk">@@ -1219,6 +1245,8 @@</span> <span class="p_context"> static void mmc_select_driver_type(struct mmc_card *card)</span>
 static int mmc_select_hs200(struct mmc_card *card)
 {
 	struct mmc_host *host = card-&gt;host;
<span class="p_add">+	bool send_status = true;</span>
<span class="p_add">+	unsigned int old_timing;</span>
 	int err = -EINVAL;
 	u8 val;
 
<span class="p_chunk">@@ -1234,6 +1262,9 @@</span> <span class="p_context"> static int mmc_select_hs200(struct mmc_card *card)</span>
 
 	mmc_select_driver_type(card);
 
<span class="p_add">+	if (host-&gt;caps &amp; MMC_CAP_WAIT_WHILE_BUSY)</span>
<span class="p_add">+		send_status = false;</span>
<span class="p_add">+</span>
 	/*
 	 * Set the bus width(4 or 8) with host&#39;s support and
 	 * switch to HS200 mode if bus width is set successfully.
<span class="p_chunk">@@ -1245,11 +1276,25 @@</span> <span class="p_context"> static int mmc_select_hs200(struct mmc_card *card)</span>
 		err = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
 				   EXT_CSD_HS_TIMING, val,
 				   card-&gt;ext_csd.generic_cmd6_time,
<span class="p_del">-				   true, true, true);</span>
<span class="p_del">-		if (!err)</span>
<span class="p_del">-			mmc_set_timing(host, MMC_TIMING_MMC_HS200);</span>
<span class="p_add">+				   true, send_status, true);</span>
<span class="p_add">+		if (err)</span>
<span class="p_add">+			goto err;</span>
<span class="p_add">+		old_timing = host-&gt;ios.timing;</span>
<span class="p_add">+		mmc_set_timing(host, MMC_TIMING_MMC_HS200);</span>
<span class="p_add">+		if (!send_status) {</span>
<span class="p_add">+			err = mmc_switch_status(card);</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * mmc_select_timing() assumes timing has not changed if</span>
<span class="p_add">+			 * it is a switch error.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if (err == -EBADMSG)</span>
<span class="p_add">+				mmc_set_timing(host, old_timing);</span>
<span class="p_add">+		}</span>
 	}
 err:
<span class="p_add">+	if (err)</span>
<span class="p_add">+		pr_err(&quot;%s: %s failed, error %d\n&quot;, mmc_hostname(card-&gt;host),</span>
<span class="p_add">+		       __func__, err);</span>
 	return err;
 }
 
<span class="p_header">diff --git a/drivers/mtd/nand/nand_base.c b/drivers/mtd/nand/nand_base.c</span>
<span class="p_header">index ceb68ca..066f967 100644</span>
<span class="p_header">--- a/drivers/mtd/nand/nand_base.c</span>
<span class="p_header">+++ b/drivers/mtd/nand/nand_base.c</span>
<span class="p_chunk">@@ -2964,7 +2964,7 @@</span> <span class="p_context"> static void nand_resume(struct mtd_info *mtd)</span>
  */
 static void nand_shutdown(struct mtd_info *mtd)
 {
<span class="p_del">-	nand_get_device(mtd, FL_SHUTDOWN);</span>
<span class="p_add">+	nand_get_device(mtd, FL_PM_SUSPENDED);</span>
 }
 
 /* Set default functions */
<span class="p_header">diff --git a/drivers/mtd/ubi/wl.c b/drivers/mtd/ubi/wl.c</span>
<span class="p_header">index eb4489f9..5606563 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/wl.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/wl.c</span>
<span class="p_chunk">@@ -603,6 +603,7 @@</span> <span class="p_context"> static int schedule_erase(struct ubi_device *ubi, struct ubi_wl_entry *e,</span>
 	return 0;
 }
 
<span class="p_add">+static int __erase_worker(struct ubi_device *ubi, struct ubi_work *wl_wrk);</span>
 /**
  * do_sync_erase - run the erase worker synchronously.
  * @ubi: UBI device description object
<span class="p_chunk">@@ -615,20 +616,16 @@</span> <span class="p_context"> static int schedule_erase(struct ubi_device *ubi, struct ubi_wl_entry *e,</span>
 static int do_sync_erase(struct ubi_device *ubi, struct ubi_wl_entry *e,
 			 int vol_id, int lnum, int torture)
 {
<span class="p_del">-	struct ubi_work *wl_wrk;</span>
<span class="p_add">+	struct ubi_work wl_wrk;</span>
 
 	dbg_wl(&quot;sync erase of PEB %i&quot;, e-&gt;pnum);
 
<span class="p_del">-	wl_wrk = kmalloc(sizeof(struct ubi_work), GFP_NOFS);</span>
<span class="p_del">-	if (!wl_wrk)</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_del">-</span>
<span class="p_del">-	wl_wrk-&gt;e = e;</span>
<span class="p_del">-	wl_wrk-&gt;vol_id = vol_id;</span>
<span class="p_del">-	wl_wrk-&gt;lnum = lnum;</span>
<span class="p_del">-	wl_wrk-&gt;torture = torture;</span>
<span class="p_add">+	wl_wrk.e = e;</span>
<span class="p_add">+	wl_wrk.vol_id = vol_id;</span>
<span class="p_add">+	wl_wrk.lnum = lnum;</span>
<span class="p_add">+	wl_wrk.torture = torture;</span>
 
<span class="p_del">-	return erase_worker(ubi, wl_wrk, 0);</span>
<span class="p_add">+	return __erase_worker(ubi, &amp;wl_wrk);</span>
 }
 
 /**
<span class="p_chunk">@@ -1014,7 +1011,7 @@</span> <span class="p_context"> out_unlock:</span>
 }
 
 /**
<span class="p_del">- * erase_worker - physical eraseblock erase worker function.</span>
<span class="p_add">+ * __erase_worker - physical eraseblock erase worker function.</span>
  * @ubi: UBI device description object
  * @wl_wrk: the work object
  * @shutdown: non-zero if the worker has to free memory and exit
<span class="p_chunk">@@ -1025,8 +1022,7 @@</span> <span class="p_context"> out_unlock:</span>
  * needed. Returns zero in case of success and a negative error code in case of
  * failure.
  */
<span class="p_del">-static int erase_worker(struct ubi_device *ubi, struct ubi_work *wl_wrk,</span>
<span class="p_del">-			int shutdown)</span>
<span class="p_add">+static int __erase_worker(struct ubi_device *ubi, struct ubi_work *wl_wrk)</span>
 {
 	struct ubi_wl_entry *e = wl_wrk-&gt;e;
 	int pnum = e-&gt;pnum;
<span class="p_chunk">@@ -1034,21 +1030,11 @@</span> <span class="p_context"> static int erase_worker(struct ubi_device *ubi, struct ubi_work *wl_wrk,</span>
 	int lnum = wl_wrk-&gt;lnum;
 	int err, available_consumed = 0;
 
<span class="p_del">-	if (shutdown) {</span>
<span class="p_del">-		dbg_wl(&quot;cancel erasure of PEB %d EC %d&quot;, pnum, e-&gt;ec);</span>
<span class="p_del">-		kfree(wl_wrk);</span>
<span class="p_del">-		wl_entry_destroy(ubi, e);</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	dbg_wl(&quot;erase PEB %d EC %d LEB %d:%d&quot;,
 	       pnum, e-&gt;ec, wl_wrk-&gt;vol_id, wl_wrk-&gt;lnum);
 
 	err = sync_erase(ubi, e, wl_wrk-&gt;torture);
 	if (!err) {
<span class="p_del">-		/* Fine, we&#39;ve erased it successfully */</span>
<span class="p_del">-		kfree(wl_wrk);</span>
<span class="p_del">-</span>
 		spin_lock(&amp;ubi-&gt;wl_lock);
 		wl_tree_add(e, &amp;ubi-&gt;free);
 		ubi-&gt;free_count++;
<span class="p_chunk">@@ -1066,7 +1052,6 @@</span> <span class="p_context"> static int erase_worker(struct ubi_device *ubi, struct ubi_work *wl_wrk,</span>
 	}
 
 	ubi_err(ubi, &quot;failed to erase PEB %d, error %d&quot;, pnum, err);
<span class="p_del">-	kfree(wl_wrk);</span>
 
 	if (err == -EINTR || err == -ENOMEM || err == -EAGAIN ||
 	    err == -EBUSY) {
<span class="p_chunk">@@ -1075,6 +1060,7 @@</span> <span class="p_context"> static int erase_worker(struct ubi_device *ubi, struct ubi_work *wl_wrk,</span>
 		/* Re-schedule the LEB for erasure */
 		err1 = schedule_erase(ubi, e, vol_id, lnum, 0);
 		if (err1) {
<span class="p_add">+			wl_entry_destroy(ubi, e);</span>
 			err = err1;
 			goto out_ro;
 		}
<span class="p_chunk">@@ -1150,6 +1136,25 @@</span> <span class="p_context"> out_ro:</span>
 	return err;
 }
 
<span class="p_add">+static int erase_worker(struct ubi_device *ubi, struct ubi_work *wl_wrk,</span>
<span class="p_add">+			  int shutdown)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (shutdown) {</span>
<span class="p_add">+		struct ubi_wl_entry *e = wl_wrk-&gt;e;</span>
<span class="p_add">+</span>
<span class="p_add">+		dbg_wl(&quot;cancel erasure of PEB %d EC %d&quot;, e-&gt;pnum, e-&gt;ec);</span>
<span class="p_add">+		kfree(wl_wrk);</span>
<span class="p_add">+		wl_entry_destroy(ubi, e);</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = __erase_worker(ubi, wl_wrk);</span>
<span class="p_add">+	kfree(wl_wrk);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * ubi_wl_put_peb - return a PEB to the wear-leveling sub-system.
  * @ubi: UBI device description object
<span class="p_header">diff --git a/drivers/net/ethernet/amd/xgbe/xgbe-dev.c b/drivers/net/ethernet/amd/xgbe/xgbe-dev.c</span>
<span class="p_header">index f672dba..7b64623 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/amd/xgbe/xgbe-dev.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/amd/xgbe/xgbe-dev.c</span>
<span class="p_chunk">@@ -1849,7 +1849,7 @@</span> <span class="p_context"> static int xgbe_exit(struct xgbe_prv_data *pdata)</span>
 	usleep_range(10, 15);
 
 	/* Poll Until Poll Condition */
<span class="p_del">-	while (count-- &amp;&amp; XGMAC_IOREAD_BITS(pdata, DMA_MR, SWR))</span>
<span class="p_add">+	while (--count &amp;&amp; XGMAC_IOREAD_BITS(pdata, DMA_MR, SWR))</span>
 		usleep_range(500, 600);
 
 	if (!count)
<span class="p_chunk">@@ -1873,7 +1873,7 @@</span> <span class="p_context"> static int xgbe_flush_tx_queues(struct xgbe_prv_data *pdata)</span>
 	/* Poll Until Poll Condition */
 	for (i = 0; i &lt; pdata-&gt;tx_q_count; i++) {
 		count = 2000;
<span class="p_del">-		while (count-- &amp;&amp; XGMAC_MTL_IOREAD_BITS(pdata, i,</span>
<span class="p_add">+		while (--count &amp;&amp; XGMAC_MTL_IOREAD_BITS(pdata, i,</span>
 							MTL_Q_TQOMR, FTQ))
 			usleep_range(500, 600);
 
<span class="p_header">diff --git a/drivers/net/ethernet/marvell/mvneta.c b/drivers/net/ethernet/marvell/mvneta.c</span>
<span class="p_header">index 7e788073..060af9b 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/marvell/mvneta.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/marvell/mvneta.c</span>
<span class="p_chunk">@@ -35,7 +35,7 @@</span> <span class="p_context"></span>
 
 /* Registers */
 #define MVNETA_RXQ_CONFIG_REG(q)                (0x1400 + ((q) &lt;&lt; 2))
<span class="p_del">-#define      MVNETA_RXQ_HW_BUF_ALLOC            BIT(1)</span>
<span class="p_add">+#define      MVNETA_RXQ_HW_BUF_ALLOC            BIT(0)</span>
 #define      MVNETA_RXQ_PKT_OFFSET_ALL_MASK     (0xf    &lt;&lt; 8)
 #define      MVNETA_RXQ_PKT_OFFSET_MASK(offs)   ((offs) &lt;&lt; 8)
 #define MVNETA_RXQ_THRESHOLD_REG(q)             (0x14c0 + ((q) &lt;&lt; 2))
<span class="p_chunk">@@ -61,6 +61,7 @@</span> <span class="p_context"></span>
 #define MVNETA_WIN_SIZE(w)                      (0x2204 + ((w) &lt;&lt; 3))
 #define MVNETA_WIN_REMAP(w)                     (0x2280 + ((w) &lt;&lt; 2))
 #define MVNETA_BASE_ADDR_ENABLE                 0x2290
<span class="p_add">+#define MVNETA_ACCESS_PROTECT_ENABLE            0x2294</span>
 #define MVNETA_PORT_CONFIG                      0x2400
 #define      MVNETA_UNI_PROMISC_MODE            BIT(0)
 #define      MVNETA_DEF_RXQ(q)                  ((q) &lt;&lt; 1)
<span class="p_chunk">@@ -156,7 +157,7 @@</span> <span class="p_context"></span>
 
 #define MVNETA_INTR_ENABLE                       0x25b8
 #define      MVNETA_TXQ_INTR_ENABLE_ALL_MASK     0x0000ff00
<span class="p_del">-#define      MVNETA_RXQ_INTR_ENABLE_ALL_MASK     0xff000000  // note: neta says it&#39;s 0x000000FF</span>
<span class="p_add">+#define      MVNETA_RXQ_INTR_ENABLE_ALL_MASK     0x000000ff</span>
 
 #define MVNETA_RXQ_CMD                           0x2680
 #define      MVNETA_RXQ_DISABLE_SHIFT            8
<span class="p_chunk">@@ -2975,6 +2976,7 @@</span> <span class="p_context"> static void mvneta_conf_mbus_windows(struct mvneta_port *pp,</span>
 	}
 
 	mvreg_write(pp, MVNETA_BASE_ADDR_ENABLE, win_enable);
<span class="p_add">+	mvreg_write(pp, MVNETA_ACCESS_PROTECT_ENABLE, win_protect);</span>
 }
 
 /* Power up the port */
<span class="p_header">diff --git a/drivers/net/ethernet/marvell/mvpp2.c b/drivers/net/ethernet/marvell/mvpp2.c</span>
<span class="p_header">index d9884fd..a4beccf 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/marvell/mvpp2.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/marvell/mvpp2.c</span>
<span class="p_chunk">@@ -3413,16 +3413,23 @@</span> <span class="p_context"> static void mvpp2_bm_pool_bufsize_set(struct mvpp2 *priv,</span>
 }
 
 /* Free all buffers from the pool */
<span class="p_del">-static void mvpp2_bm_bufs_free(struct mvpp2 *priv, struct mvpp2_bm_pool *bm_pool)</span>
<span class="p_add">+static void mvpp2_bm_bufs_free(struct device *dev, struct mvpp2 *priv,</span>
<span class="p_add">+			       struct mvpp2_bm_pool *bm_pool)</span>
 {
 	int i;
 
 	for (i = 0; i &lt; bm_pool-&gt;buf_num; i++) {
<span class="p_add">+		dma_addr_t buf_phys_addr;</span>
 		u32 vaddr;
 
 		/* Get buffer virtual address (indirect access) */
<span class="p_del">-		mvpp2_read(priv, MVPP2_BM_PHY_ALLOC_REG(bm_pool-&gt;id));</span>
<span class="p_add">+		buf_phys_addr = mvpp2_read(priv,</span>
<span class="p_add">+					   MVPP2_BM_PHY_ALLOC_REG(bm_pool-&gt;id));</span>
 		vaddr = mvpp2_read(priv, MVPP2_BM_VIRT_ALLOC_REG);
<span class="p_add">+</span>
<span class="p_add">+		dma_unmap_single(dev, buf_phys_addr,</span>
<span class="p_add">+				 bm_pool-&gt;buf_size, DMA_FROM_DEVICE);</span>
<span class="p_add">+</span>
 		if (!vaddr)
 			break;
 		dev_kfree_skb_any((struct sk_buff *)vaddr);
<span class="p_chunk">@@ -3439,7 +3446,7 @@</span> <span class="p_context"> static int mvpp2_bm_pool_destroy(struct platform_device *pdev,</span>
 {
 	u32 val;
 
<span class="p_del">-	mvpp2_bm_bufs_free(priv, bm_pool);</span>
<span class="p_add">+	mvpp2_bm_bufs_free(&amp;pdev-&gt;dev, priv, bm_pool);</span>
 	if (bm_pool-&gt;buf_num) {
 		WARN(1, &quot;cannot free all buffers in pool %d\n&quot;, bm_pool-&gt;id);
 		return 0;
<span class="p_chunk">@@ -3692,7 +3699,8 @@</span> <span class="p_context"> mvpp2_bm_pool_use(struct mvpp2_port *port, int pool, enum mvpp2_bm_type type,</span>
 				   MVPP2_BM_LONG_BUF_NUM :
 				   MVPP2_BM_SHORT_BUF_NUM;
 		else
<span class="p_del">-			mvpp2_bm_bufs_free(port-&gt;priv, new_pool);</span>
<span class="p_add">+			mvpp2_bm_bufs_free(port-&gt;dev-&gt;dev.parent,</span>
<span class="p_add">+					   port-&gt;priv, new_pool);</span>
 
 		new_pool-&gt;pkt_size = pkt_size;
 
<span class="p_chunk">@@ -3756,7 +3764,7 @@</span> <span class="p_context"> static int mvpp2_bm_update_mtu(struct net_device *dev, int mtu)</span>
 	int pkt_size = MVPP2_RX_PKT_SIZE(mtu);
 
 	/* Update BM pool with new buffer size */
<span class="p_del">-	mvpp2_bm_bufs_free(port-&gt;priv, port_pool);</span>
<span class="p_add">+	mvpp2_bm_bufs_free(dev-&gt;dev.parent, port-&gt;priv, port_pool);</span>
 	if (port_pool-&gt;buf_num) {
 		WARN(1, &quot;cannot free all buffers in pool %d\n&quot;, port_pool-&gt;id);
 		return -EIO;
<span class="p_chunk">@@ -4401,11 +4409,10 @@</span> <span class="p_context"> static void mvpp2_txq_bufs_free(struct mvpp2_port *port,</span>
 
 		mvpp2_txq_inc_get(txq_pcpu);
 
<span class="p_del">-		if (!skb)</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-</span>
 		dma_unmap_single(port-&gt;dev-&gt;dev.parent, buf_phys_addr,
 				 skb_headlen(skb), DMA_TO_DEVICE);
<span class="p_add">+		if (!skb)</span>
<span class="p_add">+			continue;</span>
 		dev_kfree_skb_any(skb);
 	}
 }
<span class="p_chunk">@@ -5092,7 +5099,8 @@</span> <span class="p_context"> static int mvpp2_rx(struct mvpp2_port *port, int rx_todo,</span>
 		    struct mvpp2_rx_queue *rxq)
 {
 	struct net_device *dev = port-&gt;dev;
<span class="p_del">-	int rx_received, rx_filled, i;</span>
<span class="p_add">+	int rx_received;</span>
<span class="p_add">+	int rx_done = 0;</span>
 	u32 rcvd_pkts = 0;
 	u32 rcvd_bytes = 0;
 
<span class="p_chunk">@@ -5101,17 +5109,18 @@</span> <span class="p_context"> static int mvpp2_rx(struct mvpp2_port *port, int rx_todo,</span>
 	if (rx_todo &gt; rx_received)
 		rx_todo = rx_received;
 
<span class="p_del">-	rx_filled = 0;</span>
<span class="p_del">-	for (i = 0; i &lt; rx_todo; i++) {</span>
<span class="p_add">+	while (rx_done &lt; rx_todo) {</span>
 		struct mvpp2_rx_desc *rx_desc = mvpp2_rxq_next_desc_get(rxq);
 		struct mvpp2_bm_pool *bm_pool;
 		struct sk_buff *skb;
<span class="p_add">+		dma_addr_t phys_addr;</span>
 		u32 bm, rx_status;
 		int pool, rx_bytes, err;
 
<span class="p_del">-		rx_filled++;</span>
<span class="p_add">+		rx_done++;</span>
 		rx_status = rx_desc-&gt;status;
 		rx_bytes = rx_desc-&gt;data_size - MVPP2_MH_SIZE;
<span class="p_add">+		phys_addr = rx_desc-&gt;buf_phys_addr;</span>
 
 		bm = mvpp2_bm_cookie_build(rx_desc);
 		pool = mvpp2_bm_cookie_pool_get(bm);
<span class="p_chunk">@@ -5128,8 +5137,10 @@</span> <span class="p_context"> static int mvpp2_rx(struct mvpp2_port *port, int rx_todo,</span>
 		 * comprised by the RX descriptor.
 		 */
 		if (rx_status &amp; MVPP2_RXD_ERR_SUMMARY) {
<span class="p_add">+		err_drop_frame:</span>
 			dev-&gt;stats.rx_errors++;
 			mvpp2_rx_error(port, rx_desc);
<span class="p_add">+			/* Return the buffer to the pool */</span>
 			mvpp2_pool_refill(port, bm, rx_desc-&gt;buf_phys_addr,
 					  rx_desc-&gt;buf_cookie);
 			continue;
<span class="p_chunk">@@ -5137,6 +5148,15 @@</span> <span class="p_context"> static int mvpp2_rx(struct mvpp2_port *port, int rx_todo,</span>
 
 		skb = (struct sk_buff *)rx_desc-&gt;buf_cookie;
 
<span class="p_add">+		err = mvpp2_rx_refill(port, bm_pool, bm, 0);</span>
<span class="p_add">+		if (err) {</span>
<span class="p_add">+			netdev_err(port-&gt;dev, &quot;failed to refill BM pools\n&quot;);</span>
<span class="p_add">+			goto err_drop_frame;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		dma_unmap_single(dev-&gt;dev.parent, phys_addr,</span>
<span class="p_add">+				 bm_pool-&gt;buf_size, DMA_FROM_DEVICE);</span>
<span class="p_add">+</span>
 		rcvd_pkts++;
 		rcvd_bytes += rx_bytes;
 		atomic_inc(&amp;bm_pool-&gt;in_use);
<span class="p_chunk">@@ -5147,12 +5167,6 @@</span> <span class="p_context"> static int mvpp2_rx(struct mvpp2_port *port, int rx_todo,</span>
 		mvpp2_rx_csum(port, rx_status, skb);
 
 		napi_gro_receive(&amp;port-&gt;napi, skb);
<span class="p_del">-</span>
<span class="p_del">-		err = mvpp2_rx_refill(port, bm_pool, bm, 0);</span>
<span class="p_del">-		if (err) {</span>
<span class="p_del">-			netdev_err(port-&gt;dev, &quot;failed to refill BM pools\n&quot;);</span>
<span class="p_del">-			rx_filled--;</span>
<span class="p_del">-		}</span>
 	}
 
 	if (rcvd_pkts) {
<span class="p_chunk">@@ -5166,7 +5180,7 @@</span> <span class="p_context"> static int mvpp2_rx(struct mvpp2_port *port, int rx_todo,</span>
 
 	/* Update Rx queue management counters */
 	wmb();
<span class="p_del">-	mvpp2_rxq_status_update(port, rxq-&gt;id, rx_todo, rx_filled);</span>
<span class="p_add">+	mvpp2_rxq_status_update(port, rxq-&gt;id, rx_done, rx_done);</span>
 
 	return rx_todo;
 }
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/en_clock.c b/drivers/net/ethernet/mellanox/mlx4/en_clock.c</span>
<span class="p_header">index 8a083d7..038f9ce 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/en_clock.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/en_clock.c</span>
<span class="p_chunk">@@ -242,6 +242,13 @@</span> <span class="p_context"> void mlx4_en_init_timestamp(struct mlx4_en_dev *mdev)</span>
 	unsigned long flags;
 	u64 ns, zero = 0;
 
<span class="p_add">+	/* mlx4_en_init_timestamp is called for each netdev.</span>
<span class="p_add">+	 * mdev-&gt;ptp_clock is common for all ports, skip initialization if</span>
<span class="p_add">+	 * was done for other port.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (mdev-&gt;ptp_clock)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	rwlock_init(&amp;mdev-&gt;clock_lock);
 
 	memset(&amp;mdev-&gt;cycles, 0, sizeof(mdev-&gt;cycles));
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/en_main.c b/drivers/net/ethernet/mellanox/mlx4/en_main.c</span>
<span class="p_header">index 913b716..24cec68 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/en_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/en_main.c</span>
<span class="p_chunk">@@ -210,9 +210,6 @@</span> <span class="p_context"> static void mlx4_en_remove(struct mlx4_dev *dev, void *endev_ptr)</span>
 		if (mdev-&gt;pndev[i])
 			mlx4_en_destroy_netdev(mdev-&gt;pndev[i]);
 
<span class="p_del">-	if (mdev-&gt;dev-&gt;caps.flags2 &amp; MLX4_DEV_CAP_FLAG2_TS)</span>
<span class="p_del">-		mlx4_en_remove_timestamp(mdev);</span>
<span class="p_del">-</span>
 	flush_workqueue(mdev-&gt;workqueue);
 	destroy_workqueue(mdev-&gt;workqueue);
 	(void) mlx4_mr_free(dev, &amp;mdev-&gt;mr);
<span class="p_chunk">@@ -278,10 +275,6 @@</span> <span class="p_context"> static void *mlx4_en_add(struct mlx4_dev *dev)</span>
 	mlx4_foreach_port(i, dev, MLX4_PORT_TYPE_ETH)
 		mdev-&gt;port_cnt++;
 
<span class="p_del">-	/* Initialize time stamp mechanism */</span>
<span class="p_del">-	if (mdev-&gt;dev-&gt;caps.flags2 &amp; MLX4_DEV_CAP_FLAG2_TS)</span>
<span class="p_del">-		mlx4_en_init_timestamp(mdev);</span>
<span class="p_del">-</span>
 	/* Set default number of RX rings*/
 	mlx4_en_set_num_rx_rings(mdev);
 
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c</span>
<span class="p_header">index e0de2fd..8544af0 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c</span>
<span class="p_chunk">@@ -2056,6 +2056,9 @@</span> <span class="p_context"> void mlx4_en_destroy_netdev(struct net_device *dev)</span>
 	/* flush any pending task for this netdev */
 	flush_workqueue(mdev-&gt;workqueue);
 
<span class="p_add">+	if (mdev-&gt;dev-&gt;caps.flags2 &amp; MLX4_DEV_CAP_FLAG2_TS)</span>
<span class="p_add">+		mlx4_en_remove_timestamp(mdev);</span>
<span class="p_add">+</span>
 	/* Detach the netdev so tasks would not attempt to access it */
 	mutex_lock(&amp;mdev-&gt;state_lock);
 	mdev-&gt;pndev[priv-&gt;port] = NULL;
<span class="p_chunk">@@ -2997,9 +3000,12 @@</span> <span class="p_context"> int mlx4_en_init_netdev(struct mlx4_en_dev *mdev, int port,</span>
 	}
 	queue_delayed_work(mdev-&gt;workqueue, &amp;priv-&gt;stats_task, STATS_DELAY);
 
<span class="p_add">+	/* Initialize time stamp mechanism */</span>
 	if (mdev-&gt;dev-&gt;caps.flags2 &amp; MLX4_DEV_CAP_FLAG2_TS)
<span class="p_del">-		queue_delayed_work(mdev-&gt;workqueue, &amp;priv-&gt;service_task,</span>
<span class="p_del">-				   SERVICE_TASK_DELAY);</span>
<span class="p_add">+		mlx4_en_init_timestamp(mdev);</span>
<span class="p_add">+</span>
<span class="p_add">+	queue_delayed_work(mdev-&gt;workqueue, &amp;priv-&gt;service_task,</span>
<span class="p_add">+			   SERVICE_TASK_DELAY);</span>
 
 	mlx4_en_set_stats_bitmap(mdev-&gt;dev, &amp;priv-&gt;stats_bitmap,
 				 mdev-&gt;profile.prof[priv-&gt;port].rx_ppp,
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/main.c b/drivers/net/ethernet/mellanox/mlx4/main.c</span>
<span class="p_header">index a408977..fedc08f 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/main.c</span>
<span class="p_chunk">@@ -875,9 +875,10 @@</span> <span class="p_context"> static int mlx4_slave_cap(struct mlx4_dev *dev)</span>
 		dev-&gt;caps.qp1_proxy[i - 1] = func_cap.qp1_proxy_qpn;
 		dev-&gt;caps.port_mask[i] = dev-&gt;caps.port_type[i];
 		dev-&gt;caps.phys_port_id[i] = func_cap.phys_port_id;
<span class="p_del">-		if (mlx4_get_slave_pkey_gid_tbl_len(dev, i,</span>
<span class="p_del">-						    &amp;dev-&gt;caps.gid_table_len[i],</span>
<span class="p_del">-						    &amp;dev-&gt;caps.pkey_table_len[i]))</span>
<span class="p_add">+		err = mlx4_get_slave_pkey_gid_tbl_len(dev, i,</span>
<span class="p_add">+						      &amp;dev-&gt;caps.gid_table_len[i],</span>
<span class="p_add">+						      &amp;dev-&gt;caps.pkey_table_len[i]);</span>
<span class="p_add">+		if (err)</span>
 			goto err_mem;
 	}
 
<span class="p_chunk">@@ -889,6 +890,7 @@</span> <span class="p_context"> static int mlx4_slave_cap(struct mlx4_dev *dev)</span>
 			 dev-&gt;caps.uar_page_size * dev-&gt;caps.num_uars,
 			 (unsigned long long)
 			 pci_resource_len(dev-&gt;persist-&gt;pdev, 2));
<span class="p_add">+		err = -ENOMEM;</span>
 		goto err_mem;
 	}
 
<span class="p_header">diff --git a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_vnic.c b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_vnic.c</span>
<span class="p_header">index be7d7a6..b1a452f 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_vnic.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_vnic.c</span>
<span class="p_chunk">@@ -246,7 +246,8 @@</span> <span class="p_context"> int qlcnic_83xx_check_vnic_state(struct qlcnic_adapter *adapter)</span>
 	u32 state;
 
 	state = QLCRDX(ahw, QLC_83XX_VNIC_STATE);
<span class="p_del">-	while (state != QLCNIC_DEV_NPAR_OPER &amp;&amp; idc-&gt;vnic_wait_limit--) {</span>
<span class="p_add">+	while (state != QLCNIC_DEV_NPAR_OPER &amp;&amp; idc-&gt;vnic_wait_limit) {</span>
<span class="p_add">+		idc-&gt;vnic_wait_limit--;</span>
 		msleep(1000);
 		state = QLCRDX(ahw, QLC_83XX_VNIC_STATE);
 	}
<span class="p_header">diff --git a/drivers/net/ethernet/renesas/sh_eth.c b/drivers/net/ethernet/renesas/sh_eth.c</span>
<span class="p_header">index 13463c4..675cd7f 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/renesas/sh_eth.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/renesas/sh_eth.c</span>
<span class="p_chunk">@@ -2393,8 +2393,7 @@</span> <span class="p_context"> static int sh_eth_start_xmit(struct sk_buff *skb, struct net_device *ndev)</span>
 	txdesc = &amp;mdp-&gt;tx_ring[entry];
 	/* soft swap. */
 	if (!mdp-&gt;cd-&gt;hw_swap)
<span class="p_del">-		sh_eth_soft_swap(phys_to_virt(ALIGN(txdesc-&gt;addr, 4)),</span>
<span class="p_del">-				 skb-&gt;len + 2);</span>
<span class="p_add">+		sh_eth_soft_swap(PTR_ALIGN(skb-&gt;data, 4), skb-&gt;len + 2);</span>
 	txdesc-&gt;addr = dma_map_single(&amp;ndev-&gt;dev, skb-&gt;data, skb-&gt;len,
 				      DMA_TO_DEVICE);
 	if (dma_mapping_error(&amp;ndev-&gt;dev, txdesc-&gt;addr)) {
<span class="p_header">diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac-ipq806x.c b/drivers/net/ethernet/stmicro/stmmac/dwmac-ipq806x.c</span>
<span class="p_header">index f0e4bb4..ae551f4 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/stmicro/stmmac/dwmac-ipq806x.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-ipq806x.c</span>
<span class="p_chunk">@@ -320,11 +320,11 @@</span> <span class="p_context"> static void *ipq806x_gmac_setup(struct platform_device *pdev)</span>
 			     QSGMII_PHY_RX_SIGNAL_DETECT_EN |
 			     QSGMII_PHY_TX_DRIVER_EN |
 			     QSGMII_PHY_QSGMII_EN |
<span class="p_del">-			     0x4 &lt;&lt; QSGMII_PHY_PHASE_LOOP_GAIN_OFFSET |</span>
<span class="p_del">-			     0x3 &lt;&lt; QSGMII_PHY_RX_DC_BIAS_OFFSET |</span>
<span class="p_del">-			     0x1 &lt;&lt; QSGMII_PHY_RX_INPUT_EQU_OFFSET |</span>
<span class="p_del">-			     0x2 &lt;&lt; QSGMII_PHY_CDR_PI_SLEW_OFFSET |</span>
<span class="p_del">-			     0xC &lt;&lt; QSGMII_PHY_TX_DRV_AMP_OFFSET);</span>
<span class="p_add">+			     0x4ul &lt;&lt; QSGMII_PHY_PHASE_LOOP_GAIN_OFFSET |</span>
<span class="p_add">+			     0x3ul &lt;&lt; QSGMII_PHY_RX_DC_BIAS_OFFSET |</span>
<span class="p_add">+			     0x1ul &lt;&lt; QSGMII_PHY_RX_INPUT_EQU_OFFSET |</span>
<span class="p_add">+			     0x2ul &lt;&lt; QSGMII_PHY_CDR_PI_SLEW_OFFSET |</span>
<span class="p_add">+			     0xCul &lt;&lt; QSGMII_PHY_TX_DRV_AMP_OFFSET);</span>
 	}
 
 	return gmac;
<span class="p_header">diff --git a/drivers/net/ipvlan/ipvlan_core.c b/drivers/net/ipvlan/ipvlan_core.c</span>
<span class="p_header">index 207f62e..b64e172 100644</span>
<span class="p_header">--- a/drivers/net/ipvlan/ipvlan_core.c</span>
<span class="p_header">+++ b/drivers/net/ipvlan/ipvlan_core.c</span>
<span class="p_chunk">@@ -254,7 +254,7 @@</span> <span class="p_context"> acct:</span>
 	}
 }
 
<span class="p_del">-static int ipvlan_rcv_frame(struct ipvl_addr *addr, struct sk_buff *skb,</span>
<span class="p_add">+static int ipvlan_rcv_frame(struct ipvl_addr *addr, struct sk_buff **pskb,</span>
 			    bool local)
 {
 	struct ipvl_dev *ipvlan = addr-&gt;master;
<span class="p_chunk">@@ -262,6 +262,7 @@</span> <span class="p_context"> static int ipvlan_rcv_frame(struct ipvl_addr *addr, struct sk_buff *skb,</span>
 	unsigned int len;
 	rx_handler_result_t ret = RX_HANDLER_CONSUMED;
 	bool success = false;
<span class="p_add">+	struct sk_buff *skb = *pskb;</span>
 
 	len = skb-&gt;len + ETH_HLEN;
 	if (unlikely(!(dev-&gt;flags &amp; IFF_UP))) {
<span class="p_chunk">@@ -273,6 +274,7 @@</span> <span class="p_context"> static int ipvlan_rcv_frame(struct ipvl_addr *addr, struct sk_buff *skb,</span>
 	if (!skb)
 		goto out;
 
<span class="p_add">+	*pskb = skb;</span>
 	skb-&gt;dev = dev;
 	skb-&gt;pkt_type = PACKET_HOST;
 
<span class="p_chunk">@@ -484,7 +486,7 @@</span> <span class="p_context"> static int ipvlan_xmit_mode_l3(struct sk_buff *skb, struct net_device *dev)</span>
 
 	addr = ipvlan_addr_lookup(ipvlan-&gt;port, lyr3h, addr_type, true);
 	if (addr)
<span class="p_del">-		return ipvlan_rcv_frame(addr, skb, true);</span>
<span class="p_add">+		return ipvlan_rcv_frame(addr, &amp;skb, true);</span>
 
 out:
 	skb-&gt;dev = ipvlan-&gt;phy_dev;
<span class="p_chunk">@@ -504,7 +506,7 @@</span> <span class="p_context"> static int ipvlan_xmit_mode_l2(struct sk_buff *skb, struct net_device *dev)</span>
 		if (lyr3h) {
 			addr = ipvlan_addr_lookup(ipvlan-&gt;port, lyr3h, addr_type, true);
 			if (addr)
<span class="p_del">-				return ipvlan_rcv_frame(addr, skb, true);</span>
<span class="p_add">+				return ipvlan_rcv_frame(addr, &amp;skb, true);</span>
 		}
 		skb = skb_share_check(skb, GFP_ATOMIC);
 		if (!skb)
<span class="p_chunk">@@ -587,7 +589,7 @@</span> <span class="p_context"> static rx_handler_result_t ipvlan_handle_mode_l3(struct sk_buff **pskb,</span>
 
 	addr = ipvlan_addr_lookup(port, lyr3h, addr_type, true);
 	if (addr)
<span class="p_del">-		ret = ipvlan_rcv_frame(addr, skb, false);</span>
<span class="p_add">+		ret = ipvlan_rcv_frame(addr, pskb, false);</span>
 
 out:
 	return ret;
<span class="p_chunk">@@ -624,7 +626,7 @@</span> <span class="p_context"> static rx_handler_result_t ipvlan_handle_mode_l2(struct sk_buff **pskb,</span>
 
 		addr = ipvlan_addr_lookup(port, lyr3h, addr_type, true);
 		if (addr)
<span class="p_del">-			ret = ipvlan_rcv_frame(addr, skb, false);</span>
<span class="p_add">+			ret = ipvlan_rcv_frame(addr, pskb, false);</span>
 	}
 
 	return ret;
<span class="p_chunk">@@ -649,5 +651,5 @@</span> <span class="p_context"> rx_handler_result_t ipvlan_handle_frame(struct sk_buff **pskb)</span>
 	WARN_ONCE(true, &quot;ipvlan_handle_frame() called for mode = [%hx]\n&quot;,
 			  port-&gt;mode);
 	kfree_skb(skb);
<span class="p_del">-	return NET_RX_DROP;</span>
<span class="p_add">+	return RX_HANDLER_CONSUMED;</span>
 }
<span class="p_header">diff --git a/drivers/net/macvlan.c b/drivers/net/macvlan.c</span>
<span class="p_header">index 9f59f17..2a815fb 100644</span>
<span class="p_header">--- a/drivers/net/macvlan.c</span>
<span class="p_header">+++ b/drivers/net/macvlan.c</span>
<span class="p_chunk">@@ -415,6 +415,7 @@</span> <span class="p_context"> static rx_handler_result_t macvlan_handle_frame(struct sk_buff **pskb)</span>
 		skb = ip_check_defrag(skb, IP_DEFRAG_MACVLAN);
 		if (!skb)
 			return RX_HANDLER_CONSUMED;
<span class="p_add">+		*pskb = skb;</span>
 		eth = eth_hdr(skb);
 		macvlan_forward_source(skb, port, eth-&gt;h_source);
 		src = macvlan_hash_lookup(port, eth-&gt;h_source);
<span class="p_chunk">@@ -456,6 +457,7 @@</span> <span class="p_context"> static rx_handler_result_t macvlan_handle_frame(struct sk_buff **pskb)</span>
 		goto out;
 	}
 
<span class="p_add">+	*pskb = skb;</span>
 	skb-&gt;dev = dev;
 	skb-&gt;pkt_type = PACKET_HOST;
 
<span class="p_header">diff --git a/drivers/net/phy/mdio-mux.c b/drivers/net/phy/mdio-mux.c</span>
<span class="p_header">index 4d4d25e..ac8a823 100644</span>
<span class="p_header">--- a/drivers/net/phy/mdio-mux.c</span>
<span class="p_header">+++ b/drivers/net/phy/mdio-mux.c</span>
<span class="p_chunk">@@ -148,9 +148,14 @@</span> <span class="p_context"> int mdio_mux_init(struct device *dev,</span>
 		}
 		cb-&gt;bus_number = v;
 		cb-&gt;parent = pb;
<span class="p_add">+</span>
 		cb-&gt;mii_bus = mdiobus_alloc();
<span class="p_add">+		if (!cb-&gt;mii_bus) {</span>
<span class="p_add">+			ret_val = -ENOMEM;</span>
<span class="p_add">+			of_node_put(child_bus_node);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
 		cb-&gt;mii_bus-&gt;priv = cb;
<span class="p_del">-</span>
 		cb-&gt;mii_bus-&gt;irq = cb-&gt;phy_irq;
 		cb-&gt;mii_bus-&gt;name = &quot;mdio_mux&quot;;
 		snprintf(cb-&gt;mii_bus-&gt;id, MII_BUS_ID_SIZE, &quot;%x.%x&quot;,
<span class="p_header">diff --git a/drivers/net/wan/x25_asy.c b/drivers/net/wan/x25_asy.c</span>
<span class="p_header">index 5c47b01..cd39025 100644</span>
<span class="p_header">--- a/drivers/net/wan/x25_asy.c</span>
<span class="p_header">+++ b/drivers/net/wan/x25_asy.c</span>
<span class="p_chunk">@@ -549,16 +549,12 @@</span> <span class="p_context"> static void x25_asy_receive_buf(struct tty_struct *tty,</span>
 
 static int x25_asy_open_tty(struct tty_struct *tty)
 {
<span class="p_del">-	struct x25_asy *sl = tty-&gt;disc_data;</span>
<span class="p_add">+	struct x25_asy *sl;</span>
 	int err;
 
 	if (tty-&gt;ops-&gt;write == NULL)
 		return -EOPNOTSUPP;
 
<span class="p_del">-	/* First make sure we&#39;re not already connected. */</span>
<span class="p_del">-	if (sl &amp;&amp; sl-&gt;magic == X25_ASY_MAGIC)</span>
<span class="p_del">-		return -EEXIST;</span>
<span class="p_del">-</span>
 	/* OK.  Find a free X.25 channel to use. */
 	sl = x25_asy_alloc();
 	if (sl == NULL)
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/mvm/d3.c b/drivers/net/wireless/iwlwifi/mvm/d3.c</span>
<span class="p_header">index f60b89b..051bc800 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/mvm/d3.c</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/mvm/d3.c</span>
<span class="p_chunk">@@ -309,9 +309,9 @@</span> <span class="p_context"> static void iwl_mvm_wowlan_program_keys(struct ieee80211_hw *hw,</span>
 	 * to transmit packets to the AP, i.e. the PTK.
 	 */
 	if (key-&gt;flags &amp; IEEE80211_KEY_FLAG_PAIRWISE) {
<span class="p_del">-		key-&gt;hw_key_idx = 0;</span>
 		mvm-&gt;ptk_ivlen = key-&gt;iv_len;
 		mvm-&gt;ptk_icvlen = key-&gt;icv_len;
<span class="p_add">+		ret = iwl_mvm_set_sta_key(mvm, vif, sta, key, 0);</span>
 	} else {
 		/*
 		 * firmware only supports TSC/RSC for a single key,
<span class="p_chunk">@@ -319,12 +319,11 @@</span> <span class="p_context"> static void iwl_mvm_wowlan_program_keys(struct ieee80211_hw *hw,</span>
 		 * with new ones -- this relies on mac80211 doing
 		 * list_add_tail().
 		 */
<span class="p_del">-		key-&gt;hw_key_idx = 1;</span>
 		mvm-&gt;gtk_ivlen = key-&gt;iv_len;
 		mvm-&gt;gtk_icvlen = key-&gt;icv_len;
<span class="p_add">+		ret = iwl_mvm_set_sta_key(mvm, vif, sta, key, 1);</span>
 	}
 
<span class="p_del">-	ret = iwl_mvm_set_sta_key(mvm, vif, sta, key, true);</span>
 	data-&gt;error = ret != 0;
 out_unlock:
 	mutex_unlock(&amp;mvm-&gt;mutex);
<span class="p_chunk">@@ -772,9 +771,6 @@</span> <span class="p_context"> static int iwl_mvm_switch_to_d3(struct iwl_mvm *mvm)</span>
 	 */
 	set_bit(IWL_MVM_STATUS_IN_HW_RESTART, &amp;mvm-&gt;status);
 
<span class="p_del">-	/* We reprogram keys and shouldn&#39;t allocate new key indices */</span>
<span class="p_del">-	memset(mvm-&gt;fw_key_table, 0, sizeof(mvm-&gt;fw_key_table));</span>
<span class="p_del">-</span>
 	mvm-&gt;ptk_ivlen = 0;
 	mvm-&gt;ptk_icvlen = 0;
 	mvm-&gt;ptk_ivlen = 0;
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/mvm/mac80211.c b/drivers/net/wireless/iwlwifi/mvm/mac80211.c</span>
<span class="p_header">index f82019c..713e1bb 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/mvm/mac80211.c</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/mvm/mac80211.c</span>
<span class="p_chunk">@@ -2872,6 +2872,7 @@</span> <span class="p_context"> static int iwl_mvm_mac_set_key(struct ieee80211_hw *hw,</span>
 {
 	struct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);
 	int ret;
<span class="p_add">+	u8 key_offset;</span>
 
 	if (iwlwifi_mod_params.sw_crypto) {
 		IWL_DEBUG_MAC80211(mvm, &quot;leave - hwcrypto disabled\n&quot;);
<span class="p_chunk">@@ -2936,10 +2937,14 @@</span> <span class="p_context"> static int iwl_mvm_mac_set_key(struct ieee80211_hw *hw,</span>
 			break;
 		}
 
<span class="p_add">+		/* in HW restart reuse the index, otherwise request a new one */</span>
<span class="p_add">+		if (test_bit(IWL_MVM_STATUS_IN_HW_RESTART, &amp;mvm-&gt;status))</span>
<span class="p_add">+			key_offset = key-&gt;hw_key_idx;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			key_offset = STA_KEY_IDX_INVALID;</span>
<span class="p_add">+</span>
 		IWL_DEBUG_MAC80211(mvm, &quot;set hwcrypto key\n&quot;);
<span class="p_del">-		ret = iwl_mvm_set_sta_key(mvm, vif, sta, key,</span>
<span class="p_del">-					  test_bit(IWL_MVM_STATUS_IN_HW_RESTART,</span>
<span class="p_del">-						   &amp;mvm-&gt;status));</span>
<span class="p_add">+		ret = iwl_mvm_set_sta_key(mvm, vif, sta, key, key_offset);</span>
 		if (ret) {
 			IWL_WARN(mvm, &quot;set key failed\n&quot;);
 			/*
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/mvm/sta.c b/drivers/net/wireless/iwlwifi/mvm/sta.c</span>
<span class="p_header">index 26f076e..b00aca7 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/mvm/sta.c</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/mvm/sta.c</span>
<span class="p_chunk">@@ -1188,7 +1188,8 @@</span> <span class="p_context"> static u8 iwl_mvm_get_key_sta_id(struct ieee80211_vif *vif,</span>
 static int iwl_mvm_send_sta_key(struct iwl_mvm *mvm,
 				struct iwl_mvm_sta *mvm_sta,
 				struct ieee80211_key_conf *keyconf, bool mcast,
<span class="p_del">-				u32 tkip_iv32, u16 *tkip_p1k, u32 cmd_flags)</span>
<span class="p_add">+				u32 tkip_iv32, u16 *tkip_p1k, u32 cmd_flags,</span>
<span class="p_add">+				u8 key_offset)</span>
 {
 	struct iwl_mvm_add_sta_key_cmd cmd = {};
 	__le16 key_flags;
<span class="p_chunk">@@ -1230,7 +1231,7 @@</span> <span class="p_context"> static int iwl_mvm_send_sta_key(struct iwl_mvm *mvm,</span>
 	if (mcast)
 		key_flags |= cpu_to_le16(STA_KEY_MULTICAST);
 
<span class="p_del">-	cmd.key_offset = keyconf-&gt;hw_key_idx;</span>
<span class="p_add">+	cmd.key_offset = key_offset;</span>
 	cmd.key_flags = key_flags;
 	cmd.sta_id = sta_id;
 
<span class="p_chunk">@@ -1323,6 +1324,7 @@</span> <span class="p_context"> static int __iwl_mvm_set_sta_key(struct iwl_mvm *mvm,</span>
 				 struct ieee80211_vif *vif,
 				 struct ieee80211_sta *sta,
 				 struct ieee80211_key_conf *keyconf,
<span class="p_add">+				 u8 key_offset,</span>
 				 bool mcast)
 {
 	struct iwl_mvm_sta *mvm_sta = iwl_mvm_sta_from_mac80211(sta);
<span class="p_chunk">@@ -1338,17 +1340,17 @@</span> <span class="p_context"> static int __iwl_mvm_set_sta_key(struct iwl_mvm *mvm,</span>
 		ieee80211_get_key_rx_seq(keyconf, 0, &amp;seq);
 		ieee80211_get_tkip_rx_p1k(keyconf, addr, seq.tkip.iv32, p1k);
 		ret = iwl_mvm_send_sta_key(mvm, mvm_sta, keyconf, mcast,
<span class="p_del">-					   seq.tkip.iv32, p1k, 0);</span>
<span class="p_add">+					   seq.tkip.iv32, p1k, 0, key_offset);</span>
 		break;
 	case WLAN_CIPHER_SUITE_CCMP:
 	case WLAN_CIPHER_SUITE_WEP40:
 	case WLAN_CIPHER_SUITE_WEP104:
 		ret = iwl_mvm_send_sta_key(mvm, mvm_sta, keyconf, mcast,
<span class="p_del">-					   0, NULL, 0);</span>
<span class="p_add">+					   0, NULL, 0, key_offset);</span>
 		break;
 	default:
 		ret = iwl_mvm_send_sta_key(mvm, mvm_sta, keyconf, mcast,
<span class="p_del">-					   0, NULL, 0);</span>
<span class="p_add">+					   0, NULL, 0, key_offset);</span>
 	}
 
 	return ret;
<span class="p_chunk">@@ -1396,7 +1398,7 @@</span> <span class="p_context"> int iwl_mvm_set_sta_key(struct iwl_mvm *mvm,</span>
 			struct ieee80211_vif *vif,
 			struct ieee80211_sta *sta,
 			struct ieee80211_key_conf *keyconf,
<span class="p_del">-			bool have_key_offset)</span>
<span class="p_add">+			u8 key_offset)</span>
 {
 	bool mcast = !(keyconf-&gt;flags &amp; IEEE80211_KEY_FLAG_PAIRWISE);
 	u8 sta_id;
<span class="p_chunk">@@ -1433,18 +1435,25 @@</span> <span class="p_context"> int iwl_mvm_set_sta_key(struct iwl_mvm *mvm,</span>
 	if (WARN_ON_ONCE(iwl_mvm_sta_from_mac80211(sta)-&gt;vif != vif))
 		return -EINVAL;
 
<span class="p_del">-	if (!have_key_offset) {</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * The D3 firmware hardcodes the PTK offset to 0, so we have to</span>
<span class="p_del">-		 * configure it there. As a result, this workaround exists to</span>
<span class="p_del">-		 * let the caller set the key offset (hw_key_idx), see d3.c.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		keyconf-&gt;hw_key_idx = iwl_mvm_set_fw_key_idx(mvm);</span>
<span class="p_del">-		if (keyconf-&gt;hw_key_idx == STA_KEY_IDX_INVALID)</span>
<span class="p_add">+	/* If the key_offset is not pre-assigned, we need to find a</span>
<span class="p_add">+	 * new offset to use.  In normal cases, the offset is not</span>
<span class="p_add">+	 * pre-assigned, but during HW_RESTART we want to reuse the</span>
<span class="p_add">+	 * same indices, so we pass them when this function is called.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * In D3 entry, we need to hardcoded the indices (because the</span>
<span class="p_add">+	 * firmware hardcodes the PTK offset to 0).  In this case, we</span>
<span class="p_add">+	 * need to make sure we don&#39;t overwrite the hw_key_idx in the</span>
<span class="p_add">+	 * keyconf structure, because otherwise we cannot configure</span>
<span class="p_add">+	 * the original ones back when resuming.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (key_offset == STA_KEY_IDX_INVALID) {</span>
<span class="p_add">+		key_offset  = iwl_mvm_set_fw_key_idx(mvm);</span>
<span class="p_add">+		if (key_offset == STA_KEY_IDX_INVALID)</span>
 			return -ENOSPC;
<span class="p_add">+		keyconf-&gt;hw_key_idx = key_offset;</span>
 	}
 
<span class="p_del">-	ret = __iwl_mvm_set_sta_key(mvm, vif, sta, keyconf, mcast);</span>
<span class="p_add">+	ret = __iwl_mvm_set_sta_key(mvm, vif, sta, keyconf, key_offset, mcast);</span>
 	if (ret) {
 		__clear_bit(keyconf-&gt;hw_key_idx, mvm-&gt;fw_key_table);
 		goto end;
<span class="p_chunk">@@ -1458,7 +1467,8 @@</span> <span class="p_context"> int iwl_mvm_set_sta_key(struct iwl_mvm *mvm,</span>
 	 */
 	if (keyconf-&gt;cipher == WLAN_CIPHER_SUITE_WEP40 ||
 	    keyconf-&gt;cipher == WLAN_CIPHER_SUITE_WEP104) {
<span class="p_del">-		ret = __iwl_mvm_set_sta_key(mvm, vif, sta, keyconf, !mcast);</span>
<span class="p_add">+		ret = __iwl_mvm_set_sta_key(mvm, vif, sta, keyconf,</span>
<span class="p_add">+					    key_offset, !mcast);</span>
 		if (ret) {
 			__clear_bit(keyconf-&gt;hw_key_idx, mvm-&gt;fw_key_table);
 			__iwl_mvm_remove_sta_key(mvm, sta_id, keyconf, mcast);
<span class="p_chunk">@@ -1558,7 +1568,7 @@</span> <span class="p_context"> void iwl_mvm_update_tkip_key(struct iwl_mvm *mvm,</span>
 
 	mvm_sta = iwl_mvm_sta_from_mac80211(sta);
 	iwl_mvm_send_sta_key(mvm, mvm_sta, keyconf, mcast,
<span class="p_del">-			     iv32, phase1key, CMD_ASYNC);</span>
<span class="p_add">+			     iv32, phase1key, CMD_ASYNC, keyconf-&gt;hw_key_idx);</span>
 	rcu_read_unlock();
 }
 
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/mvm/sta.h b/drivers/net/wireless/iwlwifi/mvm/sta.h</span>
<span class="p_header">index 748f5dc..b3e424f 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/mvm/sta.h</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/mvm/sta.h</span>
<span class="p_chunk">@@ -365,8 +365,8 @@</span> <span class="p_context"> int iwl_mvm_rm_sta_id(struct iwl_mvm *mvm,</span>
 int iwl_mvm_set_sta_key(struct iwl_mvm *mvm,
 			struct ieee80211_vif *vif,
 			struct ieee80211_sta *sta,
<span class="p_del">-			struct ieee80211_key_conf *key,</span>
<span class="p_del">-			bool have_key_offset);</span>
<span class="p_add">+			struct ieee80211_key_conf *keyconf,</span>
<span class="p_add">+			u8 key_offset);</span>
 int iwl_mvm_remove_sta_key(struct iwl_mvm *mvm,
 			   struct ieee80211_vif *vif,
 			   struct ieee80211_sta *sta,
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/rtl8821ae/hw.c b/drivers/net/wireless/rtlwifi/rtl8821ae/hw.c</span>
<span class="p_header">index 6e9418e..bbb789f 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/rtl8821ae/hw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/rtl8821ae/hw.c</span>
<span class="p_chunk">@@ -2272,7 +2272,7 @@</span> <span class="p_context"> void rtl8821ae_enable_interrupt(struct ieee80211_hw *hw)</span>
 	struct rtl_priv *rtlpriv = rtl_priv(hw);
 	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));
 
<span class="p_del">-	if (!rtlpci-&gt;int_clear)</span>
<span class="p_add">+	if (rtlpci-&gt;int_clear)</span>
 		rtl8821ae_clear_interrupt(hw);/*clear it here first*/
 
 	rtl_write_dword(rtlpriv, REG_HIMR, rtlpci-&gt;irq_mask[0] &amp; 0xFFFFFFFF);
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/rtl8821ae/sw.c b/drivers/net/wireless/rtlwifi/rtl8821ae/sw.c</span>
<span class="p_header">index 8ee141a..142bdff 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/rtl8821ae/sw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/rtl8821ae/sw.c</span>
<span class="p_chunk">@@ -448,7 +448,7 @@</span> <span class="p_context"> MODULE_PARM_DESC(fwlps, &quot;Set to 1 to use FW control power save (default 1)\n&quot;);</span>
 MODULE_PARM_DESC(msi, &quot;Set to 1 to use MSI interrupts mode (default 1)\n&quot;);
 MODULE_PARM_DESC(debug, &quot;Set debug level (0-5) (default 0)&quot;);
 MODULE_PARM_DESC(disable_watchdog, &quot;Set to 1 to disable the watchdog (default 0)\n&quot;);
<span class="p_del">-MODULE_PARM_DESC(int_clear, &quot;Set to 1 to disable interrupt clear before set (default 0)\n&quot;);</span>
<span class="p_add">+MODULE_PARM_DESC(int_clear, &quot;Set to 0 to disable interrupt clear before set (default 1)\n&quot;);</span>
 
 static SIMPLE_DEV_PM_OPS(rtlwifi_pm_ops, rtl_pci_suspend, rtl_pci_resume);
 
<span class="p_header">diff --git a/drivers/net/xen-netback/netback.c b/drivers/net/xen-netback/netback.c</span>
<span class="p_header">index 3f44b52..4fe3e13 100644</span>
<span class="p_header">--- a/drivers/net/xen-netback/netback.c</span>
<span class="p_header">+++ b/drivers/net/xen-netback/netback.c</span>
<span class="p_chunk">@@ -247,18 +247,18 @@</span> <span class="p_context"> static struct xenvif_rx_meta *get_next_rx_buffer(struct xenvif_queue *queue,</span>
 						 struct netrx_pending_operations *npo)
 {
 	struct xenvif_rx_meta *meta;
<span class="p_del">-	struct xen_netif_rx_request *req;</span>
<span class="p_add">+	struct xen_netif_rx_request req;</span>
 
<span class="p_del">-	req = RING_GET_REQUEST(&amp;queue-&gt;rx, queue-&gt;rx.req_cons++);</span>
<span class="p_add">+	RING_COPY_REQUEST(&amp;queue-&gt;rx, queue-&gt;rx.req_cons++, &amp;req);</span>
 
 	meta = npo-&gt;meta + npo-&gt;meta_prod++;
 	meta-&gt;gso_type = XEN_NETIF_GSO_TYPE_NONE;
 	meta-&gt;gso_size = 0;
 	meta-&gt;size = 0;
<span class="p_del">-	meta-&gt;id = req-&gt;id;</span>
<span class="p_add">+	meta-&gt;id = req.id;</span>
 
 	npo-&gt;copy_off = 0;
<span class="p_del">-	npo-&gt;copy_gref = req-&gt;gref;</span>
<span class="p_add">+	npo-&gt;copy_gref = req.gref;</span>
 
 	return meta;
 }
<span class="p_chunk">@@ -370,7 +370,7 @@</span> <span class="p_context"> static int xenvif_gop_skb(struct sk_buff *skb,</span>
 	struct xenvif *vif = netdev_priv(skb-&gt;dev);
 	int nr_frags = skb_shinfo(skb)-&gt;nr_frags;
 	int i;
<span class="p_del">-	struct xen_netif_rx_request *req;</span>
<span class="p_add">+	struct xen_netif_rx_request req;</span>
 	struct xenvif_rx_meta *meta;
 	unsigned char *data;
 	int head = 1;
<span class="p_chunk">@@ -389,15 +389,15 @@</span> <span class="p_context"> static int xenvif_gop_skb(struct sk_buff *skb,</span>
 
 	/* Set up a GSO prefix descriptor, if necessary */
 	if ((1 &lt;&lt; gso_type) &amp; vif-&gt;gso_prefix_mask) {
<span class="p_del">-		req = RING_GET_REQUEST(&amp;queue-&gt;rx, queue-&gt;rx.req_cons++);</span>
<span class="p_add">+		RING_COPY_REQUEST(&amp;queue-&gt;rx, queue-&gt;rx.req_cons++, &amp;req);</span>
 		meta = npo-&gt;meta + npo-&gt;meta_prod++;
 		meta-&gt;gso_type = gso_type;
 		meta-&gt;gso_size = skb_shinfo(skb)-&gt;gso_size;
 		meta-&gt;size = 0;
<span class="p_del">-		meta-&gt;id = req-&gt;id;</span>
<span class="p_add">+		meta-&gt;id = req.id;</span>
 	}
 
<span class="p_del">-	req = RING_GET_REQUEST(&amp;queue-&gt;rx, queue-&gt;rx.req_cons++);</span>
<span class="p_add">+	RING_COPY_REQUEST(&amp;queue-&gt;rx, queue-&gt;rx.req_cons++, &amp;req);</span>
 	meta = npo-&gt;meta + npo-&gt;meta_prod++;
 
 	if ((1 &lt;&lt; gso_type) &amp; vif-&gt;gso_mask) {
<span class="p_chunk">@@ -409,9 +409,9 @@</span> <span class="p_context"> static int xenvif_gop_skb(struct sk_buff *skb,</span>
 	}
 
 	meta-&gt;size = 0;
<span class="p_del">-	meta-&gt;id = req-&gt;id;</span>
<span class="p_add">+	meta-&gt;id = req.id;</span>
 	npo-&gt;copy_off = 0;
<span class="p_del">-	npo-&gt;copy_gref = req-&gt;gref;</span>
<span class="p_add">+	npo-&gt;copy_gref = req.gref;</span>
 
 	data = skb-&gt;data;
 	while (data &lt; skb_tail_pointer(skb)) {
<span class="p_chunk">@@ -625,9 +625,7 @@</span> <span class="p_context"> static void tx_add_credit(struct xenvif_queue *queue)</span>
 	 * Allow a burst big enough to transmit a jumbo packet of up to 128kB.
 	 * Otherwise the interface can seize up due to insufficient credit.
 	 */
<span class="p_del">-	max_burst = RING_GET_REQUEST(&amp;queue-&gt;tx, queue-&gt;tx.req_cons)-&gt;size;</span>
<span class="p_del">-	max_burst = min(max_burst, 131072UL);</span>
<span class="p_del">-	max_burst = max(max_burst, queue-&gt;credit_bytes);</span>
<span class="p_add">+	max_burst = max(131072UL, queue-&gt;credit_bytes);</span>
 
 	/* Take care that adding a new chunk of credit doesn&#39;t wrap to zero. */
 	max_credit = queue-&gt;remaining_credit + queue-&gt;credit_bytes;
<span class="p_chunk">@@ -657,7 +655,7 @@</span> <span class="p_context"> static void xenvif_tx_err(struct xenvif_queue *queue,</span>
 		spin_unlock_irqrestore(&amp;queue-&gt;response_lock, flags);
 		if (cons == end)
 			break;
<span class="p_del">-		txp = RING_GET_REQUEST(&amp;queue-&gt;tx, cons++);</span>
<span class="p_add">+		RING_COPY_REQUEST(&amp;queue-&gt;tx, cons++, txp);</span>
 	} while (1);
 	queue-&gt;tx.req_cons = cons;
 }
<span class="p_chunk">@@ -724,8 +722,7 @@</span> <span class="p_context"> static int xenvif_count_requests(struct xenvif_queue *queue,</span>
 		if (drop_err)
 			txp = &amp;dropped_tx;
 
<span class="p_del">-		memcpy(txp, RING_GET_REQUEST(&amp;queue-&gt;tx, cons + slots),</span>
<span class="p_del">-		       sizeof(*txp));</span>
<span class="p_add">+		RING_COPY_REQUEST(&amp;queue-&gt;tx, cons + slots, txp);</span>
 
 		/* If the guest submitted a frame &gt;= 64 KiB then
 		 * first-&gt;size overflowed and following slots will
<span class="p_chunk">@@ -1058,8 +1055,7 @@</span> <span class="p_context"> static int xenvif_get_extras(struct xenvif_queue *queue,</span>
 			return -EBADR;
 		}
 
<span class="p_del">-		memcpy(&amp;extra, RING_GET_REQUEST(&amp;queue-&gt;tx, cons),</span>
<span class="p_del">-		       sizeof(extra));</span>
<span class="p_add">+		RING_COPY_REQUEST(&amp;queue-&gt;tx, cons, &amp;extra);</span>
 		if (unlikely(!extra.type ||
 			     extra.type &gt;= XEN_NETIF_EXTRA_TYPE_MAX)) {
 			queue-&gt;tx.req_cons = ++cons;
<span class="p_chunk">@@ -1194,7 +1190,7 @@</span> <span class="p_context"> static void xenvif_tx_build_gops(struct xenvif_queue *queue,</span>
 
 		idx = queue-&gt;tx.req_cons;
 		rmb(); /* Ensure that we see the request before we copy it. */
<span class="p_del">-		memcpy(&amp;txreq, RING_GET_REQUEST(&amp;queue-&gt;tx, idx), sizeof(txreq));</span>
<span class="p_add">+		RING_COPY_REQUEST(&amp;queue-&gt;tx, idx, &amp;txreq);</span>
 
 		/* Credit-based scheduling. */
 		if (txreq.size &gt; queue-&gt;remaining_credit &amp;&amp;
<span class="p_header">diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c</span>
<span class="p_header">index d1bfd89..049caf7 100644</span>
<span class="p_header">--- a/drivers/of/fdt.c</span>
<span class="p_header">+++ b/drivers/of/fdt.c</span>
<span class="p_chunk">@@ -13,6 +13,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/kernel.h&gt;
 #include &lt;linux/initrd.h&gt;
 #include &lt;linux/memblock.h&gt;
<span class="p_add">+#include &lt;linux/mutex.h&gt;</span>
 #include &lt;linux/of.h&gt;
 #include &lt;linux/of_fdt.h&gt;
 #include &lt;linux/of_reserved_mem.h&gt;
<span class="p_chunk">@@ -436,6 +437,8 @@</span> <span class="p_context"> static void *kernel_tree_alloc(u64 size, u64 align)</span>
 	return kzalloc(size, GFP_KERNEL);
 }
 
<span class="p_add">+static DEFINE_MUTEX(of_fdt_unflatten_mutex);</span>
<span class="p_add">+</span>
 /**
  * of_fdt_unflatten_tree - create tree of device_nodes from flat blob
  *
<span class="p_chunk">@@ -447,7 +450,9 @@</span> <span class="p_context"> static void *kernel_tree_alloc(u64 size, u64 align)</span>
 void of_fdt_unflatten_tree(const unsigned long *blob,
 			struct device_node **mynodes)
 {
<span class="p_add">+	mutex_lock(&amp;of_fdt_unflatten_mutex);</span>
 	__unflatten_device_tree(blob, mynodes, &amp;kernel_tree_alloc);
<span class="p_add">+	mutex_unlock(&amp;of_fdt_unflatten_mutex);</span>
 }
 EXPORT_SYMBOL_GPL(of_fdt_unflatten_tree);
 
<span class="p_header">diff --git a/drivers/parisc/iommu-helpers.h b/drivers/parisc/iommu-helpers.h</span>
<span class="p_header">index 761e77b..e56f156 100644</span>
<span class="p_header">--- a/drivers/parisc/iommu-helpers.h</span>
<span class="p_header">+++ b/drivers/parisc/iommu-helpers.h</span>
<span class="p_chunk">@@ -104,7 +104,11 @@</span> <span class="p_context"> iommu_coalesce_chunks(struct ioc *ioc, struct device *dev,</span>
 	struct scatterlist *contig_sg;	   /* contig chunk head */
 	unsigned long dma_offset, dma_len; /* start/len of DMA stream */
 	unsigned int n_mappings = 0;
<span class="p_del">-	unsigned int max_seg_size = dma_get_max_seg_size(dev);</span>
<span class="p_add">+	unsigned int max_seg_size = min(dma_get_max_seg_size(dev),</span>
<span class="p_add">+					(unsigned)DMA_CHUNK_SIZE);</span>
<span class="p_add">+	unsigned int max_seg_boundary = dma_get_seg_boundary(dev) + 1;</span>
<span class="p_add">+	if (max_seg_boundary)	/* check if the addition above didn&#39;t overflow */</span>
<span class="p_add">+		max_seg_size = min(max_seg_size, max_seg_boundary);</span>
 
 	while (nents &gt; 0) {
 
<span class="p_chunk">@@ -138,14 +142,11 @@</span> <span class="p_context"> iommu_coalesce_chunks(struct ioc *ioc, struct device *dev,</span>
 
 			/*
 			** First make sure current dma stream won&#39;t
<span class="p_del">-			** exceed DMA_CHUNK_SIZE if we coalesce the</span>
<span class="p_add">+			** exceed max_seg_size if we coalesce the</span>
 			** next entry.
 			*/   
<span class="p_del">-			if(unlikely(ALIGN(dma_len + dma_offset + startsg-&gt;length,</span>
<span class="p_del">-					    IOVP_SIZE) &gt; DMA_CHUNK_SIZE))</span>
<span class="p_del">-				break;</span>
<span class="p_del">-</span>
<span class="p_del">-			if (startsg-&gt;length + dma_len &gt; max_seg_size)</span>
<span class="p_add">+			if (unlikely(ALIGN(dma_len + dma_offset + startsg-&gt;length, IOVP_SIZE) &gt;</span>
<span class="p_add">+				     max_seg_size))</span>
 				break;
 
 			/*
<span class="p_header">diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c</span>
<span class="p_header">index 9261868..eead54c 100644</span>
<span class="p_header">--- a/drivers/pci/pci-sysfs.c</span>
<span class="p_header">+++ b/drivers/pci/pci-sysfs.c</span>
<span class="p_chunk">@@ -216,7 +216,10 @@</span> <span class="p_context"> static ssize_t numa_node_store(struct device *dev,</span>
 	if (ret)
 		return ret;
 
<span class="p_del">-	if (node &gt;= MAX_NUMNODES || !node_online(node))</span>
<span class="p_add">+	if ((node &lt; 0 &amp;&amp; node != NUMA_NO_NODE) || node &gt;= MAX_NUMNODES)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (node != NUMA_NO_NODE &amp;&amp; !node_online(node))</span>
 		return -EINVAL;
 
 	add_taint(TAINT_FIRMWARE_WORKAROUND, LOCKDEP_STILL_OK);
<span class="p_header">diff --git a/drivers/phy/Kconfig b/drivers/phy/Kconfig</span>
<span class="p_header">index 6b8dd16..771308e 100644</span>
<span class="p_header">--- a/drivers/phy/Kconfig</span>
<span class="p_header">+++ b/drivers/phy/Kconfig</span>
<span class="p_chunk">@@ -211,6 +211,7 @@</span> <span class="p_context"> config PHY_SUN9I_USB</span>
 	tristate &quot;Allwinner sun9i SoC USB PHY driver&quot;
 	depends on ARCH_SUNXI &amp;&amp; HAS_IOMEM &amp;&amp; OF
 	depends on RESET_CONTROLLER
<span class="p_add">+	depends on USB_COMMON</span>
 	select GENERIC_PHY
 	help
 	  Enable this to support the transceiver that is part of Allwinner
<span class="p_header">diff --git a/drivers/pinctrl/bcm/pinctrl-bcm2835.c b/drivers/pinctrl/bcm/pinctrl-bcm2835.c</span>
<span class="p_header">index 6177315..7a2d53c 100644</span>
<span class="p_header">--- a/drivers/pinctrl/bcm/pinctrl-bcm2835.c</span>
<span class="p_header">+++ b/drivers/pinctrl/bcm/pinctrl-bcm2835.c</span>
<span class="p_chunk">@@ -352,12 +352,6 @@</span> <span class="p_context"> static int bcm2835_gpio_get(struct gpio_chip *chip, unsigned offset)</span>
 	return bcm2835_gpio_get_bit(pc, GPLEV0, offset);
 }
 
<span class="p_del">-static int bcm2835_gpio_direction_output(struct gpio_chip *chip,</span>
<span class="p_del">-		unsigned offset, int value)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return pinctrl_gpio_direction_output(chip-&gt;base + offset);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static void bcm2835_gpio_set(struct gpio_chip *chip, unsigned offset, int value)
 {
 	struct bcm2835_pinctrl *pc = dev_get_drvdata(chip-&gt;dev);
<span class="p_chunk">@@ -365,6 +359,13 @@</span> <span class="p_context"> static void bcm2835_gpio_set(struct gpio_chip *chip, unsigned offset, int value)</span>
 	bcm2835_gpio_set_bit(pc, value ? GPSET0 : GPCLR0, offset);
 }
 
<span class="p_add">+static int bcm2835_gpio_direction_output(struct gpio_chip *chip,</span>
<span class="p_add">+		unsigned offset, int value)</span>
<span class="p_add">+{</span>
<span class="p_add">+	bcm2835_gpio_set(chip, offset, value);</span>
<span class="p_add">+	return pinctrl_gpio_direction_output(chip-&gt;base + offset);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int bcm2835_gpio_to_irq(struct gpio_chip *chip, unsigned offset)
 {
 	struct bcm2835_pinctrl *pc = dev_get_drvdata(chip-&gt;dev);
<span class="p_header">diff --git a/drivers/powercap/intel_rapl.c b/drivers/powercap/intel_rapl.c</span>
<span class="p_header">index 482b22d..2159634 100644</span>
<span class="p_header">--- a/drivers/powercap/intel_rapl.c</span>
<span class="p_header">+++ b/drivers/powercap/intel_rapl.c</span>
<span class="p_chunk">@@ -1336,10 +1336,13 @@</span> <span class="p_context"> static int rapl_detect_domains(struct rapl_package *rp, int cpu)</span>
 
 	for (rd = rp-&gt;domains; rd &lt; rp-&gt;domains + rp-&gt;nr_domains; rd++) {
 		/* check if the domain is locked by BIOS */
<span class="p_del">-		if (rapl_read_data_raw(rd, FW_LOCK, false, &amp;locked)) {</span>
<span class="p_add">+		ret = rapl_read_data_raw(rd, FW_LOCK, false, &amp;locked);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+		if (locked) {</span>
 			pr_info(&quot;RAPL package %d domain %s locked by BIOS\n&quot;,
 				rp-&gt;id, rd-&gt;name);
<span class="p_del">-				rd-&gt;state |= DOMAIN_STATE_BIOS_LOCKED;</span>
<span class="p_add">+			rd-&gt;state |= DOMAIN_STATE_BIOS_LOCKED;</span>
 		}
 	}
 
<span class="p_header">diff --git a/drivers/remoteproc/remoteproc_debugfs.c b/drivers/remoteproc/remoteproc_debugfs.c</span>
<span class="p_header">index 9d30809..916af50 100644</span>
<span class="p_header">--- a/drivers/remoteproc/remoteproc_debugfs.c</span>
<span class="p_header">+++ b/drivers/remoteproc/remoteproc_debugfs.c</span>
<span class="p_chunk">@@ -156,7 +156,7 @@</span> <span class="p_context"> rproc_recovery_write(struct file *filp, const char __user *user_buf,</span>
 	char buf[10];
 	int ret;
 
<span class="p_del">-	if (count &gt; sizeof(buf))</span>
<span class="p_add">+	if (count &lt; 1 || count &gt; sizeof(buf))</span>
 		return count;
 
 	ret = copy_from_user(buf, user_buf, count);
<span class="p_header">diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c</span>
<span class="p_header">index 4305178..1c1cd65 100644</span>
<span class="p_header">--- a/drivers/scsi/advansys.c</span>
<span class="p_header">+++ b/drivers/scsi/advansys.c</span>
<span class="p_chunk">@@ -7803,7 +7803,7 @@</span> <span class="p_context"> adv_build_req(struct asc_board *boardp, struct scsi_cmnd *scp,</span>
 		return ASC_BUSY;
 	}
 	scsiqp-&gt;sense_addr = cpu_to_le32(sense_addr);
<span class="p_del">-	scsiqp-&gt;sense_len = cpu_to_le32(SCSI_SENSE_BUFFERSIZE);</span>
<span class="p_add">+	scsiqp-&gt;sense_len = SCSI_SENSE_BUFFERSIZE;</span>
 
 	/* Build ADV_SCSI_REQ_Q */
 
<span class="p_header">diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c</span>
<span class="p_header">index 8bb173e..7d647a3 100644</span>
<span class="p_header">--- a/drivers/scsi/hosts.c</span>
<span class="p_header">+++ b/drivers/scsi/hosts.c</span>
<span class="p_chunk">@@ -326,6 +326,17 @@</span> <span class="p_context"> static void scsi_host_dev_release(struct device *dev)</span>
 		kfree(queuedata);
 	}
 
<span class="p_add">+	if (shost-&gt;shost_state == SHOST_CREATED) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Free the shost_dev device name here if scsi_host_alloc()</span>
<span class="p_add">+		 * and scsi_host_put() have been called but neither</span>
<span class="p_add">+		 * scsi_host_add() nor scsi_host_remove() has been called.</span>
<span class="p_add">+		 * This avoids that the memory allocated for the shost_dev</span>
<span class="p_add">+		 * name is leaked.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		kfree(dev_name(&amp;shost-&gt;shost_dev));</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	scsi_destroy_command_freelist(shost);
 	if (shost_use_blk_mq(shost)) {
 		if (shost-&gt;tag_set.tags)
<span class="p_header">diff --git a/drivers/scsi/scsi_pm.c b/drivers/scsi/scsi_pm.c</span>
<span class="p_header">index e4b7998..459abe1 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_pm.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_pm.c</span>
<span class="p_chunk">@@ -219,13 +219,13 @@</span> <span class="p_context"> static int sdev_runtime_suspend(struct device *dev)</span>
 	struct scsi_device *sdev = to_scsi_device(dev);
 	int err = 0;
 
<span class="p_del">-	if (pm &amp;&amp; pm-&gt;runtime_suspend) {</span>
<span class="p_del">-		err = blk_pre_runtime_suspend(sdev-&gt;request_queue);</span>
<span class="p_del">-		if (err)</span>
<span class="p_del">-			return err;</span>
<span class="p_add">+	err = blk_pre_runtime_suspend(sdev-&gt;request_queue);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+	if (pm &amp;&amp; pm-&gt;runtime_suspend)</span>
 		err = pm-&gt;runtime_suspend(dev);
<span class="p_del">-		blk_post_runtime_suspend(sdev-&gt;request_queue, err);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	blk_post_runtime_suspend(sdev-&gt;request_queue, err);</span>
<span class="p_add">+</span>
 	return err;
 }
 
<span class="p_chunk">@@ -248,11 +248,11 @@</span> <span class="p_context"> static int sdev_runtime_resume(struct device *dev)</span>
 	const struct dev_pm_ops *pm = dev-&gt;driver ? dev-&gt;driver-&gt;pm : NULL;
 	int err = 0;
 
<span class="p_del">-	if (pm &amp;&amp; pm-&gt;runtime_resume) {</span>
<span class="p_del">-		blk_pre_runtime_resume(sdev-&gt;request_queue);</span>
<span class="p_add">+	blk_pre_runtime_resume(sdev-&gt;request_queue);</span>
<span class="p_add">+	if (pm &amp;&amp; pm-&gt;runtime_resume)</span>
 		err = pm-&gt;runtime_resume(dev);
<span class="p_del">-		blk_post_runtime_resume(sdev-&gt;request_queue, err);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	blk_post_runtime_resume(sdev-&gt;request_queue, err);</span>
<span class="p_add">+</span>
 	return err;
 }
 
<span class="p_header">diff --git a/drivers/scsi/ses.c b/drivers/scsi/ses.c</span>
<span class="p_header">index dcb0d76..044d064 100644</span>
<span class="p_header">--- a/drivers/scsi/ses.c</span>
<span class="p_header">+++ b/drivers/scsi/ses.c</span>
<span class="p_chunk">@@ -84,6 +84,7 @@</span> <span class="p_context"> static void init_device_slot_control(unsigned char *dest_desc,</span>
 static int ses_recv_diag(struct scsi_device *sdev, int page_code,
 			 void *buf, int bufflen)
 {
<span class="p_add">+	int ret;</span>
 	unsigned char cmd[] = {
 		RECEIVE_DIAGNOSTIC,
 		1,		/* Set PCV bit */
<span class="p_chunk">@@ -92,9 +93,26 @@</span> <span class="p_context"> static int ses_recv_diag(struct scsi_device *sdev, int page_code,</span>
 		bufflen &amp; 0xff,
 		0
 	};
<span class="p_add">+	unsigned char recv_page_code;</span>
 
<span class="p_del">-	return scsi_execute_req(sdev, cmd, DMA_FROM_DEVICE, buf, bufflen,</span>
<span class="p_add">+	ret =  scsi_execute_req(sdev, cmd, DMA_FROM_DEVICE, buf, bufflen,</span>
 				NULL, SES_TIMEOUT, SES_RETRIES, NULL);
<span class="p_add">+	if (unlikely(!ret))</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	recv_page_code = ((unsigned char *)buf)[0];</span>
<span class="p_add">+</span>
<span class="p_add">+	if (likely(recv_page_code == page_code))</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* successful diagnostic but wrong page code.  This happens to some</span>
<span class="p_add">+	 * USB devices, just print a message and pretend there was an error */</span>
<span class="p_add">+</span>
<span class="p_add">+	sdev_printk(KERN_ERR, sdev,</span>
<span class="p_add">+		    &quot;Wrong diagnostic page; asked for %d got %u\n&quot;,</span>
<span class="p_add">+		    page_code, recv_page_code);</span>
<span class="p_add">+</span>
<span class="p_add">+	return -EINVAL;</span>
 }
 
 static int ses_send_diag(struct scsi_device *sdev, int page_code,
<span class="p_chunk">@@ -541,7 +559,15 @@</span> <span class="p_context"> static void ses_enclosure_data_process(struct enclosure_device *edev,</span>
 			if (desc_ptr)
 				desc_ptr += len;
 
<span class="p_del">-			if (addl_desc_ptr)</span>
<span class="p_add">+			if (addl_desc_ptr &amp;&amp;</span>
<span class="p_add">+			    /* only find additional descriptions for specific devices */</span>
<span class="p_add">+			    (type_ptr[0] == ENCLOSURE_COMPONENT_DEVICE ||</span>
<span class="p_add">+			     type_ptr[0] == ENCLOSURE_COMPONENT_ARRAY_DEVICE ||</span>
<span class="p_add">+			     type_ptr[0] == ENCLOSURE_COMPONENT_SAS_EXPANDER ||</span>
<span class="p_add">+			     /* these elements are optional */</span>
<span class="p_add">+			     type_ptr[0] == ENCLOSURE_COMPONENT_SCSI_TARGET_PORT ||</span>
<span class="p_add">+			     type_ptr[0] == ENCLOSURE_COMPONENT_SCSI_INITIATOR_PORT ||</span>
<span class="p_add">+			     type_ptr[0] == ENCLOSURE_COMPONENT_CONTROLLER_ELECTRONICS))</span>
 				addl_desc_ptr += addl_desc_ptr[1] + 2;
 
 		}
<span class="p_header">diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c</span>
<span class="p_header">index 9ce2f15..59ca751 100644</span>
<span class="p_header">--- a/drivers/spi/spi.c</span>
<span class="p_header">+++ b/drivers/spi/spi.c</span>
<span class="p_chunk">@@ -1454,7 +1454,7 @@</span> <span class="p_context"> struct spi_master *spi_alloc_master(struct device *dev, unsigned size)</span>
 	master-&gt;bus_num = -1;
 	master-&gt;num_chipselect = 1;
 	master-&gt;dev.class = &amp;spi_master_class;
<span class="p_del">-	master-&gt;dev.parent = get_device(dev);</span>
<span class="p_add">+	master-&gt;dev.parent = dev;</span>
 	spi_master_set_devdata(master, &amp;master[1]);
 
 	return master;
<span class="p_header">diff --git a/drivers/staging/iio/adc/lpc32xx_adc.c b/drivers/staging/iio/adc/lpc32xx_adc.c</span>
<span class="p_header">index 5331c44..ef6d0b0 100644</span>
<span class="p_header">--- a/drivers/staging/iio/adc/lpc32xx_adc.c</span>
<span class="p_header">+++ b/drivers/staging/iio/adc/lpc32xx_adc.c</span>
<span class="p_chunk">@@ -76,7 +76,7 @@</span> <span class="p_context"> static int lpc32xx_read_raw(struct iio_dev *indio_dev,</span>
 
 	if (mask == IIO_CHAN_INFO_RAW) {
 		mutex_lock(&amp;indio_dev-&gt;mlock);
<span class="p_del">-		clk_enable(info-&gt;clk);</span>
<span class="p_add">+		clk_prepare_enable(info-&gt;clk);</span>
 		/* Measurement setup */
 		__raw_writel(AD_INTERNAL | (chan-&gt;address) | AD_REFp | AD_REFm,
 			LPC32XX_ADC_SELECT(info-&gt;adc_base));
<span class="p_chunk">@@ -84,7 +84,7 @@</span> <span class="p_context"> static int lpc32xx_read_raw(struct iio_dev *indio_dev,</span>
 		__raw_writel(AD_PDN_CTRL | AD_STROBE,
 			LPC32XX_ADC_CTRL(info-&gt;adc_base));
 		wait_for_completion(&amp;info-&gt;completion); /* set by ISR */
<span class="p_del">-		clk_disable(info-&gt;clk);</span>
<span class="p_add">+		clk_disable_unprepare(info-&gt;clk);</span>
 		*val = info-&gt;value;
 		mutex_unlock(&amp;indio_dev-&gt;mlock);
 
<span class="p_header">diff --git a/drivers/staging/lustre/lustre/obdecho/echo_client.c b/drivers/staging/lustre/lustre/obdecho/echo_client.c</span>
<span class="p_header">index 0222fd2..a3783a2 100644</span>
<span class="p_header">--- a/drivers/staging/lustre/lustre/obdecho/echo_client.c</span>
<span class="p_header">+++ b/drivers/staging/lustre/lustre/obdecho/echo_client.c</span>
<span class="p_chunk">@@ -1268,6 +1268,7 @@</span> <span class="p_context"> static int</span>
 echo_copyout_lsm(struct lov_stripe_md *lsm, void *_ulsm, int ulsm_nob)
 {
 	struct lov_stripe_md *ulsm = _ulsm;
<span class="p_add">+	struct lov_oinfo **p;</span>
 	int nob, i;
 
 	nob = offsetof(struct lov_stripe_md, lsm_oinfo[lsm-&gt;lsm_stripe_count]);
<span class="p_chunk">@@ -1277,9 +1278,10 @@</span> <span class="p_context"> echo_copyout_lsm(struct lov_stripe_md *lsm, void *_ulsm, int ulsm_nob)</span>
 	if (copy_to_user(ulsm, lsm, sizeof(*ulsm)))
 		return -EFAULT;
 
<span class="p_del">-	for (i = 0; i &lt; lsm-&gt;lsm_stripe_count; i++) {</span>
<span class="p_del">-		if (copy_to_user(ulsm-&gt;lsm_oinfo[i], lsm-&gt;lsm_oinfo[i],</span>
<span class="p_del">-				      sizeof(lsm-&gt;lsm_oinfo[0])))</span>
<span class="p_add">+	for (i = 0, p = lsm-&gt;lsm_oinfo; i &lt; lsm-&gt;lsm_stripe_count; i++, p++) {</span>
<span class="p_add">+		struct lov_oinfo __user *up;</span>
<span class="p_add">+		if (get_user(up, ulsm-&gt;lsm_oinfo + i) ||</span>
<span class="p_add">+		    copy_to_user(up, *p, sizeof(struct lov_oinfo)))</span>
 			return -EFAULT;
 	}
 	return 0;
<span class="p_chunk">@@ -1287,9 +1289,10 @@</span> <span class="p_context"> echo_copyout_lsm(struct lov_stripe_md *lsm, void *_ulsm, int ulsm_nob)</span>
 
 static int
 echo_copyin_lsm(struct echo_device *ed, struct lov_stripe_md *lsm,
<span class="p_del">-		 void *ulsm, int ulsm_nob)</span>
<span class="p_add">+		struct lov_stripe_md __user *ulsm, int ulsm_nob)</span>
 {
 	struct echo_client_obd *ec = ed-&gt;ed_ec;
<span class="p_add">+	struct lov_oinfo **p;</span>
 	int		     i;
 
 	if (ulsm_nob &lt; sizeof(*lsm))
<span class="p_chunk">@@ -1304,12 +1307,10 @@</span> <span class="p_context"> echo_copyin_lsm(struct echo_device *ed, struct lov_stripe_md *lsm,</span>
 	    ((__u64)lsm-&gt;lsm_stripe_size * lsm-&gt;lsm_stripe_count &gt; ~0UL))
 		return -EINVAL;
 
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; i &lt; lsm-&gt;lsm_stripe_count; i++) {</span>
<span class="p_del">-		if (copy_from_user(lsm-&gt;lsm_oinfo[i],</span>
<span class="p_del">-				       ((struct lov_stripe_md *)ulsm)-&gt; \</span>
<span class="p_del">-				       lsm_oinfo[i],</span>
<span class="p_del">-				       sizeof(lsm-&gt;lsm_oinfo[0])))</span>
<span class="p_add">+	for (i = 0, p = lsm-&gt;lsm_oinfo; i &lt; lsm-&gt;lsm_stripe_count; i++, p++) {</span>
<span class="p_add">+		struct lov_oinfo __user *up;</span>
<span class="p_add">+		if (get_user(up, ulsm-&gt;lsm_oinfo + i) ||</span>
<span class="p_add">+		    copy_from_user(*p, up, sizeof(struct lov_oinfo)))</span>
 			return -EFAULT;
 	}
 	return 0;
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target.c b/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_header">index 56cf199..f7fdc85 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_chunk">@@ -4085,6 +4085,17 @@</span> <span class="p_context"> reject:</span>
 	return iscsit_add_reject(conn, ISCSI_REASON_BOOKMARK_NO_RESOURCES, buf);
 }
 
<span class="p_add">+static bool iscsi_target_check_conn_state(struct iscsi_conn *conn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	bool ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_bh(&amp;conn-&gt;state_lock);</span>
<span class="p_add">+	ret = (conn-&gt;conn_state != TARG_CONN_STATE_LOGGED_IN);</span>
<span class="p_add">+	spin_unlock_bh(&amp;conn-&gt;state_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int iscsi_target_rx_thread(void *arg)
 {
 	int ret, rc;
<span class="p_chunk">@@ -4102,7 +4113,7 @@</span> <span class="p_context"> int iscsi_target_rx_thread(void *arg)</span>
 	 * incoming iscsi/tcp socket I/O, and/or failing the connection.
 	 */
 	rc = wait_for_completion_interruptible(&amp;conn-&gt;rx_login_comp);
<span class="p_del">-	if (rc &lt; 0)</span>
<span class="p_add">+	if (rc &lt; 0 || iscsi_target_check_conn_state(conn))</span>
 		return 0;
 
 	if (conn-&gt;conn_transport-&gt;transport_type == ISCSI_INFINIBAND) {
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target_nego.c b/drivers/target/iscsi/iscsi_target_nego.c</span>
<span class="p_header">index f9cde91..9a96f17 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target_nego.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target_nego.c</span>
<span class="p_chunk">@@ -393,6 +393,7 @@</span> <span class="p_context"> err:</span>
 	if (login-&gt;login_complete) {
 		if (conn-&gt;rx_thread &amp;&amp; conn-&gt;rx_thread_active) {
 			send_sig(SIGINT, conn-&gt;rx_thread, 1);
<span class="p_add">+			complete(&amp;conn-&gt;rx_login_comp);</span>
 			kthread_stop(conn-&gt;rx_thread);
 		}
 		if (conn-&gt;tx_thread &amp;&amp; conn-&gt;tx_thread_active) {
<span class="p_header">diff --git a/drivers/target/target_core_sbc.c b/drivers/target/target_core_sbc.c</span>
<span class="p_header">index e318ddb..9444c7b 100644</span>
<span class="p_header">--- a/drivers/target/target_core_sbc.c</span>
<span class="p_header">+++ b/drivers/target/target_core_sbc.c</span>
<span class="p_chunk">@@ -339,7 +339,8 @@</span> <span class="p_context"> sbc_setup_write_same(struct se_cmd *cmd, unsigned char *flags, struct sbc_ops *o</span>
 	return 0;
 }
 
<span class="p_del">-static sense_reason_t xdreadwrite_callback(struct se_cmd *cmd, bool success)</span>
<span class="p_add">+static sense_reason_t xdreadwrite_callback(struct se_cmd *cmd, bool success,</span>
<span class="p_add">+					   int *post_ret)</span>
 {
 	unsigned char *buf, *addr;
 	struct scatterlist *sg;
<span class="p_chunk">@@ -405,7 +406,8 @@</span> <span class="p_context"> sbc_execute_rw(struct se_cmd *cmd)</span>
 			       cmd-&gt;data_direction);
 }
 
<span class="p_del">-static sense_reason_t compare_and_write_post(struct se_cmd *cmd, bool success)</span>
<span class="p_add">+static sense_reason_t compare_and_write_post(struct se_cmd *cmd, bool success,</span>
<span class="p_add">+					     int *post_ret)</span>
 {
 	struct se_device *dev = cmd-&gt;se_dev;
 
<span class="p_chunk">@@ -415,8 +417,10 @@</span> <span class="p_context"> static sense_reason_t compare_and_write_post(struct se_cmd *cmd, bool success)</span>
 	 * sent to the backend driver.
 	 */
 	spin_lock_irq(&amp;cmd-&gt;t_state_lock);
<span class="p_del">-	if ((cmd-&gt;transport_state &amp; CMD_T_SENT) &amp;&amp; !cmd-&gt;scsi_status)</span>
<span class="p_add">+	if ((cmd-&gt;transport_state &amp; CMD_T_SENT) &amp;&amp; !cmd-&gt;scsi_status) {</span>
 		cmd-&gt;se_cmd_flags |= SCF_COMPARE_AND_WRITE_POST;
<span class="p_add">+		*post_ret = 1;</span>
<span class="p_add">+	}</span>
 	spin_unlock_irq(&amp;cmd-&gt;t_state_lock);
 
 	/*
<span class="p_chunk">@@ -428,7 +432,8 @@</span> <span class="p_context"> static sense_reason_t compare_and_write_post(struct se_cmd *cmd, bool success)</span>
 	return TCM_NO_SENSE;
 }
 
<span class="p_del">-static sense_reason_t compare_and_write_callback(struct se_cmd *cmd, bool success)</span>
<span class="p_add">+static sense_reason_t compare_and_write_callback(struct se_cmd *cmd, bool success,</span>
<span class="p_add">+						 int *post_ret)</span>
 {
 	struct se_device *dev = cmd-&gt;se_dev;
 	struct scatterlist *write_sg = NULL, *sg;
<span class="p_chunk">@@ -524,11 +529,11 @@</span> <span class="p_context"> static sense_reason_t compare_and_write_callback(struct se_cmd *cmd, bool succes</span>
 
 		if (block_size &lt; PAGE_SIZE) {
 			sg_set_page(&amp;write_sg[i], m.page, block_size,
<span class="p_del">-				    block_size);</span>
<span class="p_add">+				    m.piter.sg-&gt;offset + block_size);</span>
 		} else {
 			sg_miter_next(&amp;m);
 			sg_set_page(&amp;write_sg[i], m.page, block_size,
<span class="p_del">-				    0);</span>
<span class="p_add">+				    m.piter.sg-&gt;offset);</span>
 		}
 		len -= block_size;
 		i++;
<span class="p_header">diff --git a/drivers/target/target_core_transport.c b/drivers/target/target_core_transport.c</span>
<span class="p_header">index ce8574b..bbf4f69 100644</span>
<span class="p_header">--- a/drivers/target/target_core_transport.c</span>
<span class="p_header">+++ b/drivers/target/target_core_transport.c</span>
<span class="p_chunk">@@ -1610,7 +1610,7 @@</span> <span class="p_context"> bool target_stop_cmd(struct se_cmd *cmd, unsigned long *flags)</span>
 void transport_generic_request_failure(struct se_cmd *cmd,
 		sense_reason_t sense_reason)
 {
<span class="p_del">-	int ret = 0;</span>
<span class="p_add">+	int ret = 0, post_ret = 0;</span>
 
 	pr_debug(&quot;-----[ Storage Engine Exception for cmd: %p ITT: 0x%08llx&quot;
 		&quot; CDB: 0x%02x\n&quot;, cmd, cmd-&gt;tag, cmd-&gt;t_task_cdb[0]);
<span class="p_chunk">@@ -1632,7 +1632,7 @@</span> <span class="p_context"> void transport_generic_request_failure(struct se_cmd *cmd,</span>
 	 */
 	if ((cmd-&gt;se_cmd_flags &amp; SCF_COMPARE_AND_WRITE) &amp;&amp;
 	     cmd-&gt;transport_complete_callback)
<span class="p_del">-		cmd-&gt;transport_complete_callback(cmd, false);</span>
<span class="p_add">+		cmd-&gt;transport_complete_callback(cmd, false, &amp;post_ret);</span>
 
 	switch (sense_reason) {
 	case TCM_NON_EXISTENT_LUN:
<span class="p_chunk">@@ -2027,11 +2027,13 @@</span> <span class="p_context"> static void target_complete_ok_work(struct work_struct *work)</span>
 	 */
 	if (cmd-&gt;transport_complete_callback) {
 		sense_reason_t rc;
<span class="p_add">+		bool caw = (cmd-&gt;se_cmd_flags &amp; SCF_COMPARE_AND_WRITE);</span>
<span class="p_add">+		bool zero_dl = !(cmd-&gt;data_length);</span>
<span class="p_add">+		int post_ret = 0;</span>
 
<span class="p_del">-		rc = cmd-&gt;transport_complete_callback(cmd, true);</span>
<span class="p_del">-		if (!rc &amp;&amp; !(cmd-&gt;se_cmd_flags &amp; SCF_COMPARE_AND_WRITE_POST)) {</span>
<span class="p_del">-			if ((cmd-&gt;se_cmd_flags &amp; SCF_COMPARE_AND_WRITE) &amp;&amp;</span>
<span class="p_del">-			    !cmd-&gt;data_length)</span>
<span class="p_add">+		rc = cmd-&gt;transport_complete_callback(cmd, true, &amp;post_ret);</span>
<span class="p_add">+		if (!rc &amp;&amp; !post_ret) {</span>
<span class="p_add">+			if (caw &amp;&amp; zero_dl)</span>
 				goto queue_rsp;
 
 			return;
<span class="p_header">diff --git a/drivers/tty/n_tty.c b/drivers/tty/n_tty.c</span>
<span class="p_header">index dedac8a..c82adde 100644</span>
<span class="p_header">--- a/drivers/tty/n_tty.c</span>
<span class="p_header">+++ b/drivers/tty/n_tty.c</span>
<span class="p_chunk">@@ -2058,13 +2058,13 @@</span> <span class="p_context"> static int canon_copy_from_read_buf(struct tty_struct *tty,</span>
 	size_t eol;
 	size_t tail;
 	int ret, found = 0;
<span class="p_del">-	bool eof_push = 0;</span>
 
 	/* N.B. avoid overrun if nr == 0 */
<span class="p_del">-	n = min(*nr, smp_load_acquire(&amp;ldata-&gt;canon_head) - ldata-&gt;read_tail);</span>
<span class="p_del">-	if (!n)</span>
<span class="p_add">+	if (!*nr)</span>
 		return 0;
 
<span class="p_add">+	n = min(*nr + 1, smp_load_acquire(&amp;ldata-&gt;canon_head) - ldata-&gt;read_tail);</span>
<span class="p_add">+</span>
 	tail = ldata-&gt;read_tail &amp; (N_TTY_BUF_SIZE - 1);
 	size = min_t(size_t, tail + n, N_TTY_BUF_SIZE);
 
<span class="p_chunk">@@ -2085,12 +2085,11 @@</span> <span class="p_context"> static int canon_copy_from_read_buf(struct tty_struct *tty,</span>
 	n = eol - tail;
 	if (n &gt; N_TTY_BUF_SIZE)
 		n += N_TTY_BUF_SIZE;
<span class="p_del">-	n += found;</span>
<span class="p_del">-	c = n;</span>
<span class="p_add">+	c = n + found;</span>
 
<span class="p_del">-	if (found &amp;&amp; !ldata-&gt;push &amp;&amp; read_buf(ldata, eol) == __DISABLED_CHAR) {</span>
<span class="p_del">-		n--;</span>
<span class="p_del">-		eof_push = !n &amp;&amp; ldata-&gt;read_tail != ldata-&gt;line_start;</span>
<span class="p_add">+	if (!found || read_buf(ldata, eol) != __DISABLED_CHAR) {</span>
<span class="p_add">+		c = min(*nr, c);</span>
<span class="p_add">+		n = c;</span>
 	}
 
 	n_tty_trace(&quot;%s: eol:%zu found:%d n:%zu c:%zu size:%zu more:%zu\n&quot;,
<span class="p_chunk">@@ -2120,7 +2119,7 @@</span> <span class="p_context"> static int canon_copy_from_read_buf(struct tty_struct *tty,</span>
 			ldata-&gt;push = 0;
 		tty_audit_push(tty);
 	}
<span class="p_del">-	return eof_push ? -EAGAIN : 0;</span>
<span class="p_add">+	return 0;</span>
 }
 
 extern ssize_t redirected_tty_write(struct file *, const char __user *,
<span class="p_chunk">@@ -2290,10 +2289,7 @@</span> <span class="p_context"> static ssize_t n_tty_read(struct tty_struct *tty, struct file *file,</span>
 
 		if (ldata-&gt;icanon &amp;&amp; !L_EXTPROC(tty)) {
 			retval = canon_copy_from_read_buf(tty, &amp;b, &amp;nr);
<span class="p_del">-			if (retval == -EAGAIN) {</span>
<span class="p_del">-				retval = 0;</span>
<span class="p_del">-				continue;</span>
<span class="p_del">-			} else if (retval)</span>
<span class="p_add">+			if (retval)</span>
 				break;
 		} else {
 			int uncopied;
<span class="p_header">diff --git a/drivers/tty/serial/8250/8250_uniphier.c b/drivers/tty/serial/8250/8250_uniphier.c</span>
<span class="p_header">index d11621e..245edbb 100644</span>
<span class="p_header">--- a/drivers/tty/serial/8250/8250_uniphier.c</span>
<span class="p_header">+++ b/drivers/tty/serial/8250/8250_uniphier.c</span>
<span class="p_chunk">@@ -115,12 +115,16 @@</span> <span class="p_context"> static void uniphier_serial_out(struct uart_port *p, int offset, int value)</span>
  */
 static int uniphier_serial_dl_read(struct uart_8250_port *up)
 {
<span class="p_del">-	return readl(up-&gt;port.membase + UNIPHIER_UART_DLR);</span>
<span class="p_add">+	int offset = UNIPHIER_UART_DLR &lt;&lt; up-&gt;port.regshift;</span>
<span class="p_add">+</span>
<span class="p_add">+	return readl(up-&gt;port.membase + offset);</span>
 }
 
 static void uniphier_serial_dl_write(struct uart_8250_port *up, int value)
 {
<span class="p_del">-	writel(value, up-&gt;port.membase + UNIPHIER_UART_DLR);</span>
<span class="p_add">+	int offset = UNIPHIER_UART_DLR &lt;&lt; up-&gt;port.regshift;</span>
<span class="p_add">+</span>
<span class="p_add">+	writel(value, up-&gt;port.membase + offset);</span>
 }
 
 static int uniphier_of_serial_setup(struct device *dev, struct uart_port *port,
<span class="p_header">diff --git a/drivers/tty/tty_buffer.c b/drivers/tty/tty_buffer.c</span>
<span class="p_header">index 4cf263d..6059177 100644</span>
<span class="p_header">--- a/drivers/tty/tty_buffer.c</span>
<span class="p_header">+++ b/drivers/tty/tty_buffer.c</span>
<span class="p_chunk">@@ -442,7 +442,7 @@</span> <span class="p_context"> receive_buf(struct tty_struct *tty, struct tty_buffer *head, int count)</span>
 		count = disc-&gt;ops-&gt;receive_buf2(tty, p, f, count);
 	else {
 		count = min_t(int, count, tty-&gt;receive_room);
<span class="p_del">-		if (count)</span>
<span class="p_add">+		if (count &amp;&amp; disc-&gt;ops-&gt;receive_buf)</span>
 			disc-&gt;ops-&gt;receive_buf(tty, p, f, count);
 	}
 	head-&gt;read += count;
<span class="p_header">diff --git a/drivers/usb/chipidea/debug.c b/drivers/usb/chipidea/debug.c</span>
<span class="p_header">index 5b7061a..6a4151c 100644</span>
<span class="p_header">--- a/drivers/usb/chipidea/debug.c</span>
<span class="p_header">+++ b/drivers/usb/chipidea/debug.c</span>
<span class="p_chunk">@@ -316,8 +316,10 @@</span> <span class="p_context"> static ssize_t ci_role_write(struct file *file, const char __user *ubuf,</span>
 	if (role == CI_ROLE_END || role == ci-&gt;role)
 		return -EINVAL;
 
<span class="p_add">+	disable_irq(ci-&gt;irq);</span>
 	ci_role_stop(ci);
 	ret = ci_role_start(ci, role);
<span class="p_add">+	enable_irq(ci-&gt;irq);</span>
 
 	return ret ? ret : count;
 }
<span class="p_header">diff --git a/drivers/usb/class/cdc-acm.c b/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">index b30e742..26ca4f9 100644</span>
<span class="p_header">--- a/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">+++ b/drivers/usb/class/cdc-acm.c</span>
<span class="p_chunk">@@ -1838,6 +1838,11 @@</span> <span class="p_context"> static const struct usb_device_id acm_ids[] = {</span>
 	},
 #endif
 
<span class="p_add">+	/* Exclude Infineon Flash Loader utility */</span>
<span class="p_add">+	{ USB_DEVICE(0x058b, 0x0041),</span>
<span class="p_add">+	.driver_info = IGNORE_DEVICE,</span>
<span class="p_add">+	},</span>
<span class="p_add">+</span>
 	/* control interfaces without any protocol set */
 	{ USB_INTERFACE_INFO(USB_CLASS_COMM, USB_CDC_SUBCLASS_ACM,
 		USB_CDC_PROTO_NONE) },
<span class="p_header">diff --git a/drivers/usb/core/config.c b/drivers/usb/core/config.c</span>
<span class="p_header">index b9ddf0c..894894f 100644</span>
<span class="p_header">--- a/drivers/usb/core/config.c</span>
<span class="p_header">+++ b/drivers/usb/core/config.c</span>
<span class="p_chunk">@@ -115,7 +115,8 @@</span> <span class="p_context"> static void usb_parse_ss_endpoint_companion(struct device *ddev, int cfgno,</span>
 		   USB_SS_MULT(desc-&gt;bmAttributes) &gt; 3) {
 		dev_warn(ddev, &quot;Isoc endpoint has Mult of %d in &quot;
 				&quot;config %d interface %d altsetting %d ep %d: &quot;
<span class="p_del">-				&quot;setting to 3\n&quot;, desc-&gt;bmAttributes + 1,</span>
<span class="p_add">+				&quot;setting to 3\n&quot;,</span>
<span class="p_add">+				USB_SS_MULT(desc-&gt;bmAttributes),</span>
 				cfgno, inum, asnum, ep-&gt;desc.bEndpointAddress);
 		ep-&gt;ss_ep_comp.bmAttributes = 2;
 	}
<span class="p_header">diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c</span>
<span class="p_header">index 73dfa19..2f0fa89 100644</span>
<span class="p_header">--- a/drivers/usb/core/hub.c</span>
<span class="p_header">+++ b/drivers/usb/core/hub.c</span>
<span class="p_chunk">@@ -124,6 +124,10 @@</span> <span class="p_context"> struct usb_hub *usb_hub_to_struct_hub(struct usb_device *hdev)</span>
 
 int usb_device_supports_lpm(struct usb_device *udev)
 {
<span class="p_add">+	/* Some devices have trouble with LPM */</span>
<span class="p_add">+	if (udev-&gt;quirks &amp; USB_QUIRK_NO_LPM)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	/* USB 2.1 (and greater) devices indicate LPM support through
 	 * their USB 2.0 Extended Capabilities BOS descriptor.
 	 */
<span class="p_chunk">@@ -1031,10 +1035,20 @@</span> <span class="p_context"> static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)</span>
 	unsigned delay;
 
 	/* Continue a partial initialization */
<span class="p_del">-	if (type == HUB_INIT2)</span>
<span class="p_del">-		goto init2;</span>
<span class="p_del">-	if (type == HUB_INIT3)</span>
<span class="p_add">+	if (type == HUB_INIT2 || type == HUB_INIT3) {</span>
<span class="p_add">+		device_lock(hub-&gt;intfdev);</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Was the hub disconnected while we were waiting? */</span>
<span class="p_add">+		if (hub-&gt;disconnected) {</span>
<span class="p_add">+			device_unlock(hub-&gt;intfdev);</span>
<span class="p_add">+			kref_put(&amp;hub-&gt;kref, hub_release);</span>
<span class="p_add">+			return;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		if (type == HUB_INIT2)</span>
<span class="p_add">+			goto init2;</span>
 		goto init3;
<span class="p_add">+	}</span>
<span class="p_add">+	kref_get(&amp;hub-&gt;kref);</span>
 
 	/* The superspeed hub except for root hub has to use Hub Depth
 	 * value as an offset into the route string to locate the bits
<span class="p_chunk">@@ -1232,6 +1246,7 @@</span> <span class="p_context"> static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)</span>
 			queue_delayed_work(system_power_efficient_wq,
 					&amp;hub-&gt;init_work,
 					msecs_to_jiffies(delay));
<span class="p_add">+			device_unlock(hub-&gt;intfdev);</span>
 			return;		/* Continues at init3: below */
 		} else {
 			msleep(delay);
<span class="p_chunk">@@ -1253,6 +1268,11 @@</span> <span class="p_context"> static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)</span>
 	/* Allow autosuspend if it was suppressed */
 	if (type &lt;= HUB_INIT3)
 		usb_autopm_put_interface_async(to_usb_interface(hub-&gt;intfdev));
<span class="p_add">+</span>
<span class="p_add">+	if (type == HUB_INIT2 || type == HUB_INIT3)</span>
<span class="p_add">+		device_unlock(hub-&gt;intfdev);</span>
<span class="p_add">+</span>
<span class="p_add">+	kref_put(&amp;hub-&gt;kref, hub_release);</span>
 }
 
 /* Implement the continuations for the delays above */
<span class="p_chunk">@@ -4499,6 +4519,8 @@</span> <span class="p_context"> hub_port_init (struct usb_hub *hub, struct usb_device *udev, int port1,</span>
 		goto fail;
 	}
 
<span class="p_add">+	usb_detect_quirks(udev);</span>
<span class="p_add">+</span>
 	if (udev-&gt;wusb == 0 &amp;&amp; le16_to_cpu(udev-&gt;descriptor.bcdUSB) &gt;= 0x0201) {
 		retval = usb_get_bos_descriptor(udev);
 		if (!retval) {
<span class="p_chunk">@@ -4697,7 +4719,6 @@</span> <span class="p_context"> static void hub_port_connect(struct usb_hub *hub, int port1, u16 portstatus,</span>
 		if (status &lt; 0)
 			goto loop;
 
<span class="p_del">-		usb_detect_quirks(udev);</span>
 		if (udev-&gt;quirks &amp; USB_QUIRK_DELAY_INIT)
 			msleep(1000);
 
<span class="p_chunk">@@ -5313,9 +5334,6 @@</span> <span class="p_context"> static int usb_reset_and_verify_device(struct usb_device *udev)</span>
 	if (udev-&gt;usb2_hw_lpm_enabled == 1)
 		usb_set_usb2_hardware_lpm(udev, 0);
 
<span class="p_del">-	bos = udev-&gt;bos;</span>
<span class="p_del">-	udev-&gt;bos = NULL;</span>
<span class="p_del">-</span>
 	/* Disable LPM and LTM while we reset the device and reinstall the alt
 	 * settings.  Device-initiated LPM settings, and system exit latency
 	 * settings are cleared when the device is reset, so we have to set
<span class="p_chunk">@@ -5324,15 +5342,18 @@</span> <span class="p_context"> static int usb_reset_and_verify_device(struct usb_device *udev)</span>
 	ret = usb_unlocked_disable_lpm(udev);
 	if (ret) {
 		dev_err(&amp;udev-&gt;dev, &quot;%s Failed to disable LPM\n.&quot;, __func__);
<span class="p_del">-		goto re_enumerate;</span>
<span class="p_add">+		goto re_enumerate_no_bos;</span>
 	}
 	ret = usb_disable_ltm(udev);
 	if (ret) {
 		dev_err(&amp;udev-&gt;dev, &quot;%s Failed to disable LTM\n.&quot;,
 				__func__);
<span class="p_del">-		goto re_enumerate;</span>
<span class="p_add">+		goto re_enumerate_no_bos;</span>
 	}
 
<span class="p_add">+	bos = udev-&gt;bos;</span>
<span class="p_add">+	udev-&gt;bos = NULL;</span>
<span class="p_add">+</span>
 	for (i = 0; i &lt; SET_CONFIG_TRIES; ++i) {
 
 		/* ep0 maxpacket size may change; let the HCD know about it.
<span class="p_chunk">@@ -5429,10 +5450,11 @@</span> <span class="p_context"> done:</span>
 	return 0;
 
 re_enumerate:
<span class="p_del">-	/* LPM state doesn&#39;t matter when we&#39;re about to destroy the device. */</span>
<span class="p_del">-	hub_port_logical_disconnect(parent_hub, port1);</span>
 	usb_release_bos_descriptor(udev);
 	udev-&gt;bos = bos;
<span class="p_add">+re_enumerate_no_bos:</span>
<span class="p_add">+	/* LPM state doesn&#39;t matter when we&#39;re about to destroy the device. */</span>
<span class="p_add">+	hub_port_logical_disconnect(parent_hub, port1);</span>
 	return -ENODEV;
 }
 
<span class="p_header">diff --git a/drivers/usb/core/quirks.c b/drivers/usb/core/quirks.c</span>
<span class="p_header">index f5a3819..017c1de 100644</span>
<span class="p_header">--- a/drivers/usb/core/quirks.c</span>
<span class="p_header">+++ b/drivers/usb/core/quirks.c</span>
<span class="p_chunk">@@ -199,6 +199,12 @@</span> <span class="p_context"> static const struct usb_device_id usb_quirk_list[] = {</span>
 	{ USB_DEVICE(0x1a0a, 0x0200), .driver_info =
 			USB_QUIRK_LINEAR_UFRAME_INTR_BINTERVAL },
 
<span class="p_add">+	/* Blackmagic Design Intensity Shuttle */</span>
<span class="p_add">+	{ USB_DEVICE(0x1edb, 0xbd3b), .driver_info = USB_QUIRK_NO_LPM },</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Blackmagic Design UltraStudio SDI */</span>
<span class="p_add">+	{ USB_DEVICE(0x1edb, 0xbd4f), .driver_info = USB_QUIRK_NO_LPM },</span>
<span class="p_add">+</span>
 	{ }  /* terminating entry must be last */
 };
 
<span class="p_header">diff --git a/drivers/usb/gadget/udc/pxa27x_udc.c b/drivers/usb/gadget/udc/pxa27x_udc.c</span>
<span class="p_header">index b51226a..7a45470 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/udc/pxa27x_udc.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/udc/pxa27x_udc.c</span>
<span class="p_chunk">@@ -2535,6 +2535,9 @@</span> <span class="p_context"> static int pxa_udc_suspend(struct platform_device *_dev, pm_message_t state)</span>
 	udc-&gt;pullup_resume = udc-&gt;pullup_on;
 	dplus_pullup(udc, 0);
 
<span class="p_add">+	if (udc-&gt;driver)</span>
<span class="p_add">+		udc-&gt;driver-&gt;disconnect(&amp;udc-&gt;gadget);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/usb/host/whci/qset.c b/drivers/usb/host/whci/qset.c</span>
<span class="p_header">index dc31c42..9f1c053 100644</span>
<span class="p_header">--- a/drivers/usb/host/whci/qset.c</span>
<span class="p_header">+++ b/drivers/usb/host/whci/qset.c</span>
<span class="p_chunk">@@ -377,6 +377,10 @@</span> <span class="p_context"> static int qset_fill_page_list(struct whc *whc, struct whc_std *std, gfp_t mem_f</span>
 	if (std-&gt;pl_virt == NULL)
 		return -ENOMEM;
 	std-&gt;dma_addr = dma_map_single(whc-&gt;wusbhc.dev, std-&gt;pl_virt, pl_len, DMA_TO_DEVICE);
<span class="p_add">+	if (dma_mapping_error(whc-&gt;wusbhc.dev, std-&gt;dma_addr)) {</span>
<span class="p_add">+		kfree(std-&gt;pl_virt);</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+	}</span>
 
 	for (p = 0; p &lt; std-&gt;num_pointers; p++) {
 		std-&gt;pl_virt[p].buf_ptr = cpu_to_le64(dma_addr);
<span class="p_header">diff --git a/drivers/usb/host/xhci-hub.c b/drivers/usb/host/xhci-hub.c</span>
<span class="p_header">index 78241b5..976a15b 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-hub.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-hub.c</span>
<span class="p_chunk">@@ -616,8 +616,30 @@</span> <span class="p_context"> static u32 xhci_get_port_status(struct usb_hcd *hcd,</span>
 		if ((raw_port_status &amp; PORT_RESET) ||
 				!(raw_port_status &amp; PORT_PE))
 			return 0xffffffff;
<span class="p_del">-		if (time_after_eq(jiffies,</span>
<span class="p_del">-					bus_state-&gt;resume_done[wIndex])) {</span>
<span class="p_add">+		/* did port event handler already start resume timing? */</span>
<span class="p_add">+		if (!bus_state-&gt;resume_done[wIndex]) {</span>
<span class="p_add">+			/* If not, maybe we are in a host initated resume? */</span>
<span class="p_add">+			if (test_bit(wIndex, &amp;bus_state-&gt;resuming_ports)) {</span>
<span class="p_add">+				/* Host initated resume doesn&#39;t time the resume</span>
<span class="p_add">+				 * signalling using resume_done[].</span>
<span class="p_add">+				 * It manually sets RESUME state, sleeps 20ms</span>
<span class="p_add">+				 * and sets U0 state. This should probably be</span>
<span class="p_add">+				 * changed, but not right now.</span>
<span class="p_add">+				 */</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				/* port resume was discovered now and here,</span>
<span class="p_add">+				 * start resume timing</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				unsigned long timeout = jiffies +</span>
<span class="p_add">+					msecs_to_jiffies(USB_RESUME_TIMEOUT);</span>
<span class="p_add">+</span>
<span class="p_add">+				set_bit(wIndex, &amp;bus_state-&gt;resuming_ports);</span>
<span class="p_add">+				bus_state-&gt;resume_done[wIndex] = timeout;</span>
<span class="p_add">+				mod_timer(&amp;hcd-&gt;rh_timer, timeout);</span>
<span class="p_add">+			}</span>
<span class="p_add">+		/* Has resume been signalled for USB_RESUME_TIME yet? */</span>
<span class="p_add">+		} else if (time_after_eq(jiffies,</span>
<span class="p_add">+					 bus_state-&gt;resume_done[wIndex])) {</span>
 			int time_left;
 
 			xhci_dbg(xhci, &quot;Resume USB2 port %d\n&quot;,
<span class="p_chunk">@@ -658,19 +680,35 @@</span> <span class="p_context"> static u32 xhci_get_port_status(struct usb_hcd *hcd,</span>
 		} else {
 			/*
 			 * The resume has been signaling for less than
<span class="p_del">-			 * 20ms. Report the port status as SUSPEND,</span>
<span class="p_del">-			 * let the usbcore check port status again</span>
<span class="p_del">-			 * and clear resume signaling later.</span>
<span class="p_add">+			 * USB_RESUME_TIME. Report the port status as SUSPEND,</span>
<span class="p_add">+			 * let the usbcore check port status again and clear</span>
<span class="p_add">+			 * resume signaling later.</span>
 			 */
 			status |= USB_PORT_STAT_SUSPEND;
 		}
 	}
<span class="p_del">-	if ((raw_port_status &amp; PORT_PLS_MASK) == XDEV_U0</span>
<span class="p_del">-			&amp;&amp; (raw_port_status &amp; PORT_POWER)</span>
<span class="p_del">-			&amp;&amp; (bus_state-&gt;suspended_ports &amp; (1 &lt;&lt; wIndex))) {</span>
<span class="p_del">-		bus_state-&gt;suspended_ports &amp;= ~(1 &lt;&lt; wIndex);</span>
<span class="p_del">-		if (hcd-&gt;speed != HCD_USB3)</span>
<span class="p_del">-			bus_state-&gt;port_c_suspend |= 1 &lt;&lt; wIndex;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Clear stale usb2 resume signalling variables in case port changed</span>
<span class="p_add">+	 * state during resume signalling. For example on error</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if ((bus_state-&gt;resume_done[wIndex] ||</span>
<span class="p_add">+	     test_bit(wIndex, &amp;bus_state-&gt;resuming_ports)) &amp;&amp;</span>
<span class="p_add">+	    (raw_port_status &amp; PORT_PLS_MASK) != XDEV_U3 &amp;&amp;</span>
<span class="p_add">+	    (raw_port_status &amp; PORT_PLS_MASK) != XDEV_RESUME) {</span>
<span class="p_add">+		bus_state-&gt;resume_done[wIndex] = 0;</span>
<span class="p_add">+		clear_bit(wIndex, &amp;bus_state-&gt;resuming_ports);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((raw_port_status &amp; PORT_PLS_MASK) == XDEV_U0 &amp;&amp;</span>
<span class="p_add">+	    (raw_port_status &amp; PORT_POWER)) {</span>
<span class="p_add">+		if (bus_state-&gt;suspended_ports &amp; (1 &lt;&lt; wIndex)) {</span>
<span class="p_add">+			bus_state-&gt;suspended_ports &amp;= ~(1 &lt;&lt; wIndex);</span>
<span class="p_add">+			if (hcd-&gt;speed != HCD_USB3)</span>
<span class="p_add">+				bus_state-&gt;port_c_suspend |= 1 &lt;&lt; wIndex;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		bus_state-&gt;resume_done[wIndex] = 0;</span>
<span class="p_add">+		clear_bit(wIndex, &amp;bus_state-&gt;resuming_ports);</span>
 	}
 	if (raw_port_status &amp; PORT_CONNECT) {
 		status |= USB_PORT_STAT_CONNECTION;
<span class="p_chunk">@@ -995,6 +1033,7 @@</span> <span class="p_context"> int xhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,</span>
 				if ((temp &amp; PORT_PE) == 0)
 					goto error;
 
<span class="p_add">+				set_bit(wIndex, &amp;bus_state-&gt;resuming_ports);</span>
 				xhci_set_link_state(xhci, port_array, wIndex,
 							XDEV_RESUME);
 				spin_unlock_irqrestore(&amp;xhci-&gt;lock, flags);
<span class="p_chunk">@@ -1002,6 +1041,7 @@</span> <span class="p_context"> int xhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,</span>
 				spin_lock_irqsave(&amp;xhci-&gt;lock, flags);
 				xhci_set_link_state(xhci, port_array, wIndex,
 							XDEV_U0);
<span class="p_add">+				clear_bit(wIndex, &amp;bus_state-&gt;resuming_ports);</span>
 			}
 			bus_state-&gt;port_c_suspend |= 1 &lt;&lt; wIndex;
 
<span class="p_header">diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">index c47d3e4..c92235a 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-pci.c</span>
<span class="p_chunk">@@ -188,10 +188,14 @@</span> <span class="p_context"> static void xhci_pme_acpi_rtd3_enable(struct pci_dev *dev)</span>
 		0xb7, 0x0c, 0x34, 0xac,	0x01, 0xe9, 0xbf, 0x45,
 		0xb7, 0xe6, 0x2b, 0x34, 0xec, 0x93, 0x1e, 0x23,
 	};
<span class="p_del">-	acpi_evaluate_dsm(ACPI_HANDLE(&amp;dev-&gt;dev), intel_dsm_uuid, 3, 1, NULL);</span>
<span class="p_add">+	union acpi_object *obj;</span>
<span class="p_add">+</span>
<span class="p_add">+	obj = acpi_evaluate_dsm(ACPI_HANDLE(&amp;dev-&gt;dev), intel_dsm_uuid, 3, 1,</span>
<span class="p_add">+				NULL);</span>
<span class="p_add">+	ACPI_FREE(obj);</span>
 }
 #else
<span class="p_del">-	static void xhci_pme_acpi_rtd3_enable(struct pci_dev *dev) { }</span>
<span class="p_add">+static void xhci_pme_acpi_rtd3_enable(struct pci_dev *dev) { }</span>
 #endif /* CONFIG_ACPI */
 
 /* called during probe() after chip reset completes */
<span class="p_header">diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">index 63041c1..ea9690e 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-ring.c</span>
<span class="p_chunk">@@ -1583,7 +1583,8 @@</span> <span class="p_context"> static void handle_port_status(struct xhci_hcd *xhci,</span>
 			 */
 			bogus_port_status = true;
 			goto cleanup;
<span class="p_del">-		} else {</span>
<span class="p_add">+		} else if (!test_bit(faked_port_index,</span>
<span class="p_add">+				     &amp;bus_state-&gt;resuming_ports)) {</span>
 			xhci_dbg(xhci, &quot;resume HS port %d\n&quot;, port_id);
 			bus_state-&gt;resume_done[faked_port_index] = jiffies +
 				msecs_to_jiffies(USB_RESUME_TIMEOUT);
<span class="p_header">diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c</span>
<span class="p_header">index 6062996..b30f55e 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci.c</span>
<span class="p_chunk">@@ -4782,8 +4782,16 @@</span> <span class="p_context"> int xhci_update_hub_device(struct usb_hcd *hcd, struct usb_device *hdev,</span>
 	ctrl_ctx-&gt;add_flags |= cpu_to_le32(SLOT_FLAG);
 	slot_ctx = xhci_get_slot_ctx(xhci, config_cmd-&gt;in_ctx);
 	slot_ctx-&gt;dev_info |= cpu_to_le32(DEV_HUB);
<span class="p_add">+	/*</span>
<span class="p_add">+	 * refer to section 6.2.2: MTT should be 0 for full speed hub,</span>
<span class="p_add">+	 * but it may be already set to 1 when setup an xHCI virtual</span>
<span class="p_add">+	 * device, so clear it anyway.</span>
<span class="p_add">+	 */</span>
 	if (tt-&gt;multi)
 		slot_ctx-&gt;dev_info |= cpu_to_le32(DEV_MTT);
<span class="p_add">+	else if (hdev-&gt;speed == USB_SPEED_FULL)</span>
<span class="p_add">+		slot_ctx-&gt;dev_info &amp;= cpu_to_le32(~DEV_MTT);</span>
<span class="p_add">+</span>
 	if (xhci-&gt;hci_version &gt; 0x95) {
 		xhci_dbg(xhci, &quot;xHCI version %x needs hub &quot;
 				&quot;TT think time and number of ports\n&quot;,
<span class="p_header">diff --git a/drivers/usb/musb/Kconfig b/drivers/usb/musb/Kconfig</span>
<span class="p_header">index 39db8b6..d1b9e0c 100644</span>
<span class="p_header">--- a/drivers/usb/musb/Kconfig</span>
<span class="p_header">+++ b/drivers/usb/musb/Kconfig</span>
<span class="p_chunk">@@ -147,7 +147,7 @@</span> <span class="p_context"> config USB_TI_CPPI_DMA</span>
 
 config USB_TI_CPPI41_DMA
 	bool &#39;TI CPPI 4.1 (AM335x)&#39;
<span class="p_del">-	depends on ARCH_OMAP</span>
<span class="p_add">+	depends on ARCH_OMAP &amp;&amp; DMADEVICES</span>
 	select TI_CPPI41
 
 config USB_TUSB_OMAP_DMA
<span class="p_header">diff --git a/drivers/usb/serial/cp210x.c b/drivers/usb/serial/cp210x.c</span>
<span class="p_header">index eac7cca..7d4f51a 100644</span>
<span class="p_header">--- a/drivers/usb/serial/cp210x.c</span>
<span class="p_header">+++ b/drivers/usb/serial/cp210x.c</span>
<span class="p_chunk">@@ -132,7 +132,6 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{ USB_DEVICE(0x10C4, 0xEA60) }, /* Silicon Labs factory default */
 	{ USB_DEVICE(0x10C4, 0xEA61) }, /* Silicon Labs factory default */
 	{ USB_DEVICE(0x10C4, 0xEA70) }, /* Silicon Labs factory default */
<span class="p_del">-	{ USB_DEVICE(0x10C4, 0xEA80) }, /* Silicon Labs factory default */</span>
 	{ USB_DEVICE(0x10C4, 0xEA71) }, /* Infinity GPS-MIC-1 Radio Monophone */
 	{ USB_DEVICE(0x10C4, 0xF001) }, /* Elan Digital Systems USBscope50 */
 	{ USB_DEVICE(0x10C4, 0xF002) }, /* Elan Digital Systems USBwave12 */
<span class="p_header">diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c</span>
<span class="p_header">index f51a5d5..ec1b8f2 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ipaq.c</span>
<span class="p_header">+++ b/drivers/usb/serial/ipaq.c</span>
<span class="p_chunk">@@ -531,7 +531,8 @@</span> <span class="p_context"> static int ipaq_open(struct tty_struct *tty,</span>
 	 * through. Since this has a reasonably high failure rate, we retry
 	 * several times.
 	 */
<span class="p_del">-	while (retries--) {</span>
<span class="p_add">+	while (retries) {</span>
<span class="p_add">+		retries--;</span>
 		result = usb_control_msg(serial-&gt;dev,
 				usb_sndctrlpipe(serial-&gt;dev, 0), 0x22, 0x21,
 				0x1, 0, NULL, 0, 100);
<span class="p_header">diff --git a/drivers/usb/serial/qcserial.c b/drivers/usb/serial/qcserial.c</span>
<span class="p_header">index 514fa91..293b27a 100644</span>
<span class="p_header">--- a/drivers/usb/serial/qcserial.c</span>
<span class="p_header">+++ b/drivers/usb/serial/qcserial.c</span>
<span class="p_chunk">@@ -216,6 +216,10 @@</span> <span class="p_context"> static int qcprobe(struct usb_serial *serial, const struct usb_device_id *id)</span>
 	if (intf-&gt;desc.bInterfaceClass != USB_CLASS_VENDOR_SPEC)
 		goto done;
 
<span class="p_add">+	/* we only support vendor specific functions */</span>
<span class="p_add">+	if (intf-&gt;desc.bInterfaceClass != USB_CLASS_VENDOR_SPEC)</span>
<span class="p_add">+		goto done;</span>
<span class="p_add">+</span>
 	nintf = serial-&gt;dev-&gt;actconfig-&gt;desc.bNumInterfaces;
 	dev_dbg(dev, &quot;Num Interfaces = %d\n&quot;, nintf);
 	ifnum = intf-&gt;desc.bInterfaceNumber;
<span class="p_header">diff --git a/drivers/usb/serial/usb-serial-simple.c b/drivers/usb/serial/usb-serial-simple.c</span>
<span class="p_header">index 3658662..a204782 100644</span>
<span class="p_header">--- a/drivers/usb/serial/usb-serial-simple.c</span>
<span class="p_header">+++ b/drivers/usb/serial/usb-serial-simple.c</span>
<span class="p_chunk">@@ -53,6 +53,7 @@</span> <span class="p_context"> DEVICE(funsoft, FUNSOFT_IDS);</span>
 
 /* Infineon Flashloader driver */
 #define FLASHLOADER_IDS()		\
<span class="p_add">+	{ USB_DEVICE_INTERFACE_CLASS(0x058b, 0x0041, USB_CLASS_CDC_DATA) }, \</span>
 	{ USB_DEVICE(0x8087, 0x0716) }
 DEVICE(flashloader, FLASHLOADER_IDS);
 
<span class="p_header">diff --git a/drivers/usb/storage/uas.c b/drivers/usb/storage/uas.c</span>
<span class="p_header">index f689219..43b1caf 100644</span>
<span class="p_header">--- a/drivers/usb/storage/uas.c</span>
<span class="p_header">+++ b/drivers/usb/storage/uas.c</span>
<span class="p_chunk">@@ -796,6 +796,10 @@</span> <span class="p_context"> static int uas_slave_configure(struct scsi_device *sdev)</span>
 	if (devinfo-&gt;flags &amp; US_FL_NO_REPORT_OPCODES)
 		sdev-&gt;no_report_opcodes = 1;
 
<span class="p_add">+	/* A few buggy USB-ATA bridges don&#39;t understand FUA */</span>
<span class="p_add">+	if (devinfo-&gt;flags &amp; US_FL_BROKEN_FUA)</span>
<span class="p_add">+		sdev-&gt;broken_fua = 1;</span>
<span class="p_add">+</span>
 	scsi_change_queue_depth(sdev, devinfo-&gt;qdepth - 2);
 	return 0;
 }
<span class="p_header">diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h</span>
<span class="p_header">index 6b24791..7ffe420 100644</span>
<span class="p_header">--- a/drivers/usb/storage/unusual_devs.h</span>
<span class="p_header">+++ b/drivers/usb/storage/unusual_devs.h</span>
<span class="p_chunk">@@ -1987,7 +1987,7 @@</span> <span class="p_context"> UNUSUAL_DEV(  0x14cd, 0x6600, 0x0201, 0x0201,</span>
 		US_FL_IGNORE_RESIDUE ),
 
 /* Reported by Michael Bsch &lt;m@bues.ch&gt; */
<span class="p_del">-UNUSUAL_DEV(  0x152d, 0x0567, 0x0114, 0x0114,</span>
<span class="p_add">+UNUSUAL_DEV(  0x152d, 0x0567, 0x0114, 0x0116,</span>
 		&quot;JMicron&quot;,
 		&quot;USB to ATA/ATAPI Bridge&quot;,
 		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
<span class="p_header">diff --git a/drivers/usb/storage/unusual_uas.h b/drivers/usb/storage/unusual_uas.h</span>
<span class="p_header">index c85ea53..ccc113e 100644</span>
<span class="p_header">--- a/drivers/usb/storage/unusual_uas.h</span>
<span class="p_header">+++ b/drivers/usb/storage/unusual_uas.h</span>
<span class="p_chunk">@@ -132,7 +132,7 @@</span> <span class="p_context"> UNUSUAL_DEV(0x152d, 0x0567, 0x0000, 0x9999,</span>
 		&quot;JMicron&quot;,
 		&quot;JMS567&quot;,
 		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
<span class="p_del">-		US_FL_NO_REPORT_OPCODES),</span>
<span class="p_add">+		US_FL_BROKEN_FUA | US_FL_NO_REPORT_OPCODES),</span>
 
 /* Reported-by: Hans de Goede &lt;hdegoede@redhat.com&gt; */
 UNUSUAL_DEV(0x2109, 0x0711, 0x0000, 0x9999,
<span class="p_header">diff --git a/drivers/vhost/vhost.c b/drivers/vhost/vhost.c</span>
<span class="p_header">index eec2f11..080422f 100644</span>
<span class="p_header">--- a/drivers/vhost/vhost.c</span>
<span class="p_header">+++ b/drivers/vhost/vhost.c</span>
<span class="p_chunk">@@ -819,7 +819,7 @@</span> <span class="p_context"> long vhost_vring_ioctl(struct vhost_dev *d, int ioctl, void __user *argp)</span>
 		BUILD_BUG_ON(__alignof__ *vq-&gt;used &gt; VRING_USED_ALIGN_SIZE);
 		if ((a.avail_user_addr &amp; (VRING_AVAIL_ALIGN_SIZE - 1)) ||
 		    (a.used_user_addr &amp; (VRING_USED_ALIGN_SIZE - 1)) ||
<span class="p_del">-		    (a.log_guest_addr &amp; (sizeof(u64) - 1))) {</span>
<span class="p_add">+		    (a.log_guest_addr &amp; (VRING_USED_ALIGN_SIZE - 1))) {</span>
 			r = -EINVAL;
 			break;
 		}
<span class="p_header">diff --git a/drivers/video/fbdev/fsl-diu-fb.c b/drivers/video/fbdev/fsl-diu-fb.c</span>
<span class="p_header">index 7fa2e6f..2a1fde6 100644</span>
<span class="p_header">--- a/drivers/video/fbdev/fsl-diu-fb.c</span>
<span class="p_header">+++ b/drivers/video/fbdev/fsl-diu-fb.c</span>
<span class="p_chunk">@@ -479,7 +479,10 @@</span> <span class="p_context"> static enum fsl_diu_monitor_port fsl_diu_name_to_port(const char *s)</span>
 			port = FSL_DIU_PORT_DLVDS;
 	}
 
<span class="p_del">-	return diu_ops.valid_monitor_port(port);</span>
<span class="p_add">+	if (diu_ops.valid_monitor_port)</span>
<span class="p_add">+		port = diu_ops.valid_monitor_port(port);</span>
<span class="p_add">+</span>
<span class="p_add">+	return port;</span>
 }
 
 /*
<span class="p_chunk">@@ -1908,6 +1911,14 @@</span> <span class="p_context"> static int __init fsl_diu_init(void)</span>
 #else
 	monitor_port = fsl_diu_name_to_port(monitor_string);
 #endif
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Must to verify set_pixel_clock. If not implement on platform,</span>
<span class="p_add">+	 * then that means that there is no platform support for the DIU.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!diu_ops.set_pixel_clock)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	pr_info(&quot;Freescale Display Interface Unit (DIU) framebuffer driver\n&quot;);
 
 #ifdef CONFIG_NOT_COHERENT_CACHE
<span class="p_header">diff --git a/drivers/virtio/virtio.c b/drivers/virtio/virtio.c</span>
<span class="p_header">index b1877d7..7062bb0 100644</span>
<span class="p_header">--- a/drivers/virtio/virtio.c</span>
<span class="p_header">+++ b/drivers/virtio/virtio.c</span>
<span class="p_chunk">@@ -412,6 +412,7 @@</span> <span class="p_context"> static int virtio_init(void)</span>
 static void __exit virtio_exit(void)
 {
 	bus_unregister(&amp;virtio_bus);
<span class="p_add">+	ida_destroy(&amp;virtio_index_ida);</span>
 }
 core_initcall(virtio_init);
 module_exit(virtio_exit);
<span class="p_header">diff --git a/drivers/watchdog/omap_wdt.c b/drivers/watchdog/omap_wdt.c</span>
<span class="p_header">index de911c7..7abd698 100644</span>
<span class="p_header">--- a/drivers/watchdog/omap_wdt.c</span>
<span class="p_header">+++ b/drivers/watchdog/omap_wdt.c</span>
<span class="p_chunk">@@ -205,7 +205,7 @@</span> <span class="p_context"> static int omap_wdt_set_timeout(struct watchdog_device *wdog,</span>
 
 static unsigned int omap_wdt_get_timeleft(struct watchdog_device *wdog)
 {
<span class="p_del">-	struct omap_wdt_dev *wdev = watchdog_get_drvdata(wdog);</span>
<span class="p_add">+	struct omap_wdt_dev *wdev = to_omap_wdt_dev(wdog);</span>
 	void __iomem *base = wdev-&gt;base;
 	u32 value;
 
<span class="p_header">diff --git a/drivers/xen/events/events_fifo.c b/drivers/xen/events/events_fifo.c</span>
<span class="p_header">index ed673e1..b14545e 100644</span>
<span class="p_header">--- a/drivers/xen/events/events_fifo.c</span>
<span class="p_header">+++ b/drivers/xen/events/events_fifo.c</span>
<span class="p_chunk">@@ -281,7 +281,8 @@</span> <span class="p_context"> static void handle_irq_for_port(unsigned port)</span>
 
 static void consume_one_event(unsigned cpu,
 			      struct evtchn_fifo_control_block *control_block,
<span class="p_del">-			      unsigned priority, unsigned long *ready)</span>
<span class="p_add">+			      unsigned priority, unsigned long *ready,</span>
<span class="p_add">+			      bool drop)</span>
 {
 	struct evtchn_fifo_queue *q = &amp;per_cpu(cpu_queue, cpu);
 	uint32_t head;
<span class="p_chunk">@@ -313,13 +314,17 @@</span> <span class="p_context"> static void consume_one_event(unsigned cpu,</span>
 	if (head == 0)
 		clear_bit(priority, ready);
 
<span class="p_del">-	if (evtchn_fifo_is_pending(port) &amp;&amp; !evtchn_fifo_is_masked(port))</span>
<span class="p_del">-		handle_irq_for_port(port);</span>
<span class="p_add">+	if (evtchn_fifo_is_pending(port) &amp;&amp; !evtchn_fifo_is_masked(port)) {</span>
<span class="p_add">+		if (unlikely(drop))</span>
<span class="p_add">+			pr_warn(&quot;Dropping pending event for port %u\n&quot;, port);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			handle_irq_for_port(port);</span>
<span class="p_add">+	}</span>
 
 	q-&gt;head[priority] = head;
 }
 
<span class="p_del">-static void evtchn_fifo_handle_events(unsigned cpu)</span>
<span class="p_add">+static void __evtchn_fifo_handle_events(unsigned cpu, bool drop)</span>
 {
 	struct evtchn_fifo_control_block *control_block;
 	unsigned long ready;
<span class="p_chunk">@@ -331,11 +336,16 @@</span> <span class="p_context"> static void evtchn_fifo_handle_events(unsigned cpu)</span>
 
 	while (ready) {
 		q = find_first_bit(&amp;ready, EVTCHN_FIFO_MAX_QUEUES);
<span class="p_del">-		consume_one_event(cpu, control_block, q, &amp;ready);</span>
<span class="p_add">+		consume_one_event(cpu, control_block, q, &amp;ready, drop);</span>
 		ready |= xchg(&amp;control_block-&gt;ready, 0);
 	}
 }
 
<span class="p_add">+static void evtchn_fifo_handle_events(unsigned cpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	__evtchn_fifo_handle_events(cpu, false);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void evtchn_fifo_resume(void)
 {
 	unsigned cpu;
<span class="p_chunk">@@ -420,6 +430,9 @@</span> <span class="p_context"> static int evtchn_fifo_cpu_notification(struct notifier_block *self,</span>
 		if (!per_cpu(cpu_control_block, cpu))
 			ret = evtchn_fifo_alloc_control_block(cpu);
 		break;
<span class="p_add">+	case CPU_DEAD:</span>
<span class="p_add">+		__evtchn_fifo_handle_events(cpu, true);</span>
<span class="p_add">+		break;</span>
 	default:
 		break;
 	}
<span class="p_header">diff --git a/drivers/xen/gntdev.c b/drivers/xen/gntdev.c</span>
<span class="p_header">index 0dbb222..3dcc16e 100644</span>
<span class="p_header">--- a/drivers/xen/gntdev.c</span>
<span class="p_header">+++ b/drivers/xen/gntdev.c</span>
<span class="p_chunk">@@ -804,7 +804,7 @@</span> <span class="p_context"> static int gntdev_mmap(struct file *flip, struct vm_area_struct *vma)</span>
 
 	vma-&gt;vm_ops = &amp;gntdev_vmops;
 
<span class="p_del">-	vma-&gt;vm_flags |= VM_DONTEXPAND | VM_DONTDUMP;</span>
<span class="p_add">+	vma-&gt;vm_flags |= VM_DONTEXPAND | VM_DONTDUMP | VM_IO;</span>
 
 	if (use_ptemod)
 		vma-&gt;vm_flags |= VM_DONTCOPY;
<span class="p_header">diff --git a/drivers/xen/xen-pciback/pciback.h b/drivers/xen/xen-pciback/pciback.h</span>
<span class="p_header">index 58e38d5..4d529f3 100644</span>
<span class="p_header">--- a/drivers/xen/xen-pciback/pciback.h</span>
<span class="p_header">+++ b/drivers/xen/xen-pciback/pciback.h</span>
<span class="p_chunk">@@ -37,6 +37,7 @@</span> <span class="p_context"> struct xen_pcibk_device {</span>
 	struct xen_pci_sharedinfo *sh_info;
 	unsigned long flags;
 	struct work_struct op_work;
<span class="p_add">+	struct xen_pci_op op;</span>
 };
 
 struct xen_pcibk_dev_data {
<span class="p_header">diff --git a/drivers/xen/xen-pciback/pciback_ops.c b/drivers/xen/xen-pciback/pciback_ops.c</span>
<span class="p_header">index c4a0666..73dafdc 100644</span>
<span class="p_header">--- a/drivers/xen/xen-pciback/pciback_ops.c</span>
<span class="p_header">+++ b/drivers/xen/xen-pciback/pciback_ops.c</span>
<span class="p_chunk">@@ -70,6 +70,13 @@</span> <span class="p_context"> static void xen_pcibk_control_isr(struct pci_dev *dev, int reset)</span>
 		enable ? &quot;enable&quot; : &quot;disable&quot;);
 
 	if (enable) {
<span class="p_add">+		/*</span>
<span class="p_add">+		 * The MSI or MSI-X should not have an IRQ handler. Otherwise</span>
<span class="p_add">+		 * if the guest terminates we BUG_ON in free_msi_irqs.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (dev-&gt;msi_enabled || dev-&gt;msix_enabled)</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+</span>
 		rc = request_irq(dev_data-&gt;irq,
 				xen_pcibk_guest_interrupt, IRQF_SHARED,
 				dev_data-&gt;irq_name, dev);
<span class="p_chunk">@@ -144,7 +151,12 @@</span> <span class="p_context"> int xen_pcibk_enable_msi(struct xen_pcibk_device *pdev,</span>
 	if (unlikely(verbose_request))
 		printk(KERN_DEBUG DRV_NAME &quot;: %s: enable MSI\n&quot;, pci_name(dev));
 
<span class="p_del">-	status = pci_enable_msi(dev);</span>
<span class="p_add">+	if (dev-&gt;msi_enabled)</span>
<span class="p_add">+		status = -EALREADY;</span>
<span class="p_add">+	else if (dev-&gt;msix_enabled)</span>
<span class="p_add">+		status = -ENXIO;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		status = pci_enable_msi(dev);</span>
 
 	if (status) {
 		pr_warn_ratelimited(&quot;%s: error enabling MSI for guest %u: err %d\n&quot;,
<span class="p_chunk">@@ -173,20 +185,23 @@</span> <span class="p_context"> static</span>
 int xen_pcibk_disable_msi(struct xen_pcibk_device *pdev,
 			  struct pci_dev *dev, struct xen_pci_op *op)
 {
<span class="p_del">-	struct xen_pcibk_dev_data *dev_data;</span>
<span class="p_del">-</span>
 	if (unlikely(verbose_request))
 		printk(KERN_DEBUG DRV_NAME &quot;: %s: disable MSI\n&quot;,
 		       pci_name(dev));
<span class="p_del">-	pci_disable_msi(dev);</span>
 
<span class="p_add">+	if (dev-&gt;msi_enabled) {</span>
<span class="p_add">+		struct xen_pcibk_dev_data *dev_data;</span>
<span class="p_add">+</span>
<span class="p_add">+		pci_disable_msi(dev);</span>
<span class="p_add">+</span>
<span class="p_add">+		dev_data = pci_get_drvdata(dev);</span>
<span class="p_add">+		if (dev_data)</span>
<span class="p_add">+			dev_data-&gt;ack_intr = 1;</span>
<span class="p_add">+	}</span>
 	op-&gt;value = dev-&gt;irq ? xen_pirq_from_irq(dev-&gt;irq) : 0;
 	if (unlikely(verbose_request))
 		printk(KERN_DEBUG DRV_NAME &quot;: %s: MSI: %d\n&quot;, pci_name(dev),
 			op-&gt;value);
<span class="p_del">-	dev_data = pci_get_drvdata(dev);</span>
<span class="p_del">-	if (dev_data)</span>
<span class="p_del">-		dev_data-&gt;ack_intr = 1;</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -197,13 +212,26 @@</span> <span class="p_context"> int xen_pcibk_enable_msix(struct xen_pcibk_device *pdev,</span>
 	struct xen_pcibk_dev_data *dev_data;
 	int i, result;
 	struct msix_entry *entries;
<span class="p_add">+	u16 cmd;</span>
 
 	if (unlikely(verbose_request))
 		printk(KERN_DEBUG DRV_NAME &quot;: %s: enable MSI-X\n&quot;,
 		       pci_name(dev));
<span class="p_add">+</span>
 	if (op-&gt;value &gt; SH_INFO_MAX_VEC)
 		return -EINVAL;
 
<span class="p_add">+	if (dev-&gt;msix_enabled)</span>
<span class="p_add">+		return -EALREADY;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * PCI_COMMAND_MEMORY must be enabled, otherwise we may not be able</span>
<span class="p_add">+	 * to access the BARs where the MSI-X entries reside.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	pci_read_config_word(dev, PCI_COMMAND, &amp;cmd);</span>
<span class="p_add">+	if (dev-&gt;msi_enabled || !(cmd &amp; PCI_COMMAND_MEMORY))</span>
<span class="p_add">+		return -ENXIO;</span>
<span class="p_add">+</span>
 	entries = kmalloc(op-&gt;value * sizeof(*entries), GFP_KERNEL);
 	if (entries == NULL)
 		return -ENOMEM;
<span class="p_chunk">@@ -245,23 +273,27 @@</span> <span class="p_context"> static</span>
 int xen_pcibk_disable_msix(struct xen_pcibk_device *pdev,
 			   struct pci_dev *dev, struct xen_pci_op *op)
 {
<span class="p_del">-	struct xen_pcibk_dev_data *dev_data;</span>
 	if (unlikely(verbose_request))
 		printk(KERN_DEBUG DRV_NAME &quot;: %s: disable MSI-X\n&quot;,
 			pci_name(dev));
<span class="p_del">-	pci_disable_msix(dev);</span>
 
<span class="p_add">+	if (dev-&gt;msix_enabled) {</span>
<span class="p_add">+		struct xen_pcibk_dev_data *dev_data;</span>
<span class="p_add">+</span>
<span class="p_add">+		pci_disable_msix(dev);</span>
<span class="p_add">+</span>
<span class="p_add">+		dev_data = pci_get_drvdata(dev);</span>
<span class="p_add">+		if (dev_data)</span>
<span class="p_add">+			dev_data-&gt;ack_intr = 1;</span>
<span class="p_add">+	}</span>
 	/*
 	 * SR-IOV devices (which don&#39;t have any legacy IRQ) have
 	 * an undefined IRQ value of zero.
 	 */
 	op-&gt;value = dev-&gt;irq ? xen_pirq_from_irq(dev-&gt;irq) : 0;
 	if (unlikely(verbose_request))
<span class="p_del">-		printk(KERN_DEBUG DRV_NAME &quot;: %s: MSI-X: %d\n&quot;, pci_name(dev),</span>
<span class="p_del">-			op-&gt;value);</span>
<span class="p_del">-	dev_data = pci_get_drvdata(dev);</span>
<span class="p_del">-	if (dev_data)</span>
<span class="p_del">-		dev_data-&gt;ack_intr = 1;</span>
<span class="p_add">+		printk(KERN_DEBUG DRV_NAME &quot;: %s: MSI-X: %d\n&quot;,</span>
<span class="p_add">+		       pci_name(dev), op-&gt;value);</span>
 	return 0;
 }
 #endif
<span class="p_chunk">@@ -298,9 +330,11 @@</span> <span class="p_context"> void xen_pcibk_do_op(struct work_struct *data)</span>
 		container_of(data, struct xen_pcibk_device, op_work);
 	struct pci_dev *dev;
 	struct xen_pcibk_dev_data *dev_data = NULL;
<span class="p_del">-	struct xen_pci_op *op = &amp;pdev-&gt;sh_info-&gt;op;</span>
<span class="p_add">+	struct xen_pci_op *op = &amp;pdev-&gt;op;</span>
 	int test_intx = 0;
 
<span class="p_add">+	*op = pdev-&gt;sh_info-&gt;op;</span>
<span class="p_add">+	barrier();</span>
 	dev = xen_pcibk_get_pci_dev(pdev, op-&gt;domain, op-&gt;bus, op-&gt;devfn);
 
 	if (dev == NULL)
<span class="p_chunk">@@ -342,6 +376,17 @@</span> <span class="p_context"> void xen_pcibk_do_op(struct work_struct *data)</span>
 		if ((dev_data-&gt;enable_intx != test_intx))
 			xen_pcibk_control_isr(dev, 0 /* no reset */);
 	}
<span class="p_add">+	pdev-&gt;sh_info-&gt;op.err = op-&gt;err;</span>
<span class="p_add">+	pdev-&gt;sh_info-&gt;op.value = op-&gt;value;</span>
<span class="p_add">+#ifdef CONFIG_PCI_MSI</span>
<span class="p_add">+	if (op-&gt;cmd == XEN_PCI_OP_enable_msix &amp;&amp; op-&gt;err == 0) {</span>
<span class="p_add">+		unsigned int i;</span>
<span class="p_add">+</span>
<span class="p_add">+		for (i = 0; i &lt; op-&gt;value; i++)</span>
<span class="p_add">+			pdev-&gt;sh_info-&gt;op.msix_entries[i].vector =</span>
<span class="p_add">+				op-&gt;msix_entries[i].vector;</span>
<span class="p_add">+	}</span>
<span class="p_add">+#endif</span>
 	/* Tell the driver domain that we&#39;re done. */
 	wmb();
 	clear_bit(_XEN_PCIF_active, (unsigned long *)&amp;pdev-&gt;sh_info-&gt;flags);
<span class="p_header">diff --git a/drivers/xen/xen-scsiback.c b/drivers/xen/xen-scsiback.c</span>
<span class="p_header">index 9eeefd7..2af9aa8 100644</span>
<span class="p_header">--- a/drivers/xen/xen-scsiback.c</span>
<span class="p_header">+++ b/drivers/xen/xen-scsiback.c</span>
<span class="p_chunk">@@ -727,7 +727,7 @@</span> <span class="p_context"> static int scsiback_do_cmd_fn(struct vscsibk_info *info)</span>
 		if (!pending_req)
 			return 1;
 
<span class="p_del">-		ring_req = *RING_GET_REQUEST(ring, rc);</span>
<span class="p_add">+		RING_COPY_REQUEST(ring, rc, &amp;ring_req);</span>
 		ring-&gt;req_cons = ++rc;
 
 		err = prepare_pending_reqs(info, &amp;ring_req, pending_req);
<span class="p_header">diff --git a/fs/9p/vfs_inode.c b/fs/9p/vfs_inode.c</span>
<span class="p_header">index b1dc518..2f97461 100644</span>
<span class="p_header">--- a/fs/9p/vfs_inode.c</span>
<span class="p_header">+++ b/fs/9p/vfs_inode.c</span>
<span class="p_chunk">@@ -451,9 +451,9 @@</span> <span class="p_context"> void v9fs_evict_inode(struct inode *inode)</span>
 {
 	struct v9fs_inode *v9inode = V9FS_I(inode);
 
<span class="p_del">-	truncate_inode_pages_final(inode-&gt;i_mapping);</span>
<span class="p_add">+	truncate_inode_pages_final(&amp;inode-&gt;i_data);</span>
 	clear_inode(inode);
<span class="p_del">-	filemap_fdatawrite(inode-&gt;i_mapping);</span>
<span class="p_add">+	filemap_fdatawrite(&amp;inode-&gt;i_data);</span>
 
 	v9fs_cache_inode_put_cookie(inode);
 	/* clunk the fid stashed in writeback_fid */
<span class="p_header">diff --git a/fs/block_dev.c b/fs/block_dev.c</span>
<span class="p_header">index 1170f8c..426b30f 100644</span>
<span class="p_header">--- a/fs/block_dev.c</span>
<span class="p_header">+++ b/fs/block_dev.c</span>
<span class="p_chunk">@@ -1499,11 +1499,14 @@</span> <span class="p_context"> static void __blkdev_put(struct block_device *bdev, fmode_t mode, int for_part)</span>
 		WARN_ON_ONCE(bdev-&gt;bd_holders);
 		sync_blockdev(bdev);
 		kill_bdev(bdev);
<span class="p_add">+</span>
<span class="p_add">+		bdev_write_inode(bdev-&gt;bd_inode);</span>
 		/*
<span class="p_del">-		 * -&gt;release can cause the queue to disappear, so flush all</span>
<span class="p_del">-		 * dirty data before.</span>
<span class="p_add">+		 * Detaching bdev inode from its wb in __destroy_inode()</span>
<span class="p_add">+		 * is too late: the queue which embeds its bdi (along with</span>
<span class="p_add">+		 * root wb) can be gone as soon as we put_disk() below.</span>
 		 */
<span class="p_del">-		bdev_write_inode(bdev-&gt;bd_inode);</span>
<span class="p_add">+		inode_detach_wb(bdev-&gt;bd_inode);</span>
 	}
 	if (bdev-&gt;bd_contains == bdev) {
 		if (disk-&gt;fops-&gt;release)
<span class="p_header">diff --git a/fs/cachefiles/rdwr.c b/fs/cachefiles/rdwr.c</span>
<span class="p_header">index e62faae..3ce6467 100644</span>
<span class="p_header">--- a/fs/cachefiles/rdwr.c</span>
<span class="p_header">+++ b/fs/cachefiles/rdwr.c</span>
<span class="p_chunk">@@ -885,7 +885,7 @@</span> <span class="p_context"> int cachefiles_write_page(struct fscache_storage *op, struct page *page)</span>
 	loff_t pos, eof;
 	size_t len;
 	void *data;
<span class="p_del">-	int ret;</span>
<span class="p_add">+	int ret = -ENOBUFS;</span>
 
 	ASSERT(op != NULL);
 	ASSERT(page != NULL);
<span class="p_header">diff --git a/fs/cifs/inode.c b/fs/cifs/inode.c</span>
<span class="p_header">index 6b66dd5..a329f5b 100644</span>
<span class="p_header">--- a/fs/cifs/inode.c</span>
<span class="p_header">+++ b/fs/cifs/inode.c</span>
<span class="p_chunk">@@ -1831,11 +1831,11 @@</span> <span class="p_context"> cifs_invalidate_mapping(struct inode *inode)</span>
  * @word: long word containing the bit lock
  */
 static int
<span class="p_del">-cifs_wait_bit_killable(struct wait_bit_key *key)</span>
<span class="p_add">+cifs_wait_bit_killable(struct wait_bit_key *key, int mode)</span>
 {
<span class="p_del">-	if (fatal_signal_pending(current))</span>
<span class="p_del">-		return -ERESTARTSYS;</span>
 	freezable_schedule_unsafe();
<span class="p_add">+	if (signal_pending_state(mode, current))</span>
<span class="p_add">+		return -ERESTARTSYS;</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/fs/direct-io.c b/fs/direct-io.c</span>
<span class="p_header">index 745d234..d83a021 100644</span>
<span class="p_header">--- a/fs/direct-io.c</span>
<span class="p_header">+++ b/fs/direct-io.c</span>
<span class="p_chunk">@@ -1159,6 +1159,16 @@</span> <span class="p_context"> do_blockdev_direct_IO(struct kiocb *iocb, struct inode *inode,</span>
 		}
 	}
 
<span class="p_add">+	/* Once we sampled i_size check for reads beyond EOF */</span>
<span class="p_add">+	dio-&gt;i_size = i_size_read(inode);</span>
<span class="p_add">+	if (iov_iter_rw(iter) == READ &amp;&amp; offset &gt;= dio-&gt;i_size) {</span>
<span class="p_add">+		if (dio-&gt;flags &amp; DIO_LOCKING)</span>
<span class="p_add">+			mutex_unlock(&amp;inode-&gt;i_mutex);</span>
<span class="p_add">+		kmem_cache_free(dio_cache, dio);</span>
<span class="p_add">+		retval = 0;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/*
 	 * For file extending writes updating i_size before data writeouts
 	 * complete can expose uninitialized blocks in dumb filesystems.
<span class="p_chunk">@@ -1212,7 +1222,6 @@</span> <span class="p_context"> do_blockdev_direct_IO(struct kiocb *iocb, struct inode *inode,</span>
 	sdio.next_block_for_io = -1;
 
 	dio-&gt;iocb = iocb;
<span class="p_del">-	dio-&gt;i_size = i_size_read(inode);</span>
 
 	spin_lock_init(&amp;dio-&gt;bio_lock);
 	dio-&gt;refcount = 1;
<span class="p_header">diff --git a/fs/ext2/super.c b/fs/ext2/super.c</span>
<span class="p_header">index 900e19c..2597b06 100644</span>
<span class="p_header">--- a/fs/ext2/super.c</span>
<span class="p_header">+++ b/fs/ext2/super.c</span>
<span class="p_chunk">@@ -566,6 +566,8 @@</span> <span class="p_context"> static int parse_options(char *options, struct super_block *sb)</span>
 			/* Fall through */
 		case Opt_dax:
 #ifdef CONFIG_FS_DAX
<span class="p_add">+			ext2_msg(sb, KERN_WARNING,</span>
<span class="p_add">+		&quot;DAX enabled. Warning: EXPERIMENTAL, use at your own risk&quot;);</span>
 			set_opt(sbi-&gt;s_mount_opt, DAX);
 #else
 			ext2_msg(sb, KERN_INFO, &quot;dax option not supported&quot;);
<span class="p_header">diff --git a/fs/ext4/crypto.c b/fs/ext4/crypto.c</span>
<span class="p_header">index 54a5169..b44c4e5 100644</span>
<span class="p_header">--- a/fs/ext4/crypto.c</span>
<span class="p_header">+++ b/fs/ext4/crypto.c</span>
<span class="p_chunk">@@ -407,7 +407,7 @@</span> <span class="p_context"> int ext4_encrypted_zeroout(struct inode *inode, struct ext4_extent *ex)</span>
 	struct ext4_crypto_ctx	*ctx;
 	struct page		*ciphertext_page = NULL;
 	struct bio		*bio;
<span class="p_del">-	ext4_lblk_t		lblk = ex-&gt;ee_block;</span>
<span class="p_add">+	ext4_lblk_t		lblk = le32_to_cpu(ex-&gt;ee_block);</span>
 	ext4_fsblk_t		pblk = ext4_ext_pblock(ex);
 	unsigned int		len = ext4_ext_get_actual_len(ex);
 	int			err = 0;
<span class="p_header">diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h</span>
<span class="p_header">index f5e9f04..de57be0 100644</span>
<span class="p_header">--- a/fs/ext4/ext4.h</span>
<span class="p_header">+++ b/fs/ext4/ext4.h</span>
<span class="p_chunk">@@ -26,6 +26,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/seqlock.h&gt;
 #include &lt;linux/mutex.h&gt;
 #include &lt;linux/timer.h&gt;
<span class="p_add">+#include &lt;linux/version.h&gt;</span>
 #include &lt;linux/wait.h&gt;
 #include &lt;linux/blockgroup_lock.h&gt;
 #include &lt;linux/percpu_counter.h&gt;
<span class="p_chunk">@@ -723,19 +724,55 @@</span> <span class="p_context"> struct move_extent {</span>
 	&lt;= (EXT4_GOOD_OLD_INODE_SIZE +			\
 	    (einode)-&gt;i_extra_isize))			\
 
<span class="p_add">+/*</span>
<span class="p_add">+ * We use an encoding that preserves the times for extra epoch &quot;00&quot;:</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * extra  msb of                         adjust for signed</span>
<span class="p_add">+ * epoch  32-bit                         32-bit tv_sec to</span>
<span class="p_add">+ * bits   time    decoded 64-bit tv_sec  64-bit tv_sec      valid time range</span>
<span class="p_add">+ * 0 0    1    -0x80000000..-0x00000001  0x000000000 1901-12-13..1969-12-31</span>
<span class="p_add">+ * 0 0    0    0x000000000..0x07fffffff  0x000000000 1970-01-01..2038-01-19</span>
<span class="p_add">+ * 0 1    1    0x080000000..0x0ffffffff  0x100000000 2038-01-19..2106-02-07</span>
<span class="p_add">+ * 0 1    0    0x100000000..0x17fffffff  0x100000000 2106-02-07..2174-02-25</span>
<span class="p_add">+ * 1 0    1    0x180000000..0x1ffffffff  0x200000000 2174-02-25..2242-03-16</span>
<span class="p_add">+ * 1 0    0    0x200000000..0x27fffffff  0x200000000 2242-03-16..2310-04-04</span>
<span class="p_add">+ * 1 1    1    0x280000000..0x2ffffffff  0x300000000 2310-04-04..2378-04-22</span>
<span class="p_add">+ * 1 1    0    0x300000000..0x37fffffff  0x300000000 2378-04-22..2446-05-10</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Note that previous versions of the kernel on 64-bit systems would</span>
<span class="p_add">+ * incorrectly use extra epoch bits 1,1 for dates between 1901 and</span>
<span class="p_add">+ * 1970.  e2fsck will correct this, assuming that it is run on the</span>
<span class="p_add">+ * affected filesystem before 2242.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
 static inline __le32 ext4_encode_extra_time(struct timespec *time)
 {
<span class="p_del">-       return cpu_to_le32((sizeof(time-&gt;tv_sec) &gt; 4 ?</span>
<span class="p_del">-			   (time-&gt;tv_sec &gt;&gt; 32) &amp; EXT4_EPOCH_MASK : 0) |</span>
<span class="p_del">-                          ((time-&gt;tv_nsec &lt;&lt; EXT4_EPOCH_BITS) &amp; EXT4_NSEC_MASK));</span>
<span class="p_add">+	u32 extra = sizeof(time-&gt;tv_sec) &gt; 4 ?</span>
<span class="p_add">+		((time-&gt;tv_sec - (s32)time-&gt;tv_sec) &gt;&gt; 32) &amp; EXT4_EPOCH_MASK : 0;</span>
<span class="p_add">+	return cpu_to_le32(extra | (time-&gt;tv_nsec &lt;&lt; EXT4_EPOCH_BITS));</span>
 }
 
 static inline void ext4_decode_extra_time(struct timespec *time, __le32 extra)
 {
<span class="p_del">-       if (sizeof(time-&gt;tv_sec) &gt; 4)</span>
<span class="p_del">-	       time-&gt;tv_sec |= (__u64)(le32_to_cpu(extra) &amp; EXT4_EPOCH_MASK)</span>
<span class="p_del">-			       &lt;&lt; 32;</span>
<span class="p_del">-       time-&gt;tv_nsec = (le32_to_cpu(extra) &amp; EXT4_NSEC_MASK) &gt;&gt; EXT4_EPOCH_BITS;</span>
<span class="p_add">+	if (unlikely(sizeof(time-&gt;tv_sec) &gt; 4 &amp;&amp;</span>
<span class="p_add">+			(extra &amp; cpu_to_le32(EXT4_EPOCH_MASK)))) {</span>
<span class="p_add">+#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(4,20,0)</span>
<span class="p_add">+		/* Handle legacy encoding of pre-1970 dates with epoch</span>
<span class="p_add">+		 * bits 1,1.  We assume that by kernel version 4.20,</span>
<span class="p_add">+		 * everyone will have run fsck over the affected</span>
<span class="p_add">+		 * filesystems to correct the problem.  (This</span>
<span class="p_add">+		 * backwards compatibility may be removed before this</span>
<span class="p_add">+		 * time, at the discretion of the ext4 developers.)</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		u64 extra_bits = le32_to_cpu(extra) &amp; EXT4_EPOCH_MASK;</span>
<span class="p_add">+		if (extra_bits == 3 &amp;&amp; ((time-&gt;tv_sec) &amp; 0x80000000) != 0)</span>
<span class="p_add">+			extra_bits = 0;</span>
<span class="p_add">+		time-&gt;tv_sec += extra_bits &lt;&lt; 32;</span>
<span class="p_add">+#else</span>
<span class="p_add">+		time-&gt;tv_sec += (u64)(le32_to_cpu(extra) &amp; EXT4_EPOCH_MASK) &lt;&lt; 32;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	}</span>
<span class="p_add">+	time-&gt;tv_nsec = (le32_to_cpu(extra) &amp; EXT4_NSEC_MASK) &gt;&gt; EXT4_EPOCH_BITS;</span>
 }
 
 #define EXT4_INODE_SET_XTIME(xtime, inode, raw_inode)			       \
<span class="p_header">diff --git a/fs/ext4/super.c b/fs/ext4/super.c</span>
<span class="p_header">index bc24d1b..b22d844 100644</span>
<span class="p_header">--- a/fs/ext4/super.c</span>
<span class="p_header">+++ b/fs/ext4/super.c</span>
<span class="p_chunk">@@ -1667,8 +1667,12 @@</span> <span class="p_context"> static int handle_mount_opt(struct super_block *sb, char *opt, int token,</span>
 		}
 		sbi-&gt;s_jquota_fmt = m-&gt;mount_opt;
 #endif
<span class="p_del">-#ifndef CONFIG_FS_DAX</span>
 	} else if (token == Opt_dax) {
<span class="p_add">+#ifdef CONFIG_FS_DAX</span>
<span class="p_add">+		ext4_msg(sb, KERN_WARNING,</span>
<span class="p_add">+		&quot;DAX enabled. Warning: EXPERIMENTAL, use at your own risk&quot;);</span>
<span class="p_add">+			sbi-&gt;s_mount_opt |= m-&gt;mount_opt;</span>
<span class="p_add">+#else</span>
 		ext4_msg(sb, KERN_INFO, &quot;dax option not supported&quot;);
 		return -1;
 #endif
<span class="p_header">diff --git a/fs/ext4/symlink.c b/fs/ext4/symlink.c</span>
<span class="p_header">index c677f2c..3627fd7 100644</span>
<span class="p_header">--- a/fs/ext4/symlink.c</span>
<span class="p_header">+++ b/fs/ext4/symlink.c</span>
<span class="p_chunk">@@ -52,7 +52,7 @@</span> <span class="p_context"> static const char *ext4_encrypted_follow_link(struct dentry *dentry, void **cook</span>
 	/* Symlink is encrypted */
 	sd = (struct ext4_encrypted_symlink_data *)caddr;
 	cstr.name = sd-&gt;encrypted_path;
<span class="p_del">-	cstr.len  = le32_to_cpu(sd-&gt;len);</span>
<span class="p_add">+	cstr.len  = le16_to_cpu(sd-&gt;len);</span>
 	if ((cstr.len +
 	     sizeof(struct ext4_encrypted_symlink_data) - 1) &gt;
 	    max_size) {
<span class="p_header">diff --git a/fs/fat/dir.c b/fs/fat/dir.c</span>
<span class="p_header">index 4afc4d9..8b2127f 100644</span>
<span class="p_header">--- a/fs/fat/dir.c</span>
<span class="p_header">+++ b/fs/fat/dir.c</span>
<span class="p_chunk">@@ -610,9 +610,9 @@</span> <span class="p_context"> parse_record:</span>
 		int status = fat_parse_long(inode, &amp;cpos, &amp;bh, &amp;de,
 					    &amp;unicode, &amp;nr_slots);
 		if (status &lt; 0) {
<span class="p_del">-			ctx-&gt;pos = cpos;</span>
<span class="p_add">+			bh = NULL;</span>
 			ret = status;
<span class="p_del">-			goto out;</span>
<span class="p_add">+			goto end_of_dir;</span>
 		} else if (status == PARSE_INVALID)
 			goto record_end;
 		else if (status == PARSE_NOT_LONGNAME)
<span class="p_chunk">@@ -654,8 +654,9 @@</span> <span class="p_context"> parse_record:</span>
 	fill_len = short_len;
 
 start_filldir:
<span class="p_del">-	if (!fake_offset)</span>
<span class="p_del">-		ctx-&gt;pos = cpos - (nr_slots + 1) * sizeof(struct msdos_dir_entry);</span>
<span class="p_add">+	ctx-&gt;pos = cpos - (nr_slots + 1) * sizeof(struct msdos_dir_entry);</span>
<span class="p_add">+	if (fake_offset &amp;&amp; ctx-&gt;pos &lt; 2)</span>
<span class="p_add">+		ctx-&gt;pos = 2;</span>
 
 	if (!memcmp(de-&gt;name, MSDOS_DOT, MSDOS_NAME)) {
 		if (!dir_emit_dot(file, ctx))
<span class="p_chunk">@@ -681,14 +682,19 @@</span> <span class="p_context"> record_end:</span>
 	fake_offset = 0;
 	ctx-&gt;pos = cpos;
 	goto get_new;
<span class="p_add">+</span>
 end_of_dir:
<span class="p_del">-	ctx-&gt;pos = cpos;</span>
<span class="p_add">+	if (fake_offset &amp;&amp; cpos &lt; 2)</span>
<span class="p_add">+		ctx-&gt;pos = 2;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		ctx-&gt;pos = cpos;</span>
 fill_failed:
 	brelse(bh);
 	if (unicode)
 		__putname(unicode);
 out:
 	mutex_unlock(&amp;sbi-&gt;s_lock);
<span class="p_add">+</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/fs/fuse/cuse.c b/fs/fuse/cuse.c</span>
<span class="p_header">index eae2c11..8e3ee19 100644</span>
<span class="p_header">--- a/fs/fuse/cuse.c</span>
<span class="p_header">+++ b/fs/fuse/cuse.c</span>
<span class="p_chunk">@@ -549,6 +549,8 @@</span> <span class="p_context"> static int cuse_channel_release(struct inode *inode, struct file *file)</span>
 		unregister_chrdev_region(cc-&gt;cdev-&gt;dev, 1);
 		cdev_del(cc-&gt;cdev);
 	}
<span class="p_add">+	/* Base reference is now owned by &quot;fud&quot; */</span>
<span class="p_add">+	fuse_conn_put(&amp;cc-&gt;fc);</span>
 
 	rc = fuse_dev_release(inode, file);	/* puts the base reference */
 
<span class="p_header">diff --git a/fs/fuse/file.c b/fs/fuse/file.c</span>
<span class="p_header">index f523f2f..195476a 100644</span>
<span class="p_header">--- a/fs/fuse/file.c</span>
<span class="p_header">+++ b/fs/fuse/file.c</span>
<span class="p_chunk">@@ -1049,6 +1049,7 @@</span> <span class="p_context"> static ssize_t fuse_fill_write_pages(struct fuse_req *req,</span>
 		tmp = iov_iter_copy_from_user_atomic(page, ii, offset, bytes);
 		flush_dcache_page(page);
 
<span class="p_add">+		iov_iter_advance(ii, tmp);</span>
 		if (!tmp) {
 			unlock_page(page);
 			page_cache_release(page);
<span class="p_chunk">@@ -1061,7 +1062,6 @@</span> <span class="p_context"> static ssize_t fuse_fill_write_pages(struct fuse_req *req,</span>
 		req-&gt;page_descs[req-&gt;num_pages].length = tmp;
 		req-&gt;num_pages++;
 
<span class="p_del">-		iov_iter_advance(ii, tmp);</span>
 		count += tmp;
 		pos += tmp;
 		offset += tmp;
<span class="p_header">diff --git a/fs/jbd2/transaction.c b/fs/jbd2/transaction.c</span>
<span class="p_header">index f3d0617..ad7c3fd 100644</span>
<span class="p_header">--- a/fs/jbd2/transaction.c</span>
<span class="p_header">+++ b/fs/jbd2/transaction.c</span>
<span class="p_chunk">@@ -991,7 +991,8 @@</span> <span class="p_context"> out:</span>
 }
 
 /* Fast check whether buffer is already attached to the required transaction */
<span class="p_del">-static bool jbd2_write_access_granted(handle_t *handle, struct buffer_head *bh)</span>
<span class="p_add">+static bool jbd2_write_access_granted(handle_t *handle, struct buffer_head *bh,</span>
<span class="p_add">+							bool undo)</span>
 {
 	struct journal_head *jh;
 	bool ret = false;
<span class="p_chunk">@@ -1018,6 +1019,9 @@</span> <span class="p_context"> static bool jbd2_write_access_granted(handle_t *handle, struct buffer_head *bh)</span>
 	jh = READ_ONCE(bh-&gt;b_private);
 	if (!jh)
 		goto out;
<span class="p_add">+	/* For undo access buffer must have data copied */</span>
<span class="p_add">+	if (undo &amp;&amp; !jh-&gt;b_committed_data)</span>
<span class="p_add">+		goto out;</span>
 	if (jh-&gt;b_transaction != handle-&gt;h_transaction &amp;&amp;
 	    jh-&gt;b_next_transaction != handle-&gt;h_transaction)
 		goto out;
<span class="p_chunk">@@ -1055,7 +1059,7 @@</span> <span class="p_context"> int jbd2_journal_get_write_access(handle_t *handle, struct buffer_head *bh)</span>
 	struct journal_head *jh;
 	int rc;
 
<span class="p_del">-	if (jbd2_write_access_granted(handle, bh))</span>
<span class="p_add">+	if (jbd2_write_access_granted(handle, bh, false))</span>
 		return 0;
 
 	jh = jbd2_journal_add_journal_head(bh);
<span class="p_chunk">@@ -1192,7 +1196,7 @@</span> <span class="p_context"> int jbd2_journal_get_undo_access(handle_t *handle, struct buffer_head *bh)</span>
 	char *committed_data = NULL;
 
 	JBUFFER_TRACE(jh, &quot;entry&quot;);
<span class="p_del">-	if (jbd2_write_access_granted(handle, bh))</span>
<span class="p_add">+	if (jbd2_write_access_granted(handle, bh, true))</span>
 		return 0;
 
 	jh = jbd2_journal_add_journal_head(bh);
<span class="p_chunk">@@ -2108,6 +2112,7 @@</span> <span class="p_context"> static int journal_unmap_buffer(journal_t *journal, struct buffer_head *bh,</span>
 
 		if (!buffer_dirty(bh)) {
 			/* bdflush has written it.  We can drop it now */
<span class="p_add">+			__jbd2_journal_remove_checkpoint(jh);</span>
 			goto zap_buffer;
 		}
 
<span class="p_chunk">@@ -2137,6 +2142,7 @@</span> <span class="p_context"> static int journal_unmap_buffer(journal_t *journal, struct buffer_head *bh,</span>
 				/* The orphan record&#39;s transaction has
 				 * committed.  We can cleanse this buffer */
 				clear_buffer_jbddirty(bh);
<span class="p_add">+				__jbd2_journal_remove_checkpoint(jh);</span>
 				goto zap_buffer;
 			}
 		}
<span class="p_header">diff --git a/fs/namei.c b/fs/namei.c</span>
<span class="p_header">index 36df481..f39a798 100644</span>
<span class="p_header">--- a/fs/namei.c</span>
<span class="p_header">+++ b/fs/namei.c</span>
<span class="p_chunk">@@ -1999,7 +1999,6 @@</span> <span class="p_context"> static const char *path_init(struct nameidata *nd, unsigned flags)</span>
 	nd-&gt;last_type = LAST_ROOT; /* if there are only slashes... */
 	nd-&gt;flags = flags | LOOKUP_JUMPED | LOOKUP_PARENT;
 	nd-&gt;depth = 0;
<span class="p_del">-	nd-&gt;total_link_count = 0;</span>
 	if (flags &amp; LOOKUP_ROOT) {
 		struct dentry *root = nd-&gt;root.dentry;
 		struct inode *inode = root-&gt;d_inode;
<span class="p_header">diff --git a/fs/nfs/inode.c b/fs/nfs/inode.c</span>
<span class="p_header">index f27cc76..1c65e3f 100644</span>
<span class="p_header">--- a/fs/nfs/inode.c</span>
<span class="p_header">+++ b/fs/nfs/inode.c</span>
<span class="p_chunk">@@ -75,11 +75,11 @@</span> <span class="p_context"> nfs_fattr_to_ino_t(struct nfs_fattr *fattr)</span>
  * nfs_wait_bit_killable - helper for functions that are sleeping on bit locks
  * @word: long word containing the bit lock
  */
<span class="p_del">-int nfs_wait_bit_killable(struct wait_bit_key *key)</span>
<span class="p_add">+int nfs_wait_bit_killable(struct wait_bit_key *key, int mode)</span>
 {
<span class="p_del">-	if (fatal_signal_pending(current))</span>
<span class="p_del">-		return -ERESTARTSYS;</span>
 	freezable_schedule_unsafe();
<span class="p_add">+	if (signal_pending_state(mode, current))</span>
<span class="p_add">+		return -ERESTARTSYS;</span>
 	return 0;
 }
 EXPORT_SYMBOL_GPL(nfs_wait_bit_killable);
<span class="p_header">diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h</span>
<span class="p_header">index 1dad181..d7345c4 100644</span>
<span class="p_header">--- a/fs/nfs/internal.h</span>
<span class="p_header">+++ b/fs/nfs/internal.h</span>
<span class="p_chunk">@@ -384,7 +384,7 @@</span> <span class="p_context"> extern int nfs_drop_inode(struct inode *);</span>
 extern void nfs_clear_inode(struct inode *);
 extern void nfs_evict_inode(struct inode *);
 void nfs_zap_acl_cache(struct inode *inode);
<span class="p_del">-extern int nfs_wait_bit_killable(struct wait_bit_key *key);</span>
<span class="p_add">+extern int nfs_wait_bit_killable(struct wait_bit_key *key, int mode);</span>
 
 /* super.c */
 extern const struct super_operations nfs_sops;
<span class="p_header">diff --git a/fs/nfs/pagelist.c b/fs/nfs/pagelist.c</span>
<span class="p_header">index fe3ddd2..452a011 100644</span>
<span class="p_header">--- a/fs/nfs/pagelist.c</span>
<span class="p_header">+++ b/fs/nfs/pagelist.c</span>
<span class="p_chunk">@@ -129,7 +129,7 @@</span> <span class="p_context"> __nfs_iocounter_wait(struct nfs_io_counter *c)</span>
 		set_bit(NFS_IO_INPROGRESS, &amp;c-&gt;flags);
 		if (atomic_read(&amp;c-&gt;io_count) == 0)
 			break;
<span class="p_del">-		ret = nfs_wait_bit_killable(&amp;q.key);</span>
<span class="p_add">+		ret = nfs_wait_bit_killable(&amp;q.key, TASK_KILLABLE);</span>
 	} while (atomic_read(&amp;c-&gt;io_count) != 0 &amp;&amp; !ret);
 	finish_wait(wq, &amp;q.wait);
 	return ret;
<span class="p_header">diff --git a/fs/nfs/pnfs.c b/fs/nfs/pnfs.c</span>
<span class="p_header">index 70bf706..75abed0 100644</span>
<span class="p_header">--- a/fs/nfs/pnfs.c</span>
<span class="p_header">+++ b/fs/nfs/pnfs.c</span>
<span class="p_chunk">@@ -882,28 +882,42 @@</span> <span class="p_context"> send_layoutget(struct pnfs_layout_hdr *lo,</span>
 	struct nfs_server *server = NFS_SERVER(ino);
 	struct nfs4_layoutget *lgp;
 	struct pnfs_layout_segment *lseg;
<span class="p_add">+	loff_t i_size;</span>
 
 	dprintk(&quot;--&gt; %s\n&quot;, __func__);
 
<span class="p_del">-	lgp = kzalloc(sizeof(*lgp), gfp_flags);</span>
<span class="p_del">-	if (lgp == NULL)</span>
<span class="p_del">-		return NULL;</span>
<span class="p_del">-</span>
<span class="p_del">-	lgp-&gt;args.minlength = PAGE_CACHE_SIZE;</span>
<span class="p_del">-	if (lgp-&gt;args.minlength &gt; range-&gt;length)</span>
<span class="p_del">-		lgp-&gt;args.minlength = range-&gt;length;</span>
<span class="p_del">-	lgp-&gt;args.maxcount = PNFS_LAYOUT_MAXSIZE;</span>
<span class="p_del">-	lgp-&gt;args.range = *range;</span>
<span class="p_del">-	lgp-&gt;args.type = server-&gt;pnfs_curr_ld-&gt;id;</span>
<span class="p_del">-	lgp-&gt;args.inode = ino;</span>
<span class="p_del">-	lgp-&gt;args.ctx = get_nfs_open_context(ctx);</span>
<span class="p_del">-	lgp-&gt;gfp_flags = gfp_flags;</span>
<span class="p_del">-	lgp-&gt;cred = lo-&gt;plh_lc_cred;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Synchronously retrieve layout information from server and</span>
<span class="p_del">-	 * store in lseg.</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Synchronously retrieve layout information from server and</span>
<span class="p_add">+	 * store in lseg. If we race with a concurrent seqid morphing</span>
<span class="p_add">+	 * op, then re-send the LAYOUTGET.</span>
 	 */
<span class="p_del">-	lseg = nfs4_proc_layoutget(lgp, gfp_flags);</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		lgp = kzalloc(sizeof(*lgp), gfp_flags);</span>
<span class="p_add">+		if (lgp == NULL)</span>
<span class="p_add">+			return NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+		i_size = i_size_read(ino);</span>
<span class="p_add">+</span>
<span class="p_add">+		lgp-&gt;args.minlength = PAGE_CACHE_SIZE;</span>
<span class="p_add">+		if (lgp-&gt;args.minlength &gt; range-&gt;length)</span>
<span class="p_add">+			lgp-&gt;args.minlength = range-&gt;length;</span>
<span class="p_add">+		if (range-&gt;iomode == IOMODE_READ) {</span>
<span class="p_add">+			if (range-&gt;offset &gt;= i_size)</span>
<span class="p_add">+				lgp-&gt;args.minlength = 0;</span>
<span class="p_add">+			else if (i_size - range-&gt;offset &lt; lgp-&gt;args.minlength)</span>
<span class="p_add">+				lgp-&gt;args.minlength = i_size - range-&gt;offset;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		lgp-&gt;args.maxcount = PNFS_LAYOUT_MAXSIZE;</span>
<span class="p_add">+		lgp-&gt;args.range = *range;</span>
<span class="p_add">+		lgp-&gt;args.type = server-&gt;pnfs_curr_ld-&gt;id;</span>
<span class="p_add">+		lgp-&gt;args.inode = ino;</span>
<span class="p_add">+		lgp-&gt;args.ctx = get_nfs_open_context(ctx);</span>
<span class="p_add">+		lgp-&gt;gfp_flags = gfp_flags;</span>
<span class="p_add">+		lgp-&gt;cred = lo-&gt;plh_lc_cred;</span>
<span class="p_add">+</span>
<span class="p_add">+		lseg = nfs4_proc_layoutget(lgp, gfp_flags);</span>
<span class="p_add">+	} while (lseg == ERR_PTR(-EAGAIN));</span>
<span class="p_add">+</span>
 	if (IS_ERR(lseg)) {
 		switch (PTR_ERR(lseg)) {
 		case -ENOMEM:
<span class="p_chunk">@@ -1429,11 +1443,11 @@</span> <span class="p_context"> static bool pnfs_within_mdsthreshold(struct nfs_open_context *ctx,</span>
 }
 
 /* stop waiting if someone clears NFS_LAYOUT_RETRY_LAYOUTGET bit. */
<span class="p_del">-static int pnfs_layoutget_retry_bit_wait(struct wait_bit_key *key)</span>
<span class="p_add">+static int pnfs_layoutget_retry_bit_wait(struct wait_bit_key *key, int mode)</span>
 {
 	if (!test_bit(NFS_LAYOUT_RETRY_LAYOUTGET, key-&gt;flags))
 		return 1;
<span class="p_del">-	return nfs_wait_bit_killable(key);</span>
<span class="p_add">+	return nfs_wait_bit_killable(key, mode);</span>
 }
 
 static bool pnfs_prepare_to_retry_layoutget(struct pnfs_layout_hdr *lo)
<span class="p_chunk">@@ -1633,6 +1647,7 @@</span> <span class="p_context"> pnfs_layout_process(struct nfs4_layoutget *lgp)</span>
 		/* existing state ID, make sure the sequence number matches. */
 		if (pnfs_layout_stateid_blocked(lo, &amp;res-&gt;stateid)) {
 			dprintk(&quot;%s forget reply due to sequence\n&quot;, __func__);
<span class="p_add">+			status = -EAGAIN;</span>
 			goto out_forget_reply;
 		}
 		pnfs_set_layout_stateid(lo, &amp;res-&gt;stateid, false);
<span class="p_header">diff --git a/fs/ocfs2/namei.c b/fs/ocfs2/namei.c</span>
<span class="p_header">index ff04012..564584a 100644</span>
<span class="p_header">--- a/fs/ocfs2/namei.c</span>
<span class="p_header">+++ b/fs/ocfs2/namei.c</span>
<span class="p_chunk">@@ -360,13 +360,11 @@</span> <span class="p_context"> static int ocfs2_mknod(struct inode *dir,</span>
 		goto leave;
 	}
 
<span class="p_del">-	status = posix_acl_create(dir, &amp;mode, &amp;default_acl, &amp;acl);</span>
<span class="p_add">+	status = posix_acl_create(dir, &amp;inode-&gt;i_mode, &amp;default_acl, &amp;acl);</span>
 	if (status) {
 		mlog_errno(status);
 		goto leave;
 	}
<span class="p_del">-	/* update inode-&gt;i_mode after mask with &quot;umask&quot;. */</span>
<span class="p_del">-	inode-&gt;i_mode = mode;</span>
 
 	handle = ocfs2_start_trans(osb, ocfs2_mknod_credits(osb-&gt;sb,
 							    S_ISDIR(mode),
<span class="p_header">diff --git a/fs/ocfs2/resize.c b/fs/ocfs2/resize.c</span>
<span class="p_header">index d5da6f6..79b8021 100644</span>
<span class="p_header">--- a/fs/ocfs2/resize.c</span>
<span class="p_header">+++ b/fs/ocfs2/resize.c</span>
<span class="p_chunk">@@ -54,11 +54,12 @@</span> <span class="p_context"></span>
 static u16 ocfs2_calc_new_backup_super(struct inode *inode,
 				       struct ocfs2_group_desc *gd,
 				       u16 cl_cpg,
<span class="p_add">+				       u16 old_bg_clusters,</span>
 				       int set)
 {
 	int i;
 	u16 backups = 0;
<span class="p_del">-	u32 cluster;</span>
<span class="p_add">+	u32 cluster, lgd_cluster;</span>
 	u64 blkno, gd_blkno, lgd_blkno = le64_to_cpu(gd-&gt;bg_blkno);
 
 	for (i = 0; i &lt; OCFS2_MAX_BACKUP_SUPERBLOCKS; i++) {
<span class="p_chunk">@@ -71,6 +72,12 @@</span> <span class="p_context"> static u16 ocfs2_calc_new_backup_super(struct inode *inode,</span>
 		else if (gd_blkno &gt; lgd_blkno)
 			break;
 
<span class="p_add">+		/* check if already done backup super */</span>
<span class="p_add">+		lgd_cluster = ocfs2_blocks_to_clusters(inode-&gt;i_sb, lgd_blkno);</span>
<span class="p_add">+		lgd_cluster += old_bg_clusters;</span>
<span class="p_add">+		if (lgd_cluster &gt;= cluster)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
 		if (set)
 			ocfs2_set_bit(cluster % cl_cpg,
 				      (unsigned long *)gd-&gt;bg_bitmap);
<span class="p_chunk">@@ -99,6 +106,7 @@</span> <span class="p_context"> static int ocfs2_update_last_group_and_inode(handle_t *handle,</span>
 	u16 chain, num_bits, backups = 0;
 	u16 cl_bpc = le16_to_cpu(cl-&gt;cl_bpc);
 	u16 cl_cpg = le16_to_cpu(cl-&gt;cl_cpg);
<span class="p_add">+	u16 old_bg_clusters;</span>
 
 	trace_ocfs2_update_last_group_and_inode(new_clusters,
 						first_new_cluster);
<span class="p_chunk">@@ -112,6 +120,7 @@</span> <span class="p_context"> static int ocfs2_update_last_group_and_inode(handle_t *handle,</span>
 
 	group = (struct ocfs2_group_desc *)group_bh-&gt;b_data;
 
<span class="p_add">+	old_bg_clusters = le16_to_cpu(group-&gt;bg_bits) / cl_bpc;</span>
 	/* update the group first. */
 	num_bits = new_clusters * cl_bpc;
 	le16_add_cpu(&amp;group-&gt;bg_bits, num_bits);
<span class="p_chunk">@@ -125,7 +134,7 @@</span> <span class="p_context"> static int ocfs2_update_last_group_and_inode(handle_t *handle,</span>
 				     OCFS2_FEATURE_COMPAT_BACKUP_SB)) {
 		backups = ocfs2_calc_new_backup_super(bm_inode,
 						     group,
<span class="p_del">-						     cl_cpg, 1);</span>
<span class="p_add">+						     cl_cpg, old_bg_clusters, 1);</span>
 		le16_add_cpu(&amp;group-&gt;bg_free_bits_count, -1 * backups);
 	}
 
<span class="p_chunk">@@ -163,7 +172,7 @@</span> <span class="p_context"> out_rollback:</span>
 	if (ret &lt; 0) {
 		ocfs2_calc_new_backup_super(bm_inode,
 					    group,
<span class="p_del">-					    cl_cpg, 0);</span>
<span class="p_add">+					    cl_cpg, old_bg_clusters, 0);</span>
 		le16_add_cpu(&amp;group-&gt;bg_free_bits_count, backups);
 		le16_add_cpu(&amp;group-&gt;bg_bits, -1 * num_bits);
 		le16_add_cpu(&amp;group-&gt;bg_free_bits_count, -1 * num_bits);
<span class="p_header">diff --git a/fs/overlayfs/inode.c b/fs/overlayfs/inode.c</span>
<span class="p_header">index ec0c2a0..9612849 100644</span>
<span class="p_header">--- a/fs/overlayfs/inode.c</span>
<span class="p_header">+++ b/fs/overlayfs/inode.c</span>
<span class="p_chunk">@@ -49,13 +49,13 @@</span> <span class="p_context"> int ovl_setattr(struct dentry *dentry, struct iattr *attr)</span>
 	if (err)
 		goto out;
 
<span class="p_del">-	upperdentry = ovl_dentry_upper(dentry);</span>
<span class="p_del">-	if (upperdentry) {</span>
<span class="p_add">+	err = ovl_copy_up(dentry);</span>
<span class="p_add">+	if (!err) {</span>
<span class="p_add">+		upperdentry = ovl_dentry_upper(dentry);</span>
<span class="p_add">+</span>
 		mutex_lock(&amp;upperdentry-&gt;d_inode-&gt;i_mutex);
 		err = notify_change(upperdentry, attr, NULL);
 		mutex_unlock(&amp;upperdentry-&gt;d_inode-&gt;i_mutex);
<span class="p_del">-	} else {</span>
<span class="p_del">-		err = ovl_copy_up_last(dentry, attr, false);</span>
 	}
 	ovl_drop_write(dentry);
 out:
<span class="p_header">diff --git a/fs/splice.c b/fs/splice.c</span>
<span class="p_header">index 5fc1e50..014657c 100644</span>
<span class="p_header">--- a/fs/splice.c</span>
<span class="p_header">+++ b/fs/splice.c</span>
<span class="p_chunk">@@ -809,6 +809,13 @@</span> <span class="p_context"> static int splice_from_pipe_feed(struct pipe_inode_info *pipe, struct splice_des</span>
  */
 static int splice_from_pipe_next(struct pipe_inode_info *pipe, struct splice_desc *sd)
 {
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Check for signal early to make process killable when there are</span>
<span class="p_add">+	 * always buffers available</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (signal_pending(current))</span>
<span class="p_add">+		return -ERESTARTSYS;</span>
<span class="p_add">+</span>
 	while (!pipe-&gt;nrbufs) {
 		if (!pipe-&gt;writers)
 			return 0;
<span class="p_chunk">@@ -884,6 +891,7 @@</span> <span class="p_context"> ssize_t __splice_from_pipe(struct pipe_inode_info *pipe, struct splice_desc *sd,</span>
 
 	splice_from_pipe_begin(sd);
 	do {
<span class="p_add">+		cond_resched();</span>
 		ret = splice_from_pipe_next(pipe, sd);
 		if (ret &gt; 0)
 			ret = splice_from_pipe_feed(pipe, sd, actor);
<span class="p_header">diff --git a/fs/sysv/inode.c b/fs/sysv/inode.c</span>
<span class="p_header">index 590ad92..02fa1dc 100644</span>
<span class="p_header">--- a/fs/sysv/inode.c</span>
<span class="p_header">+++ b/fs/sysv/inode.c</span>
<span class="p_chunk">@@ -162,15 +162,8 @@</span> <span class="p_context"> void sysv_set_inode(struct inode *inode, dev_t rdev)</span>
 		inode-&gt;i_fop = &amp;sysv_dir_operations;
 		inode-&gt;i_mapping-&gt;a_ops = &amp;sysv_aops;
 	} else if (S_ISLNK(inode-&gt;i_mode)) {
<span class="p_del">-		if (inode-&gt;i_blocks) {</span>
<span class="p_del">-			inode-&gt;i_op = &amp;sysv_symlink_inode_operations;</span>
<span class="p_del">-			inode-&gt;i_mapping-&gt;a_ops = &amp;sysv_aops;</span>
<span class="p_del">-		} else {</span>
<span class="p_del">-			inode-&gt;i_op = &amp;simple_symlink_inode_operations;</span>
<span class="p_del">-			inode-&gt;i_link = (char *)SYSV_I(inode)-&gt;i_data;</span>
<span class="p_del">-			nd_terminate_link(inode-&gt;i_link, inode-&gt;i_size,</span>
<span class="p_del">-				sizeof(SYSV_I(inode)-&gt;i_data) - 1);</span>
<span class="p_del">-		}</span>
<span class="p_add">+		inode-&gt;i_op = &amp;sysv_symlink_inode_operations;</span>
<span class="p_add">+		inode-&gt;i_mapping-&gt;a_ops = &amp;sysv_aops;</span>
 	} else
 		init_special_inode(inode, inode-&gt;i_mode, rdev);
 }
<span class="p_header">diff --git a/include/drm/drmP.h b/include/drm/drmP.h</span>
<span class="p_header">index 5aa5197..ee28f59 100644</span>
<span class="p_header">--- a/include/drm/drmP.h</span>
<span class="p_header">+++ b/include/drm/drmP.h</span>
<span class="p_chunk">@@ -299,6 +299,11 @@</span> <span class="p_context"> struct drm_file {</span>
 	unsigned universal_planes:1;
 	/* true if client understands atomic properties */
 	unsigned atomic:1;
<span class="p_add">+	/*</span>
<span class="p_add">+	 * This client is allowed to gain master privileges for @master.</span>
<span class="p_add">+	 * Protected by struct drm_device::master_mutex.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	unsigned allowed_master:1;</span>
 
 	struct pid *pid;
 	kuid_t uid;
<span class="p_chunk">@@ -898,6 +903,7 @@</span> <span class="p_context"> extern int drm_open(struct inode *inode, struct file *filp);</span>
 extern ssize_t drm_read(struct file *filp, char __user *buffer,
 			size_t count, loff_t *offset);
 extern int drm_release(struct inode *inode, struct file *filp);
<span class="p_add">+extern int drm_new_set_master(struct drm_device *dev, struct drm_file *fpriv);</span>
 
 				/* Mapping support (drm_vm.h) */
 extern unsigned int drm_poll(struct file *filp, struct poll_table_struct *wait);
<span class="p_header">diff --git a/include/linux/acpi.h b/include/linux/acpi.h</span>
<span class="p_header">index b92ec06..242c84d 100644</span>
<span class="p_header">--- a/include/linux/acpi.h</span>
<span class="p_header">+++ b/include/linux/acpi.h</span>
<span class="p_chunk">@@ -784,8 +784,8 @@</span> <span class="p_context"> static inline int acpi_dev_get_property_array(struct acpi_device *adev,</span>
 	return -ENXIO;
 }
 static inline int acpi_dev_get_property_reference(struct acpi_device *adev,
<span class="p_del">-				const char *name, const char *cells_name,</span>
<span class="p_del">-				size_t index, struct acpi_reference_args *args)</span>
<span class="p_add">+				const char *name, size_t index,</span>
<span class="p_add">+				struct acpi_reference_args *args)</span>
 {
 	return -ENXIO;
 }
<span class="p_header">diff --git a/include/linux/blkdev.h b/include/linux/blkdev.h</span>
<span class="p_header">index d4068c1..f8d6f12 100644</span>
<span class="p_header">--- a/include/linux/blkdev.h</span>
<span class="p_header">+++ b/include/linux/blkdev.h</span>
<span class="p_chunk">@@ -772,7 +772,6 @@</span> <span class="p_context"> extern void blk_rq_set_block_pc(struct request *);</span>
 extern void blk_requeue_request(struct request_queue *, struct request *);
 extern void blk_add_request_payload(struct request *rq, struct page *page,
 		unsigned int len);
<span class="p_del">-extern int blk_rq_check_limits(struct request_queue *q, struct request *rq);</span>
 extern int blk_lld_busy(struct request_queue *q);
 extern int blk_rq_prep_clone(struct request *rq, struct request *rq_src,
 			     struct bio_set *bs, gfp_t gfp_mask,
<span class="p_header">diff --git a/include/linux/enclosure.h b/include/linux/enclosure.h</span>
<span class="p_header">index 7be22da..a4cf57c 100644</span>
<span class="p_header">--- a/include/linux/enclosure.h</span>
<span class="p_header">+++ b/include/linux/enclosure.h</span>
<span class="p_chunk">@@ -29,7 +29,11 @@</span> <span class="p_context"></span>
 /* A few generic types ... taken from ses-2 */
 enum enclosure_component_type {
 	ENCLOSURE_COMPONENT_DEVICE = 0x01,
<span class="p_add">+	ENCLOSURE_COMPONENT_CONTROLLER_ELECTRONICS = 0x07,</span>
<span class="p_add">+	ENCLOSURE_COMPONENT_SCSI_TARGET_PORT = 0x14,</span>
<span class="p_add">+	ENCLOSURE_COMPONENT_SCSI_INITIATOR_PORT = 0x15,</span>
 	ENCLOSURE_COMPONENT_ARRAY_DEVICE = 0x17,
<span class="p_add">+	ENCLOSURE_COMPONENT_SAS_EXPANDER = 0x18,</span>
 };
 
 /* ses-2 common element status */
<span class="p_header">diff --git a/include/linux/filter.h b/include/linux/filter.h</span>
<span class="p_header">index 17724f6..137b10c 100644</span>
<span class="p_header">--- a/include/linux/filter.h</span>
<span class="p_header">+++ b/include/linux/filter.h</span>
<span class="p_chunk">@@ -446,6 +446,25 @@</span> <span class="p_context"> static inline void bpf_jit_free(struct bpf_prog *fp)</span>
 
 #define BPF_ANC		BIT(15)
 
<span class="p_add">+static inline bool bpf_needs_clear_a(const struct sock_filter *first)</span>
<span class="p_add">+{</span>
<span class="p_add">+	switch (first-&gt;code) {</span>
<span class="p_add">+	case BPF_RET | BPF_K:</span>
<span class="p_add">+	case BPF_LD | BPF_W | BPF_LEN:</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	case BPF_LD | BPF_W | BPF_ABS:</span>
<span class="p_add">+	case BPF_LD | BPF_H | BPF_ABS:</span>
<span class="p_add">+	case BPF_LD | BPF_B | BPF_ABS:</span>
<span class="p_add">+		if (first-&gt;k == SKF_AD_OFF + SKF_AD_ALU_XOR_X)</span>
<span class="p_add">+			return true;</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline u16 bpf_anc_helper(const struct sock_filter *ftest)
 {
 	BUG_ON(ftest-&gt;code &amp; BPF_ANC);
<span class="p_header">diff --git a/include/linux/ftrace.h b/include/linux/ftrace.h</span>
<span class="p_header">index 6cd8c0e..47420d4 100644</span>
<span class="p_header">--- a/include/linux/ftrace.h</span>
<span class="p_header">+++ b/include/linux/ftrace.h</span>
<span class="p_chunk">@@ -575,6 +575,7 @@</span> <span class="p_context"> extern int ftrace_arch_read_dyn_info(char *buf, int size);</span>
 
 extern int skip_trace(unsigned long ip);
 extern void ftrace_module_init(struct module *mod);
<span class="p_add">+extern void ftrace_release_mod(struct module *mod);</span>
 
 extern void ftrace_disable_daemon(void);
 extern void ftrace_enable_daemon(void);
<span class="p_header">diff --git a/include/linux/mmdebug.h b/include/linux/mmdebug.h</span>
<span class="p_header">index 877ef22..772362a 100644</span>
<span class="p_header">--- a/include/linux/mmdebug.h</span>
<span class="p_header">+++ b/include/linux/mmdebug.h</span>
<span class="p_chunk">@@ -1,6 +1,7 @@</span> <span class="p_context"></span>
 #ifndef LINUX_MM_DEBUG_H
 #define LINUX_MM_DEBUG_H 1
 
<span class="p_add">+#include &lt;linux/bug.h&gt;</span>
 #include &lt;linux/stringify.h&gt;
 
 struct page;
<span class="p_header">diff --git a/include/linux/signal.h b/include/linux/signal.h</span>
<span class="p_header">index ab1e039..92557bb 100644</span>
<span class="p_header">--- a/include/linux/signal.h</span>
<span class="p_header">+++ b/include/linux/signal.h</span>
<span class="p_chunk">@@ -239,7 +239,6 @@</span> <span class="p_context"> extern int sigprocmask(int, sigset_t *, sigset_t *);</span>
 extern void set_current_blocked(sigset_t *);
 extern void __set_current_blocked(const sigset_t *);
 extern int show_unhandled_signals;
<span class="p_del">-extern int sigsuspend(sigset_t *);</span>
 
 struct sigaction {
 #ifndef __ARCH_HAS_IRIX_SIGACTION
<span class="p_header">diff --git a/include/linux/thermal.h b/include/linux/thermal.h</span>
<span class="p_header">index 037e9df..b5ea8e0 100644</span>
<span class="p_header">--- a/include/linux/thermal.h</span>
<span class="p_header">+++ b/include/linux/thermal.h</span>
<span class="p_chunk">@@ -434,7 +434,8 @@</span> <span class="p_context"> static inline void thermal_zone_device_unregister(</span>
 static inline int thermal_zone_bind_cooling_device(
 	struct thermal_zone_device *tz, int trip,
 	struct thermal_cooling_device *cdev,
<span class="p_del">-	unsigned long upper, unsigned long lower)</span>
<span class="p_add">+	unsigned long upper, unsigned long lower,</span>
<span class="p_add">+	unsigned int weight)</span>
 { return -ENODEV; }
 static inline int thermal_zone_unbind_cooling_device(
 	struct thermal_zone_device *tz, int trip,
<span class="p_header">diff --git a/include/linux/usb/quirks.h b/include/linux/usb/quirks.h</span>
<span class="p_header">index 9948c87..1d0043d 100644</span>
<span class="p_header">--- a/include/linux/usb/quirks.h</span>
<span class="p_header">+++ b/include/linux/usb/quirks.h</span>
<span class="p_chunk">@@ -47,4 +47,7 @@</span> <span class="p_context"></span>
 /* device generates spurious wakeup, ignore remote wakeup capability */
 #define USB_QUIRK_IGNORE_REMOTE_WAKEUP		BIT(9)
 
<span class="p_add">+/* device can&#39;t handle Link Power Management */</span>
<span class="p_add">+#define USB_QUIRK_NO_LPM			BIT(10)</span>
<span class="p_add">+</span>
 #endif /* __LINUX_USB_QUIRKS_H */
<span class="p_header">diff --git a/include/linux/wait.h b/include/linux/wait.h</span>
<span class="p_header">index 1e1bf9f..513b36f 100644</span>
<span class="p_header">--- a/include/linux/wait.h</span>
<span class="p_header">+++ b/include/linux/wait.h</span>
<span class="p_chunk">@@ -145,7 +145,7 @@</span> <span class="p_context"> __remove_wait_queue(wait_queue_head_t *head, wait_queue_t *old)</span>
 	list_del(&amp;old-&gt;task_list);
 }
 
<span class="p_del">-typedef int wait_bit_action_f(struct wait_bit_key *);</span>
<span class="p_add">+typedef int wait_bit_action_f(struct wait_bit_key *, int mode);</span>
 void __wake_up(wait_queue_head_t *q, unsigned int mode, int nr, void *key);
 void __wake_up_locked_key(wait_queue_head_t *q, unsigned int mode, void *key);
 void __wake_up_sync_key(wait_queue_head_t *q, unsigned int mode, int nr, void *key);
<span class="p_chunk">@@ -960,10 +960,10 @@</span> <span class="p_context"> int wake_bit_function(wait_queue_t *wait, unsigned mode, int sync, void *key);</span>
 	} while (0)
 
 
<span class="p_del">-extern int bit_wait(struct wait_bit_key *);</span>
<span class="p_del">-extern int bit_wait_io(struct wait_bit_key *);</span>
<span class="p_del">-extern int bit_wait_timeout(struct wait_bit_key *);</span>
<span class="p_del">-extern int bit_wait_io_timeout(struct wait_bit_key *);</span>
<span class="p_add">+extern int bit_wait(struct wait_bit_key *, int);</span>
<span class="p_add">+extern int bit_wait_io(struct wait_bit_key *, int);</span>
<span class="p_add">+extern int bit_wait_timeout(struct wait_bit_key *, int);</span>
<span class="p_add">+extern int bit_wait_io_timeout(struct wait_bit_key *, int);</span>
 
 /**
  * wait_on_bit - wait for a bit to be cleared
<span class="p_header">diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h</span>
<span class="p_header">index 495c87e..eea9bde 100644</span>
<span class="p_header">--- a/include/net/sctp/structs.h</span>
<span class="p_header">+++ b/include/net/sctp/structs.h</span>
<span class="p_chunk">@@ -775,10 +775,10 @@</span> <span class="p_context"> struct sctp_transport {</span>
 		hb_sent:1,
 
 		/* Is the Path MTU update pending on this tranport */
<span class="p_del">-		pmtu_pending:1;</span>
<span class="p_add">+		pmtu_pending:1,</span>
 
<span class="p_del">-	/* Has this transport moved the ctsn since we last sacked */</span>
<span class="p_del">-	__u32 sack_generation;</span>
<span class="p_add">+		/* Has this transport moved the ctsn since we last sacked */</span>
<span class="p_add">+		sack_generation:1;</span>
 	u32 dst_cookie;
 
 	struct flowi fl;
<span class="p_chunk">@@ -1482,19 +1482,20 @@</span> <span class="p_context"> struct sctp_association {</span>
 			prsctp_capable:1,   /* Can peer do PR-SCTP? */
 			auth_capable:1;     /* Is peer doing SCTP-AUTH? */
 
<span class="p_del">-		/* Ack State   : This flag indicates if the next received</span>
<span class="p_add">+		/* sack_needed : This flag indicates if the next received</span>
 		 *             : packet is to be responded to with a
<span class="p_del">-		 *             : SACK. This is initializedto 0.  When a packet</span>
<span class="p_del">-		 *             : is received it is incremented. If this value</span>
<span class="p_add">+		 *             : SACK. This is initialized to 0.  When a packet</span>
<span class="p_add">+		 *             : is received sack_cnt is incremented. If this value</span>
 		 *             : reaches 2 or more, a SACK is sent and the
 		 *             : value is reset to 0. Note: This is used only
 		 *             : when no DATA chunks are received out of
 		 *             : order.  When DATA chunks are out of order,
 		 *             : SACK&#39;s are not delayed (see Section 6).
 		 */
<span class="p_del">-		__u8    sack_needed;     /* Do we need to sack the peer? */</span>
<span class="p_add">+		__u8    sack_needed:1,     /* Do we need to sack the peer? */</span>
<span class="p_add">+			sack_generation:1,</span>
<span class="p_add">+			zero_window_announced:1;</span>
 		__u32	sack_cnt;
<span class="p_del">-		__u32	sack_generation;</span>
 
 		__u32   adaptation_ind;	 /* Adaptation Code point. */
 
<span class="p_header">diff --git a/include/net/sock.h b/include/net/sock.h</span>
<span class="p_header">index 208c874..639138b 100644</span>
<span class="p_header">--- a/include/net/sock.h</span>
<span class="p_header">+++ b/include/net/sock.h</span>
<span class="p_chunk">@@ -371,7 +371,7 @@</span> <span class="p_context"> struct sock {</span>
 	struct socket_wq __rcu	*sk_wq;
 
 #ifdef CONFIG_XFRM
<span class="p_del">-	struct xfrm_policy	*sk_policy[2];</span>
<span class="p_add">+	struct xfrm_policy __rcu *sk_policy[2];</span>
 #endif
 	unsigned long 		sk_flags;
 	struct dst_entry	*sk_rx_dst;
<span class="p_chunk">@@ -387,8 +387,8 @@</span> <span class="p_context"> struct sock {</span>
 				sk_no_check_rx : 1,
 				sk_userlocks : 4,
 				sk_protocol  : 8,
<span class="p_del">-#define SK_PROTOCOL_MAX U8_MAX</span>
 				sk_type      : 16;
<span class="p_add">+#define SK_PROTOCOL_MAX U8_MAX</span>
 	kmemcheck_bitfield_end(flags);
 	int			sk_wmem_queued;
 	gfp_t			sk_allocation;
<span class="p_header">diff --git a/include/net/xfrm.h b/include/net/xfrm.h</span>
<span class="p_header">index f0ee97e..02a1d20 100644</span>
<span class="p_header">--- a/include/net/xfrm.h</span>
<span class="p_header">+++ b/include/net/xfrm.h</span>
<span class="p_chunk">@@ -1140,12 +1140,14 @@</span> <span class="p_context"> static inline int xfrm6_route_forward(struct sk_buff *skb)</span>
 	return xfrm_route_forward(skb, AF_INET6);
 }
 
<span class="p_del">-int __xfrm_sk_clone_policy(struct sock *sk);</span>
<span class="p_add">+int __xfrm_sk_clone_policy(struct sock *sk, const struct sock *osk);</span>
 
<span class="p_del">-static inline int xfrm_sk_clone_policy(struct sock *sk)</span>
<span class="p_add">+static inline int xfrm_sk_clone_policy(struct sock *sk, const struct sock *osk)</span>
 {
<span class="p_del">-	if (unlikely(sk-&gt;sk_policy[0] || sk-&gt;sk_policy[1]))</span>
<span class="p_del">-		return __xfrm_sk_clone_policy(sk);</span>
<span class="p_add">+	sk-&gt;sk_policy[0] = NULL;</span>
<span class="p_add">+	sk-&gt;sk_policy[1] = NULL;</span>
<span class="p_add">+	if (unlikely(osk-&gt;sk_policy[0] || osk-&gt;sk_policy[1]))</span>
<span class="p_add">+		return __xfrm_sk_clone_policy(sk, osk);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -1153,12 +1155,16 @@</span> <span class="p_context"> int xfrm_policy_delete(struct xfrm_policy *pol, int dir);</span>
 
 static inline void xfrm_sk_free_policy(struct sock *sk)
 {
<span class="p_del">-	if (unlikely(sk-&gt;sk_policy[0] != NULL)) {</span>
<span class="p_del">-		xfrm_policy_delete(sk-&gt;sk_policy[0], XFRM_POLICY_MAX);</span>
<span class="p_add">+	struct xfrm_policy *pol;</span>
<span class="p_add">+</span>
<span class="p_add">+	pol = rcu_dereference_protected(sk-&gt;sk_policy[0], 1);</span>
<span class="p_add">+	if (unlikely(pol != NULL)) {</span>
<span class="p_add">+		xfrm_policy_delete(pol, XFRM_POLICY_MAX);</span>
 		sk-&gt;sk_policy[0] = NULL;
 	}
<span class="p_del">-	if (unlikely(sk-&gt;sk_policy[1] != NULL)) {</span>
<span class="p_del">-		xfrm_policy_delete(sk-&gt;sk_policy[1], XFRM_POLICY_MAX+1);</span>
<span class="p_add">+	pol = rcu_dereference_protected(sk-&gt;sk_policy[1], 1);</span>
<span class="p_add">+	if (unlikely(pol != NULL)) {</span>
<span class="p_add">+		xfrm_policy_delete(pol, XFRM_POLICY_MAX+1);</span>
 		sk-&gt;sk_policy[1] = NULL;
 	}
 }
<span class="p_chunk">@@ -1168,7 +1174,7 @@</span> <span class="p_context"> void xfrm_garbage_collect(struct net *net);</span>
 #else
 
 static inline void xfrm_sk_free_policy(struct sock *sk) {}
<span class="p_del">-static inline int xfrm_sk_clone_policy(struct sock *sk) { return 0; }</span>
<span class="p_add">+static inline int xfrm_sk_clone_policy(struct sock *sk, const struct sock *osk) { return 0; }</span>
 static inline int xfrm6_route_forward(struct sk_buff *skb) { return 1; }  
 static inline int xfrm4_route_forward(struct sk_buff *skb) { return 1; } 
 static inline int xfrm6_policy_check(struct sock *sk, int dir, struct sk_buff *skb)
<span class="p_header">diff --git a/include/sound/soc.h b/include/sound/soc.h</span>
<span class="p_header">index 334d0d2..78a58c1 100644</span>
<span class="p_header">--- a/include/sound/soc.h</span>
<span class="p_header">+++ b/include/sound/soc.h</span>
<span class="p_chunk">@@ -1629,7 +1629,7 @@</span> <span class="p_context"> extern const struct dev_pm_ops snd_soc_pm_ops;</span>
 /* Helper functions */
 static inline void snd_soc_dapm_mutex_lock(struct snd_soc_dapm_context *dapm)
 {
<span class="p_del">-	mutex_lock(&amp;dapm-&gt;card-&gt;dapm_mutex);</span>
<span class="p_add">+	mutex_lock_nested(&amp;dapm-&gt;card-&gt;dapm_mutex, SND_SOC_DAPM_CLASS_RUNTIME);</span>
 }
 
 static inline void snd_soc_dapm_mutex_unlock(struct snd_soc_dapm_context *dapm)
<span class="p_header">diff --git a/include/target/target_core_base.h b/include/target/target_core_base.h</span>
<span class="p_header">index 17ae2d6..8b0c0dc 100644</span>
<span class="p_header">--- a/include/target/target_core_base.h</span>
<span class="p_header">+++ b/include/target/target_core_base.h</span>
<span class="p_chunk">@@ -480,7 +480,7 @@</span> <span class="p_context"> struct se_cmd {</span>
 	struct kref		cmd_kref;
 	const struct target_core_fabric_ops *se_tfo;
 	sense_reason_t		(*execute_cmd)(struct se_cmd *);
<span class="p_del">-	sense_reason_t (*transport_complete_callback)(struct se_cmd *, bool);</span>
<span class="p_add">+	sense_reason_t (*transport_complete_callback)(struct se_cmd *, bool, int *);</span>
 	void			*protocol_data;
 
 	unsigned char		*t_task_cdb;
<span class="p_header">diff --git a/include/xen/interface/io/ring.h b/include/xen/interface/io/ring.h</span>
<span class="p_header">index 7d28aff..7dc685b 100644</span>
<span class="p_header">--- a/include/xen/interface/io/ring.h</span>
<span class="p_header">+++ b/include/xen/interface/io/ring.h</span>
<span class="p_chunk">@@ -181,6 +181,20 @@</span> <span class="p_context"> struct __name##_back_ring {						\</span>
 #define RING_GET_REQUEST(_r, _idx)					\
     (&amp;((_r)-&gt;sring-&gt;ring[((_idx) &amp; (RING_SIZE(_r) - 1))].req))
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Get a local copy of a request.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Use this in preference to RING_GET_REQUEST() so all processing is</span>
<span class="p_add">+ * done on a local copy that cannot be modified by the other end.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Note that https://gcc.gnu.org/bugzilla/show_bug.cgi?id=58145 may cause this</span>
<span class="p_add">+ * to be ineffective where _req is a struct which consists of only bitfields.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define RING_COPY_REQUEST(_r, _idx, _req) do {				\</span>
<span class="p_add">+	/* Use volatile to force the copy into _req. */			\</span>
<span class="p_add">+	*(_req) = *(volatile typeof(_req))RING_GET_REQUEST(_r, _idx);	\</span>
<span class="p_add">+} while (0)</span>
<span class="p_add">+</span>
 #define RING_GET_RESPONSE(_r, _idx)					\
     (&amp;((_r)-&gt;sring-&gt;ring[((_idx) &amp; (RING_SIZE(_r) - 1))].rsp))
 
<span class="p_header">diff --git a/kernel/events/core.c b/kernel/events/core.c</span>
<span class="p_header">index c06fa66..d86859f 100644</span>
<span class="p_header">--- a/kernel/events/core.c</span>
<span class="p_header">+++ b/kernel/events/core.c</span>
<span class="p_chunk">@@ -4034,7 +4034,14 @@</span> <span class="p_context"> retry:</span>
 		goto retry;
 	}
 
<span class="p_del">-	__perf_event_period(&amp;pe);</span>
<span class="p_add">+	if (event-&gt;attr.freq) {</span>
<span class="p_add">+		event-&gt;attr.sample_freq = value;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		event-&gt;attr.sample_period = value;</span>
<span class="p_add">+		event-&gt;hw.sample_period = value;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	local64_set(&amp;event-&gt;hw.period_left, 0);</span>
 	raw_spin_unlock_irq(&amp;ctx-&gt;lock);
 
 	return 0;
<span class="p_header">diff --git a/kernel/fork.c b/kernel/fork.c</span>
<span class="p_header">index e769c8c..a0fb0ce 100644</span>
<span class="p_header">--- a/kernel/fork.c</span>
<span class="p_header">+++ b/kernel/fork.c</span>
<span class="p_chunk">@@ -379,6 +379,7 @@</span> <span class="p_context"> static struct task_struct *dup_task_struct(struct task_struct *orig)</span>
 #endif
 	tsk-&gt;splice_pipe = NULL;
 	tsk-&gt;task_frag.page = NULL;
<span class="p_add">+	tsk-&gt;wake_q.next = NULL;</span>
 
 	account_kernel_stack(ti, 1);
 
<span class="p_header">diff --git a/kernel/irq/manage.c b/kernel/irq/manage.c</span>
<span class="p_header">index f974485..aaec958 100644</span>
<span class="p_header">--- a/kernel/irq/manage.c</span>
<span class="p_header">+++ b/kernel/irq/manage.c</span>
<span class="p_chunk">@@ -1363,6 +1363,7 @@</span> <span class="p_context"> static struct irqaction *__free_irq(unsigned int irq, void *dev_id)</span>
 	if (!desc)
 		return NULL;
 
<span class="p_add">+	chip_bus_lock(desc);</span>
 	raw_spin_lock_irqsave(&amp;desc-&gt;lock, flags);
 
 	/*
<span class="p_chunk">@@ -1376,7 +1377,7 @@</span> <span class="p_context"> static struct irqaction *__free_irq(unsigned int irq, void *dev_id)</span>
 		if (!action) {
 			WARN(1, &quot;Trying to free already-free IRQ %d\n&quot;, irq);
 			raw_spin_unlock_irqrestore(&amp;desc-&gt;lock, flags);
<span class="p_del">-</span>
<span class="p_add">+			chip_bus_sync_unlock(desc);</span>
 			return NULL;
 		}
 
<span class="p_chunk">@@ -1403,6 +1404,7 @@</span> <span class="p_context"> static struct irqaction *__free_irq(unsigned int irq, void *dev_id)</span>
 #endif
 
 	raw_spin_unlock_irqrestore(&amp;desc-&gt;lock, flags);
<span class="p_add">+	chip_bus_sync_unlock(desc);</span>
 
 	unregister_handler_proc(irq, action);
 
<span class="p_chunk">@@ -1476,9 +1478,7 @@</span> <span class="p_context"> void free_irq(unsigned int irq, void *dev_id)</span>
 		desc-&gt;affinity_notify = NULL;
 #endif
 
<span class="p_del">-	chip_bus_lock(desc);</span>
 	kfree(__free_irq(irq, dev_id));
<span class="p_del">-	chip_bus_sync_unlock(desc);</span>
 }
 EXPORT_SYMBOL(free_irq);
 
<span class="p_header">diff --git a/kernel/module.c b/kernel/module.c</span>
<span class="p_header">index 8f051a1..38c7bd5 100644</span>
<span class="p_header">--- a/kernel/module.c</span>
<span class="p_header">+++ b/kernel/module.c</span>
<span class="p_chunk">@@ -3571,6 +3571,12 @@</span> <span class="p_context"> static int load_module(struct load_info *info, const char __user *uargs,</span>
 	synchronize_sched();
 	mutex_unlock(&amp;module_mutex);
  free_module:
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Ftrace needs to clean up what it initialized.</span>
<span class="p_add">+	 * This does nothing if ftrace_module_init() wasn&#39;t called,</span>
<span class="p_add">+	 * but it must be called outside of module_mutex.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ftrace_release_mod(mod);</span>
 	/* Free lock-classes; relies on the preceding sync_rcu() */
 	lockdep_free_key_range(mod-&gt;module_core, mod-&gt;core_size);
 
<span class="p_header">diff --git a/kernel/sched/core.c b/kernel/sched/core.c</span>
<span class="p_header">index 6776631..99cc1f4 100644</span>
<span class="p_header">--- a/kernel/sched/core.c</span>
<span class="p_header">+++ b/kernel/sched/core.c</span>
<span class="p_chunk">@@ -1972,7 +1972,6 @@</span> <span class="p_context"> out:</span>
  */
 int wake_up_process(struct task_struct *p)
 {
<span class="p_del">-	WARN_ON(task_is_stopped_or_traced(p));</span>
 	return try_to_wake_up(p, TASK_NORMAL, 0);
 }
 EXPORT_SYMBOL(wake_up_process);
<span class="p_chunk">@@ -5718,13 +5717,13 @@</span> <span class="p_context"> static int init_rootdomain(struct root_domain *rd)</span>
 {
 	memset(rd, 0, sizeof(*rd));
 
<span class="p_del">-	if (!alloc_cpumask_var(&amp;rd-&gt;span, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;rd-&gt;span, GFP_KERNEL))</span>
 		goto out;
<span class="p_del">-	if (!alloc_cpumask_var(&amp;rd-&gt;online, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;rd-&gt;online, GFP_KERNEL))</span>
 		goto free_span;
<span class="p_del">-	if (!alloc_cpumask_var(&amp;rd-&gt;dlo_mask, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;rd-&gt;dlo_mask, GFP_KERNEL))</span>
 		goto free_online;
<span class="p_del">-	if (!alloc_cpumask_var(&amp;rd-&gt;rto_mask, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;rd-&gt;rto_mask, GFP_KERNEL))</span>
 		goto free_dlo_mask;
 
 	init_dl_bw(&amp;rd-&gt;dl_bw);
<span class="p_header">diff --git a/kernel/sched/rt.c b/kernel/sched/rt.c</span>
<span class="p_header">index 0d193a24..00426df 100644</span>
<span class="p_header">--- a/kernel/sched/rt.c</span>
<span class="p_header">+++ b/kernel/sched/rt.c</span>
<span class="p_chunk">@@ -64,7 +64,7 @@</span> <span class="p_context"> static void start_rt_bandwidth(struct rt_bandwidth *rt_b)</span>
 	raw_spin_unlock(&amp;rt_b-&gt;rt_runtime_lock);
 }
 
<span class="p_del">-#ifdef CONFIG_SMP</span>
<span class="p_add">+#if defined(CONFIG_SMP) &amp;&amp; defined(HAVE_RT_PUSH_IPI)</span>
 static void push_irq_work_func(struct irq_work *work);
 #endif
 
<span class="p_header">diff --git a/kernel/sched/wait.c b/kernel/sched/wait.c</span>
<span class="p_header">index 052e026..f15d6b6 100644</span>
<span class="p_header">--- a/kernel/sched/wait.c</span>
<span class="p_header">+++ b/kernel/sched/wait.c</span>
<span class="p_chunk">@@ -392,7 +392,7 @@</span> <span class="p_context"> __wait_on_bit(wait_queue_head_t *wq, struct wait_bit_queue *q,</span>
 	do {
 		prepare_to_wait(wq, &amp;q-&gt;wait, mode);
 		if (test_bit(q-&gt;key.bit_nr, q-&gt;key.flags))
<span class="p_del">-			ret = (*action)(&amp;q-&gt;key);</span>
<span class="p_add">+			ret = (*action)(&amp;q-&gt;key, mode);</span>
 	} while (test_bit(q-&gt;key.bit_nr, q-&gt;key.flags) &amp;&amp; !ret);
 	finish_wait(wq, &amp;q-&gt;wait);
 	return ret;
<span class="p_chunk">@@ -431,7 +431,7 @@</span> <span class="p_context"> __wait_on_bit_lock(wait_queue_head_t *wq, struct wait_bit_queue *q,</span>
 		prepare_to_wait_exclusive(wq, &amp;q-&gt;wait, mode);
 		if (!test_bit(q-&gt;key.bit_nr, q-&gt;key.flags))
 			continue;
<span class="p_del">-		ret = action(&amp;q-&gt;key);</span>
<span class="p_add">+		ret = action(&amp;q-&gt;key, mode);</span>
 		if (!ret)
 			continue;
 		abort_exclusive_wait(wq, &amp;q-&gt;wait, mode, &amp;q-&gt;key);
<span class="p_chunk">@@ -581,44 +581,44 @@</span> <span class="p_context"> void wake_up_atomic_t(atomic_t *p)</span>
 }
 EXPORT_SYMBOL(wake_up_atomic_t);
 
<span class="p_del">-__sched int bit_wait(struct wait_bit_key *word)</span>
<span class="p_add">+__sched int bit_wait(struct wait_bit_key *word, int mode)</span>
 {
<span class="p_del">-	if (signal_pending_state(current-&gt;state, current))</span>
<span class="p_del">-		return 1;</span>
 	schedule();
<span class="p_add">+	if (signal_pending_state(mode, current))</span>
<span class="p_add">+		return -EINTR;</span>
 	return 0;
 }
 EXPORT_SYMBOL(bit_wait);
 
<span class="p_del">-__sched int bit_wait_io(struct wait_bit_key *word)</span>
<span class="p_add">+__sched int bit_wait_io(struct wait_bit_key *word, int mode)</span>
 {
<span class="p_del">-	if (signal_pending_state(current-&gt;state, current))</span>
<span class="p_del">-		return 1;</span>
 	io_schedule();
<span class="p_add">+	if (signal_pending_state(mode, current))</span>
<span class="p_add">+		return -EINTR;</span>
 	return 0;
 }
 EXPORT_SYMBOL(bit_wait_io);
 
<span class="p_del">-__sched int bit_wait_timeout(struct wait_bit_key *word)</span>
<span class="p_add">+__sched int bit_wait_timeout(struct wait_bit_key *word, int mode)</span>
 {
 	unsigned long now = READ_ONCE(jiffies);
<span class="p_del">-	if (signal_pending_state(current-&gt;state, current))</span>
<span class="p_del">-		return 1;</span>
 	if (time_after_eq(now, word-&gt;timeout))
 		return -EAGAIN;
 	schedule_timeout(word-&gt;timeout - now);
<span class="p_add">+	if (signal_pending_state(mode, current))</span>
<span class="p_add">+		return -EINTR;</span>
 	return 0;
 }
 EXPORT_SYMBOL_GPL(bit_wait_timeout);
 
<span class="p_del">-__sched int bit_wait_io_timeout(struct wait_bit_key *word)</span>
<span class="p_add">+__sched int bit_wait_io_timeout(struct wait_bit_key *word, int mode)</span>
 {
 	unsigned long now = READ_ONCE(jiffies);
<span class="p_del">-	if (signal_pending_state(current-&gt;state, current))</span>
<span class="p_del">-		return 1;</span>
 	if (time_after_eq(now, word-&gt;timeout))
 		return -EAGAIN;
 	io_schedule_timeout(word-&gt;timeout - now);
<span class="p_add">+	if (signal_pending_state(mode, current))</span>
<span class="p_add">+		return -EINTR;</span>
 	return 0;
 }
 EXPORT_SYMBOL_GPL(bit_wait_io_timeout);
<span class="p_header">diff --git a/kernel/signal.c b/kernel/signal.c</span>
<span class="p_header">index 0f6bbbe..6c863ca 100644</span>
<span class="p_header">--- a/kernel/signal.c</span>
<span class="p_header">+++ b/kernel/signal.c</span>
<span class="p_chunk">@@ -3552,7 +3552,7 @@</span> <span class="p_context"> SYSCALL_DEFINE0(pause)</span>
 
 #endif
 
<span class="p_del">-int sigsuspend(sigset_t *set)</span>
<span class="p_add">+static int sigsuspend(sigset_t *set)</span>
 {
 	current-&gt;saved_sigmask = current-&gt;blocked;
 	set_current_blocked(set);
<span class="p_header">diff --git a/kernel/trace/ring_buffer.c b/kernel/trace/ring_buffer.c</span>
<span class="p_header">index 6260717..40718df 100644</span>
<span class="p_header">--- a/kernel/trace/ring_buffer.c</span>
<span class="p_header">+++ b/kernel/trace/ring_buffer.c</span>
<span class="p_chunk">@@ -1943,12 +1943,6 @@</span> <span class="p_context"> rb_set_commit_to_write(struct ring_buffer_per_cpu *cpu_buffer)</span>
 		goto again;
 }
 
<span class="p_del">-static void rb_reset_reader_page(struct ring_buffer_per_cpu *cpu_buffer)</span>
<span class="p_del">-{</span>
<span class="p_del">-	cpu_buffer-&gt;read_stamp = cpu_buffer-&gt;reader_page-&gt;page-&gt;time_stamp;</span>
<span class="p_del">-	cpu_buffer-&gt;reader_page-&gt;read = 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static void rb_inc_iter(struct ring_buffer_iter *iter)
 {
 	struct ring_buffer_per_cpu *cpu_buffer = iter-&gt;cpu_buffer;
<span class="p_chunk">@@ -3586,7 +3580,7 @@</span> <span class="p_context"> rb_get_reader_page(struct ring_buffer_per_cpu *cpu_buffer)</span>
 
 	/* Finally update the reader page to the new head */
 	cpu_buffer-&gt;reader_page = reader;
<span class="p_del">-	rb_reset_reader_page(cpu_buffer);</span>
<span class="p_add">+	cpu_buffer-&gt;reader_page-&gt;read = 0;</span>
 
 	if (overwrite != cpu_buffer-&gt;last_overrun) {
 		cpu_buffer-&gt;lost_events = overwrite - cpu_buffer-&gt;last_overrun;
<span class="p_chunk">@@ -3596,6 +3590,10 @@</span> <span class="p_context"> rb_get_reader_page(struct ring_buffer_per_cpu *cpu_buffer)</span>
 	goto again;
 
  out:
<span class="p_add">+	/* Update the read_stamp on the first event */</span>
<span class="p_add">+	if (reader &amp;&amp; reader-&gt;read == 0)</span>
<span class="p_add">+		cpu_buffer-&gt;read_stamp = reader-&gt;page-&gt;time_stamp;</span>
<span class="p_add">+</span>
 	arch_spin_unlock(&amp;cpu_buffer-&gt;lock);
 	local_irq_restore(flags);
 
<span class="p_header">diff --git a/kernel/trace/trace_printk.c b/kernel/trace/trace_printk.c</span>
<span class="p_header">index 36c1455..2dbffe2 100644</span>
<span class="p_header">--- a/kernel/trace/trace_printk.c</span>
<span class="p_header">+++ b/kernel/trace/trace_printk.c</span>
<span class="p_chunk">@@ -267,6 +267,7 @@</span> <span class="p_context"> static const char **find_next(void *v, loff_t *pos)</span>
 	if (*pos &lt; last_index + start_index)
 		return __start___tracepoint_str + (*pos - last_index);
 
<span class="p_add">+	start_index += last_index;</span>
 	return find_next_mod_format(start_index, v, fmt, pos);
 }
 
<span class="p_header">diff --git a/lib/dma-debug.c b/lib/dma-debug.c</span>
<span class="p_header">index dace71f..c5fddeb 100644</span>
<span class="p_header">--- a/lib/dma-debug.c</span>
<span class="p_header">+++ b/lib/dma-debug.c</span>
<span class="p_chunk">@@ -1456,7 +1456,7 @@</span> <span class="p_context"> void debug_dma_alloc_coherent(struct device *dev, size_t size,</span>
 	entry-&gt;type      = dma_debug_coherent;
 	entry-&gt;dev       = dev;
 	entry-&gt;pfn	 = page_to_pfn(virt_to_page(virt));
<span class="p_del">-	entry-&gt;offset	 = (size_t) virt &amp; PAGE_MASK;</span>
<span class="p_add">+	entry-&gt;offset	 = (size_t) virt &amp; ~PAGE_MASK;</span>
 	entry-&gt;size      = size;
 	entry-&gt;dev_addr  = dma_addr;
 	entry-&gt;direction = DMA_BIDIRECTIONAL;
<span class="p_chunk">@@ -1472,7 +1472,7 @@</span> <span class="p_context"> void debug_dma_free_coherent(struct device *dev, size_t size,</span>
 		.type           = dma_debug_coherent,
 		.dev            = dev,
 		.pfn		= page_to_pfn(virt_to_page(virt)),
<span class="p_del">-		.offset		= (size_t) virt &amp; PAGE_MASK,</span>
<span class="p_add">+		.offset		= (size_t) virt &amp; ~PAGE_MASK,</span>
 		.dev_addr       = addr,
 		.size           = size,
 		.direction      = DMA_BIDIRECTIONAL,
<span class="p_header">diff --git a/mm/backing-dev.c b/mm/backing-dev.c</span>
<span class="p_header">index dc07d88..632b79b 100644</span>
<span class="p_header">--- a/mm/backing-dev.c</span>
<span class="p_header">+++ b/mm/backing-dev.c</span>
<span class="p_chunk">@@ -943,8 +943,9 @@</span> <span class="p_context"> EXPORT_SYMBOL(congestion_wait);</span>
  * jiffies for either a BDI to exit congestion of the given @sync queue
  * or a write to complete.
  *
<span class="p_del">- * In the absence of zone congestion, cond_resched() is called to yield</span>
<span class="p_del">- * the processor if necessary but otherwise does not sleep.</span>
<span class="p_add">+ * In the absence of zone congestion, a short sleep or a cond_resched is</span>
<span class="p_add">+ * performed to yield the processor and to allow other subsystems to make</span>
<span class="p_add">+ * a forward progress.</span>
  *
  * The return value is 0 if the sleep is for the full timeout. Otherwise,
  * it is the number of jiffies that were still remaining when the function
<span class="p_chunk">@@ -964,7 +965,19 @@</span> <span class="p_context"> long wait_iff_congested(struct zone *zone, int sync, long timeout)</span>
 	 */
 	if (atomic_read(&amp;nr_wb_congested[sync]) == 0 ||
 	    !test_bit(ZONE_CONGESTED, &amp;zone-&gt;flags)) {
<span class="p_del">-		cond_resched();</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Memory allocation/reclaim might be called from a WQ</span>
<span class="p_add">+		 * context and the current implementation of the WQ</span>
<span class="p_add">+		 * concurrency control doesn&#39;t recognize that a particular</span>
<span class="p_add">+		 * WQ is congested if the worker thread is looping without</span>
<span class="p_add">+		 * ever sleeping. Therefore we have to do a short sleep</span>
<span class="p_add">+		 * here rather than calling cond_resched().</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (current-&gt;flags &amp; PF_WQ_WORKER)</span>
<span class="p_add">+			schedule_timeout(1);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			cond_resched();</span>
 
 		/* In case we scheduled, work out time remaining */
 		ret = timeout - (jiffies - start);
<span class="p_header">diff --git a/mm/hugetlb.c b/mm/hugetlb.c</span>
<span class="p_header">index 62c1ec5..080ed4b 100644</span>
<span class="p_header">--- a/mm/hugetlb.c</span>
<span class="p_header">+++ b/mm/hugetlb.c</span>
<span class="p_chunk">@@ -1563,7 +1563,10 @@</span> <span class="p_context"> static struct page *alloc_huge_page(struct vm_area_struct *vma,</span>
 		page = alloc_buddy_huge_page(h, NUMA_NO_NODE);
 		if (!page)
 			goto out_uncharge_cgroup;
<span class="p_del">-</span>
<span class="p_add">+		if (!avoid_reserve &amp;&amp; vma_has_reserves(vma, chg)) {</span>
<span class="p_add">+			SetPagePrivate(page);</span>
<span class="p_add">+			h-&gt;resv_huge_pages--;</span>
<span class="p_add">+		}</span>
 		spin_lock(&amp;hugetlb_lock);
 		list_move(&amp;page-&gt;lru, &amp;h-&gt;hugepage_activelist);
 		/* Fall through */
<span class="p_chunk">@@ -3347,12 +3350,12 @@</span> <span class="p_context"> int hugetlb_fault(struct mm_struct *mm, struct vm_area_struct *vma,</span>
 		} else if (unlikely(is_hugetlb_entry_hwpoisoned(entry)))
 			return VM_FAULT_HWPOISON_LARGE |
 				VM_FAULT_SET_HINDEX(hstate_index(h));
<span class="p_add">+	} else {</span>
<span class="p_add">+		ptep = huge_pte_alloc(mm, address, huge_page_size(h));</span>
<span class="p_add">+		if (!ptep)</span>
<span class="p_add">+			return VM_FAULT_OOM;</span>
 	}
 
<span class="p_del">-	ptep = huge_pte_alloc(mm, address, huge_page_size(h));</span>
<span class="p_del">-	if (!ptep)</span>
<span class="p_del">-		return VM_FAULT_OOM;</span>
<span class="p_del">-</span>
 	mapping = vma-&gt;vm_file-&gt;f_mapping;
 	idx = vma_hugecache_offset(h, vma, address);
 
<span class="p_header">diff --git a/mm/memory_hotplug.c b/mm/memory_hotplug.c</span>
<span class="p_header">index 8fd97da..5860ef1 100644</span>
<span class="p_header">--- a/mm/memory_hotplug.c</span>
<span class="p_header">+++ b/mm/memory_hotplug.c</span>
<span class="p_chunk">@@ -1354,23 +1354,30 @@</span> <span class="p_context"> int is_mem_section_removable(unsigned long start_pfn, unsigned long nr_pages)</span>
  */
 int test_pages_in_a_zone(unsigned long start_pfn, unsigned long end_pfn)
 {
<span class="p_del">-	unsigned long pfn;</span>
<span class="p_add">+	unsigned long pfn, sec_end_pfn;</span>
 	struct zone *zone = NULL;
 	struct page *page;
 	int i;
<span class="p_del">-	for (pfn = start_pfn;</span>
<span class="p_add">+	for (pfn = start_pfn, sec_end_pfn = SECTION_ALIGN_UP(start_pfn);</span>
 	     pfn &lt; end_pfn;
<span class="p_del">-	     pfn += MAX_ORDER_NR_PAGES) {</span>
<span class="p_del">-		i = 0;</span>
<span class="p_del">-		/* This is just a CONFIG_HOLES_IN_ZONE check.*/</span>
<span class="p_del">-		while ((i &lt; MAX_ORDER_NR_PAGES) &amp;&amp; !pfn_valid_within(pfn + i))</span>
<span class="p_del">-			i++;</span>
<span class="p_del">-		if (i == MAX_ORDER_NR_PAGES)</span>
<span class="p_add">+	     pfn = sec_end_pfn + 1, sec_end_pfn += PAGES_PER_SECTION) {</span>
<span class="p_add">+		/* Make sure the memory section is present first */</span>
<span class="p_add">+		if (!present_section_nr(pfn_to_section_nr(pfn)))</span>
 			continue;
<span class="p_del">-		page = pfn_to_page(pfn + i);</span>
<span class="p_del">-		if (zone &amp;&amp; page_zone(page) != zone)</span>
<span class="p_del">-			return 0;</span>
<span class="p_del">-		zone = page_zone(page);</span>
<span class="p_add">+		for (; pfn &lt; sec_end_pfn &amp;&amp; pfn &lt; end_pfn;</span>
<span class="p_add">+		     pfn += MAX_ORDER_NR_PAGES) {</span>
<span class="p_add">+			i = 0;</span>
<span class="p_add">+			/* This is just a CONFIG_HOLES_IN_ZONE check.*/</span>
<span class="p_add">+			while ((i &lt; MAX_ORDER_NR_PAGES) &amp;&amp;</span>
<span class="p_add">+				!pfn_valid_within(pfn + i))</span>
<span class="p_add">+				i++;</span>
<span class="p_add">+			if (i == MAX_ORDER_NR_PAGES)</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			page = pfn_to_page(pfn + i);</span>
<span class="p_add">+			if (zone &amp;&amp; page_zone(page) != zone)</span>
<span class="p_add">+				return 0;</span>
<span class="p_add">+			zone = page_zone(page);</span>
<span class="p_add">+		}</span>
 	}
 	return 1;
 }
<span class="p_header">diff --git a/mm/vmstat.c b/mm/vmstat.c</span>
<span class="p_header">index 4f5cd97..705d4a1 100644</span>
<span class="p_header">--- a/mm/vmstat.c</span>
<span class="p_header">+++ b/mm/vmstat.c</span>
<span class="p_chunk">@@ -1357,6 +1357,7 @@</span> <span class="p_context"> static const struct file_operations proc_vmstat_file_operations = {</span>
 #endif /* CONFIG_PROC_FS */
 
 #ifdef CONFIG_SMP
<span class="p_add">+static struct workqueue_struct *vmstat_wq;</span>
 static DEFINE_PER_CPU(struct delayed_work, vmstat_work);
 int sysctl_stat_interval __read_mostly = HZ;
 static cpumask_var_t cpu_stat_off;
<span class="p_chunk">@@ -1369,7 +1370,8 @@</span> <span class="p_context"> static void vmstat_update(struct work_struct *w)</span>
 		 * to occur in the future. Keep on running the
 		 * update worker thread.
 		 */
<span class="p_del">-		schedule_delayed_work(this_cpu_ptr(&amp;vmstat_work),</span>
<span class="p_add">+		queue_delayed_work(vmstat_wq,</span>
<span class="p_add">+			this_cpu_ptr(&amp;vmstat_work),</span>
 			round_jiffies_relative(sysctl_stat_interval));
 	else {
 		/*
<span class="p_chunk">@@ -1437,7 +1439,7 @@</span> <span class="p_context"> static void vmstat_shepherd(struct work_struct *w)</span>
 		if (need_update(cpu) &amp;&amp;
 			cpumask_test_and_clear_cpu(cpu, cpu_stat_off))
 
<span class="p_del">-			schedule_delayed_work_on(cpu,</span>
<span class="p_add">+			queue_delayed_work_on(cpu, vmstat_wq,</span>
 				&amp;per_cpu(vmstat_work, cpu), 0);
 
 	put_online_cpus();
<span class="p_chunk">@@ -1459,6 +1461,7 @@</span> <span class="p_context"> static void __init start_shepherd_timer(void)</span>
 		BUG();
 	cpumask_copy(cpu_stat_off, cpu_online_mask);
 
<span class="p_add">+	vmstat_wq = alloc_workqueue(&quot;vmstat&quot;, WQ_FREEZABLE|WQ_MEM_RECLAIM, 0);</span>
 	schedule_delayed_work(&amp;shepherd,
 		round_jiffies_relative(sysctl_stat_interval));
 }
<span class="p_header">diff --git a/net/bluetooth/smp.c b/net/bluetooth/smp.c</span>
<span class="p_header">index 0510a57..d29fda2 100644</span>
<span class="p_header">--- a/net/bluetooth/smp.c</span>
<span class="p_header">+++ b/net/bluetooth/smp.c</span>
<span class="p_chunk">@@ -3001,8 +3001,13 @@</span> <span class="p_context"> static void smp_ready_cb(struct l2cap_chan *chan)</span>
 
 	BT_DBG(&quot;chan %p&quot;, chan);
 
<span class="p_add">+	/* No need to call l2cap_chan_hold() here since we already own</span>
<span class="p_add">+	 * the reference taken in smp_new_conn_cb(). This is just the</span>
<span class="p_add">+	 * first time that we tie it to a specific pointer. The code in</span>
<span class="p_add">+	 * l2cap_core.c ensures that there&#39;s no risk this function wont</span>
<span class="p_add">+	 * get called if smp_new_conn_cb was previously called.</span>
<span class="p_add">+	 */</span>
 	conn-&gt;smp = chan;
<span class="p_del">-	l2cap_chan_hold(chan);</span>
 
 	if (hcon-&gt;type == ACL_LINK &amp;&amp; test_bit(HCI_CONN_ENCRYPT, &amp;hcon-&gt;flags))
 		bredr_pairing(chan);
<span class="p_header">diff --git a/net/core/dst.c b/net/core/dst.c</span>
<span class="p_header">index cc4a086..27e030f 100644</span>
<span class="p_header">--- a/net/core/dst.c</span>
<span class="p_header">+++ b/net/core/dst.c</span>
<span class="p_chunk">@@ -282,12 +282,13 @@</span> <span class="p_context"> void dst_release(struct dst_entry *dst)</span>
 {
 	if (dst) {
 		int newrefcnt;
<span class="p_add">+		unsigned short nocache = dst-&gt;flags &amp; DST_NOCACHE;</span>
 
 		newrefcnt = atomic_dec_return(&amp;dst-&gt;__refcnt);
 		if (unlikely(newrefcnt &lt; 0))
 			net_warn_ratelimited(&quot;%s: dst:%p refcnt:%d\n&quot;,
 					     __func__, dst, newrefcnt);
<span class="p_del">-		if (!newrefcnt &amp;&amp; unlikely(dst-&gt;flags &amp; DST_NOCACHE))</span>
<span class="p_add">+		if (!newrefcnt &amp;&amp; unlikely(nocache))</span>
 			call_rcu(&amp;dst-&gt;rcu_head, dst_destroy_rcu);
 	}
 }
<span class="p_header">diff --git a/net/core/sock.c b/net/core/sock.c</span>
<span class="p_header">index 623224a..3148f24 100644</span>
<span class="p_header">--- a/net/core/sock.c</span>
<span class="p_header">+++ b/net/core/sock.c</span>
<span class="p_chunk">@@ -1536,7 +1536,7 @@</span> <span class="p_context"> struct sock *sk_clone_lock(const struct sock *sk, const gfp_t priority)</span>
 			 */
 			is_charged = sk_filter_charge(newsk, filter);
 
<span class="p_del">-		if (unlikely(!is_charged || xfrm_sk_clone_policy(newsk))) {</span>
<span class="p_add">+		if (unlikely(!is_charged || xfrm_sk_clone_policy(newsk, sk))) {</span>
 			/* It is still raw copy of parent, so invalidate
 			 * destructor and make plain sk_free() */
 			newsk-&gt;sk_destruct = NULL;
<span class="p_header">diff --git a/net/ipv4/igmp.c b/net/ipv4/igmp.c</span>
<span class="p_header">index 53d5252..2a2b6a4 100644</span>
<span class="p_header">--- a/net/ipv4/igmp.c</span>
<span class="p_header">+++ b/net/ipv4/igmp.c</span>
<span class="p_chunk">@@ -2102,7 +2102,7 @@</span> <span class="p_context"> int ip_mc_leave_group(struct sock *sk, struct ip_mreqn *imr)</span>
 	ASSERT_RTNL();
 
 	in_dev = ip_mc_find_dev(net, imr);
<span class="p_del">-	if (!in_dev) {</span>
<span class="p_add">+	if (!imr-&gt;imr_ifindex &amp;&amp; !imr-&gt;imr_address.s_addr &amp;&amp; !in_dev) {</span>
 		ret = -ENODEV;
 		goto out;
 	}
<span class="p_chunk">@@ -2123,7 +2123,8 @@</span> <span class="p_context"> int ip_mc_leave_group(struct sock *sk, struct ip_mreqn *imr)</span>
 
 		*imlp = iml-&gt;next_rcu;
 
<span class="p_del">-		ip_mc_dec_group(in_dev, group);</span>
<span class="p_add">+		if (in_dev)</span>
<span class="p_add">+			ip_mc_dec_group(in_dev, group);</span>
 
 		/* decrease mem now to avoid the memleak warning */
 		atomic_sub(sizeof(*iml), &amp;sk-&gt;sk_omem_alloc);
<span class="p_header">diff --git a/net/ipv6/addrconf.c b/net/ipv6/addrconf.c</span>
<span class="p_header">index f4d78a4..d956e30 100644</span>
<span class="p_header">--- a/net/ipv6/addrconf.c</span>
<span class="p_header">+++ b/net/ipv6/addrconf.c</span>
<span class="p_chunk">@@ -5269,13 +5269,10 @@</span> <span class="p_context"> static int addrconf_sysctl_stable_secret(struct ctl_table *ctl, int write,</span>
 		goto out;
 	}
 
<span class="p_del">-	if (!write) {</span>
<span class="p_del">-		err = snprintf(str, sizeof(str), &quot;%pI6&quot;,</span>
<span class="p_del">-			       &amp;secret-&gt;secret);</span>
<span class="p_del">-		if (err &gt;= sizeof(str)) {</span>
<span class="p_del">-			err = -EIO;</span>
<span class="p_del">-			goto out;</span>
<span class="p_del">-		}</span>
<span class="p_add">+	err = snprintf(str, sizeof(str), &quot;%pI6&quot;, &amp;secret-&gt;secret);</span>
<span class="p_add">+	if (err &gt;= sizeof(str)) {</span>
<span class="p_add">+		err = -EIO;</span>
<span class="p_add">+		goto out;</span>
 	}
 
 	err = proc_dostring(&amp;lctl, write, buffer, lenp, ppos);
<span class="p_header">diff --git a/net/ipv6/addrlabel.c b/net/ipv6/addrlabel.c</span>
<span class="p_header">index 882124e..a8f6986 100644</span>
<span class="p_header">--- a/net/ipv6/addrlabel.c</span>
<span class="p_header">+++ b/net/ipv6/addrlabel.c</span>
<span class="p_chunk">@@ -552,7 +552,7 @@</span> <span class="p_context"> static int ip6addrlbl_get(struct sk_buff *in_skb, struct nlmsghdr *nlh)</span>
 
 	rcu_read_lock();
 	p = __ipv6_addr_label(net, addr, ipv6_addr_type(addr), ifal-&gt;ifal_index);
<span class="p_del">-	if (p &amp;&amp; ip6addrlbl_hold(p))</span>
<span class="p_add">+	if (p &amp;&amp; !ip6addrlbl_hold(p))</span>
 		p = NULL;
 	lseq = ip6addrlbl_table.seq;
 	rcu_read_unlock();
<span class="p_header">diff --git a/net/mac80211/cfg.c b/net/mac80211/cfg.c</span>
<span class="p_header">index bf7023f..5f8bbee 100644</span>
<span class="p_header">--- a/net/mac80211/cfg.c</span>
<span class="p_header">+++ b/net/mac80211/cfg.c</span>
<span class="p_chunk">@@ -3439,8 +3439,12 @@</span> <span class="p_context"> static int ieee80211_mgmt_tx(struct wiphy *wiphy, struct wireless_dev *wdev,</span>
 			goto out_unlock;
 		}
 	} else {
<span class="p_del">-		/* for cookie below */</span>
<span class="p_del">-		ack_skb = skb;</span>
<span class="p_add">+		/* Assign a dummy non-zero cookie, it&#39;s not sent to</span>
<span class="p_add">+		 * userspace in this case but we rely on its value</span>
<span class="p_add">+		 * internally in the need_offchan case to distinguish</span>
<span class="p_add">+		 * mgmt-tx from remain-on-channel.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		*cookie = 0xffffffff;</span>
 	}
 
 	if (!need_offchan) {
<span class="p_header">diff --git a/net/mac80211/iface.c b/net/mac80211/iface.c</span>
<span class="p_header">index 553ac6d..436c423 100644</span>
<span class="p_header">--- a/net/mac80211/iface.c</span>
<span class="p_header">+++ b/net/mac80211/iface.c</span>
<span class="p_chunk">@@ -76,7 +76,8 @@</span> <span class="p_context"> bool __ieee80211_recalc_txpower(struct ieee80211_sub_if_data *sdata)</span>
 void ieee80211_recalc_txpower(struct ieee80211_sub_if_data *sdata,
 			      bool update_bss)
 {
<span class="p_del">-	if (__ieee80211_recalc_txpower(sdata) || update_bss)</span>
<span class="p_add">+	if (__ieee80211_recalc_txpower(sdata) ||</span>
<span class="p_add">+	    (update_bss &amp;&amp; ieee80211_sdata_running(sdata)))</span>
 		ieee80211_bss_info_change_notify(sdata, BSS_CHANGED_TXPOWER);
 }
 
<span class="p_header">diff --git a/net/mac80211/mesh_pathtbl.c b/net/mac80211/mesh_pathtbl.c</span>
<span class="p_header">index b890e22..b3b44a5 100644</span>
<span class="p_header">--- a/net/mac80211/mesh_pathtbl.c</span>
<span class="p_header">+++ b/net/mac80211/mesh_pathtbl.c</span>
<span class="p_chunk">@@ -779,10 +779,8 @@</span> <span class="p_context"> void mesh_plink_broken(struct sta_info *sta)</span>
 static void mesh_path_node_reclaim(struct rcu_head *rp)
 {
 	struct mpath_node *node = container_of(rp, struct mpath_node, rcu);
<span class="p_del">-	struct ieee80211_sub_if_data *sdata = node-&gt;mpath-&gt;sdata;</span>
 
 	del_timer_sync(&amp;node-&gt;mpath-&gt;timer);
<span class="p_del">-	atomic_dec(&amp;sdata-&gt;u.mesh.mpaths);</span>
 	kfree(node-&gt;mpath);
 	kfree(node);
 }
<span class="p_chunk">@@ -790,8 +788,9 @@</span> <span class="p_context"> static void mesh_path_node_reclaim(struct rcu_head *rp)</span>
 /* needs to be called with the corresponding hashwlock taken */
 static void __mesh_path_del(struct mesh_table *tbl, struct mpath_node *node)
 {
<span class="p_del">-	struct mesh_path *mpath;</span>
<span class="p_del">-	mpath = node-&gt;mpath;</span>
<span class="p_add">+	struct mesh_path *mpath = node-&gt;mpath;</span>
<span class="p_add">+	struct ieee80211_sub_if_data *sdata = node-&gt;mpath-&gt;sdata;</span>
<span class="p_add">+</span>
 	spin_lock(&amp;mpath-&gt;state_lock);
 	mpath-&gt;flags |= MESH_PATH_RESOLVING;
 	if (mpath-&gt;is_gate)
<span class="p_chunk">@@ -799,6 +798,7 @@</span> <span class="p_context"> static void __mesh_path_del(struct mesh_table *tbl, struct mpath_node *node)</span>
 	hlist_del_rcu(&amp;node-&gt;list);
 	call_rcu(&amp;node-&gt;rcu, mesh_path_node_reclaim);
 	spin_unlock(&amp;mpath-&gt;state_lock);
<span class="p_add">+	atomic_dec(&amp;sdata-&gt;u.mesh.mpaths);</span>
 	atomic_dec(&amp;tbl-&gt;entries);
 }
 
<span class="p_header">diff --git a/net/mac80211/scan.c b/net/mac80211/scan.c</span>
<span class="p_header">index 11d0901..9c1cccd 100644</span>
<span class="p_header">--- a/net/mac80211/scan.c</span>
<span class="p_header">+++ b/net/mac80211/scan.c</span>
<span class="p_chunk">@@ -599,8 +599,8 @@</span> <span class="p_context"> static int __ieee80211_start_scan(struct ieee80211_sub_if_data *sdata,</span>
 		/* We need to ensure power level is at max for scanning. */
 		ieee80211_hw_config(local, 0);
 
<span class="p_del">-		if ((req-&gt;channels[0]-&gt;flags &amp;</span>
<span class="p_del">-		     IEEE80211_CHAN_NO_IR) ||</span>
<span class="p_add">+		if ((req-&gt;channels[0]-&gt;flags &amp; (IEEE80211_CHAN_NO_IR |</span>
<span class="p_add">+						IEEE80211_CHAN_RADAR)) ||</span>
 		    !req-&gt;n_ssids) {
 			next_delay = IEEE80211_PASSIVE_CHANNEL_TIME;
 		} else {
<span class="p_chunk">@@ -647,7 +647,7 @@</span> <span class="p_context"> ieee80211_scan_get_channel_time(struct ieee80211_channel *chan)</span>
 	 * TODO: channel switching also consumes quite some time,
 	 * add that delay as well to get a better estimation
 	 */
<span class="p_del">-	if (chan-&gt;flags &amp; IEEE80211_CHAN_NO_IR)</span>
<span class="p_add">+	if (chan-&gt;flags &amp; (IEEE80211_CHAN_NO_IR | IEEE80211_CHAN_RADAR))</span>
 		return IEEE80211_PASSIVE_CHANNEL_TIME;
 	return IEEE80211_PROBE_DELAY + IEEE80211_CHANNEL_TIME;
 }
<span class="p_chunk">@@ -779,7 +779,8 @@</span> <span class="p_context"> static void ieee80211_scan_state_set_channel(struct ieee80211_local *local,</span>
 	 *
 	 * In any case, it is not necessary for a passive scan.
 	 */
<span class="p_del">-	if (chan-&gt;flags &amp; IEEE80211_CHAN_NO_IR || !scan_req-&gt;n_ssids) {</span>
<span class="p_add">+	if ((chan-&gt;flags &amp; (IEEE80211_CHAN_NO_IR | IEEE80211_CHAN_RADAR)) ||</span>
<span class="p_add">+	    !scan_req-&gt;n_ssids) {</span>
 		*next_delay = IEEE80211_PASSIVE_CHANNEL_TIME;
 		local-&gt;next_scan_state = SCAN_DECISION;
 		return;
<span class="p_header">diff --git a/net/netfilter/nfnetlink_queue_core.c b/net/netfilter/nfnetlink_queue_core.c</span>
<span class="p_header">index a5cd6d9..2bfb1fd 100644</span>
<span class="p_header">--- a/net/netfilter/nfnetlink_queue_core.c</span>
<span class="p_header">+++ b/net/netfilter/nfnetlink_queue_core.c</span>
<span class="p_chunk">@@ -1392,6 +1392,7 @@</span> <span class="p_context"> static int __init nfnetlink_queue_init(void)</span>
 
 cleanup_netlink_notifier:
 	netlink_unregister_notifier(&amp;nfqnl_rtnl_notifier);
<span class="p_add">+	unregister_pernet_subsys(&amp;nfnl_queue_net_ops);</span>
 out:
 	return status;
 }
<span class="p_header">diff --git a/net/rfkill/core.c b/net/rfkill/core.c</span>
<span class="p_header">index f12149a..31b5c63 100644</span>
<span class="p_header">--- a/net/rfkill/core.c</span>
<span class="p_header">+++ b/net/rfkill/core.c</span>
<span class="p_chunk">@@ -49,7 +49,6 @@</span> <span class="p_context"></span>
 struct rfkill {
 	spinlock_t		lock;
 
<span class="p_del">-	const char		*name;</span>
 	enum rfkill_type	type;
 
 	unsigned long		state;
<span class="p_chunk">@@ -73,6 +72,7 @@</span> <span class="p_context"> struct rfkill {</span>
 	struct delayed_work	poll_work;
 	struct work_struct	uevent_work;
 	struct work_struct	sync_work;
<span class="p_add">+	char			name[];</span>
 };
 #define to_rfkill(d)	container_of(d, struct rfkill, dev)
 
<span class="p_chunk">@@ -868,14 +868,14 @@</span> <span class="p_context"> struct rfkill * __must_check rfkill_alloc(const char *name,</span>
 	if (WARN_ON(type == RFKILL_TYPE_ALL || type &gt;= NUM_RFKILL_TYPES))
 		return NULL;
 
<span class="p_del">-	rfkill = kzalloc(sizeof(*rfkill), GFP_KERNEL);</span>
<span class="p_add">+	rfkill = kzalloc(sizeof(*rfkill) + strlen(name) + 1, GFP_KERNEL);</span>
 	if (!rfkill)
 		return NULL;
 
 	spin_lock_init(&amp;rfkill-&gt;lock);
 	INIT_LIST_HEAD(&amp;rfkill-&gt;node);
 	rfkill-&gt;type = type;
<span class="p_del">-	rfkill-&gt;name = name;</span>
<span class="p_add">+	strcpy(rfkill-&gt;name, name);</span>
 	rfkill-&gt;ops = ops;
 	rfkill-&gt;data = ops_data;
 
<span class="p_header">diff --git a/net/sched/sch_generic.c b/net/sched/sch_generic.c</span>
<span class="p_header">index b453270..3c6f6b77 100644</span>
<span class="p_header">--- a/net/sched/sch_generic.c</span>
<span class="p_header">+++ b/net/sched/sch_generic.c</span>
<span class="p_chunk">@@ -666,8 +666,10 @@</span> <span class="p_context"> static void qdisc_rcu_free(struct rcu_head *head)</span>
 {
 	struct Qdisc *qdisc = container_of(head, struct Qdisc, rcu_head);
 
<span class="p_del">-	if (qdisc_is_percpu_stats(qdisc))</span>
<span class="p_add">+	if (qdisc_is_percpu_stats(qdisc)) {</span>
 		free_percpu(qdisc-&gt;cpu_bstats);
<span class="p_add">+		free_percpu(qdisc-&gt;cpu_qstats);</span>
<span class="p_add">+	}</span>
 
 	kfree((char *) qdisc - qdisc-&gt;padded);
 }
<span class="p_header">diff --git a/net/sctp/outqueue.c b/net/sctp/outqueue.c</span>
<span class="p_header">index 7e8f0a1..8d88823 100644</span>
<span class="p_header">--- a/net/sctp/outqueue.c</span>
<span class="p_header">+++ b/net/sctp/outqueue.c</span>
<span class="p_chunk">@@ -1251,6 +1251,7 @@</span> <span class="p_context"> int sctp_outq_sack(struct sctp_outq *q, struct sctp_chunk *chunk)</span>
 	 */
 
 	sack_a_rwnd = ntohl(sack-&gt;a_rwnd);
<span class="p_add">+	asoc-&gt;peer.zero_window_announced = !sack_a_rwnd;</span>
 	outstanding = q-&gt;outstanding_bytes;
 
 	if (outstanding &lt; sack_a_rwnd)
<span class="p_header">diff --git a/net/sctp/sm_statefuns.c b/net/sctp/sm_statefuns.c</span>
<span class="p_header">index 3ee27b7..3809a74 100644</span>
<span class="p_header">--- a/net/sctp/sm_statefuns.c</span>
<span class="p_header">+++ b/net/sctp/sm_statefuns.c</span>
<span class="p_chunk">@@ -5412,7 +5412,8 @@</span> <span class="p_context"> sctp_disposition_t sctp_sf_do_6_3_3_rtx(struct net *net,</span>
 	SCTP_INC_STATS(net, SCTP_MIB_T3_RTX_EXPIREDS);
 
 	if (asoc-&gt;overall_error_count &gt;= asoc-&gt;max_retrans) {
<span class="p_del">-		if (asoc-&gt;state == SCTP_STATE_SHUTDOWN_PENDING) {</span>
<span class="p_add">+		if (asoc-&gt;peer.zero_window_announced &amp;&amp;</span>
<span class="p_add">+		    asoc-&gt;state == SCTP_STATE_SHUTDOWN_PENDING) {</span>
 			/*
 			 * We are here likely because the receiver had its rwnd
 			 * closed for a while and we have not been able to
<span class="p_header">diff --git a/net/sunrpc/sched.c b/net/sunrpc/sched.c</span>
<span class="p_header">index 337ca85..6c21ca1 100644</span>
<span class="p_header">--- a/net/sunrpc/sched.c</span>
<span class="p_header">+++ b/net/sunrpc/sched.c</span>
<span class="p_chunk">@@ -250,11 +250,11 @@</span> <span class="p_context"> void rpc_destroy_wait_queue(struct rpc_wait_queue *queue)</span>
 }
 EXPORT_SYMBOL_GPL(rpc_destroy_wait_queue);
 
<span class="p_del">-static int rpc_wait_bit_killable(struct wait_bit_key *key)</span>
<span class="p_add">+static int rpc_wait_bit_killable(struct wait_bit_key *key, int mode)</span>
 {
<span class="p_del">-	if (fatal_signal_pending(current))</span>
<span class="p_del">-		return -ERESTARTSYS;</span>
 	freezable_schedule_unsafe();
<span class="p_add">+	if (signal_pending_state(mode, current))</span>
<span class="p_add">+		return -ERESTARTSYS;</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/net/sunrpc/svc.c b/net/sunrpc/svc.c</span>
<span class="p_header">index 5a16d8d..12d5990 100644</span>
<span class="p_header">--- a/net/sunrpc/svc.c</span>
<span class="p_header">+++ b/net/sunrpc/svc.c</span>
<span class="p_chunk">@@ -1367,6 +1367,19 @@</span> <span class="p_context"> bc_svc_process(struct svc_serv *serv, struct rpc_rqst *req,</span>
 	memcpy(&amp;rqstp-&gt;rq_arg, &amp;req-&gt;rq_rcv_buf, sizeof(rqstp-&gt;rq_arg));
 	memcpy(&amp;rqstp-&gt;rq_res, &amp;req-&gt;rq_snd_buf, sizeof(rqstp-&gt;rq_res));
 
<span class="p_add">+	/* Adjust the argument buffer length */</span>
<span class="p_add">+	rqstp-&gt;rq_arg.len = req-&gt;rq_private_buf.len;</span>
<span class="p_add">+	if (rqstp-&gt;rq_arg.len &lt;= rqstp-&gt;rq_arg.head[0].iov_len) {</span>
<span class="p_add">+		rqstp-&gt;rq_arg.head[0].iov_len = rqstp-&gt;rq_arg.len;</span>
<span class="p_add">+		rqstp-&gt;rq_arg.page_len = 0;</span>
<span class="p_add">+	} else if (rqstp-&gt;rq_arg.len &lt;= rqstp-&gt;rq_arg.head[0].iov_len +</span>
<span class="p_add">+			rqstp-&gt;rq_arg.page_len)</span>
<span class="p_add">+		rqstp-&gt;rq_arg.page_len = rqstp-&gt;rq_arg.len -</span>
<span class="p_add">+			rqstp-&gt;rq_arg.head[0].iov_len;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		rqstp-&gt;rq_arg.len = rqstp-&gt;rq_arg.head[0].iov_len +</span>
<span class="p_add">+			rqstp-&gt;rq_arg.page_len;</span>
<span class="p_add">+</span>
 	/* reset result send buffer &quot;put&quot; position */
 	resv-&gt;iov_len = 0;
 
<span class="p_header">diff --git a/net/xfrm/xfrm_policy.c b/net/xfrm/xfrm_policy.c</span>
<span class="p_header">index 18cead7..2718184 100644</span>
<span class="p_header">--- a/net/xfrm/xfrm_policy.c</span>
<span class="p_header">+++ b/net/xfrm/xfrm_policy.c</span>
<span class="p_chunk">@@ -1212,8 +1212,10 @@</span> <span class="p_context"> static struct xfrm_policy *xfrm_sk_policy_lookup(struct sock *sk, int dir,</span>
 	struct xfrm_policy *pol;
 	struct net *net = sock_net(sk);
 
<span class="p_add">+	rcu_read_lock();</span>
 	read_lock_bh(&amp;net-&gt;xfrm.xfrm_policy_lock);
<span class="p_del">-	if ((pol = sk-&gt;sk_policy[dir]) != NULL) {</span>
<span class="p_add">+	pol = rcu_dereference(sk-&gt;sk_policy[dir]);</span>
<span class="p_add">+	if (pol != NULL) {</span>
 		bool match = xfrm_selector_match(&amp;pol-&gt;selector, fl,
 						 sk-&gt;sk_family);
 		int err = 0;
<span class="p_chunk">@@ -1237,6 +1239,7 @@</span> <span class="p_context"> static struct xfrm_policy *xfrm_sk_policy_lookup(struct sock *sk, int dir,</span>
 	}
 out:
 	read_unlock_bh(&amp;net-&gt;xfrm.xfrm_policy_lock);
<span class="p_add">+	rcu_read_unlock();</span>
 	return pol;
 }
 
<span class="p_chunk">@@ -1305,13 +1308,14 @@</span> <span class="p_context"> int xfrm_sk_policy_insert(struct sock *sk, int dir, struct xfrm_policy *pol)</span>
 #endif
 
 	write_lock_bh(&amp;net-&gt;xfrm.xfrm_policy_lock);
<span class="p_del">-	old_pol = sk-&gt;sk_policy[dir];</span>
<span class="p_del">-	sk-&gt;sk_policy[dir] = pol;</span>
<span class="p_add">+	old_pol = rcu_dereference_protected(sk-&gt;sk_policy[dir],</span>
<span class="p_add">+				lockdep_is_held(&amp;net-&gt;xfrm.xfrm_policy_lock));</span>
 	if (pol) {
 		pol-&gt;curlft.add_time = get_seconds();
 		pol-&gt;index = xfrm_gen_index(net, XFRM_POLICY_MAX+dir, 0);
 		xfrm_sk_policy_link(pol, dir);
 	}
<span class="p_add">+	rcu_assign_pointer(sk-&gt;sk_policy[dir], pol);</span>
 	if (old_pol) {
 		if (pol)
 			xfrm_policy_requeue(old_pol, pol);
<span class="p_chunk">@@ -1359,17 +1363,26 @@</span> <span class="p_context"> static struct xfrm_policy *clone_policy(const struct xfrm_policy *old, int dir)</span>
 	return newp;
 }
 
<span class="p_del">-int __xfrm_sk_clone_policy(struct sock *sk)</span>
<span class="p_add">+int __xfrm_sk_clone_policy(struct sock *sk, const struct sock *osk)</span>
 {
<span class="p_del">-	struct xfrm_policy *p0 = sk-&gt;sk_policy[0],</span>
<span class="p_del">-			   *p1 = sk-&gt;sk_policy[1];</span>
<span class="p_add">+	const struct xfrm_policy *p;</span>
<span class="p_add">+	struct xfrm_policy *np;</span>
<span class="p_add">+	int i, ret = 0;</span>
 
<span class="p_del">-	sk-&gt;sk_policy[0] = sk-&gt;sk_policy[1] = NULL;</span>
<span class="p_del">-	if (p0 &amp;&amp; (sk-&gt;sk_policy[0] = clone_policy(p0, 0)) == NULL)</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_del">-	if (p1 &amp;&amp; (sk-&gt;sk_policy[1] = clone_policy(p1, 1)) == NULL)</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_del">-	return 0;</span>
<span class="p_add">+	rcu_read_lock();</span>
<span class="p_add">+	for (i = 0; i &lt; 2; i++) {</span>
<span class="p_add">+		p = rcu_dereference(osk-&gt;sk_policy[i]);</span>
<span class="p_add">+		if (p) {</span>
<span class="p_add">+			np = clone_policy(p, i);</span>
<span class="p_add">+			if (unlikely(!np)) {</span>
<span class="p_add">+				ret = -ENOMEM;</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			}</span>
<span class="p_add">+			rcu_assign_pointer(sk-&gt;sk_policy[i], np);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	rcu_read_unlock();</span>
<span class="p_add">+	return ret;</span>
 }
 
 static int
<span class="p_header">diff --git a/scripts/recordmcount.c b/scripts/recordmcount.c</span>
<span class="p_header">index e00bcd1..825d717 100644</span>
<span class="p_header">--- a/scripts/recordmcount.c</span>
<span class="p_header">+++ b/scripts/recordmcount.c</span>
<span class="p_chunk">@@ -48,12 +48,17 @@</span> <span class="p_context"></span>
 
 static int fd_map;	/* File descriptor for file being modified. */
 static int mmap_failed; /* Boolean flag. */
<span class="p_del">-static void *ehdr_curr; /* current ElfXX_Ehdr *  for resource cleanup */</span>
 static char gpfx;	/* prefix for global symbol name (sometimes &#39;_&#39;) */
 static struct stat sb;	/* Remember .st_size, etc. */
 static jmp_buf jmpenv;	/* setjmp/longjmp per-file error escape */
 static const char *altmcount;	/* alternate mcount symbol name */
 static int warn_on_notrace_sect; /* warn when section has mcount not being recorded */
<span class="p_add">+static void *file_map;	/* pointer of the mapped file */</span>
<span class="p_add">+static void *file_end;	/* pointer to the end of the mapped file */</span>
<span class="p_add">+static int file_updated; /* flag to state file was changed */</span>
<span class="p_add">+static void *file_ptr;	/* current file pointer location */</span>
<span class="p_add">+static void *file_append; /* added to the end of the file */</span>
<span class="p_add">+static size_t file_append_size; /* how much is added to end of file */</span>
 
 /* setjmp() return values */
 enum {
<span class="p_chunk">@@ -67,10 +72,14 @@</span> <span class="p_context"> static void</span>
 cleanup(void)
 {
 	if (!mmap_failed)
<span class="p_del">-		munmap(ehdr_curr, sb.st_size);</span>
<span class="p_add">+		munmap(file_map, sb.st_size);</span>
 	else
<span class="p_del">-		free(ehdr_curr);</span>
<span class="p_del">-	close(fd_map);</span>
<span class="p_add">+		free(file_map);</span>
<span class="p_add">+	file_map = NULL;</span>
<span class="p_add">+	free(file_append);</span>
<span class="p_add">+	file_append = NULL;</span>
<span class="p_add">+	file_append_size = 0;</span>
<span class="p_add">+	file_updated = 0;</span>
 }
 
 static void __attribute__((noreturn))
<span class="p_chunk">@@ -92,12 +101,22 @@</span> <span class="p_context"> succeed_file(void)</span>
 static off_t
 ulseek(int const fd, off_t const offset, int const whence)
 {
<span class="p_del">-	off_t const w = lseek(fd, offset, whence);</span>
<span class="p_del">-	if (w == (off_t)-1) {</span>
<span class="p_del">-		perror(&quot;lseek&quot;);</span>
<span class="p_add">+	switch (whence) {</span>
<span class="p_add">+	case SEEK_SET:</span>
<span class="p_add">+		file_ptr = file_map + offset;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case SEEK_CUR:</span>
<span class="p_add">+		file_ptr += offset;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case SEEK_END:</span>
<span class="p_add">+		file_ptr = file_map + (sb.st_size - offset);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (file_ptr &lt; file_map) {</span>
<span class="p_add">+		fprintf(stderr, &quot;lseek: seek before file\n&quot;);</span>
 		fail_file();
 	}
<span class="p_del">-	return w;</span>
<span class="p_add">+	return file_ptr - file_map;</span>
 }
 
 static size_t
<span class="p_chunk">@@ -114,12 +133,38 @@</span> <span class="p_context"> uread(int const fd, void *const buf, size_t const count)</span>
 static size_t
 uwrite(int const fd, void const *const buf, size_t const count)
 {
<span class="p_del">-	size_t const n = write(fd, buf, count);</span>
<span class="p_del">-	if (n != count) {</span>
<span class="p_del">-		perror(&quot;write&quot;);</span>
<span class="p_del">-		fail_file();</span>
<span class="p_add">+	size_t cnt = count;</span>
<span class="p_add">+	off_t idx = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	file_updated = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (file_ptr + count &gt;= file_end) {</span>
<span class="p_add">+		off_t aoffset = (file_ptr + count) - file_end;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (aoffset &gt; file_append_size) {</span>
<span class="p_add">+			file_append = realloc(file_append, aoffset);</span>
<span class="p_add">+			file_append_size = aoffset;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		if (!file_append) {</span>
<span class="p_add">+			perror(&quot;write&quot;);</span>
<span class="p_add">+			fail_file();</span>
<span class="p_add">+		}</span>
<span class="p_add">+		if (file_ptr &lt; file_end) {</span>
<span class="p_add">+			cnt = file_end - file_ptr;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			cnt = 0;</span>
<span class="p_add">+			idx = aoffset - count;</span>
<span class="p_add">+		}</span>
 	}
<span class="p_del">-	return n;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (cnt)</span>
<span class="p_add">+		memcpy(file_ptr, buf, cnt);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (cnt &lt; count)</span>
<span class="p_add">+		memcpy(file_append + idx, buf + cnt, count - cnt);</span>
<span class="p_add">+</span>
<span class="p_add">+	file_ptr += count;</span>
<span class="p_add">+	return count;</span>
 }
 
 static void *
<span class="p_chunk">@@ -192,9 +237,7 @@</span> <span class="p_context"> static int make_nop_arm64(void *map, size_t const offset)</span>
  */
 static void *mmap_file(char const *fname)
 {
<span class="p_del">-	void *addr;</span>
<span class="p_del">-</span>
<span class="p_del">-	fd_map = open(fname, O_RDWR);</span>
<span class="p_add">+	fd_map = open(fname, O_RDONLY);</span>
 	if (fd_map &lt; 0 || fstat(fd_map, &amp;sb) &lt; 0) {
 		perror(fname);
 		fail_file();
<span class="p_chunk">@@ -203,15 +246,58 @@</span> <span class="p_context"> static void *mmap_file(char const *fname)</span>
 		fprintf(stderr, &quot;not a regular file: %s\n&quot;, fname);
 		fail_file();
 	}
<span class="p_del">-	addr = mmap(0, sb.st_size, PROT_READ|PROT_WRITE, MAP_PRIVATE,</span>
<span class="p_del">-		    fd_map, 0);</span>
<span class="p_add">+	file_map = mmap(0, sb.st_size, PROT_READ|PROT_WRITE, MAP_PRIVATE,</span>
<span class="p_add">+			fd_map, 0);</span>
 	mmap_failed = 0;
<span class="p_del">-	if (addr == MAP_FAILED) {</span>
<span class="p_add">+	if (file_map == MAP_FAILED) {</span>
 		mmap_failed = 1;
<span class="p_del">-		addr = umalloc(sb.st_size);</span>
<span class="p_del">-		uread(fd_map, addr, sb.st_size);</span>
<span class="p_add">+		file_map = umalloc(sb.st_size);</span>
<span class="p_add">+		uread(fd_map, file_map, sb.st_size);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	close(fd_map);</span>
<span class="p_add">+</span>
<span class="p_add">+	file_end = file_map + sb.st_size;</span>
<span class="p_add">+</span>
<span class="p_add">+	return file_map;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void write_file(const char *fname)</span>
<span class="p_add">+{</span>
<span class="p_add">+	char tmp_file[strlen(fname) + 4];</span>
<span class="p_add">+	size_t n;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!file_updated)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	sprintf(tmp_file, &quot;%s.rc&quot;, fname);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * After reading the entire file into memory, delete it</span>
<span class="p_add">+	 * and write it back, to prevent weird side effects of modifying</span>
<span class="p_add">+	 * an object file in place.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	fd_map = open(tmp_file, O_WRONLY | O_TRUNC | O_CREAT, sb.st_mode);</span>
<span class="p_add">+	if (fd_map &lt; 0) {</span>
<span class="p_add">+		perror(fname);</span>
<span class="p_add">+		fail_file();</span>
<span class="p_add">+	}</span>
<span class="p_add">+	n = write(fd_map, file_map, sb.st_size);</span>
<span class="p_add">+	if (n != sb.st_size) {</span>
<span class="p_add">+		perror(&quot;write&quot;);</span>
<span class="p_add">+		fail_file();</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (file_append_size) {</span>
<span class="p_add">+		n = write(fd_map, file_append, file_append_size);</span>
<span class="p_add">+		if (n != file_append_size) {</span>
<span class="p_add">+			perror(&quot;write&quot;);</span>
<span class="p_add">+			fail_file();</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	close(fd_map);</span>
<span class="p_add">+	if (rename(tmp_file, fname) &lt; 0) {</span>
<span class="p_add">+		perror(fname);</span>
<span class="p_add">+		fail_file();</span>
 	}
<span class="p_del">-	return addr;</span>
 }
 
 /* w8rev, w8nat, ...: Handle endianness. */
<span class="p_chunk">@@ -318,7 +404,6 @@</span> <span class="p_context"> do_file(char const *const fname)</span>
 	Elf32_Ehdr *const ehdr = mmap_file(fname);
 	unsigned int reltype = 0;
 
<span class="p_del">-	ehdr_curr = ehdr;</span>
 	w = w4nat;
 	w2 = w2nat;
 	w8 = w8nat;
<span class="p_chunk">@@ -439,6 +524,7 @@</span> <span class="p_context"> do_file(char const *const fname)</span>
 	}
 	}  /* end switch */
 
<span class="p_add">+	write_file(fname);</span>
 	cleanup();
 }
 
<span class="p_chunk">@@ -491,11 +577,14 @@</span> <span class="p_context"> main(int argc, char *argv[])</span>
 		case SJ_SETJMP:    /* normal sequence */
 			/* Avoid problems if early cleanup() */
 			fd_map = -1;
<span class="p_del">-			ehdr_curr = NULL;</span>
 			mmap_failed = 1;
<span class="p_add">+			file_map = NULL;</span>
<span class="p_add">+			file_ptr = NULL;</span>
<span class="p_add">+			file_updated = 0;</span>
 			do_file(file);
 			break;
 		case SJ_FAIL:    /* error in do_file or below */
<span class="p_add">+			fprintf(stderr, &quot;%s: failed\n&quot;, file);</span>
 			++n_error;
 			break;
 		case SJ_SUCCEED:    /* premature success */
<span class="p_header">diff --git a/sound/pci/hda/hda_intel.c b/sound/pci/hda/hda_intel.c</span>
<span class="p_header">index 4d2cbe2..de2b2e2 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_intel.c</span>
<span class="p_header">+++ b/sound/pci/hda/hda_intel.c</span>
<span class="p_chunk">@@ -927,6 +927,36 @@</span> <span class="p_context"> static int azx_resume(struct device *dev)</span>
 }
 #endif /* CONFIG_PM_SLEEP || SUPPORT_VGA_SWITCHEROO */
 
<span class="p_add">+#ifdef CONFIG_PM_SLEEP</span>
<span class="p_add">+/* put codec down to D3 at hibernation for Intel SKL+;</span>
<span class="p_add">+ * otherwise BIOS may still access the codec and screw up the driver</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define IS_SKL(pci) ((pci)-&gt;vendor == 0x8086 &amp;&amp; (pci)-&gt;device == 0xa170)</span>
<span class="p_add">+#define IS_SKL_LP(pci) ((pci)-&gt;vendor == 0x8086 &amp;&amp; (pci)-&gt;device == 0x9d70)</span>
<span class="p_add">+#define IS_BXT(pci) ((pci)-&gt;vendor == 0x8086 &amp;&amp; (pci)-&gt;device == 0x5a98)</span>
<span class="p_add">+#define IS_SKL_PLUS(pci) (IS_SKL(pci) || IS_SKL_LP(pci) || IS_BXT(pci))</span>
<span class="p_add">+</span>
<span class="p_add">+static int azx_freeze_noirq(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct pci_dev *pci = to_pci_dev(dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (IS_SKL_PLUS(pci))</span>
<span class="p_add">+		pci_set_power_state(pci, PCI_D3hot);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int azx_thaw_noirq(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct pci_dev *pci = to_pci_dev(dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (IS_SKL_PLUS(pci))</span>
<span class="p_add">+		pci_set_power_state(pci, PCI_D0);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif /* CONFIG_PM_SLEEP */</span>
<span class="p_add">+</span>
 #ifdef CONFIG_PM
 static int azx_runtime_suspend(struct device *dev)
 {
<span class="p_chunk">@@ -1036,6 +1066,10 @@</span> <span class="p_context"> static int azx_runtime_idle(struct device *dev)</span>
 
 static const struct dev_pm_ops azx_pm = {
 	SET_SYSTEM_SLEEP_PM_OPS(azx_suspend, azx_resume)
<span class="p_add">+#ifdef CONFIG_PM_SLEEP</span>
<span class="p_add">+	.freeze_noirq = azx_freeze_noirq,</span>
<span class="p_add">+	.thaw_noirq = azx_thaw_noirq,</span>
<span class="p_add">+#endif</span>
 	SET_RUNTIME_PM_OPS(azx_runtime_suspend, azx_runtime_resume, azx_runtime_idle)
 };
 
<span class="p_header">diff --git a/sound/pci/hda/patch_ca0132.c b/sound/pci/hda/patch_ca0132.c</span>
<span class="p_header">index 0f039abe..470ecc8 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_ca0132.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_ca0132.c</span>
<span class="p_chunk">@@ -764,7 +764,8 @@</span> <span class="p_context"> enum {</span>
 };
 
 static const struct snd_pci_quirk ca0132_quirks[] = {
<span class="p_del">-	SND_PCI_QUIRK(0x1028, 0x0685, &quot;Alienware 15&quot;, QUIRK_ALIENWARE),</span>
<span class="p_add">+	SND_PCI_QUIRK(0x1028, 0x0685, &quot;Alienware 15 2015&quot;, QUIRK_ALIENWARE),</span>
<span class="p_add">+	SND_PCI_QUIRK(0x1028, 0x0688, &quot;Alienware 17 2015&quot;, QUIRK_ALIENWARE),</span>
 	{}
 };
 
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index 8d932d5..1e5627b 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -67,6 +67,10 @@</span> <span class="p_context"> enum {</span>
 	ALC_HEADSET_TYPE_OMTP,
 };
 
<span class="p_add">+enum {</span>
<span class="p_add">+	ALC_KEY_MICMUTE_INDEX,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 struct alc_customize_define {
 	unsigned int  sku_cfg;
 	unsigned char port_connectivity;
<span class="p_chunk">@@ -111,6 +115,7 @@</span> <span class="p_context"> struct alc_spec {</span>
 	void (*power_hook)(struct hda_codec *codec);
 #endif
 	void (*shutup)(struct hda_codec *codec);
<span class="p_add">+	void (*reboot_notify)(struct hda_codec *codec);</span>
 
 	int init_amp;
 	int codec_variant;	/* flag for other variants */
<span class="p_chunk">@@ -122,6 +127,7 @@</span> <span class="p_context"> struct alc_spec {</span>
 	unsigned int pll_coef_idx, pll_coef_bit;
 	unsigned int coef0;
 	struct input_dev *kb_dev;
<span class="p_add">+	u8 alc_mute_keycode_map[1];</span>
 };
 
 /*
<span class="p_chunk">@@ -773,6 +779,25 @@</span> <span class="p_context"> static inline void alc_shutup(struct hda_codec *codec)</span>
 		snd_hda_shutup_pins(codec);
 }
 
<span class="p_add">+static void alc_reboot_notify(struct hda_codec *codec)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct alc_spec *spec = codec-&gt;spec;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (spec &amp;&amp; spec-&gt;reboot_notify)</span>
<span class="p_add">+		spec-&gt;reboot_notify(codec);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		alc_shutup(codec);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* power down codec to D3 at reboot/shutdown; set as reboot_notify ops */</span>
<span class="p_add">+static void alc_d3_at_reboot(struct hda_codec *codec)</span>
<span class="p_add">+{</span>
<span class="p_add">+	snd_hda_codec_set_power_to_all(codec, codec-&gt;core.afg, AC_PWRST_D3);</span>
<span class="p_add">+	snd_hda_codec_write(codec, codec-&gt;core.afg, 0,</span>
<span class="p_add">+			    AC_VERB_SET_POWER_STATE, AC_PWRST_D3);</span>
<span class="p_add">+	msleep(10);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #define alc_free	snd_hda_gen_free
 
 #ifdef CONFIG_PM
<span class="p_chunk">@@ -818,7 +843,7 @@</span> <span class="p_context"> static const struct hda_codec_ops alc_patch_ops = {</span>
 	.suspend = alc_suspend,
 	.check_power_status = snd_hda_gen_check_power_status,
 #endif
<span class="p_del">-	.reboot_notify = alc_shutup,</span>
<span class="p_add">+	.reboot_notify = alc_reboot_notify,</span>
 };
 
 
<span class="p_chunk">@@ -1765,10 +1790,12 @@</span> <span class="p_context"> enum {</span>
 	ALC889_FIXUP_MBA11_VREF,
 	ALC889_FIXUP_MBA21_VREF,
 	ALC889_FIXUP_MP11_VREF,
<span class="p_add">+	ALC889_FIXUP_MP41_VREF,</span>
 	ALC882_FIXUP_INV_DMIC,
 	ALC882_FIXUP_NO_PRIMARY_HP,
 	ALC887_FIXUP_ASUS_BASS,
 	ALC887_FIXUP_BASS_CHMAP,
<span class="p_add">+	ALC882_FIXUP_DISABLE_AAMIX,</span>
 };
 
 static void alc889_fixup_coef(struct hda_codec *codec,
<span class="p_chunk">@@ -1852,7 +1879,7 @@</span> <span class="p_context"> static void alc889_fixup_mbp_vref(struct hda_codec *codec,</span>
 				  const struct hda_fixup *fix, int action)
 {
 	struct alc_spec *spec = codec-&gt;spec;
<span class="p_del">-	static hda_nid_t nids[2] = { 0x14, 0x15 };</span>
<span class="p_add">+	static hda_nid_t nids[3] = { 0x14, 0x15, 0x19 };</span>
 	int i;
 
 	if (action != HDA_FIXUP_ACT_INIT)
<span class="p_chunk">@@ -1930,6 +1957,8 @@</span> <span class="p_context"> static void alc882_fixup_no_primary_hp(struct hda_codec *codec,</span>
 
 static void alc_fixup_bass_chmap(struct hda_codec *codec,
 				 const struct hda_fixup *fix, int action);
<span class="p_add">+static void alc_fixup_disable_aamix(struct hda_codec *codec,</span>
<span class="p_add">+				    const struct hda_fixup *fix, int action);</span>
 
 static const struct hda_fixup alc882_fixups[] = {
 	[ALC882_FIXUP_ABIT_AW9D_MAX] = {
<span class="p_chunk">@@ -2140,6 +2169,12 @@</span> <span class="p_context"> static const struct hda_fixup alc882_fixups[] = {</span>
 		.chained = true,
 		.chain_id = ALC885_FIXUP_MACPRO_GPIO,
 	},
<span class="p_add">+	[ALC889_FIXUP_MP41_VREF] = {</span>
<span class="p_add">+		.type = HDA_FIXUP_FUNC,</span>
<span class="p_add">+		.v.func = alc889_fixup_mbp_vref,</span>
<span class="p_add">+		.chained = true,</span>
<span class="p_add">+		.chain_id = ALC885_FIXUP_MACPRO_GPIO,</span>
<span class="p_add">+	},</span>
 	[ALC882_FIXUP_INV_DMIC] = {
 		.type = HDA_FIXUP_FUNC,
 		.v.func = alc_fixup_inv_dmic,
<span class="p_chunk">@@ -2161,6 +2196,10 @@</span> <span class="p_context"> static const struct hda_fixup alc882_fixups[] = {</span>
 		.type = HDA_FIXUP_FUNC,
 		.v.func = alc_fixup_bass_chmap,
 	},
<span class="p_add">+	[ALC882_FIXUP_DISABLE_AAMIX] = {</span>
<span class="p_add">+		.type = HDA_FIXUP_FUNC,</span>
<span class="p_add">+		.v.func = alc_fixup_disable_aamix,</span>
<span class="p_add">+	},</span>
 };
 
 static const struct snd_pci_quirk alc882_fixup_tbl[] = {
<span class="p_chunk">@@ -2218,7 +2257,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc882_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x106b, 0x3f00, &quot;Macbook 5,1&quot;, ALC889_FIXUP_IMAC91_VREF),
 	SND_PCI_QUIRK(0x106b, 0x4000, &quot;MacbookPro 5,1&quot;, ALC889_FIXUP_IMAC91_VREF),
 	SND_PCI_QUIRK(0x106b, 0x4100, &quot;Macmini 3,1&quot;, ALC889_FIXUP_IMAC91_VREF),
<span class="p_del">-	SND_PCI_QUIRK(0x106b, 0x4200, &quot;Mac Pro 5,1&quot;, ALC885_FIXUP_MACPRO_GPIO),</span>
<span class="p_add">+	SND_PCI_QUIRK(0x106b, 0x4200, &quot;Mac Pro 4,1/5,1&quot;, ALC889_FIXUP_MP41_VREF),</span>
 	SND_PCI_QUIRK(0x106b, 0x4300, &quot;iMac 9,1&quot;, ALC889_FIXUP_IMAC91_VREF),
 	SND_PCI_QUIRK(0x106b, 0x4600, &quot;MacbookPro 5,2&quot;, ALC889_FIXUP_IMAC91_VREF),
 	SND_PCI_QUIRK(0x106b, 0x4900, &quot;iMac 9,1 Aluminum&quot;, ALC889_FIXUP_IMAC91_VREF),
<span class="p_chunk">@@ -2228,6 +2267,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc882_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x1462, 0x7350, &quot;MSI-7350&quot;, ALC889_FIXUP_CD),
 	SND_PCI_QUIRK_VENDOR(0x1462, &quot;MSI&quot;, ALC882_FIXUP_GPIO3),
 	SND_PCI_QUIRK(0x1458, 0xa002, &quot;Gigabyte EP45-DS3/Z87X-UD3H&quot;, ALC889_FIXUP_FRONT_HP_NO_PRESENCE),
<span class="p_add">+	SND_PCI_QUIRK(0x1458, 0xa182, &quot;Gigabyte Z170X-UD3&quot;, ALC882_FIXUP_DISABLE_AAMIX),</span>
 	SND_PCI_QUIRK(0x147b, 0x107a, &quot;Abit AW9D-MAX&quot;, ALC882_FIXUP_ABIT_AW9D_MAX),
 	SND_PCI_QUIRK_VENDOR(0x1558, &quot;Clevo laptop&quot;, ALC882_FIXUP_EAPD),
 	SND_PCI_QUIRK(0x161f, 0x2054, &quot;Medion laptop&quot;, ALC883_FIXUP_EAPD),
<span class="p_chunk">@@ -3437,12 +3477,43 @@</span> <span class="p_context"> static void gpio2_mic_hotkey_event(struct hda_codec *codec,</span>
 
 	/* GPIO2 just toggles on a keypress/keyrelease cycle. Therefore
 	   send both key on and key off event for every interrupt. */
<span class="p_del">-	input_report_key(spec-&gt;kb_dev, KEY_MICMUTE, 1);</span>
<span class="p_add">+	input_report_key(spec-&gt;kb_dev, spec-&gt;alc_mute_keycode_map[ALC_KEY_MICMUTE_INDEX], 1);</span>
 	input_sync(spec-&gt;kb_dev);
<span class="p_del">-	input_report_key(spec-&gt;kb_dev, KEY_MICMUTE, 0);</span>
<span class="p_add">+	input_report_key(spec-&gt;kb_dev, spec-&gt;alc_mute_keycode_map[ALC_KEY_MICMUTE_INDEX], 0);</span>
 	input_sync(spec-&gt;kb_dev);
 }
 
<span class="p_add">+static int alc_register_micmute_input_device(struct hda_codec *codec)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct alc_spec *spec = codec-&gt;spec;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	spec-&gt;kb_dev = input_allocate_device();</span>
<span class="p_add">+	if (!spec-&gt;kb_dev) {</span>
<span class="p_add">+		codec_err(codec, &quot;Out of memory (input_allocate_device)\n&quot;);</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	spec-&gt;alc_mute_keycode_map[ALC_KEY_MICMUTE_INDEX] = KEY_MICMUTE;</span>
<span class="p_add">+</span>
<span class="p_add">+	spec-&gt;kb_dev-&gt;name = &quot;Microphone Mute Button&quot;;</span>
<span class="p_add">+	spec-&gt;kb_dev-&gt;evbit[0] = BIT_MASK(EV_KEY);</span>
<span class="p_add">+	spec-&gt;kb_dev-&gt;keycodesize = sizeof(spec-&gt;alc_mute_keycode_map[0]);</span>
<span class="p_add">+	spec-&gt;kb_dev-&gt;keycodemax = ARRAY_SIZE(spec-&gt;alc_mute_keycode_map);</span>
<span class="p_add">+	spec-&gt;kb_dev-&gt;keycode = spec-&gt;alc_mute_keycode_map;</span>
<span class="p_add">+	for (i = 0; i &lt; ARRAY_SIZE(spec-&gt;alc_mute_keycode_map); i++)</span>
<span class="p_add">+		set_bit(spec-&gt;alc_mute_keycode_map[i], spec-&gt;kb_dev-&gt;keybit);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (input_register_device(spec-&gt;kb_dev)) {</span>
<span class="p_add">+		codec_err(codec, &quot;input_register_device failed\n&quot;);</span>
<span class="p_add">+		input_free_device(spec-&gt;kb_dev);</span>
<span class="p_add">+		spec-&gt;kb_dev = NULL;</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void alc280_fixup_hp_gpio2_mic_hotkey(struct hda_codec *codec,
 					     const struct hda_fixup *fix, int action)
 {
<span class="p_chunk">@@ -3460,20 +3531,8 @@</span> <span class="p_context"> static void alc280_fixup_hp_gpio2_mic_hotkey(struct hda_codec *codec,</span>
 	struct alc_spec *spec = codec-&gt;spec;
 
 	if (action == HDA_FIXUP_ACT_PRE_PROBE) {
<span class="p_del">-		spec-&gt;kb_dev = input_allocate_device();</span>
<span class="p_del">-		if (!spec-&gt;kb_dev) {</span>
<span class="p_del">-			codec_err(codec, &quot;Out of memory (input_allocate_device)\n&quot;);</span>
<span class="p_del">-			return;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		spec-&gt;kb_dev-&gt;name = &quot;Microphone Mute Button&quot;;</span>
<span class="p_del">-		spec-&gt;kb_dev-&gt;evbit[0] = BIT_MASK(EV_KEY);</span>
<span class="p_del">-		spec-&gt;kb_dev-&gt;keybit[BIT_WORD(KEY_MICMUTE)] = BIT_MASK(KEY_MICMUTE);</span>
<span class="p_del">-		if (input_register_device(spec-&gt;kb_dev)) {</span>
<span class="p_del">-			codec_err(codec, &quot;input_register_device failed\n&quot;);</span>
<span class="p_del">-			input_free_device(spec-&gt;kb_dev);</span>
<span class="p_del">-			spec-&gt;kb_dev = NULL;</span>
<span class="p_add">+		if (alc_register_micmute_input_device(codec) != 0)</span>
 			return;
<span class="p_del">-		}</span>
 
 		snd_hda_add_verbs(codec, gpio_init);
 		snd_hda_codec_write_cache(codec, codec-&gt;core.afg, 0,
<span class="p_chunk">@@ -3503,6 +3562,47 @@</span> <span class="p_context"> static void alc280_fixup_hp_gpio2_mic_hotkey(struct hda_codec *codec,</span>
 	}
 }
 
<span class="p_add">+static void alc233_fixup_lenovo_line2_mic_hotkey(struct hda_codec *codec,</span>
<span class="p_add">+					     const struct hda_fixup *fix, int action)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* Line2 = mic mute hotkey</span>
<span class="p_add">+	   GPIO2 = mic mute LED */</span>
<span class="p_add">+	static const struct hda_verb gpio_init[] = {</span>
<span class="p_add">+		{ 0x01, AC_VERB_SET_GPIO_MASK, 0x04 },</span>
<span class="p_add">+		{ 0x01, AC_VERB_SET_GPIO_DIRECTION, 0x04 },</span>
<span class="p_add">+		{}</span>
<span class="p_add">+	};</span>
<span class="p_add">+</span>
<span class="p_add">+	struct alc_spec *spec = codec-&gt;spec;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (action == HDA_FIXUP_ACT_PRE_PROBE) {</span>
<span class="p_add">+		if (alc_register_micmute_input_device(codec) != 0)</span>
<span class="p_add">+			return;</span>
<span class="p_add">+</span>
<span class="p_add">+		snd_hda_add_verbs(codec, gpio_init);</span>
<span class="p_add">+		snd_hda_jack_detect_enable_callback(codec, 0x1b,</span>
<span class="p_add">+						    gpio2_mic_hotkey_event);</span>
<span class="p_add">+</span>
<span class="p_add">+		spec-&gt;gen.cap_sync_hook = alc_fixup_gpio_mic_mute_hook;</span>
<span class="p_add">+		spec-&gt;gpio_led = 0;</span>
<span class="p_add">+		spec-&gt;mute_led_polarity = 0;</span>
<span class="p_add">+		spec-&gt;gpio_mic_led_mask = 0x04;</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!spec-&gt;kb_dev)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (action) {</span>
<span class="p_add">+	case HDA_FIXUP_ACT_PROBE:</span>
<span class="p_add">+		spec-&gt;init_amp = ALC_INIT_DEFAULT;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case HDA_FIXUP_ACT_FREE:</span>
<span class="p_add">+		input_unregister_device(spec-&gt;kb_dev);</span>
<span class="p_add">+		spec-&gt;kb_dev = NULL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void alc269_fixup_hp_line1_mic1_led(struct hda_codec *codec,
 				const struct hda_fixup *fix, int action)
 {
<span class="p_chunk">@@ -4200,6 +4300,8 @@</span> <span class="p_context"> static void alc_fixup_tpt440_dock(struct hda_codec *codec,</span>
 	struct alc_spec *spec = codec-&gt;spec;
 
 	if (action == HDA_FIXUP_ACT_PRE_PROBE) {
<span class="p_add">+		spec-&gt;shutup = alc_no_shutup; /* reduce click noise */</span>
<span class="p_add">+		spec-&gt;reboot_notify = alc_d3_at_reboot; /* reduce noise */</span>
 		spec-&gt;parse_flags = HDA_PINCFG_NO_HP_FIXUP;
 		codec-&gt;power_save_node = 0; /* avoid click noises */
 		snd_hda_apply_pincfgs(codec, pincfgs);
<span class="p_chunk">@@ -4580,6 +4682,7 @@</span> <span class="p_context"> enum {</span>
 	ALC255_FIXUP_HEADSET_MODE_NO_HP_MIC,
 	ALC293_FIXUP_DELL1_MIC_NO_PRESENCE,
 	ALC292_FIXUP_TPT440_DOCK,
<span class="p_add">+	ALC292_FIXUP_TPT440,</span>
 	ALC283_FIXUP_BXBT2807_MIC,
 	ALC255_FIXUP_DELL_WMI_MIC_MUTE_LED,
 	ALC282_FIXUP_ASPIRE_V5_PINS,
<span class="p_chunk">@@ -4595,8 +4698,12 @@</span> <span class="p_context"> enum {</span>
 	ALC288_FIXUP_DISABLE_AAMIX,
 	ALC292_FIXUP_DELL_E7X,
 	ALC292_FIXUP_DISABLE_AAMIX,
<span class="p_add">+	ALC293_FIXUP_DISABLE_AAMIX_MULTIJACK,</span>
 	ALC298_FIXUP_DELL1_MIC_NO_PRESENCE,
 	ALC275_FIXUP_DELL_XPS,
<span class="p_add">+	ALC256_FIXUP_DELL_XPS_13_HEADPHONE_NOISE,</span>
<span class="p_add">+	ALC293_FIXUP_LENOVO_SPK_NOISE,</span>
<span class="p_add">+	ALC233_FIXUP_LENOVO_LINE2_MIC_HOTKEY,</span>
 };
 
 static const struct hda_fixup alc269_fixups[] = {
<span class="p_chunk">@@ -5051,6 +5158,12 @@</span> <span class="p_context"> static const struct hda_fixup alc269_fixups[] = {</span>
 		.chained = true,
 		.chain_id = ALC269_FIXUP_LIMIT_INT_MIC_BOOST
 	},
<span class="p_add">+	[ALC292_FIXUP_TPT440] = {</span>
<span class="p_add">+		.type = HDA_FIXUP_FUNC,</span>
<span class="p_add">+		.v.func = alc_fixup_disable_aamix,</span>
<span class="p_add">+		.chained = true,</span>
<span class="p_add">+		.chain_id = ALC292_FIXUP_TPT440_DOCK,</span>
<span class="p_add">+	},</span>
 	[ALC283_FIXUP_BXBT2807_MIC] = {
 		.type = HDA_FIXUP_PINS,
 		.v.pins = (const struct hda_pintbl[]) {
<span class="p_chunk">@@ -5150,6 +5263,12 @@</span> <span class="p_context"> static const struct hda_fixup alc269_fixups[] = {</span>
 		.chained = true,
 		.chain_id = ALC269_FIXUP_DELL2_MIC_NO_PRESENCE
 	},
<span class="p_add">+	[ALC293_FIXUP_DISABLE_AAMIX_MULTIJACK] = {</span>
<span class="p_add">+		.type = HDA_FIXUP_FUNC,</span>
<span class="p_add">+		.v.func = alc_fixup_disable_aamix,</span>
<span class="p_add">+		.chained = true,</span>
<span class="p_add">+		.chain_id = ALC293_FIXUP_DELL1_MIC_NO_PRESENCE</span>
<span class="p_add">+	},</span>
 	[ALC292_FIXUP_DELL_E7X] = {
 		.type = HDA_FIXUP_FUNC,
 		.v.func = alc_fixup_dell_xps13,
<span class="p_chunk">@@ -5177,6 +5296,27 @@</span> <span class="p_context"> static const struct hda_fixup alc269_fixups[] = {</span>
 			{}
 		}
 	},
<span class="p_add">+	[ALC256_FIXUP_DELL_XPS_13_HEADPHONE_NOISE] = {</span>
<span class="p_add">+		.type = HDA_FIXUP_VERBS,</span>
<span class="p_add">+		.v.verbs = (const struct hda_verb[]) {</span>
<span class="p_add">+			/* Disable pass-through path for FRONT 14h */</span>
<span class="p_add">+			{0x20, AC_VERB_SET_COEF_INDEX, 0x36},</span>
<span class="p_add">+			{0x20, AC_VERB_SET_PROC_COEF, 0x1737},</span>
<span class="p_add">+			{}</span>
<span class="p_add">+		},</span>
<span class="p_add">+		.chained = true,</span>
<span class="p_add">+		.chain_id = ALC255_FIXUP_DELL1_MIC_NO_PRESENCE</span>
<span class="p_add">+	},</span>
<span class="p_add">+	[ALC293_FIXUP_LENOVO_SPK_NOISE] = {</span>
<span class="p_add">+		.type = HDA_FIXUP_FUNC,</span>
<span class="p_add">+		.v.func = alc_fixup_disable_aamix,</span>
<span class="p_add">+		.chained = true,</span>
<span class="p_add">+		.chain_id = ALC269_FIXUP_THINKPAD_ACPI</span>
<span class="p_add">+	},</span>
<span class="p_add">+	[ALC233_FIXUP_LENOVO_LINE2_MIC_HOTKEY] = {</span>
<span class="p_add">+		.type = HDA_FIXUP_FUNC,</span>
<span class="p_add">+		.v.func = alc233_fixup_lenovo_line2_mic_hotkey,</span>
<span class="p_add">+	},</span>
 };
 
 static const struct snd_pci_quirk alc269_fixup_tbl[] = {
<span class="p_chunk">@@ -5190,8 +5330,10 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc269_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x1025, 0x0742, &quot;Acer AO756&quot;, ALC271_FIXUP_HP_GATE_MIC_JACK),
 	SND_PCI_QUIRK(0x1025, 0x0775, &quot;Acer Aspire E1-572&quot;, ALC271_FIXUP_HP_GATE_MIC_JACK_E1_572),
 	SND_PCI_QUIRK(0x1025, 0x079b, &quot;Acer Aspire V5-573G&quot;, ALC282_FIXUP_ASPIRE_V5_PINS),
<span class="p_add">+	SND_PCI_QUIRK(0x1025, 0x106d, &quot;Acer Cloudbook 14&quot;, ALC283_FIXUP_CHROME_BOOK),</span>
 	SND_PCI_QUIRK(0x1028, 0x0470, &quot;Dell M101z&quot;, ALC269_FIXUP_DELL_M101Z),
 	SND_PCI_QUIRK(0x1028, 0x054b, &quot;Dell XPS one 2710&quot;, ALC275_FIXUP_DELL_XPS),
<span class="p_add">+	SND_PCI_QUIRK(0x1028, 0x05bd, &quot;Dell Latitude E6440&quot;, ALC292_FIXUP_DELL_E7X),</span>
 	SND_PCI_QUIRK(0x1028, 0x05ca, &quot;Dell Latitude E7240&quot;, ALC292_FIXUP_DELL_E7X),
 	SND_PCI_QUIRK(0x1028, 0x05cb, &quot;Dell Latitude E7440&quot;, ALC292_FIXUP_DELL_E7X),
 	SND_PCI_QUIRK(0x1028, 0x05da, &quot;Dell Vostro 5460&quot;, ALC290_FIXUP_SUBWOOFER),
<span class="p_chunk">@@ -5209,11 +5351,12 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc269_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x1028, 0x06c7, &quot;Dell&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x1028, 0x06d9, &quot;Dell&quot;, ALC293_FIXUP_DELL1_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x1028, 0x06da, &quot;Dell&quot;, ALC293_FIXUP_DELL1_MIC_NO_PRESENCE),
<span class="p_del">-	SND_PCI_QUIRK(0x1028, 0x06db, &quot;Dell&quot;, ALC292_FIXUP_DISABLE_AAMIX),</span>
<span class="p_del">-	SND_PCI_QUIRK(0x1028, 0x06dd, &quot;Dell&quot;, ALC292_FIXUP_DISABLE_AAMIX),</span>
<span class="p_del">-	SND_PCI_QUIRK(0x1028, 0x06de, &quot;Dell&quot;, ALC292_FIXUP_DISABLE_AAMIX),</span>
<span class="p_del">-	SND_PCI_QUIRK(0x1028, 0x06df, &quot;Dell&quot;, ALC292_FIXUP_DISABLE_AAMIX),</span>
<span class="p_del">-	SND_PCI_QUIRK(0x1028, 0x06e0, &quot;Dell&quot;, ALC292_FIXUP_DISABLE_AAMIX),</span>
<span class="p_add">+	SND_PCI_QUIRK(0x1028, 0x06db, &quot;Dell&quot;, ALC293_FIXUP_DISABLE_AAMIX_MULTIJACK),</span>
<span class="p_add">+	SND_PCI_QUIRK(0x1028, 0x06dd, &quot;Dell&quot;, ALC293_FIXUP_DISABLE_AAMIX_MULTIJACK),</span>
<span class="p_add">+	SND_PCI_QUIRK(0x1028, 0x06de, &quot;Dell&quot;, ALC293_FIXUP_DISABLE_AAMIX_MULTIJACK),</span>
<span class="p_add">+	SND_PCI_QUIRK(0x1028, 0x06df, &quot;Dell&quot;, ALC293_FIXUP_DISABLE_AAMIX_MULTIJACK),</span>
<span class="p_add">+	SND_PCI_QUIRK(0x1028, 0x06e0, &quot;Dell&quot;, ALC293_FIXUP_DISABLE_AAMIX_MULTIJACK),</span>
<span class="p_add">+	SND_PCI_QUIRK(0x1028, 0x0704, &quot;Dell XPS 13&quot;, ALC256_FIXUP_DELL_XPS_13_HEADPHONE_NOISE),</span>
 	SND_PCI_QUIRK(0x1028, 0x164a, &quot;Dell&quot;, ALC293_FIXUP_DELL1_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x1028, 0x164b, &quot;Dell&quot;, ALC293_FIXUP_DELL1_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x103c, 0x1586, &quot;HP&quot;, ALC269_FIXUP_HP_MUTE_LED_MIC2),
<span class="p_chunk">@@ -5312,15 +5455,18 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc269_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x17aa, 0x21fb, &quot;Thinkpad T430s&quot;, ALC269_FIXUP_LENOVO_DOCK),
 	SND_PCI_QUIRK(0x17aa, 0x2203, &quot;Thinkpad X230 Tablet&quot;, ALC269_FIXUP_LENOVO_DOCK),
 	SND_PCI_QUIRK(0x17aa, 0x2208, &quot;Thinkpad T431s&quot;, ALC269_FIXUP_LENOVO_DOCK),
<span class="p_del">-	SND_PCI_QUIRK(0x17aa, 0x220c, &quot;Thinkpad T440s&quot;, ALC292_FIXUP_TPT440_DOCK),</span>
<span class="p_add">+	SND_PCI_QUIRK(0x17aa, 0x220c, &quot;Thinkpad T440s&quot;, ALC292_FIXUP_TPT440),</span>
 	SND_PCI_QUIRK(0x17aa, 0x220e, &quot;Thinkpad T440p&quot;, ALC292_FIXUP_TPT440_DOCK),
 	SND_PCI_QUIRK(0x17aa, 0x2210, &quot;Thinkpad T540p&quot;, ALC292_FIXUP_TPT440_DOCK),
 	SND_PCI_QUIRK(0x17aa, 0x2211, &quot;Thinkpad W541&quot;, ALC292_FIXUP_TPT440_DOCK),
 	SND_PCI_QUIRK(0x17aa, 0x2212, &quot;Thinkpad T440&quot;, ALC292_FIXUP_TPT440_DOCK),
 	SND_PCI_QUIRK(0x17aa, 0x2214, &quot;Thinkpad X240&quot;, ALC292_FIXUP_TPT440_DOCK),
 	SND_PCI_QUIRK(0x17aa, 0x2215, &quot;Thinkpad&quot;, ALC269_FIXUP_LIMIT_INT_MIC_BOOST),
<span class="p_add">+	SND_PCI_QUIRK(0x17aa, 0x2218, &quot;Thinkpad X1 Carbon 2nd&quot;, ALC292_FIXUP_TPT440_DOCK),</span>
 	SND_PCI_QUIRK(0x17aa, 0x2223, &quot;ThinkPad T550&quot;, ALC292_FIXUP_TPT440_DOCK),
 	SND_PCI_QUIRK(0x17aa, 0x2226, &quot;ThinkPad X250&quot;, ALC292_FIXUP_TPT440_DOCK),
<span class="p_add">+	SND_PCI_QUIRK(0x17aa, 0x2233, &quot;Thinkpad&quot;, ALC293_FIXUP_LENOVO_SPK_NOISE),</span>
<span class="p_add">+	SND_PCI_QUIRK(0x17aa, 0x30bb, &quot;ThinkCentre AIO&quot;, ALC233_FIXUP_LENOVO_LINE2_MIC_HOTKEY),</span>
 	SND_PCI_QUIRK(0x17aa, 0x3977, &quot;IdeaPad S210&quot;, ALC283_FIXUP_INT_MIC),
 	SND_PCI_QUIRK(0x17aa, 0x3978, &quot;IdeaPad Y410P&quot;, ALC269_FIXUP_NO_SHUTUP),
 	SND_PCI_QUIRK(0x17aa, 0x5013, &quot;Thinkpad&quot;, ALC269_FIXUP_LIMIT_INT_MIC_BOOST),
<span class="p_chunk">@@ -5330,6 +5476,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc269_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x17aa, 0x5034, &quot;Thinkpad T450&quot;, ALC292_FIXUP_TPT440_DOCK),
 	SND_PCI_QUIRK(0x17aa, 0x5036, &quot;Thinkpad T450s&quot;, ALC292_FIXUP_TPT440_DOCK),
 	SND_PCI_QUIRK(0x17aa, 0x503c, &quot;Thinkpad L450&quot;, ALC292_FIXUP_TPT440_DOCK),
<span class="p_add">+	SND_PCI_QUIRK(0x17aa, 0x504b, &quot;Thinkpad&quot;, ALC293_FIXUP_LENOVO_SPK_NOISE),</span>
 	SND_PCI_QUIRK(0x17aa, 0x5109, &quot;Thinkpad&quot;, ALC269_FIXUP_LIMIT_INT_MIC_BOOST),
 	SND_PCI_QUIRK(0x17aa, 0x3bf8, &quot;Quanta FL1&quot;, ALC269_FIXUP_PCM_44K),
 	SND_PCI_QUIRK(0x17aa, 0x9e54, &quot;LENOVO NB&quot;, ALC269_FIXUP_LENOVO_EAPD),
<span class="p_chunk">@@ -5410,6 +5557,7 @@</span> <span class="p_context"> static const struct hda_model_fixup alc269_fixup_models[] = {</span>
 	{.id = ALC283_FIXUP_CHROME_BOOK, .name = &quot;alc283-dac-wcaps&quot;},
 	{.id = ALC283_FIXUP_SENSE_COMBO_JACK, .name = &quot;alc283-sense-combo&quot;},
 	{.id = ALC292_FIXUP_TPT440_DOCK, .name = &quot;tpt440-dock&quot;},
<span class="p_add">+	{.id = ALC292_FIXUP_TPT440, .name = &quot;tpt440&quot;},</span>
 	{}
 };
 
<span class="p_chunk">@@ -6594,6 +6742,7 @@</span> <span class="p_context"> static const struct hda_fixup alc662_fixups[] = {</span>
 static const struct snd_pci_quirk alc662_fixup_tbl[] = {
 	SND_PCI_QUIRK(0x1019, 0x9087, &quot;ECS&quot;, ALC662_FIXUP_ASUS_MODE2),
 	SND_PCI_QUIRK(0x1025, 0x022f, &quot;Acer Aspire One&quot;, ALC662_FIXUP_INV_DMIC),
<span class="p_add">+	SND_PCI_QUIRK(0x1025, 0x0241, &quot;Packard Bell DOTS&quot;, ALC662_FIXUP_INV_DMIC),</span>
 	SND_PCI_QUIRK(0x1025, 0x0308, &quot;Acer Aspire 8942G&quot;, ALC662_FIXUP_ASPIRE),
 	SND_PCI_QUIRK(0x1025, 0x031c, &quot;Gateway NV79&quot;, ALC662_FIXUP_SKU_IGNORE),
 	SND_PCI_QUIRK(0x1025, 0x0349, &quot;eMachines eM250&quot;, ALC662_FIXUP_INV_DMIC),
<span class="p_header">diff --git a/sound/pci/hda/patch_sigmatel.c b/sound/pci/hda/patch_sigmatel.c</span>
<span class="p_header">index a0798ae..14a62b8 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_sigmatel.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_sigmatel.c</span>
<span class="p_chunk">@@ -3110,6 +3110,29 @@</span> <span class="p_context"> static void stac92hd71bxx_fixup_hp_hdx(struct hda_codec *codec,</span>
 	spec-&gt;gpio_led = 0x08;
 }
 
<span class="p_add">+static bool is_hp_output(struct hda_codec *codec, hda_nid_t pin)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned int pin_cfg = snd_hda_codec_get_pincfg(codec, pin);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* count line-out, too, as BIOS sets often so */</span>
<span class="p_add">+	return get_defcfg_connect(pin_cfg) != AC_JACK_PORT_NONE &amp;&amp;</span>
<span class="p_add">+		(get_defcfg_device(pin_cfg) == AC_JACK_LINE_OUT ||</span>
<span class="p_add">+		 get_defcfg_device(pin_cfg) == AC_JACK_HP_OUT);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void fixup_hp_headphone(struct hda_codec *codec, hda_nid_t pin)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned int pin_cfg = snd_hda_codec_get_pincfg(codec, pin);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* It was changed in the BIOS to just satisfy MS DTM.</span>
<span class="p_add">+	 * Lets turn it back into slaved HP</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	pin_cfg = (pin_cfg &amp; (~AC_DEFCFG_DEVICE)) |</span>
<span class="p_add">+		(AC_JACK_HP_OUT &lt;&lt; AC_DEFCFG_DEVICE_SHIFT);</span>
<span class="p_add">+	pin_cfg = (pin_cfg &amp; (~(AC_DEFCFG_DEF_ASSOC | AC_DEFCFG_SEQUENCE))) |</span>
<span class="p_add">+		0x1f;</span>
<span class="p_add">+	snd_hda_codec_set_pincfg(codec, pin, pin_cfg);</span>
<span class="p_add">+}</span>
 
 static void stac92hd71bxx_fixup_hp(struct hda_codec *codec,
 				   const struct hda_fixup *fix, int action)
<span class="p_chunk">@@ -3119,22 +3142,12 @@</span> <span class="p_context"> static void stac92hd71bxx_fixup_hp(struct hda_codec *codec,</span>
 	if (action != HDA_FIXUP_ACT_PRE_PROBE)
 		return;
 
<span class="p_del">-	if (hp_blike_system(codec-&gt;core.subsystem_id)) {</span>
<span class="p_del">-		unsigned int pin_cfg = snd_hda_codec_get_pincfg(codec, 0x0f);</span>
<span class="p_del">-		if (get_defcfg_device(pin_cfg) == AC_JACK_LINE_OUT ||</span>
<span class="p_del">-			get_defcfg_device(pin_cfg) == AC_JACK_SPEAKER  ||</span>
<span class="p_del">-			get_defcfg_device(pin_cfg) == AC_JACK_HP_OUT) {</span>
<span class="p_del">-			/* It was changed in the BIOS to just satisfy MS DTM.</span>
<span class="p_del">-			 * Lets turn it back into slaved HP</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			pin_cfg = (pin_cfg &amp; (~AC_DEFCFG_DEVICE))</span>
<span class="p_del">-					| (AC_JACK_HP_OUT &lt;&lt;</span>
<span class="p_del">-						AC_DEFCFG_DEVICE_SHIFT);</span>
<span class="p_del">-			pin_cfg = (pin_cfg &amp; (~(AC_DEFCFG_DEF_ASSOC</span>
<span class="p_del">-							| AC_DEFCFG_SEQUENCE)))</span>
<span class="p_del">-								| 0x1f;</span>
<span class="p_del">-			snd_hda_codec_set_pincfg(codec, 0x0f, pin_cfg);</span>
<span class="p_del">-		}</span>
<span class="p_add">+	/* when both output A and F are assigned, these are supposedly</span>
<span class="p_add">+	 * dock and built-in headphones; fix both pin configs</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (is_hp_output(codec, 0x0a) &amp;&amp; is_hp_output(codec, 0x0f)) {</span>
<span class="p_add">+		fixup_hp_headphone(codec, 0x0a);</span>
<span class="p_add">+		fixup_hp_headphone(codec, 0x0f);</span>
 	}
 
 	if (find_mute_led_cfg(codec, 1))
<span class="p_header">diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c</span>
<span class="p_header">index 2306ccf..77c963c 100644</span>
<span class="p_header">--- a/sound/pci/rme96.c</span>
<span class="p_header">+++ b/sound/pci/rme96.c</span>
<span class="p_chunk">@@ -741,10 +741,11 @@</span> <span class="p_context"> snd_rme96_playback_setrate(struct rme96 *rme96,</span>
 	{
 		/* change to/from double-speed: reset the DAC (if available) */
 		snd_rme96_reset_dac(rme96);
<span class="p_add">+		return 1; /* need to restore volume */</span>
 	} else {
 		writel(rme96-&gt;wcreg, rme96-&gt;iobase + RME96_IO_CONTROL_REGISTER);
<span class="p_add">+		return 0;</span>
 	}
<span class="p_del">-	return 0;</span>
 }
 
 static int
<span class="p_chunk">@@ -980,6 +981,7 @@</span> <span class="p_context"> snd_rme96_playback_hw_params(struct snd_pcm_substream *substream,</span>
 	struct rme96 *rme96 = snd_pcm_substream_chip(substream);
 	struct snd_pcm_runtime *runtime = substream-&gt;runtime;
 	int err, rate, dummy;
<span class="p_add">+	bool apply_dac_volume = false;</span>
 
 	runtime-&gt;dma_area = (void __force *)(rme96-&gt;iobase +
 					     RME96_IO_PLAY_BUFFER);
<span class="p_chunk">@@ -993,24 +995,26 @@</span> <span class="p_context"> snd_rme96_playback_hw_params(struct snd_pcm_substream *substream,</span>
 	{
                 /* slave clock */
                 if ((int)params_rate(params) != rate) {
<span class="p_del">-			spin_unlock_irq(&amp;rme96-&gt;lock);</span>
<span class="p_del">-			return -EIO;                    </span>
<span class="p_del">-                }</span>
<span class="p_del">-	} else if ((err = snd_rme96_playback_setrate(rme96, params_rate(params))) &lt; 0) {</span>
<span class="p_del">-		spin_unlock_irq(&amp;rme96-&gt;lock);</span>
<span class="p_del">-		return err;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	if ((err = snd_rme96_playback_setformat(rme96, params_format(params))) &lt; 0) {</span>
<span class="p_del">-		spin_unlock_irq(&amp;rme96-&gt;lock);</span>
<span class="p_del">-		return err;</span>
<span class="p_add">+			err = -EIO;</span>
<span class="p_add">+			goto error;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		err = snd_rme96_playback_setrate(rme96, params_rate(params));</span>
<span class="p_add">+		if (err &lt; 0)</span>
<span class="p_add">+			goto error;</span>
<span class="p_add">+		apply_dac_volume = err &gt; 0; /* need to restore volume later? */</span>
 	}
<span class="p_add">+</span>
<span class="p_add">+	err = snd_rme96_playback_setformat(rme96, params_format(params));</span>
<span class="p_add">+	if (err &lt; 0)</span>
<span class="p_add">+		goto error;</span>
 	snd_rme96_setframelog(rme96, params_channels(params), 1);
 	if (rme96-&gt;capture_periodsize != 0) {
 		if (params_period_size(params) &lt;&lt; rme96-&gt;playback_frlog !=
 		    rme96-&gt;capture_periodsize)
 		{
<span class="p_del">-			spin_unlock_irq(&amp;rme96-&gt;lock);</span>
<span class="p_del">-			return -EBUSY;</span>
<span class="p_add">+			err = -EBUSY;</span>
<span class="p_add">+			goto error;</span>
 		}
 	}
 	rme96-&gt;playback_periodsize =
<span class="p_chunk">@@ -1021,9 +1025,16 @@</span> <span class="p_context"> snd_rme96_playback_hw_params(struct snd_pcm_substream *substream,</span>
 		rme96-&gt;wcreg &amp;= ~(RME96_WCR_PRO | RME96_WCR_DOLBY | RME96_WCR_EMP);
 		writel(rme96-&gt;wcreg |= rme96-&gt;wcreg_spdif_stream, rme96-&gt;iobase + RME96_IO_CONTROL_REGISTER);
 	}
<span class="p_add">+</span>
<span class="p_add">+	err = 0;</span>
<span class="p_add">+ error:</span>
 	spin_unlock_irq(&amp;rme96-&gt;lock);
<span class="p_del">-		</span>
<span class="p_del">-	return 0;</span>
<span class="p_add">+	if (apply_dac_volume) {</span>
<span class="p_add">+		usleep_range(3000, 10000);</span>
<span class="p_add">+		snd_rme96_apply_dac_volume(rme96);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return err;</span>
 }
 
 static int
<span class="p_header">diff --git a/sound/soc/codecs/arizona.c b/sound/soc/codecs/arizona.c</span>
<span class="p_header">index 4180827..02b1e0c 100644</span>
<span class="p_header">--- a/sound/soc/codecs/arizona.c</span>
<span class="p_header">+++ b/sound/soc/codecs/arizona.c</span>
<span class="p_chunk">@@ -1499,7 +1499,7 @@</span> <span class="p_context"> static int arizona_hw_params(struct snd_pcm_substream *substream,</span>
 	bool reconfig;
 	unsigned int aif_tx_state, aif_rx_state;
 
<span class="p_del">-	if (params_rate(params) % 8000)</span>
<span class="p_add">+	if (params_rate(params) % 4000)</span>
 		rates = &amp;arizona_44k1_bclk_rates[0];
 	else
 		rates = &amp;arizona_48k_bclk_rates[0];
<span class="p_header">diff --git a/sound/soc/codecs/es8328.c b/sound/soc/codecs/es8328.c</span>
<span class="p_header">index 6a09101..fb7b61f 100644</span>
<span class="p_header">--- a/sound/soc/codecs/es8328.c</span>
<span class="p_header">+++ b/sound/soc/codecs/es8328.c</span>
<span class="p_chunk">@@ -85,7 +85,15 @@</span> <span class="p_context"> static const DECLARE_TLV_DB_SCALE(pga_tlv, 0, 300, 0);</span>
 static const DECLARE_TLV_DB_SCALE(bypass_tlv, -1500, 300, 0);
 static const DECLARE_TLV_DB_SCALE(mic_tlv, 0, 300, 0);
 
<span class="p_del">-static const int deemph_settings[] = { 0, 32000, 44100, 48000 };</span>
<span class="p_add">+static const struct {</span>
<span class="p_add">+	int rate;</span>
<span class="p_add">+	unsigned int val;</span>
<span class="p_add">+} deemph_settings[] = {</span>
<span class="p_add">+	{ 0,     ES8328_DACCONTROL6_DEEMPH_OFF },</span>
<span class="p_add">+	{ 32000, ES8328_DACCONTROL6_DEEMPH_32k },</span>
<span class="p_add">+	{ 44100, ES8328_DACCONTROL6_DEEMPH_44_1k },</span>
<span class="p_add">+	{ 48000, ES8328_DACCONTROL6_DEEMPH_48k },</span>
<span class="p_add">+};</span>
 
 static int es8328_set_deemph(struct snd_soc_codec *codec)
 {
<span class="p_chunk">@@ -97,21 +105,22 @@</span> <span class="p_context"> static int es8328_set_deemph(struct snd_soc_codec *codec)</span>
 	 * rate.
 	 */
 	if (es8328-&gt;deemph) {
<span class="p_del">-		best = 1;</span>
<span class="p_del">-		for (i = 2; i &lt; ARRAY_SIZE(deemph_settings); i++) {</span>
<span class="p_del">-			if (abs(deemph_settings[i] - es8328-&gt;playback_fs) &lt;</span>
<span class="p_del">-			    abs(deemph_settings[best] - es8328-&gt;playback_fs))</span>
<span class="p_add">+		best = 0;</span>
<span class="p_add">+		for (i = 1; i &lt; ARRAY_SIZE(deemph_settings); i++) {</span>
<span class="p_add">+			if (abs(deemph_settings[i].rate - es8328-&gt;playback_fs) &lt;</span>
<span class="p_add">+			    abs(deemph_settings[best].rate - es8328-&gt;playback_fs))</span>
 				best = i;
 		}
 
<span class="p_del">-		val = best &lt;&lt; 1;</span>
<span class="p_add">+		val = deemph_settings[best].val;</span>
 	} else {
<span class="p_del">-		val = 0;</span>
<span class="p_add">+		val = ES8328_DACCONTROL6_DEEMPH_OFF;</span>
 	}
 
 	dev_dbg(codec-&gt;dev, &quot;Set deemphasis %d\n&quot;, val);
 
<span class="p_del">-	return snd_soc_update_bits(codec, ES8328_DACCONTROL6, 0x6, val);</span>
<span class="p_add">+	return snd_soc_update_bits(codec, ES8328_DACCONTROL6,</span>
<span class="p_add">+			ES8328_DACCONTROL6_DEEMPH_MASK, val);</span>
 }
 
 static int es8328_get_deemph(struct snd_kcontrol *kcontrol,
<span class="p_header">diff --git a/sound/soc/codecs/es8328.h b/sound/soc/codecs/es8328.h</span>
<span class="p_header">index cb36afe..156c748 100644</span>
<span class="p_header">--- a/sound/soc/codecs/es8328.h</span>
<span class="p_header">+++ b/sound/soc/codecs/es8328.h</span>
<span class="p_chunk">@@ -153,6 +153,7 @@</span> <span class="p_context"> int es8328_probe(struct device *dev, struct regmap *regmap);</span>
 #define ES8328_DACCONTROL6_CLICKFREE (1 &lt;&lt; 3)
 #define ES8328_DACCONTROL6_DAC_INVR (1 &lt;&lt; 4)
 #define ES8328_DACCONTROL6_DAC_INVL (1 &lt;&lt; 5)
<span class="p_add">+#define ES8328_DACCONTROL6_DEEMPH_MASK (3 &lt;&lt; 6)</span>
 #define ES8328_DACCONTROL6_DEEMPH_OFF (0 &lt;&lt; 6)
 #define ES8328_DACCONTROL6_DEEMPH_32k (1 &lt;&lt; 6)
 #define ES8328_DACCONTROL6_DEEMPH_44_1k (2 &lt;&lt; 6)
<span class="p_header">diff --git a/sound/soc/codecs/wm8962.c b/sound/soc/codecs/wm8962.c</span>
<span class="p_header">index c5748fd..18cbd9c 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8962.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8962.c</span>
<span class="p_chunk">@@ -365,8 +365,8 @@</span> <span class="p_context"> static struct reg_default wm8962_reg[] = {</span>
 	{ 16924, 0x0059 },   /* R16924 - HDBASS_PG_1 */
 	{ 16925, 0x999A },   /* R16925 - HDBASS_PG_0 */
 
<span class="p_del">-	{ 17048, 0x0083 },   /* R17408 - HPF_C_1 */</span>
<span class="p_del">-	{ 17049, 0x98AD },   /* R17409 - HPF_C_0 */</span>
<span class="p_add">+	{ 17408, 0x0083 },   /* R17408 - HPF_C_1 */</span>
<span class="p_add">+	{ 17409, 0x98AD },   /* R17409 - HPF_C_0 */</span>
 
 	{ 17920, 0x007F },   /* R17920 - ADCL_RETUNE_C1_1 */
 	{ 17921, 0xFFFF },   /* R17921 - ADCL_RETUNE_C1_0 */
<span class="p_header">diff --git a/sound/soc/codecs/wm8974.c b/sound/soc/codecs/wm8974.c</span>
<span class="p_header">index 33b16a7..57a8bae 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8974.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8974.c</span>
<span class="p_chunk">@@ -574,6 +574,7 @@</span> <span class="p_context"> static const struct regmap_config wm8974_regmap = {</span>
 	.max_register = WM8974_MONOMIX,
 	.reg_defaults = wm8974_reg_defaults,
 	.num_reg_defaults = ARRAY_SIZE(wm8974_reg_defaults),
<span class="p_add">+	.cache_type = REGCACHE_FLAT,</span>
 };
 
 static int wm8974_probe(struct snd_soc_codec *codec)
<span class="p_header">diff --git a/sound/soc/davinci/davinci-mcasp.c b/sound/soc/davinci/davinci-mcasp.c</span>
<span class="p_header">index b960e62..0f1a0cf 100644</span>
<span class="p_header">--- a/sound/soc/davinci/davinci-mcasp.c</span>
<span class="p_header">+++ b/sound/soc/davinci/davinci-mcasp.c</span>
<span class="p_chunk">@@ -222,8 +222,8 @@</span> <span class="p_context"> static void mcasp_start_tx(struct davinci_mcasp *mcasp)</span>
 
 	/* wait for XDATA to be cleared */
 	cnt = 0;
<span class="p_del">-	while (!(mcasp_get_reg(mcasp, DAVINCI_MCASP_TXSTAT_REG) &amp;</span>
<span class="p_del">-		 ~XRDATA) &amp;&amp; (cnt &lt; 100000))</span>
<span class="p_add">+	while ((mcasp_get_reg(mcasp, DAVINCI_MCASP_TXSTAT_REG) &amp; XRDATA) &amp;&amp;</span>
<span class="p_add">+	       (cnt &lt; 100000))</span>
 		cnt++;
 
 	/* Release TX state machine */
<span class="p_header">diff --git a/sound/soc/sh/rcar/gen.c b/sound/soc/sh/rcar/gen.c</span>
<span class="p_header">index 8c7dc51..f7a0cb7 100644</span>
<span class="p_header">--- a/sound/soc/sh/rcar/gen.c</span>
<span class="p_header">+++ b/sound/soc/sh/rcar/gen.c</span>
<span class="p_chunk">@@ -214,7 +214,7 @@</span> <span class="p_context"> static int rsnd_gen2_probe(struct platform_device *pdev,</span>
 		RSND_GEN_S_REG(SCU_SYS_STATUS0,	0x1c8),
 		RSND_GEN_S_REG(SCU_SYS_INT_EN0,	0x1cc),
 		RSND_GEN_S_REG(SCU_SYS_STATUS1,	0x1d0),
<span class="p_del">-		RSND_GEN_S_REG(SCU_SYS_INT_EN1,	0x1c4),</span>
<span class="p_add">+		RSND_GEN_S_REG(SCU_SYS_INT_EN1,	0x1d4),</span>
 		RSND_GEN_M_REG(SRC_SWRSR,	0x200,	0x40),
 		RSND_GEN_M_REG(SRC_SRCIR,	0x204,	0x40),
 		RSND_GEN_M_REG(SRC_ADINR,	0x214,	0x40),
<span class="p_header">diff --git a/sound/usb/mixer.c b/sound/usb/mixer.c</span>
<span class="p_header">index 83d6e76..761fa37 100644</span>
<span class="p_header">--- a/sound/usb/mixer.c</span>
<span class="p_header">+++ b/sound/usb/mixer.c</span>
<span class="p_chunk">@@ -1336,6 +1336,8 @@</span> <span class="p_context"> static void build_feature_ctl(struct mixer_build *state, void *raw_desc,</span>
 		}
 	}
 
<span class="p_add">+	snd_usb_mixer_fu_apply_quirk(state-&gt;mixer, cval, unitid, kctl);</span>
<span class="p_add">+</span>
 	range = (cval-&gt;max - cval-&gt;min) / cval-&gt;res;
 	/*
 	 * Are there devices with volume range more than 255? I use a bit more
<span class="p_header">diff --git a/sound/usb/mixer_maps.c b/sound/usb/mixer_maps.c</span>
<span class="p_header">index 6a803ef..ddca654 100644</span>
<span class="p_header">--- a/sound/usb/mixer_maps.c</span>
<span class="p_header">+++ b/sound/usb/mixer_maps.c</span>
<span class="p_chunk">@@ -348,13 +348,6 @@</span> <span class="p_context"> static struct usbmix_name_map bose_companion5_map[] = {</span>
 	{ 0 }	/* terminator */
 };
 
<span class="p_del">-/* Dragonfly DAC 1.2, the dB conversion factor is 1 instead of 256 */</span>
<span class="p_del">-static struct usbmix_dB_map dragonfly_1_2_dB = {0, 5000};</span>
<span class="p_del">-static struct usbmix_name_map dragonfly_1_2_map[] = {</span>
<span class="p_del">-	{ 7, NULL, .dB = &amp;dragonfly_1_2_dB },</span>
<span class="p_del">-	{ 0 }	/* terminator */</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
 /*
  * Control map entries
  */
<span class="p_chunk">@@ -470,11 +463,6 @@</span> <span class="p_context"> static struct usbmix_ctl_map usbmix_ctl_maps[] = {</span>
 		.id = USB_ID(0x05a7, 0x1020),
 		.map = bose_companion5_map,
 	},
<span class="p_del">-	{</span>
<span class="p_del">-		/* Dragonfly DAC 1.2 */</span>
<span class="p_del">-		.id = USB_ID(0x21b4, 0x0081),</span>
<span class="p_del">-		.map = dragonfly_1_2_map,</span>
<span class="p_del">-	},</span>
 	{ 0 } /* terminator */
 };
 
<span class="p_header">diff --git a/sound/usb/mixer_quirks.c b/sound/usb/mixer_quirks.c</span>
<span class="p_header">index 337c317..48a7450 100644</span>
<span class="p_header">--- a/sound/usb/mixer_quirks.c</span>
<span class="p_header">+++ b/sound/usb/mixer_quirks.c</span>
<span class="p_chunk">@@ -37,6 +37,7 @@</span> <span class="p_context"></span>
 #include &lt;sound/control.h&gt;
 #include &lt;sound/hwdep.h&gt;
 #include &lt;sound/info.h&gt;
<span class="p_add">+#include &lt;sound/tlv.h&gt;</span>
 
 #include &quot;usbaudio.h&quot;
 #include &quot;mixer.h&quot;
<span class="p_chunk">@@ -1843,3 +1844,39 @@</span> <span class="p_context"> void snd_usb_mixer_rc_memory_change(struct usb_mixer_interface *mixer,</span>
 	}
 }
 
<span class="p_add">+static void snd_dragonfly_quirk_db_scale(struct usb_mixer_interface *mixer,</span>
<span class="p_add">+					 struct snd_kcontrol *kctl)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* Approximation using 10 ranges based on output measurement on hw v1.2.</span>
<span class="p_add">+	 * This seems close to the cubic mapping e.g. alsamixer uses. */</span>
<span class="p_add">+	static const DECLARE_TLV_DB_RANGE(scale,</span>
<span class="p_add">+		 0,  1, TLV_DB_MINMAX_ITEM(-5300, -4970),</span>
<span class="p_add">+		 2,  5, TLV_DB_MINMAX_ITEM(-4710, -4160),</span>
<span class="p_add">+		 6,  7, TLV_DB_MINMAX_ITEM(-3884, -3710),</span>
<span class="p_add">+		 8, 14, TLV_DB_MINMAX_ITEM(-3443, -2560),</span>
<span class="p_add">+		15, 16, TLV_DB_MINMAX_ITEM(-2475, -2324),</span>
<span class="p_add">+		17, 19, TLV_DB_MINMAX_ITEM(-2228, -2031),</span>
<span class="p_add">+		20, 26, TLV_DB_MINMAX_ITEM(-1910, -1393),</span>
<span class="p_add">+		27, 31, TLV_DB_MINMAX_ITEM(-1322, -1032),</span>
<span class="p_add">+		32, 40, TLV_DB_MINMAX_ITEM(-968, -490),</span>
<span class="p_add">+		41, 50, TLV_DB_MINMAX_ITEM(-441, 0),</span>
<span class="p_add">+	);</span>
<span class="p_add">+</span>
<span class="p_add">+	usb_audio_info(mixer-&gt;chip, &quot;applying DragonFly dB scale quirk\n&quot;);</span>
<span class="p_add">+	kctl-&gt;tlv.p = scale;</span>
<span class="p_add">+	kctl-&gt;vd[0].access |= SNDRV_CTL_ELEM_ACCESS_TLV_READ;</span>
<span class="p_add">+	kctl-&gt;vd[0].access &amp;= ~SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void snd_usb_mixer_fu_apply_quirk(struct usb_mixer_interface *mixer,</span>
<span class="p_add">+				  struct usb_mixer_elem_info *cval, int unitid,</span>
<span class="p_add">+				  struct snd_kcontrol *kctl)</span>
<span class="p_add">+{</span>
<span class="p_add">+	switch (mixer-&gt;chip-&gt;usb_id) {</span>
<span class="p_add">+	case USB_ID(0x21b4, 0x0081): /* AudioQuest DragonFly */</span>
<span class="p_add">+		if (unitid == 7 &amp;&amp; cval-&gt;min == 0 &amp;&amp; cval-&gt;max == 50)</span>
<span class="p_add">+			snd_dragonfly_quirk_db_scale(mixer, kctl);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_header">diff --git a/sound/usb/mixer_quirks.h b/sound/usb/mixer_quirks.h</span>
<span class="p_header">index bdbfab0..177c329 100644</span>
<span class="p_header">--- a/sound/usb/mixer_quirks.h</span>
<span class="p_header">+++ b/sound/usb/mixer_quirks.h</span>
<span class="p_chunk">@@ -9,5 +9,9 @@</span> <span class="p_context"> void snd_emuusb_set_samplerate(struct snd_usb_audio *chip,</span>
 void snd_usb_mixer_rc_memory_change(struct usb_mixer_interface *mixer,
 				    int unitid);
 
<span class="p_add">+void snd_usb_mixer_fu_apply_quirk(struct usb_mixer_interface *mixer,</span>
<span class="p_add">+				  struct usb_mixer_elem_info *cval, int unitid,</span>
<span class="p_add">+				  struct snd_kcontrol *kctl);</span>
<span class="p_add">+</span>
 #endif /* SND_USB_MIXER_QUIRKS_H */
 
<span class="p_header">diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c</span>
<span class="p_header">index eef9b8e..c73c379 100644</span>
<span class="p_header">--- a/sound/usb/quirks.c</span>
<span class="p_header">+++ b/sound/usb/quirks.c</span>
<span class="p_chunk">@@ -1122,6 +1122,7 @@</span> <span class="p_context"> bool snd_usb_get_sample_rate_quirk(struct snd_usb_audio *chip)</span>
 	case USB_ID(0x045E, 0x0779): /* MS Lifecam HD-3000 */
 	case USB_ID(0x04D8, 0xFEEA): /* Benchmark DAC1 Pre */
 	case USB_ID(0x074D, 0x3553): /* Outlaw RR2150 (Micronas UAC3553B) */
<span class="p_add">+	case USB_ID(0x21B4, 0x0081): /* AudioQuest DragonFly */</span>
 		return true;
 	}
 	return false;
<span class="p_header">diff --git a/tools/Makefile b/tools/Makefile</span>
<span class="p_header">index d6f307d..681292b 100644</span>
<span class="p_header">--- a/tools/Makefile</span>
<span class="p_header">+++ b/tools/Makefile</span>
<span class="p_chunk">@@ -32,6 +32,10 @@</span> <span class="p_context"> help:</span>
 	@echo &#39;  from the kernel command line to build and install one of&#39;
 	@echo &#39;  the tools above&#39;
 	@echo &#39;&#39;
<span class="p_add">+	@echo &#39;  $$ make tools/all&#39;</span>
<span class="p_add">+	@echo &#39;&#39;</span>
<span class="p_add">+	@echo &#39;  builds all tools.&#39;</span>
<span class="p_add">+	@echo &#39;&#39;</span>
 	@echo &#39;  $$ make tools/install&#39;
 	@echo &#39;&#39;
 	@echo &#39;  installs all tools.&#39;
<span class="p_chunk">@@ -77,6 +81,11 @@</span> <span class="p_context"> tmon: FORCE</span>
 freefall: FORCE
 	$(call descend,laptop/$@)
 
<span class="p_add">+all: acpi cgroup cpupower hv firewire lguest \</span>
<span class="p_add">+		perf selftests turbostat usb \</span>
<span class="p_add">+		virtio vm net x86_energy_perf_policy \</span>
<span class="p_add">+		tmon freefall</span>
<span class="p_add">+</span>
 acpi_install:
 	$(call descend,power/$(@:_install=),install)
 
<span class="p_header">diff --git a/tools/perf/util/dso.c b/tools/perf/util/dso.c</span>
<span class="p_header">index 7c0c083..425df5c 100644</span>
<span class="p_header">--- a/tools/perf/util/dso.c</span>
<span class="p_header">+++ b/tools/perf/util/dso.c</span>
<span class="p_chunk">@@ -933,6 +933,7 @@</span> <span class="p_context"> static struct dso *__dso__findlink_by_longname(struct rb_root *root,</span>
 		/* Add new node and rebalance tree */
 		rb_link_node(&amp;dso-&gt;rb_node, parent, p);
 		rb_insert_color(&amp;dso-&gt;rb_node, root);
<span class="p_add">+		dso-&gt;root = root;</span>
 	}
 	return NULL;
 }
<span class="p_chunk">@@ -945,15 +946,30 @@</span> <span class="p_context"> static inline struct dso *__dso__find_by_longname(struct rb_root *root,</span>
 
 void dso__set_long_name(struct dso *dso, const char *name, bool name_allocated)
 {
<span class="p_add">+	struct rb_root *root = dso-&gt;root;</span>
<span class="p_add">+</span>
 	if (name == NULL)
 		return;
 
 	if (dso-&gt;long_name_allocated)
 		free((char *)dso-&gt;long_name);
 
<span class="p_add">+	if (root) {</span>
<span class="p_add">+		rb_erase(&amp;dso-&gt;rb_node, root);</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * __dso__findlink_by_longname() isn&#39;t guaranteed to add it</span>
<span class="p_add">+		 * back, so a clean removal is required here.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		RB_CLEAR_NODE(&amp;dso-&gt;rb_node);</span>
<span class="p_add">+		dso-&gt;root = NULL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	dso-&gt;long_name		 = name;
 	dso-&gt;long_name_len	 = strlen(name);
 	dso-&gt;long_name_allocated = name_allocated;
<span class="p_add">+</span>
<span class="p_add">+	if (root)</span>
<span class="p_add">+		__dso__findlink_by_longname(root, dso, NULL);</span>
 }
 
 void dso__set_short_name(struct dso *dso, const char *name, bool name_allocated)
<span class="p_chunk">@@ -1046,6 +1062,7 @@</span> <span class="p_context"> struct dso *dso__new(const char *name)</span>
 		dso-&gt;kernel = DSO_TYPE_USER;
 		dso-&gt;needs_swap = DSO_SWAP__UNSET;
 		RB_CLEAR_NODE(&amp;dso-&gt;rb_node);
<span class="p_add">+		dso-&gt;root = NULL;</span>
 		INIT_LIST_HEAD(&amp;dso-&gt;node);
 		INIT_LIST_HEAD(&amp;dso-&gt;data.open_entry);
 		pthread_mutex_init(&amp;dso-&gt;lock, NULL);
<span class="p_header">diff --git a/tools/perf/util/dso.h b/tools/perf/util/dso.h</span>
<span class="p_header">index 2fe98bb..b9ec6d8 100644</span>
<span class="p_header">--- a/tools/perf/util/dso.h</span>
<span class="p_header">+++ b/tools/perf/util/dso.h</span>
<span class="p_chunk">@@ -135,6 +135,7 @@</span> <span class="p_context"> struct dso {</span>
 	pthread_mutex_t	 lock;
 	struct list_head node;
 	struct rb_node	 rb_node;	/* rbtree node sorted by long name */
<span class="p_add">+	struct rb_root	 *root;		/* root of rbtree that rb_node is in */</span>
 	struct rb_root	 symbols[MAP__NR_TYPES];
 	struct rb_root	 symbol_names[MAP__NR_TYPES];
 	void		 *a2l;
<span class="p_header">diff --git a/tools/perf/util/machine.c b/tools/perf/util/machine.c</span>
<span class="p_header">index f1a4c83..69c17dc 100644</span>
<span class="p_header">--- a/tools/perf/util/machine.c</span>
<span class="p_header">+++ b/tools/perf/util/machine.c</span>
<span class="p_chunk">@@ -90,6 +90,7 @@</span> <span class="p_context"> static void dsos__purge(struct dsos *dsos)</span>
 
 	list_for_each_entry_safe(pos, n, &amp;dsos-&gt;head, node) {
 		RB_CLEAR_NODE(&amp;pos-&gt;rb_node);
<span class="p_add">+		pos-&gt;root = NULL;</span>
 		list_del_init(&amp;pos-&gt;node);
 		dso__put(pos);
 	}

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



