
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[3.19.y-ckt,stable] Linux 3.19.8-ckt12 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [3.19.y-ckt,stable] Linux 3.19.8-ckt12</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=7718">Kamal Mostafa</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Dec. 21, 2015, 9:48 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1450734539-21730-2-git-send-email-kamal@canonical.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/7898391/mbox/"
   >mbox</a>
|
   <a href="/patch/7898391/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/7898391/">/patch/7898391/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork1.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork1.web.kernel.org (Postfix) with ESMTP id 87C589F318
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 21 Dec 2015 21:49:44 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id C85C020274
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 21 Dec 2015 21:49:36 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id E7A302058E
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 21 Dec 2015 21:49:28 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1752352AbbLUVtZ (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Mon, 21 Dec 2015 16:49:25 -0500
Received: from youngberry.canonical.com ([91.189.89.112]:60152 &quot;EHLO
	youngberry.canonical.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1752263AbbLUVtG (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Mon, 21 Dec 2015 16:49:06 -0500
Received: from 1.general.kamal.us.vpn ([10.172.68.52] helo=fourier)
	by youngberry.canonical.com with esmtpsa
	(TLS1.0:DHE_RSA_AES_128_CBC_SHA1:16) (Exim 4.76)
	(envelope-from &lt;kamal@canonical.com&gt;)
	id 1aB8KF-00045r-4I; Mon, 21 Dec 2015 21:49:03 +0000
Received: from kamal by fourier with local (Exim 4.82)
	(envelope-from &lt;kamal@whence.com&gt;)
	id 1aB8KC-0005f6-Ro; Mon, 21 Dec 2015 13:49:00 -0800
From: Kamal Mostafa &lt;kamal@canonical.com&gt;
To: linux-kernel@vger.kernel.org, stable@vger.kernel.org,
	kernel-team@lists.ubuntu.com
Cc: lwn@lwn.net
Subject: Re: [3.19.y-ckt stable] Linux 3.19.8-ckt12
Date: Mon, 21 Dec 2015 13:48:59 -0800
Message-Id: &lt;1450734539-21730-2-git-send-email-kamal@canonical.com&gt;
X-Mailer: git-send-email 1.9.1
In-Reply-To: &lt;1450734539-21730-1-git-send-email-kamal@canonical.com&gt;
References: &lt;1450734539-21730-1-git-send-email-kamal@canonical.com&gt;
X-Extended-Stable: 3.19
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-6.9 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7718">Kamal Mostafa</a> - Dec. 21, 2015, 9:48 p.m.</div>
<pre class="content">
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index d160d27..921cb4a 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,7 +1,7 @@</span> <span class="p_context"></span>
 VERSION = 3
 PATCHLEVEL = 19
 SUBLEVEL = 8
<span class="p_del">-EXTRAVERSION = -ckt11</span>
<span class="p_add">+EXTRAVERSION = -ckt12</span>
 NAME = Sedated Swine
 
 # *DOCUMENTATION*
<span class="p_header">diff --git a/arch/arc/kernel/unwind.c b/arch/arc/kernel/unwind.c</span>
<span class="p_header">index e550b11..2d6a36e 100644</span>
<span class="p_header">--- a/arch/arc/kernel/unwind.c</span>
<span class="p_header">+++ b/arch/arc/kernel/unwind.c</span>
<span class="p_chunk">@@ -986,42 +986,13 @@</span> <span class="p_context"> int arc_unwind(struct unwind_frame_info *frame)</span>
 							    (const u8 *)(fde +
 									 1) +
 							    *fde, ptrType);
<span class="p_del">-				if (pc &gt;= endLoc)</span>
<span class="p_add">+				if (pc &gt;= endLoc) {</span>
 					fde = NULL;
<span class="p_del">-			} else</span>
<span class="p_del">-				fde = NULL;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		if (fde == NULL) {</span>
<span class="p_del">-			for (fde = table-&gt;address, tableSize = table-&gt;size;</span>
<span class="p_del">-			     cie = NULL, tableSize &gt; sizeof(*fde)</span>
<span class="p_del">-			     &amp;&amp; tableSize - sizeof(*fde) &gt;= *fde;</span>
<span class="p_del">-			     tableSize -= sizeof(*fde) + *fde,</span>
<span class="p_del">-			     fde += 1 + *fde / sizeof(*fde)) {</span>
<span class="p_del">-				cie = cie_for_fde(fde, table);</span>
<span class="p_del">-				if (cie == &amp;bad_cie) {</span>
 					cie = NULL;
<span class="p_del">-					break;</span>
 				}
<span class="p_del">-				if (cie == NULL</span>
<span class="p_del">-				    || cie == &amp;not_fde</span>
<span class="p_del">-				    || (ptrType = fde_pointer_type(cie)) &lt; 0)</span>
<span class="p_del">-					continue;</span>
<span class="p_del">-				ptr = (const u8 *)(fde + 2);</span>
<span class="p_del">-				startLoc = read_pointer(&amp;ptr,</span>
<span class="p_del">-							(const u8 *)(fde + 1) +</span>
<span class="p_del">-							*fde, ptrType);</span>
<span class="p_del">-				if (!startLoc)</span>
<span class="p_del">-					continue;</span>
<span class="p_del">-				if (!(ptrType &amp; DW_EH_PE_indirect))</span>
<span class="p_del">-					ptrType &amp;=</span>
<span class="p_del">-					    DW_EH_PE_FORM | DW_EH_PE_signed;</span>
<span class="p_del">-				endLoc =</span>
<span class="p_del">-				    startLoc + read_pointer(&amp;ptr,</span>
<span class="p_del">-							    (const u8 *)(fde +</span>
<span class="p_del">-									 1) +</span>
<span class="p_del">-							    *fde, ptrType);</span>
<span class="p_del">-				if (pc &gt;= startLoc &amp;&amp; pc &lt; endLoc)</span>
<span class="p_del">-					break;</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				fde = NULL;</span>
<span class="p_add">+				cie = NULL;</span>
 			}
 		}
 	}
<span class="p_header">diff --git a/arch/arm/boot/dts/kirkwood-ts219.dtsi b/arch/arm/boot/dts/kirkwood-ts219.dtsi</span>
<span class="p_header">index df7f152..8e15b36 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/kirkwood-ts219.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/kirkwood-ts219.dtsi</span>
<span class="p_chunk">@@ -40,7 +40,7 @@</span> <span class="p_context"></span>
 		};
 		poweroff@12100 {
 			compatible = &quot;qnap,power-off&quot;;
<span class="p_del">-			reg = &lt;0x12000 0x100&gt;;</span>
<span class="p_add">+			reg = &lt;0x12100 0x100&gt;;</span>
 			clocks = &lt;&amp;gate_clk 7&gt;;
 		};
 		spi@10600 {
<span class="p_header">diff --git a/arch/arm/boot/dts/vfxxx.dtsi b/arch/arm/boot/dts/vfxxx.dtsi</span>
<span class="p_header">index 505969a..26efcd29 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/vfxxx.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/vfxxx.dtsi</span>
<span class="p_chunk">@@ -128,7 +128,7 @@</span> <span class="p_context"></span>
 				reg = &lt;0x4002c000 0x1000&gt;;
 				clocks = &lt;&amp;clks VF610_CLK_DSPI0&gt;;
 				clock-names = &quot;dspi&quot;;
<span class="p_del">-				spi-num-chipselects = &lt;5&gt;;</span>
<span class="p_add">+				spi-num-chipselects = &lt;6&gt;;</span>
 				status = &quot;disabled&quot;;
 			};
 
<span class="p_header">diff --git a/arch/arm/kvm/mmu.c b/arch/arm/kvm/mmu.c</span>
<span class="p_header">index 0512ed4..966f8d2 100644</span>
<span class="p_header">--- a/arch/arm/kvm/mmu.c</span>
<span class="p_header">+++ b/arch/arm/kvm/mmu.c</span>
<span class="p_chunk">@@ -78,6 +78,11 @@</span> <span class="p_context"> static void kvm_flush_dcache_pud(pud_t pud)</span>
 	__kvm_flush_dcache_pud(pud);
 }
 
<span class="p_add">+static bool kvm_is_device_pfn(unsigned long pfn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return !pfn_valid(pfn);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int mmu_topup_memory_cache(struct kvm_mmu_memory_cache *cache,
 				  int min, int max)
 {
<span class="p_chunk">@@ -174,7 +179,7 @@</span> <span class="p_context"> static void unmap_ptes(struct kvm *kvm, pmd_t *pmd,</span>
 			kvm_tlb_flush_vmid_ipa(kvm, addr);
 
 			/* No need to invalidate the cache for device mappings */
<span class="p_del">-			if ((pte_val(old_pte) &amp; PAGE_S2_DEVICE) != PAGE_S2_DEVICE)</span>
<span class="p_add">+			if (!kvm_is_device_pfn(pte_pfn(old_pte)))</span>
 				kvm_flush_dcache_pte(old_pte);
 
 			put_page(virt_to_page(pte));
<span class="p_chunk">@@ -266,8 +271,7 @@</span> <span class="p_context"> static void stage2_flush_ptes(struct kvm *kvm, pmd_t *pmd,</span>
 
 	pte = pte_offset_kernel(pmd, addr);
 	do {
<span class="p_del">-		if (!pte_none(*pte) &amp;&amp;</span>
<span class="p_del">-		    (pte_val(*pte) &amp; PAGE_S2_DEVICE) != PAGE_S2_DEVICE)</span>
<span class="p_add">+		if (!pte_none(*pte) &amp;&amp; !kvm_is_device_pfn(pte_pfn(*pte)))</span>
 			kvm_flush_dcache_pte(*pte);
 	} while (pte++, addr += PAGE_SIZE, addr != end);
 }
<span class="p_chunk">@@ -983,11 +987,6 @@</span> <span class="p_context"> static bool kvm_is_write_fault(struct kvm_vcpu *vcpu)</span>
 	return kvm_vcpu_dabt_iswrite(vcpu);
 }
 
<span class="p_del">-static bool kvm_is_device_pfn(unsigned long pfn)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return !pfn_valid(pfn);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static void coherent_cache_guest_page(struct kvm_vcpu *vcpu, pfn_t pfn,
 				      unsigned long size, bool uncached)
 {
<span class="p_header">diff --git a/arch/arm/mach-dove/include/mach/entry-macro.S b/arch/arm/mach-dove/include/mach/entry-macro.S</span>
<span class="p_header">index 72d622b..df1d44b 100644</span>
<span class="p_header">--- a/arch/arm/mach-dove/include/mach/entry-macro.S</span>
<span class="p_header">+++ b/arch/arm/mach-dove/include/mach/entry-macro.S</span>
<span class="p_chunk">@@ -18,13 +18,13 @@</span> <span class="p_context"></span>
 	@ check low interrupts
 	ldr	\irqstat, [\base, #IRQ_CAUSE_LOW_OFF]
 	ldr	\tmp, [\base, #IRQ_MASK_LOW_OFF]
<span class="p_del">-	mov	\irqnr, #31</span>
<span class="p_add">+	mov	\irqnr, #32</span>
 	ands	\irqstat, \irqstat, \tmp
 
 	@ if no low interrupts set, check high interrupts
 	ldreq	\irqstat, [\base, #IRQ_CAUSE_HIGH_OFF]
 	ldreq	\tmp, [\base, #IRQ_MASK_HIGH_OFF]
<span class="p_del">-	moveq	\irqnr, #63</span>
<span class="p_add">+	moveq	\irqnr, #64</span>
 	andeqs	\irqstat, \irqstat, \tmp
 
 	@ find first active interrupt source
<span class="p_header">diff --git a/arch/arm/mach-orion5x/include/mach/entry-macro.S b/arch/arm/mach-orion5x/include/mach/entry-macro.S</span>
<span class="p_header">index 79eb502..73919a3 100644</span>
<span class="p_header">--- a/arch/arm/mach-orion5x/include/mach/entry-macro.S</span>
<span class="p_header">+++ b/arch/arm/mach-orion5x/include/mach/entry-macro.S</span>
<span class="p_chunk">@@ -21,5 +21,5 @@</span> <span class="p_context"></span>
 	@ find cause bits that are unmasked
 	ands	\irqstat, \irqstat, \tmp	@ clear Z flag if any
 	clzne	\irqnr,	\irqstat		@ calc irqnr
<span class="p_del">-	rsbne	\irqnr, \irqnr, #31</span>
<span class="p_add">+	rsbne	\irqnr, \irqnr, #32</span>
 	.endm
<span class="p_header">diff --git a/arch/arm64/include/asm/kvm_emulate.h b/arch/arm64/include/asm/kvm_emulate.h</span>
<span class="p_header">index 3cb4c85..a1050f7 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/kvm_emulate.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/kvm_emulate.h</span>
<span class="p_chunk">@@ -96,11 +96,13 @@</span> <span class="p_context"> static inline void vcpu_set_thumb(struct kvm_vcpu *vcpu)</span>
 	*vcpu_cpsr(vcpu) |= COMPAT_PSR_T_BIT;
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * vcpu_reg should always be passed a register number coming from a</span>
<span class="p_add">+ * read of ESR_EL2. Otherwise, it may give the wrong result on AArch32</span>
<span class="p_add">+ * with banked registers.</span>
<span class="p_add">+ */</span>
 static inline unsigned long *vcpu_reg(const struct kvm_vcpu *vcpu, u8 reg_num)
 {
<span class="p_del">-	if (vcpu_mode_is_32bit(vcpu))</span>
<span class="p_del">-		return vcpu_reg32(vcpu, reg_num);</span>
<span class="p_del">-</span>
 	return (unsigned long *)&amp;vcpu_gp_regs(vcpu)-&gt;regs.regs[reg_num];
 }
 
<span class="p_header">diff --git a/arch/arm64/kernel/setup.c b/arch/arm64/kernel/setup.c</span>
<span class="p_header">index 79fedd8d..386acb8 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/setup.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/setup.c</span>
<span class="p_chunk">@@ -520,6 +520,9 @@</span> <span class="p_context"> static int c_show(struct seq_file *m, void *v)</span>
 #ifdef CONFIG_SMP
 		seq_printf(m, &quot;processor\t: %d\n&quot;, i);
 #endif
<span class="p_add">+		seq_printf(m, &quot;BogoMIPS\t: %lu.%02lu\n\n&quot;,</span>
<span class="p_add">+			   loops_per_jiffy / (500000UL/HZ),</span>
<span class="p_add">+			   loops_per_jiffy / (5000UL/HZ) % 100);</span>
 
 		/*
 		 * Dump out the common processor features in a single line.
<span class="p_header">diff --git a/arch/arm64/kernel/suspend.c b/arch/arm64/kernel/suspend.c</span>
<span class="p_header">index 2d6b606..23e35de 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/suspend.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/suspend.c</span>
<span class="p_chunk">@@ -1,3 +1,4 @@</span> <span class="p_context"></span>
<span class="p_add">+#include &lt;linux/ftrace.h&gt;</span>
 #include &lt;linux/percpu.h&gt;
 #include &lt;linux/slab.h&gt;
 #include &lt;asm/cacheflush.h&gt;
<span class="p_chunk">@@ -92,6 +93,13 @@</span> <span class="p_context"> int __cpu_suspend(unsigned long arg, int (*fn)(unsigned long))</span>
 	local_dbg_save(flags);
 
 	/*
<span class="p_add">+	 * Function graph tracer state gets incosistent when the kernel</span>
<span class="p_add">+	 * calls functions that never return (aka suspend finishers) hence</span>
<span class="p_add">+	 * disable graph tracing during their execution.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	pause_graph_tracing();</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
 	 * mm context saved on the stack, it will be restored when
 	 * the cpu comes out of reset through the identity mapped
 	 * page tables, so that the thread address space is properly
<span class="p_chunk">@@ -128,6 +136,8 @@</span> <span class="p_context"> int __cpu_suspend(unsigned long arg, int (*fn)(unsigned long))</span>
 			hw_breakpoint_restore(NULL);
 	}
 
<span class="p_add">+	unpause_graph_tracing();</span>
<span class="p_add">+</span>
 	/*
 	 * Restore pstate flags. OS lock and mdscr have been already
 	 * restored, so from this point onwards, debugging is fully
<span class="p_header">diff --git a/arch/arm64/kvm/inject_fault.c b/arch/arm64/kvm/inject_fault.c</span>
<span class="p_header">index 86825f88..f527a37 100644</span>
<span class="p_header">--- a/arch/arm64/kvm/inject_fault.c</span>
<span class="p_header">+++ b/arch/arm64/kvm/inject_fault.c</span>
<span class="p_chunk">@@ -48,7 +48,7 @@</span> <span class="p_context"> static void prepare_fault32(struct kvm_vcpu *vcpu, u32 mode, u32 vect_offset)</span>
 
 	/* Note: These now point to the banked copies */
 	*vcpu_spsr(vcpu) = new_spsr_value;
<span class="p_del">-	*vcpu_reg(vcpu, 14) = *vcpu_pc(vcpu) + return_offset;</span>
<span class="p_add">+	*vcpu_reg32(vcpu, 14) = *vcpu_pc(vcpu) + return_offset;</span>
 
 	/* Branch to exception vector */
 	if (sctlr &amp; (1 &lt;&lt; 13))
<span class="p_header">diff --git a/arch/mips/kvm/emulate.c b/arch/mips/kvm/emulate.c</span>
<span class="p_header">index 838d3a6..3d44b2d 100644</span>
<span class="p_header">--- a/arch/mips/kvm/emulate.c</span>
<span class="p_header">+++ b/arch/mips/kvm/emulate.c</span>
<span class="p_chunk">@@ -1407,7 +1407,7 @@</span> <span class="p_context"> enum emulation_result kvm_mips_emulate_cache(uint32_t inst, uint32_t *opc,</span>
 
 	base = (inst &gt;&gt; 21) &amp; 0x1f;
 	op_inst = (inst &gt;&gt; 16) &amp; 0x1f;
<span class="p_del">-	offset = inst &amp; 0xffff;</span>
<span class="p_add">+	offset = (int16_t)inst;</span>
 	cache = (inst &gt;&gt; 16) &amp; 0x3;
 	op = (inst &gt;&gt; 18) &amp; 0x7;
 
<span class="p_header">diff --git a/arch/mips/kvm/locore.S b/arch/mips/kvm/locore.S</span>
<span class="p_header">index 4a68b17..c6b11ef 100644</span>
<span class="p_header">--- a/arch/mips/kvm/locore.S</span>
<span class="p_header">+++ b/arch/mips/kvm/locore.S</span>
<span class="p_chunk">@@ -163,9 +163,11 @@</span> <span class="p_context"> FEXPORT(__kvm_mips_vcpu_run)</span>
 
 FEXPORT(__kvm_mips_load_asid)
 	/* Set the ASID for the Guest Kernel */
<span class="p_del">-	INT_SLL	t0, t0, 1	/* with kseg0 @ 0x40000000, kernel */</span>
<span class="p_del">-			        /* addresses shift to 0x80000000 */</span>
<span class="p_del">-	bltz	t0, 1f		/* If kernel */</span>
<span class="p_add">+	PTR_L	t0, VCPU_COP0(k1)</span>
<span class="p_add">+	LONG_L	t0, COP0_STATUS(t0)</span>
<span class="p_add">+	andi	t0, KSU_USER | ST0_ERL | ST0_EXL</span>
<span class="p_add">+	xori	t0, KSU_USER</span>
<span class="p_add">+	bnez	t0, 1f		/* If kernel */</span>
 	 INT_ADDIU t1, k1, VCPU_GUEST_KERNEL_ASID  /* (BD)  */
 	INT_ADDIU t1, k1, VCPU_GUEST_USER_ASID    /* else user */
 1:
<span class="p_chunk">@@ -444,9 +446,11 @@</span> <span class="p_context"> __kvm_mips_return_to_guest:</span>
 	mtc0	t0, CP0_EPC
 
 	/* Set the ASID for the Guest Kernel */
<span class="p_del">-	INT_SLL	t0, t0, 1	/* with kseg0 @ 0x40000000, kernel */</span>
<span class="p_del">-				/* addresses shift to 0x80000000 */</span>
<span class="p_del">-	bltz	t0, 1f		/* If kernel */</span>
<span class="p_add">+	PTR_L	t0, VCPU_COP0(k1)</span>
<span class="p_add">+	LONG_L	t0, COP0_STATUS(t0)</span>
<span class="p_add">+	andi	t0, KSU_USER | ST0_ERL | ST0_EXL</span>
<span class="p_add">+	xori	t0, KSU_USER</span>
<span class="p_add">+	bnez	t0, 1f		/* If kernel */</span>
 	 INT_ADDIU t1, k1, VCPU_GUEST_KERNEL_ASID  /* (BD)  */
 	INT_ADDIU t1, k1, VCPU_GUEST_USER_ASID    /* else user */
 1:
<span class="p_header">diff --git a/arch/mips/kvm/mips.c b/arch/mips/kvm/mips.c</span>
<span class="p_header">index a53eaf5..b7f253f 100644</span>
<span class="p_header">--- a/arch/mips/kvm/mips.c</span>
<span class="p_header">+++ b/arch/mips/kvm/mips.c</span>
<span class="p_chunk">@@ -271,7 +271,7 @@</span> <span class="p_context"> struct kvm_vcpu *kvm_arch_vcpu_create(struct kvm *kvm, unsigned int id)</span>
 
 	if (!gebase) {
 		err = -ENOMEM;
<span class="p_del">-		goto out_free_cpu;</span>
<span class="p_add">+		goto out_uninit_cpu;</span>
 	}
 	kvm_debug(&quot;Allocated %d bytes for KVM Exception Handlers @ %p\n&quot;,
 		  ALIGN(size, PAGE_SIZE), gebase);
<span class="p_chunk">@@ -335,6 +335,9 @@</span> <span class="p_context"> struct kvm_vcpu *kvm_arch_vcpu_create(struct kvm *kvm, unsigned int id)</span>
 out_free_gebase:
 	kfree(gebase);
 
<span class="p_add">+out_uninit_cpu:</span>
<span class="p_add">+	kvm_vcpu_uninit(vcpu);</span>
<span class="p_add">+</span>
 out_free_cpu:
 	kfree(vcpu);
 
<span class="p_header">diff --git a/arch/parisc/include/uapi/asm/mman.h b/arch/parisc/include/uapi/asm/mman.h</span>
<span class="p_header">index 294d251..2ae13ce5 100644</span>
<span class="p_header">--- a/arch/parisc/include/uapi/asm/mman.h</span>
<span class="p_header">+++ b/arch/parisc/include/uapi/asm/mman.h</span>
<span class="p_chunk">@@ -46,16 +46,6 @@</span> <span class="p_context"></span>
 #define MADV_DONTFORK	10		/* don&#39;t inherit across fork */
 #define MADV_DOFORK	11		/* do inherit across fork */
 
<span class="p_del">-/* The range 12-64 is reserved for page size specification. */</span>
<span class="p_del">-#define MADV_4K_PAGES   12              /* Use 4K pages  */</span>
<span class="p_del">-#define MADV_16K_PAGES  14              /* Use 16K pages */</span>
<span class="p_del">-#define MADV_64K_PAGES  16              /* Use 64K pages */</span>
<span class="p_del">-#define MADV_256K_PAGES 18              /* Use 256K pages */</span>
<span class="p_del">-#define MADV_1M_PAGES   20              /* Use 1 Megabyte pages */</span>
<span class="p_del">-#define MADV_4M_PAGES   22              /* Use 4 Megabyte pages */</span>
<span class="p_del">-#define MADV_16M_PAGES  24              /* Use 16 Megabyte pages */</span>
<span class="p_del">-#define MADV_64M_PAGES  26              /* Use 64 Megabyte pages */</span>
<span class="p_del">-</span>
 #define MADV_MERGEABLE   65		/* KSM may merge identical pages */
 #define MADV_UNMERGEABLE 66		/* KSM may not merge identical pages */
 
<span class="p_header">diff --git a/arch/powerpc/include/asm/reg.h b/arch/powerpc/include/asm/reg.h</span>
<span class="p_header">index 1c874fb..f5d03cf 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/reg.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/reg.h</span>
<span class="p_chunk">@@ -108,6 +108,7 @@</span> <span class="p_context"></span>
 #define MSR_TS_T	__MASK(MSR_TS_T_LG)	/*  Transaction Transactional */
 #define MSR_TS_MASK	(MSR_TS_T | MSR_TS_S)   /* Transaction State bits */
 #define MSR_TM_ACTIVE(x) (((x) &amp; MSR_TS_MASK) != 0) /* Transaction active? */
<span class="p_add">+#define MSR_TM_RESV(x) (((x) &amp; MSR_TS_MASK) == MSR_TS_MASK) /* Reserved */</span>
 #define MSR_TM_TRANSACTIONAL(x)	(((x) &amp; MSR_TS_MASK) == MSR_TS_T)
 #define MSR_TM_SUSPENDED(x)	(((x) &amp; MSR_TS_MASK) == MSR_TS_S)
 
<span class="p_header">diff --git a/arch/powerpc/kernel/process.c b/arch/powerpc/kernel/process.c</span>
<span class="p_header">index b4cc7be..320c584 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/process.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/process.c</span>
<span class="p_chunk">@@ -554,6 +554,24 @@</span> <span class="p_context"> static void tm_reclaim_thread(struct thread_struct *thr,</span>
 		msr_diff &amp;= MSR_FP | MSR_VEC | MSR_VSX | MSR_FE0 | MSR_FE1;
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Use the current MSR TM suspended bit to track if we have</span>
<span class="p_add">+	 * checkpointed state outstanding.</span>
<span class="p_add">+	 * On signal delivery, we&#39;d normally reclaim the checkpointed</span>
<span class="p_add">+	 * state to obtain stack pointer (see:get_tm_stackpointer()).</span>
<span class="p_add">+	 * This will then directly return to userspace without going</span>
<span class="p_add">+	 * through __switch_to(). However, if the stack frame is bad,</span>
<span class="p_add">+	 * we need to exit this thread which calls __switch_to() which</span>
<span class="p_add">+	 * will again attempt to reclaim the already saved tm state.</span>
<span class="p_add">+	 * Hence we need to check that we&#39;ve not already reclaimed</span>
<span class="p_add">+	 * this state.</span>
<span class="p_add">+	 * We do this using the current MSR, rather tracking it in</span>
<span class="p_add">+	 * some specific thread_struct bit, as it has the additional</span>
<span class="p_add">+	 * benifit of checking for a potential TM bad thing exception.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!MSR_TM_SUSPENDED(mfmsr()))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	tm_reclaim(thr, thr-&gt;regs-&gt;msr, cause);
 
 	/* Having done the reclaim, we now have the checkpointed
<span class="p_header">diff --git a/arch/powerpc/kernel/signal_32.c b/arch/powerpc/kernel/signal_32.c</span>
<span class="p_header">index b171001..abad089 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/signal_32.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/signal_32.c</span>
<span class="p_chunk">@@ -875,6 +875,15 @@</span> <span class="p_context"> static long restore_tm_user_regs(struct pt_regs *regs,</span>
 		return 1;
 #endif /* CONFIG_SPE */
 
<span class="p_add">+	/* Get the top half of the MSR from the user context */</span>
<span class="p_add">+	if (__get_user(msr_hi, &amp;tm_sr-&gt;mc_gregs[PT_MSR]))</span>
<span class="p_add">+		return 1;</span>
<span class="p_add">+	msr_hi &lt;&lt;= 32;</span>
<span class="p_add">+	/* If TM bits are set to the reserved value, it&#39;s an invalid context */</span>
<span class="p_add">+	if (MSR_TM_RESV(msr_hi))</span>
<span class="p_add">+		return 1;</span>
<span class="p_add">+	/* Pull in the MSR TM bits from the user context */</span>
<span class="p_add">+	regs-&gt;msr = (regs-&gt;msr &amp; ~MSR_TS_MASK) | (msr_hi &amp; MSR_TS_MASK);</span>
 	/* Now, recheckpoint.  This loads up all of the checkpointed (older)
 	 * registers, including FP and V[S]Rs.  After recheckpointing, the
 	 * transactional versions should be loaded.
<span class="p_chunk">@@ -884,11 +893,6 @@</span> <span class="p_context"> static long restore_tm_user_regs(struct pt_regs *regs,</span>
 	current-&gt;thread.tm_texasr |= TEXASR_FS;
 	/* This loads the checkpointed FP/VEC state, if used */
 	tm_recheckpoint(&amp;current-&gt;thread, msr);
<span class="p_del">-	/* Get the top half of the MSR */</span>
<span class="p_del">-	if (__get_user(msr_hi, &amp;tm_sr-&gt;mc_gregs[PT_MSR]))</span>
<span class="p_del">-		return 1;</span>
<span class="p_del">-	/* Pull in MSR TM from user context */</span>
<span class="p_del">-	regs-&gt;msr = (regs-&gt;msr &amp; ~MSR_TS_MASK) | ((msr_hi&lt;&lt;32) &amp; MSR_TS_MASK);</span>
 
 	/* This loads the speculative FP/VEC state, if used */
 	if (msr &amp; MSR_FP) {
<span class="p_header">diff --git a/arch/powerpc/kernel/signal_64.c b/arch/powerpc/kernel/signal_64.c</span>
<span class="p_header">index 2cb0c94..98131b3 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/signal_64.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/signal_64.c</span>
<span class="p_chunk">@@ -427,6 +427,10 @@</span> <span class="p_context"> static long restore_tm_sigcontexts(struct pt_regs *regs,</span>
 
 	/* get MSR separately, transfer the LE bit if doing signal return */
 	err |= __get_user(msr, &amp;sc-&gt;gp_regs[PT_MSR]);
<span class="p_add">+	/* Don&#39;t allow reserved mode. */</span>
<span class="p_add">+	if (MSR_TM_RESV(msr))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	/* pull in MSR TM from user context */
 	regs-&gt;msr = (regs-&gt;msr &amp; ~MSR_TS_MASK) | (msr &amp; MSR_TS_MASK);
 
<span class="p_header">diff --git a/arch/s390/kvm/interrupt.c b/arch/s390/kvm/interrupt.c</span>
<span class="p_header">index 07da75c..befe999 100644</span>
<span class="p_header">--- a/arch/s390/kvm/interrupt.c</span>
<span class="p_header">+++ b/arch/s390/kvm/interrupt.c</span>
<span class="p_chunk">@@ -1060,6 +1060,10 @@</span> <span class="p_context"> static int __inject_sigp_emergency(struct kvm_vcpu *vcpu,</span>
 	trace_kvm_s390_inject_vcpu(vcpu-&gt;vcpu_id, KVM_S390_INT_EMERGENCY,
 				   emerg-&gt;code, 0, 2);
 
<span class="p_add">+	/* sending vcpu invalid */</span>
<span class="p_add">+	if (kvm_get_vcpu_by_id(vcpu-&gt;kvm, emerg.code) == NULL)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	set_bit(emerg-&gt;code, li-&gt;sigp_emerg_pending);
 	set_bit(IRQ_PEND_EXT_EMERGENCY, &amp;li-&gt;pending_irqs);
 	atomic_set_mask(CPUSTAT_EXT_INT, li-&gt;cpuflags);
<span class="p_header">diff --git a/arch/s390/kvm/sigp.c b/arch/s390/kvm/sigp.c</span>
<span class="p_header">index 6651f9f..7ca07cb 100644</span>
<span class="p_header">--- a/arch/s390/kvm/sigp.c</span>
<span class="p_header">+++ b/arch/s390/kvm/sigp.c</span>
<span class="p_chunk">@@ -317,12 +317,8 @@</span> <span class="p_context"> static int handle_sigp_dst(struct kvm_vcpu *vcpu, u8 order_code,</span>
 			   u16 cpu_addr, u32 parameter, u64 *status_reg)
 {
 	int rc;
<span class="p_del">-	struct kvm_vcpu *dst_vcpu;</span>
<span class="p_add">+	struct kvm_vcpu *dst_vcpu = kvm_get_vcpu_by_id(vcpu-&gt;kvm, cpu_addr);</span>
 
<span class="p_del">-	if (cpu_addr &gt;= KVM_MAX_VCPUS)</span>
<span class="p_del">-		return SIGP_CC_NOT_OPERATIONAL;</span>
<span class="p_del">-</span>
<span class="p_del">-	dst_vcpu = kvm_get_vcpu(vcpu-&gt;kvm, cpu_addr);</span>
 	if (!dst_vcpu)
 		return SIGP_CC_NOT_OPERATIONAL;
 
<span class="p_chunk">@@ -452,7 +448,7 @@</span> <span class="p_context"> int kvm_s390_handle_sigp_pei(struct kvm_vcpu *vcpu)</span>
 	trace_kvm_s390_handle_sigp_pei(vcpu, order_code, cpu_addr);
 
 	if (order_code == SIGP_EXTERNAL_CALL) {
<span class="p_del">-		dest_vcpu = kvm_get_vcpu(vcpu-&gt;kvm, cpu_addr);</span>
<span class="p_add">+		dest_vcpu = kvm_get_vcpu_by_id(vcpu-&gt;kvm, cpu_addr);</span>
 		BUG_ON(dest_vcpu == NULL);
 
 		kvm_s390_vcpu_wakeup(dest_vcpu);
<span class="p_header">diff --git a/arch/x86/include/asm/mmu_context.h b/arch/x86/include/asm/mmu_context.h</span>
<span class="p_header">index 1ab38a4..acdeb2be 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/mmu_context.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/mmu_context.h</span>
<span class="p_chunk">@@ -165,6 +165,19 @@</span> <span class="p_context"> static inline void arch_exit_mmap(struct mm_struct *mm)</span>
 	paravirt_arch_exit_mmap(mm);
 }
 
<span class="p_add">+#ifdef CONFIG_X86_64</span>
<span class="p_add">+static inline bool is_64bit_mm(struct mm_struct *mm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return	!config_enabled(CONFIG_IA32_EMULATION) ||</span>
<span class="p_add">+		!(mm-&gt;context.ia32_compat == TIF_IA32);</span>
<span class="p_add">+}</span>
<span class="p_add">+#else</span>
<span class="p_add">+static inline bool is_64bit_mm(struct mm_struct *mm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 static inline void arch_bprm_mm_init(struct mm_struct *mm,
 		struct vm_area_struct *vma)
 {
<span class="p_header">diff --git a/arch/x86/include/asm/mpx.h b/arch/x86/include/asm/mpx.h</span>
<span class="p_header">index a952a13d..2857144 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/mpx.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/mpx.h</span>
<span class="p_chunk">@@ -46,7 +46,6 @@</span> <span class="p_context"></span>
 #define MPX_BNDCFG_TAIL		12
 #define MPX_BNDSTA_ADDR_MASK	(~((1UL&lt;&lt;MPX_BNDSTA_TAIL)-1))
 #define MPX_BNDCFG_ADDR_MASK	(~((1UL&lt;&lt;MPX_BNDCFG_TAIL)-1))
<span class="p_del">-#define MPX_BT_ADDR_MASK	(~((1UL&lt;&lt;MPX_BD_ENTRY_TAIL)-1))</span>
 
 #define MPX_BNDCFG_ADDR_MASK	(~((1UL&lt;&lt;MPX_BNDCFG_TAIL)-1))
 #define MPX_BNDSTA_ERROR_CODE	0x3
<span class="p_header">diff --git a/arch/x86/kernel/cpu/common.c b/arch/x86/kernel/cpu/common.c</span>
<span class="p_header">index 382a097..547ba45 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/common.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/common.c</span>
<span class="p_chunk">@@ -290,10 +290,9 @@</span> <span class="p_context"> __setup(&quot;nosmap&quot;, setup_disable_smap);</span>
 
 static __always_inline void setup_smap(struct cpuinfo_x86 *c)
 {
<span class="p_del">-	unsigned long eflags;</span>
<span class="p_add">+	unsigned long eflags = native_save_fl();</span>
 
 	/* This should have been cleared long ago */
<span class="p_del">-	raw_local_save_flags(eflags);</span>
 	BUG_ON(eflags &amp; X86_EFLAGS_AC);
 
 	if (cpu_has(c, X86_FEATURE_SMAP)) {
<span class="p_header">diff --git a/arch/x86/kernel/signal.c b/arch/x86/kernel/signal.c</span>
<span class="p_header">index ed37a76..11577f5 100644</span>
<span class="p_header">--- a/arch/x86/kernel/signal.c</span>
<span class="p_header">+++ b/arch/x86/kernel/signal.c</span>
<span class="p_chunk">@@ -684,12 +684,15 @@</span> <span class="p_context"> handle_signal(struct ksignal *ksig, struct pt_regs *regs)</span>
 	signal_setup_done(failed, ksig, test_thread_flag(TIF_SINGLESTEP));
 }
 
<span class="p_del">-#ifdef CONFIG_X86_32</span>
<span class="p_del">-#define NR_restart_syscall	__NR_restart_syscall</span>
<span class="p_del">-#else /* !CONFIG_X86_32 */</span>
<span class="p_del">-#define NR_restart_syscall	\</span>
<span class="p_del">-	test_thread_flag(TIF_IA32) ? __NR_ia32_restart_syscall : __NR_restart_syscall</span>
<span class="p_del">-#endif /* CONFIG_X86_32 */</span>
<span class="p_add">+static inline unsigned long get_nr_restart_syscall(const struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+#if defined(CONFIG_X86_32) || !defined(CONFIG_X86_64)</span>
<span class="p_add">+	return __NR_restart_syscall;</span>
<span class="p_add">+#else /* !CONFIG_X86_32 &amp;&amp; CONFIG_X86_64 */</span>
<span class="p_add">+	return test_thread_flag(TIF_IA32) ? __NR_ia32_restart_syscall :</span>
<span class="p_add">+		__NR_restart_syscall | (regs-&gt;orig_ax &amp; __X32_SYSCALL_BIT);</span>
<span class="p_add">+#endif /* CONFIG_X86_32 || !CONFIG_X86_64 */</span>
<span class="p_add">+}</span>
 
 /*
  * Note that &#39;init&#39; is a special process: it doesn&#39;t get signals it doesn&#39;t
<span class="p_chunk">@@ -718,7 +721,7 @@</span> <span class="p_context"> static void do_signal(struct pt_regs *regs)</span>
 			break;
 
 		case -ERESTART_RESTARTBLOCK:
<span class="p_del">-			regs-&gt;ax = NR_restart_syscall;</span>
<span class="p_add">+			regs-&gt;ax = get_nr_restart_syscall(regs);</span>
 			regs-&gt;ip -= 2;
 			break;
 		}
<span class="p_header">diff --git a/arch/x86/kernel/uprobes.c b/arch/x86/kernel/uprobes.c</span>
<span class="p_header">index 8b96a94..6b1ca70 100644</span>
<span class="p_header">--- a/arch/x86/kernel/uprobes.c</span>
<span class="p_header">+++ b/arch/x86/kernel/uprobes.c</span>
<span class="p_chunk">@@ -29,6 +29,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/kdebug.h&gt;
 #include &lt;asm/processor.h&gt;
 #include &lt;asm/insn.h&gt;
<span class="p_add">+#include &lt;asm/mmu_context.h&gt;</span>
 
 /* Post-execution fixups. */
 
<span class="p_chunk">@@ -245,11 +246,6 @@</span> <span class="p_context"> static int uprobe_init_insn(struct arch_uprobe *auprobe, struct insn *insn, bool</span>
 }
 
 #ifdef CONFIG_X86_64
<span class="p_del">-static inline bool is_64bit_mm(struct mm_struct *mm)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return	!config_enabled(CONFIG_IA32_EMULATION) ||</span>
<span class="p_del">-		!(mm-&gt;context.ia32_compat == TIF_IA32);</span>
<span class="p_del">-}</span>
 /*
  * If arch_uprobe-&gt;insn doesn&#39;t use rip-relative addressing, return
  * immediately.  Otherwise, rewrite the instruction so that it accesses
<span class="p_chunk">@@ -430,10 +426,6 @@</span> <span class="p_context"> static void riprel_post_xol(struct arch_uprobe *auprobe, struct pt_regs *regs)</span>
 	}
 }
 #else /* 32-bit: */
<span class="p_del">-static inline bool is_64bit_mm(struct mm_struct *mm)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return false;</span>
<span class="p_del">-}</span>
 /*
  * No RIP-relative addressing on 32-bit
  */
<span class="p_header">diff --git a/arch/x86/kernel/xsave.c b/arch/x86/kernel/xsave.c</span>
<span class="p_header">index 8be1e17..8c2b709 100644</span>
<span class="p_header">--- a/arch/x86/kernel/xsave.c</span>
<span class="p_header">+++ b/arch/x86/kernel/xsave.c</span>
<span class="p_chunk">@@ -432,20 +432,19 @@</span> <span class="p_context"> int __restore_xstate_sig(void __user *buf, void __user *buf_fx, int size)</span>
  */
 static void prepare_fx_sw_frame(void)
 {
<span class="p_del">-	int fsave_header_size = sizeof(struct i387_fsave_struct);</span>
 	int size = xstate_size + FP_XSTATE_MAGIC2_SIZE;
 
<span class="p_del">-	if (config_enabled(CONFIG_X86_32))</span>
<span class="p_del">-		size += fsave_header_size;</span>
<span class="p_del">-</span>
 	fx_sw_reserved.magic1 = FP_XSTATE_MAGIC1;
 	fx_sw_reserved.extended_size = size;
 	fx_sw_reserved.xstate_bv = pcntxt_mask;
 	fx_sw_reserved.xstate_size = xstate_size;
 
<span class="p_del">-	if (config_enabled(CONFIG_IA32_EMULATION)) {</span>
<span class="p_add">+	if (config_enabled(CONFIG_IA32_EMULATION) ||</span>
<span class="p_add">+	    config_enabled(CONFIG_X86_32)) {</span>
<span class="p_add">+		int fsave_header_size = sizeof(struct i387_fsave_struct);</span>
<span class="p_add">+</span>
 		fx_sw_reserved_ia32 = fx_sw_reserved;
<span class="p_del">-		fx_sw_reserved_ia32.extended_size += fsave_header_size;</span>
<span class="p_add">+		fx_sw_reserved_ia32.extended_size = size + fsave_header_size;</span>
 	}
 }
 
<span class="p_header">diff --git a/arch/x86/mm/mpx.c b/arch/x86/mm/mpx.c</span>
<span class="p_header">index 4d1c11c..feda8ca 100644</span>
<span class="p_header">--- a/arch/x86/mm/mpx.c</span>
<span class="p_header">+++ b/arch/x86/mm/mpx.c</span>
<span class="p_chunk">@@ -120,19 +120,19 @@</span> <span class="p_context"> static int get_reg_offset(struct insn *insn, struct pt_regs *regs,</span>
 	switch (type) {
 	case REG_TYPE_RM:
 		regno = X86_MODRM_RM(insn-&gt;modrm.value);
<span class="p_del">-		if (X86_REX_B(insn-&gt;rex_prefix.value) == 1)</span>
<span class="p_add">+		if (X86_REX_B(insn-&gt;rex_prefix.value))</span>
 			regno += 8;
 		break;
 
 	case REG_TYPE_INDEX:
 		regno = X86_SIB_INDEX(insn-&gt;sib.value);
<span class="p_del">-		if (X86_REX_X(insn-&gt;rex_prefix.value) == 1)</span>
<span class="p_add">+		if (X86_REX_X(insn-&gt;rex_prefix.value))</span>
 			regno += 8;
 		break;
 
 	case REG_TYPE_BASE:
 		regno = X86_SIB_BASE(insn-&gt;sib.value);
<span class="p_del">-		if (X86_REX_B(insn-&gt;rex_prefix.value) == 1)</span>
<span class="p_add">+		if (X86_REX_B(insn-&gt;rex_prefix.value))</span>
 			regno += 8;
 		break;
 
<span class="p_chunk">@@ -409,6 +409,7 @@</span> <span class="p_context"> static int allocate_bt(long __user *bd_entry)</span>
 	unsigned long expected_old_val = 0;
 	unsigned long actual_old_val = 0;
 	unsigned long bt_addr;
<span class="p_add">+	unsigned long bd_new_entry;</span>
 	int ret = 0;
 
 	/*
<span class="p_chunk">@@ -421,7 +422,7 @@</span> <span class="p_context"> static int allocate_bt(long __user *bd_entry)</span>
 	/*
 	 * Set the valid flag (kinda like _PAGE_PRESENT in a pte)
 	 */
<span class="p_del">-	bt_addr = bt_addr | MPX_BD_ENTRY_VALID_FLAG;</span>
<span class="p_add">+	bd_new_entry = bt_addr | MPX_BD_ENTRY_VALID_FLAG;</span>
 
 	/*
 	 * Go poke the address of the new bounds table in to the
<span class="p_chunk">@@ -435,7 +436,7 @@</span> <span class="p_context"> static int allocate_bt(long __user *bd_entry)</span>
 	 * of the MPX code that have to pagefault_disable().
 	 */
 	ret = user_atomic_cmpxchg_inatomic(&amp;actual_old_val, bd_entry,
<span class="p_del">-					   expected_old_val, bt_addr);</span>
<span class="p_add">+					   expected_old_val, bd_new_entry);</span>
 	if (ret)
 		goto out_unmap;
 
<span class="p_chunk">@@ -465,7 +466,7 @@</span> <span class="p_context"> static int allocate_bt(long __user *bd_entry)</span>
 	}
 	return 0;
 out_unmap:
<span class="p_del">-	vm_munmap(bt_addr &amp; MPX_BT_ADDR_MASK, MPX_BT_SIZE_BYTES);</span>
<span class="p_add">+	vm_munmap(bt_addr, MPX_BT_SIZE_BYTES);</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -554,29 +555,78 @@</span> <span class="p_context"> static int mpx_resolve_fault(long __user *addr, int write)</span>
 	return 0;
 }
 
<span class="p_add">+static unsigned long mpx_bd_entry_to_bt_addr(struct mm_struct *mm,</span>
<span class="p_add">+					     unsigned long bd_entry)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long bt_addr = bd_entry;</span>
<span class="p_add">+	int align_to_bytes;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Bit 0 in a bt_entry is always the valid bit.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	bt_addr &amp;= ~MPX_BD_ENTRY_VALID_FLAG;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Tables are naturally aligned at 8-byte boundaries</span>
<span class="p_add">+	 * on 64-bit and 4-byte boundaries on 32-bit.  The</span>
<span class="p_add">+	 * documentation makes it appear that the low bits</span>
<span class="p_add">+	 * are ignored by the hardware, so we do the same.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (is_64bit_mm(mm))</span>
<span class="p_add">+		align_to_bytes = 8;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		align_to_bytes = 4;</span>
<span class="p_add">+	bt_addr &amp;= ~(align_to_bytes-1);</span>
<span class="p_add">+	return bt_addr;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * We only want to do a 4-byte get_user() on 32-bit.  Otherwise,</span>
<span class="p_add">+ * we might run off the end of the bounds table if we are on</span>
<span class="p_add">+ * a 64-bit kernel and try to get 8 bytes.</span>
<span class="p_add">+ */</span>
<span class="p_add">+int get_user_bd_entry(struct mm_struct *mm, unsigned long *bd_entry_ret,</span>
<span class="p_add">+		long __user *bd_entry_ptr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 bd_entry_32;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (is_64bit_mm(mm))</span>
<span class="p_add">+		return get_user(*bd_entry_ret, bd_entry_ptr);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Note that get_user() uses the type of the *pointer* to</span>
<span class="p_add">+	 * establish the size of the get, not the destination.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ret = get_user(bd_entry_32, (u32 __user *)bd_entry_ptr);</span>
<span class="p_add">+	*bd_entry_ret = bd_entry_32;</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * Get the base of bounds tables pointed by specific bounds
  * directory entry.
  */
 static int get_bt_addr(struct mm_struct *mm,
<span class="p_del">-			long __user *bd_entry, unsigned long *bt_addr)</span>
<span class="p_add">+			long __user *bd_entry_ptr,</span>
<span class="p_add">+			unsigned long *bt_addr_result)</span>
 {
 	int ret;
 	int valid_bit;
<span class="p_add">+	unsigned long bd_entry;</span>
<span class="p_add">+	unsigned long bt_addr;</span>
 
<span class="p_del">-	if (!access_ok(VERIFY_READ, (bd_entry), sizeof(*bd_entry)))</span>
<span class="p_add">+	if (!access_ok(VERIFY_READ, (bd_entry_ptr), sizeof(*bd_entry_ptr)))</span>
 		return -EFAULT;
 
 	while (1) {
 		int need_write = 0;
 
 		pagefault_disable();
<span class="p_del">-		ret = get_user(*bt_addr, bd_entry);</span>
<span class="p_add">+		ret = get_user_bd_entry(mm, &amp;bd_entry, bd_entry_ptr);</span>
 		pagefault_enable();
 		if (!ret)
 			break;
 		if (ret == -EFAULT)
<span class="p_del">-			ret = mpx_resolve_fault(bd_entry, need_write);</span>
<span class="p_add">+			ret = mpx_resolve_fault(bd_entry_ptr, need_write);</span>
 		/*
 		 * If we could not resolve the fault, consider it
 		 * userspace&#39;s fault and error out.
<span class="p_chunk">@@ -585,8 +635,8 @@</span> <span class="p_context"> static int get_bt_addr(struct mm_struct *mm,</span>
 			return ret;
 	}
 
<span class="p_del">-	valid_bit = *bt_addr &amp; MPX_BD_ENTRY_VALID_FLAG;</span>
<span class="p_del">-	*bt_addr &amp;= MPX_BT_ADDR_MASK;</span>
<span class="p_add">+	valid_bit = bd_entry &amp; MPX_BD_ENTRY_VALID_FLAG;</span>
<span class="p_add">+	bt_addr = mpx_bd_entry_to_bt_addr(mm, bd_entry);</span>
 
 	/*
 	 * When the kernel is managing bounds tables, a bounds directory
<span class="p_chunk">@@ -595,7 +645,7 @@</span> <span class="p_context"> static int get_bt_addr(struct mm_struct *mm,</span>
 	 * data in the address field, we know something is wrong. This
 	 * -EINVAL return will cause a SIGSEGV.
 	 */
<span class="p_del">-	if (!valid_bit &amp;&amp; *bt_addr)</span>
<span class="p_add">+	if (!valid_bit &amp;&amp; bt_addr)</span>
 		return -EINVAL;
 	/*
 	 * Do we have an completely zeroed bt entry?  That is OK.  It
<span class="p_chunk">@@ -606,6 +656,7 @@</span> <span class="p_context"> static int get_bt_addr(struct mm_struct *mm,</span>
 	if (!valid_bit)
 		return -ENOENT;
 
<span class="p_add">+	*bt_addr_result = bt_addr;</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/block/blk-core.c b/block/blk-core.c</span>
<span class="p_header">index 3ad4055..adb49b4 100644</span>
<span class="p_header">--- a/block/blk-core.c</span>
<span class="p_header">+++ b/block/blk-core.c</span>
<span class="p_chunk">@@ -1985,7 +1985,8 @@</span> <span class="p_context"> void submit_bio(int rw, struct bio *bio)</span>
 EXPORT_SYMBOL(submit_bio);
 
 /**
<span class="p_del">- * blk_rq_check_limits - Helper function to check a request for the queue limit</span>
<span class="p_add">+ * blk_cloned_rq_check_limits - Helper function to check a cloned request</span>
<span class="p_add">+ *                              for new the queue limits</span>
  * @q:  the queue
  * @rq: the request being checked
  *
<span class="p_chunk">@@ -1996,20 +1997,13 @@</span> <span class="p_context"> EXPORT_SYMBOL(submit_bio);</span>
  *    after it is inserted to @q, it should be checked against @q before
  *    the insertion using this generic function.
  *
<span class="p_del">- *    This function should also be useful for request stacking drivers</span>
<span class="p_del">- *    in some cases below, so export this function.</span>
  *    Request stacking drivers like request-based dm may change the queue
<span class="p_del">- *    limits while requests are in the queue (e.g. dm&#39;s table swapping).</span>
<span class="p_del">- *    Such request stacking drivers should check those requests against</span>
<span class="p_del">- *    the new queue limits again when they dispatch those requests,</span>
<span class="p_del">- *    although such checkings are also done against the old queue limits</span>
<span class="p_del">- *    when submitting requests.</span>
<span class="p_add">+ *    limits when retrying requests on other queues. Those requests need</span>
<span class="p_add">+ *    to be checked against the new queue limits again during dispatch.</span>
  */
<span class="p_del">-int blk_rq_check_limits(struct request_queue *q, struct request *rq)</span>
<span class="p_add">+static int blk_cloned_rq_check_limits(struct request_queue *q,</span>
<span class="p_add">+				      struct request *rq)</span>
 {
<span class="p_del">-	if (!rq_mergeable(rq))</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-</span>
 	if (blk_rq_sectors(rq) &gt; blk_queue_get_max_sectors(q, rq-&gt;cmd_flags)) {
 		printk(KERN_ERR &quot;%s: over max size limit.\n&quot;, __func__);
 		return -EIO;
<span class="p_chunk">@@ -2029,7 +2023,6 @@</span> <span class="p_context"> int blk_rq_check_limits(struct request_queue *q, struct request *rq)</span>
 
 	return 0;
 }
<span class="p_del">-EXPORT_SYMBOL_GPL(blk_rq_check_limits);</span>
 
 /**
  * blk_insert_cloned_request - Helper for stacking drivers to submit a request
<span class="p_chunk">@@ -2041,7 +2034,7 @@</span> <span class="p_context"> int blk_insert_cloned_request(struct request_queue *q, struct request *rq)</span>
 	unsigned long flags;
 	int where = ELEVATOR_INSERT_BACK;
 
<span class="p_del">-	if (blk_rq_check_limits(q, rq))</span>
<span class="p_add">+	if (blk_cloned_rq_check_limits(q, rq))</span>
 		return -EIO;
 
 	if (rq-&gt;rq_disk &amp;&amp;
<span class="p_header">diff --git a/block/partitions/mac.c b/block/partitions/mac.c</span>
<span class="p_header">index c2c48ec..621317a 100644</span>
<span class="p_header">--- a/block/partitions/mac.c</span>
<span class="p_header">+++ b/block/partitions/mac.c</span>
<span class="p_chunk">@@ -32,7 +32,7 @@</span> <span class="p_context"> int mac_partition(struct parsed_partitions *state)</span>
 	Sector sect;
 	unsigned char *data;
 	int slot, blocks_in_map;
<span class="p_del">-	unsigned secsize;</span>
<span class="p_add">+	unsigned secsize, datasize, partoffset;</span>
 #ifdef CONFIG_PPC_PMAC
 	int found_root = 0;
 	int found_root_goodness = 0;
<span class="p_chunk">@@ -50,10 +50,14 @@</span> <span class="p_context"> int mac_partition(struct parsed_partitions *state)</span>
 	}
 	secsize = be16_to_cpu(md-&gt;block_size);
 	put_dev_sector(sect);
<span class="p_del">-	data = read_part_sector(state, secsize/512, &amp;sect);</span>
<span class="p_add">+	datasize = round_down(secsize, 512);</span>
<span class="p_add">+	data = read_part_sector(state, datasize / 512, &amp;sect);</span>
 	if (!data)
 		return -1;
<span class="p_del">-	part = (struct mac_partition *) (data + secsize%512);</span>
<span class="p_add">+	partoffset = secsize % 512;</span>
<span class="p_add">+	if (partoffset + sizeof(*part) &gt; datasize)</span>
<span class="p_add">+		return -1;</span>
<span class="p_add">+	part = (struct mac_partition *) (data + partoffset);</span>
 	if (be16_to_cpu(part-&gt;signature) != MAC_PARTITION_MAGIC) {
 		put_dev_sector(sect);
 		return 0;		/* not a MacOS disk */
<span class="p_header">diff --git a/drivers/base/power/domain.c b/drivers/base/power/domain.c</span>
<span class="p_header">index 0d8780c..1401e6c 100644</span>
<span class="p_header">--- a/drivers/base/power/domain.c</span>
<span class="p_header">+++ b/drivers/base/power/domain.c</span>
<span class="p_chunk">@@ -2199,10 +2199,10 @@</span> <span class="p_context"> int genpd_dev_pm_attach(struct device *dev)</span>
 	}
 
 	pd = of_genpd_get_from_provider(&amp;pd_args);
<span class="p_add">+	of_node_put(pd_args.np);</span>
 	if (IS_ERR(pd)) {
 		dev_dbg(dev, &quot;%s() failed to find PM domain: %ld\n&quot;,
 			__func__, PTR_ERR(pd));
<span class="p_del">-		of_node_put(dev-&gt;of_node);</span>
 		return PTR_ERR(pd);
 	}
 
<span class="p_chunk">@@ -2218,7 +2218,6 @@</span> <span class="p_context"> int genpd_dev_pm_attach(struct device *dev)</span>
 	if (ret &lt; 0) {
 		dev_err(dev, &quot;failed to add to PM domain %s: %d&quot;,
 			pd-&gt;name, ret);
<span class="p_del">-		of_node_put(dev-&gt;of_node);</span>
 		return ret;
 	}
 
<span class="p_header">diff --git a/drivers/block/rbd.c b/drivers/block/rbd.c</span>
<span class="p_header">index d72954b..9e6960f 100644</span>
<span class="p_header">--- a/drivers/block/rbd.c</span>
<span class="p_header">+++ b/drivers/block/rbd.c</span>
<span class="p_chunk">@@ -3400,6 +3400,7 @@</span> <span class="p_context"> static void rbd_handle_request(struct rbd_device *rbd_dev, struct request *rq)</span>
 		goto err_rq;
 	}
 	img_request-&gt;rq = rq;
<span class="p_add">+	snapc = NULL; /* img_request consumes a ref */</span>
 
 	if (op_type == OBJ_OP_DISCARD)
 		result = rbd_img_request_fill(img_request, OBJ_REQUEST_NODATA,
<span class="p_header">diff --git a/drivers/char/ipmi/ipmi_si_intf.c b/drivers/char/ipmi/ipmi_si_intf.c</span>
<span class="p_header">index 967b73a..ecc34a9 100644</span>
<span class="p_header">--- a/drivers/char/ipmi/ipmi_si_intf.c</span>
<span class="p_header">+++ b/drivers/char/ipmi/ipmi_si_intf.c</span>
<span class="p_chunk">@@ -393,18 +393,42 @@</span> <span class="p_context"> static enum si_sm_result start_next_msg(struct smi_info *smi_info)</span>
 	return rv;
 }
 
<span class="p_del">-static void start_check_enables(struct smi_info *smi_info)</span>
<span class="p_add">+static void smi_mod_timer(struct smi_info *smi_info, unsigned long new_val)</span>
<span class="p_add">+{</span>
<span class="p_add">+	smi_info-&gt;last_timeout_jiffies = jiffies;</span>
<span class="p_add">+	mod_timer(&amp;smi_info-&gt;si_timer, new_val);</span>
<span class="p_add">+	smi_info-&gt;timer_running = true;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Start a new message and (re)start the timer and thread.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void start_new_msg(struct smi_info *smi_info, unsigned char *msg,</span>
<span class="p_add">+			  unsigned int size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	smi_mod_timer(smi_info, jiffies + SI_TIMEOUT_JIFFIES);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (smi_info-&gt;thread)</span>
<span class="p_add">+		wake_up_process(smi_info-&gt;thread);</span>
<span class="p_add">+</span>
<span class="p_add">+	smi_info-&gt;handlers-&gt;start_transaction(smi_info-&gt;si_sm, msg, size);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void start_check_enables(struct smi_info *smi_info, bool start_timer)</span>
 {
 	unsigned char msg[2];
 
 	msg[0] = (IPMI_NETFN_APP_REQUEST &lt;&lt; 2);
 	msg[1] = IPMI_GET_BMC_GLOBAL_ENABLES_CMD;
 
<span class="p_del">-	smi_info-&gt;handlers-&gt;start_transaction(smi_info-&gt;si_sm, msg, 2);</span>
<span class="p_add">+	if (start_timer)</span>
<span class="p_add">+		start_new_msg(smi_info, msg, 2);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		smi_info-&gt;handlers-&gt;start_transaction(smi_info-&gt;si_sm, msg, 2);</span>
 	smi_info-&gt;si_state = SI_CHECKING_ENABLES;
 }
 
<span class="p_del">-static void start_clear_flags(struct smi_info *smi_info)</span>
<span class="p_add">+static void start_clear_flags(struct smi_info *smi_info, bool start_timer)</span>
 {
 	unsigned char msg[3];
 
<span class="p_chunk">@@ -413,7 +437,10 @@</span> <span class="p_context"> static void start_clear_flags(struct smi_info *smi_info)</span>
 	msg[1] = IPMI_CLEAR_MSG_FLAGS_CMD;
 	msg[2] = WDT_PRE_TIMEOUT_INT;
 
<span class="p_del">-	smi_info-&gt;handlers-&gt;start_transaction(smi_info-&gt;si_sm, msg, 3);</span>
<span class="p_add">+	if (start_timer)</span>
<span class="p_add">+		start_new_msg(smi_info, msg, 3);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		smi_info-&gt;handlers-&gt;start_transaction(smi_info-&gt;si_sm, msg, 3);</span>
 	smi_info-&gt;si_state = SI_CLEARING_FLAGS;
 }
 
<span class="p_chunk">@@ -423,10 +450,8 @@</span> <span class="p_context"> static void start_getting_msg_queue(struct smi_info *smi_info)</span>
 	smi_info-&gt;curr_msg-&gt;data[1] = IPMI_GET_MSG_CMD;
 	smi_info-&gt;curr_msg-&gt;data_size = 2;
 
<span class="p_del">-	smi_info-&gt;handlers-&gt;start_transaction(</span>
<span class="p_del">-		smi_info-&gt;si_sm,</span>
<span class="p_del">-		smi_info-&gt;curr_msg-&gt;data,</span>
<span class="p_del">-		smi_info-&gt;curr_msg-&gt;data_size);</span>
<span class="p_add">+	start_new_msg(smi_info, smi_info-&gt;curr_msg-&gt;data,</span>
<span class="p_add">+		      smi_info-&gt;curr_msg-&gt;data_size);</span>
 	smi_info-&gt;si_state = SI_GETTING_MESSAGES;
 }
 
<span class="p_chunk">@@ -436,31 +461,22 @@</span> <span class="p_context"> static void start_getting_events(struct smi_info *smi_info)</span>
 	smi_info-&gt;curr_msg-&gt;data[1] = IPMI_READ_EVENT_MSG_BUFFER_CMD;
 	smi_info-&gt;curr_msg-&gt;data_size = 2;
 
<span class="p_del">-	smi_info-&gt;handlers-&gt;start_transaction(</span>
<span class="p_del">-		smi_info-&gt;si_sm,</span>
<span class="p_del">-		smi_info-&gt;curr_msg-&gt;data,</span>
<span class="p_del">-		smi_info-&gt;curr_msg-&gt;data_size);</span>
<span class="p_add">+	start_new_msg(smi_info, smi_info-&gt;curr_msg-&gt;data,</span>
<span class="p_add">+		      smi_info-&gt;curr_msg-&gt;data_size);</span>
 	smi_info-&gt;si_state = SI_GETTING_EVENTS;
 }
 
<span class="p_del">-static void smi_mod_timer(struct smi_info *smi_info, unsigned long new_val)</span>
<span class="p_del">-{</span>
<span class="p_del">-	smi_info-&gt;last_timeout_jiffies = jiffies;</span>
<span class="p_del">-	mod_timer(&amp;smi_info-&gt;si_timer, new_val);</span>
<span class="p_del">-	smi_info-&gt;timer_running = true;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /*
  * When we have a situtaion where we run out of memory and cannot
  * allocate messages, we just leave them in the BMC and run the system
  * polled until we can allocate some memory.  Once we have some
  * memory, we will re-enable the interrupt.
  */
<span class="p_del">-static inline bool disable_si_irq(struct smi_info *smi_info)</span>
<span class="p_add">+static inline bool disable_si_irq(struct smi_info *smi_info, bool start_timer)</span>
 {
 	if ((smi_info-&gt;irq) &amp;&amp; (!smi_info-&gt;interrupt_disabled)) {
 		smi_info-&gt;interrupt_disabled = true;
<span class="p_del">-		start_check_enables(smi_info);</span>
<span class="p_add">+		start_check_enables(smi_info, start_timer);</span>
 		return true;
 	}
 	return false;
<span class="p_chunk">@@ -470,7 +486,7 @@</span> <span class="p_context"> static inline bool enable_si_irq(struct smi_info *smi_info)</span>
 {
 	if ((smi_info-&gt;irq) &amp;&amp; (smi_info-&gt;interrupt_disabled)) {
 		smi_info-&gt;interrupt_disabled = false;
<span class="p_del">-		start_check_enables(smi_info);</span>
<span class="p_add">+		start_check_enables(smi_info, true);</span>
 		return true;
 	}
 	return false;
<span class="p_chunk">@@ -488,7 +504,7 @@</span> <span class="p_context"> static struct ipmi_smi_msg *alloc_msg_handle_irq(struct smi_info *smi_info)</span>
 
 	msg = ipmi_alloc_smi_msg();
 	if (!msg) {
<span class="p_del">-		if (!disable_si_irq(smi_info))</span>
<span class="p_add">+		if (!disable_si_irq(smi_info, true))</span>
 			smi_info-&gt;si_state = SI_NORMAL;
 	} else if (enable_si_irq(smi_info)) {
 		ipmi_free_smi_msg(msg);
<span class="p_chunk">@@ -504,7 +520,7 @@</span> <span class="p_context"> static void handle_flags(struct smi_info *smi_info)</span>
 		/* Watchdog pre-timeout */
 		smi_inc_stat(smi_info, watchdog_pretimeouts);
 
<span class="p_del">-		start_clear_flags(smi_info);</span>
<span class="p_add">+		start_clear_flags(smi_info, true);</span>
 		smi_info-&gt;msg_flags &amp;= ~WDT_PRE_TIMEOUT_INT;
 		if (smi_info-&gt;intf)
 			ipmi_smi_watchdog_pretimeout(smi_info-&gt;intf);
<span class="p_chunk">@@ -865,8 +881,7 @@</span> <span class="p_context"> static enum si_sm_result smi_event_handler(struct smi_info *smi_info,</span>
 			msg[0] = (IPMI_NETFN_APP_REQUEST &lt;&lt; 2);
 			msg[1] = IPMI_GET_MSG_FLAGS_CMD;
 
<span class="p_del">-			smi_info-&gt;handlers-&gt;start_transaction(</span>
<span class="p_del">-				smi_info-&gt;si_sm, msg, 2);</span>
<span class="p_add">+			start_new_msg(smi_info, msg, 2);</span>
 			smi_info-&gt;si_state = SI_GETTING_FLAGS;
 			goto restart;
 		}
<span class="p_chunk">@@ -896,7 +911,7 @@</span> <span class="p_context"> static enum si_sm_result smi_event_handler(struct smi_info *smi_info,</span>
 		 * disable and messages disabled.
 		 */
 		if (smi_info-&gt;supports_event_msg_buff || smi_info-&gt;irq) {
<span class="p_del">-			start_check_enables(smi_info);</span>
<span class="p_add">+			start_check_enables(smi_info, true);</span>
 		} else {
 			smi_info-&gt;curr_msg = alloc_msg_handle_irq(smi_info);
 			if (!smi_info-&gt;curr_msg)
<span class="p_chunk">@@ -3427,7 +3442,7 @@</span> <span class="p_context"> static int try_smi_init(struct smi_info *new_smi)</span>
 	 * Start clearing the flags before we enable interrupts or the
 	 * timer to avoid racing with the timer.
 	 */
<span class="p_del">-	start_clear_flags(new_smi);</span>
<span class="p_add">+	start_clear_flags(new_smi, false);</span>
 
 	/*
 	 * IRQ is defined to be set when non-zero.  req_events will
<span class="p_chunk">@@ -3729,7 +3744,7 @@</span> <span class="p_context"> static void cleanup_one_si(struct smi_info *to_clean)</span>
 		poll(to_clean);
 		schedule_timeout_uninterruptible(1);
 	}
<span class="p_del">-	disable_si_irq(to_clean);</span>
<span class="p_add">+	disable_si_irq(to_clean, false);</span>
 	while (to_clean-&gt;curr_msg || (to_clean-&gt;si_state != SI_NORMAL)) {
 		poll(to_clean);
 		schedule_timeout_uninterruptible(1);
<span class="p_header">diff --git a/drivers/crypto/nx/nx-aes-ccm.c b/drivers/crypto/nx/nx-aes-ccm.c</span>
<span class="p_header">index 67f8081..40992a2 100644</span>
<span class="p_header">--- a/drivers/crypto/nx/nx-aes-ccm.c</span>
<span class="p_header">+++ b/drivers/crypto/nx/nx-aes-ccm.c</span>
<span class="p_chunk">@@ -412,7 +412,7 @@</span> <span class="p_context"> static int ccm_nx_decrypt(struct aead_request   *req,</span>
 		processed += to_process;
 	} while (processed &lt; nbytes);
 
<span class="p_del">-	rc = memcmp(csbcpb-&gt;cpb.aes_ccm.out_pat_or_mac, priv-&gt;oauth_tag,</span>
<span class="p_add">+	rc = crypto_memneq(csbcpb-&gt;cpb.aes_ccm.out_pat_or_mac, priv-&gt;oauth_tag,</span>
 		    authsize) ? -EBADMSG : 0;
 out:
 	spin_unlock_irqrestore(&amp;nx_ctx-&gt;lock, irq_flags);
<span class="p_header">diff --git a/drivers/crypto/nx/nx-aes-gcm.c b/drivers/crypto/nx/nx-aes-gcm.c</span>
<span class="p_header">index 88c5624..ae4561d 100644</span>
<span class="p_header">--- a/drivers/crypto/nx/nx-aes-gcm.c</span>
<span class="p_header">+++ b/drivers/crypto/nx/nx-aes-gcm.c</span>
<span class="p_chunk">@@ -423,7 +423,7 @@</span> <span class="p_context"> mac:</span>
 		scatterwalk_map_and_copy(itag, req-&gt;src, nbytes,
 				 crypto_aead_authsize(crypto_aead_reqtfm(req)),
 				 SCATTERWALK_FROM_SG);
<span class="p_del">-		rc = memcmp(itag, otag,</span>
<span class="p_add">+		rc = crypto_memneq(itag, otag,</span>
 			    crypto_aead_authsize(crypto_aead_reqtfm(req))) ?
 		     -EBADMSG : 0;
 	}
<span class="p_header">diff --git a/drivers/crypto/qat/qat_common/adf_ctl_drv.c b/drivers/crypto/qat/qat_common/adf_ctl_drv.c</span>
<span class="p_header">index 7ee93f8..54e9e0b 100644</span>
<span class="p_header">--- a/drivers/crypto/qat/qat_common/adf_ctl_drv.c</span>
<span class="p_header">+++ b/drivers/crypto/qat/qat_common/adf_ctl_drv.c</span>
<span class="p_chunk">@@ -194,7 +194,7 @@</span> <span class="p_context"> static int adf_copy_key_value_data(struct adf_accel_dev *accel_dev,</span>
 			goto out_err;
 		}
 
<span class="p_del">-		params_head = section_head-&gt;params;</span>
<span class="p_add">+		params_head = section.params;</span>
 
 		while (params_head) {
 			if (copy_from_user(&amp;key_val, (void __user *)params_head,
<span class="p_header">diff --git a/drivers/crypto/talitos.c b/drivers/crypto/talitos.c</span>
<span class="p_header">index 0584c4e..181167f 100644</span>
<span class="p_header">--- a/drivers/crypto/talitos.c</span>
<span class="p_header">+++ b/drivers/crypto/talitos.c</span>
<span class="p_chunk">@@ -870,7 +870,7 @@</span> <span class="p_context"> static void ipsec_esp_decrypt_swauth_done(struct device *dev,</span>
 			icvdata = &amp;edesc-&gt;link_tbl[0];
 
 		sg = sg_last(req-&gt;dst, edesc-&gt;dst_nents ? : 1);
<span class="p_del">-		err = memcmp(icvdata, (char *)sg_virt(sg) + sg-&gt;length -</span>
<span class="p_add">+		err = crypto_memneq(icvdata, (char *)sg_virt(sg) + sg-&gt;length -</span>
 			     ctx-&gt;authsize, ctx-&gt;authsize) ? -EBADMSG : 0;
 	}
 
<span class="p_header">diff --git a/drivers/gpu/drm/drm_drv.c b/drivers/gpu/drm/drm_drv.c</span>
<span class="p_header">index 4f41377..0cb617d 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_drv.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_drv.c</span>
<span class="p_chunk">@@ -173,6 +173,11 @@</span> <span class="p_context"> int drm_setmaster_ioctl(struct drm_device *dev, void *data,</span>
 		goto out_unlock;
 	}
 
<span class="p_add">+	if (!file_priv-&gt;allowed_master) {</span>
<span class="p_add">+		ret = drm_new_set_master(dev, file_priv);</span>
<span class="p_add">+		goto out_unlock;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	file_priv-&gt;minor-&gt;master = drm_master_get(file_priv-&gt;master);
 	file_priv-&gt;is_master = 1;
 	if (dev-&gt;driver-&gt;master_set) {
<span class="p_header">diff --git a/drivers/gpu/drm/drm_fops.c b/drivers/gpu/drm/drm_fops.c</span>
<span class="p_header">index 0b9514b..5b91066 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_fops.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_fops.c</span>
<span class="p_chunk">@@ -126,6 +126,60 @@</span> <span class="p_context"> static int drm_cpu_valid(void)</span>
 }
 
 /**
<span class="p_add">+ * drm_new_set_master - Allocate a new master object and become master for the</span>
<span class="p_add">+ * associated master realm.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * @dev: The associated device.</span>
<span class="p_add">+ * @fpriv: File private identifying the client.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This function must be called with dev::struct_mutex held.</span>
<span class="p_add">+ * Returns negative error code on failure. Zero on success.</span>
<span class="p_add">+ */</span>
<span class="p_add">+int drm_new_set_master(struct drm_device *dev, struct drm_file *fpriv)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct drm_master *old_master;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	lockdep_assert_held_once(&amp;dev-&gt;master_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* create a new master */</span>
<span class="p_add">+	fpriv-&gt;minor-&gt;master = drm_master_create(fpriv-&gt;minor);</span>
<span class="p_add">+	if (!fpriv-&gt;minor-&gt;master)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* take another reference for the copy in the local file priv */</span>
<span class="p_add">+	old_master = fpriv-&gt;master;</span>
<span class="p_add">+	fpriv-&gt;master = drm_master_get(fpriv-&gt;minor-&gt;master);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (dev-&gt;driver-&gt;master_create) {</span>
<span class="p_add">+		ret = dev-&gt;driver-&gt;master_create(dev, fpriv-&gt;master);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			goto out_err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (dev-&gt;driver-&gt;master_set) {</span>
<span class="p_add">+		ret = dev-&gt;driver-&gt;master_set(dev, fpriv, true);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			goto out_err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	fpriv-&gt;is_master = 1;</span>
<span class="p_add">+	fpriv-&gt;allowed_master = 1;</span>
<span class="p_add">+	fpriv-&gt;authenticated = 1;</span>
<span class="p_add">+	if (old_master)</span>
<span class="p_add">+		drm_master_put(&amp;old_master);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+out_err:</span>
<span class="p_add">+	/* drop both references and restore old master on failure */</span>
<span class="p_add">+	drm_master_put(&amp;fpriv-&gt;minor-&gt;master);</span>
<span class="p_add">+	drm_master_put(&amp;fpriv-&gt;master);</span>
<span class="p_add">+	fpriv-&gt;master = old_master;</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
  * Called whenever a process opens /dev/drm.
  *
  * \param filp file pointer.
<span class="p_chunk">@@ -188,35 +242,9 @@</span> <span class="p_context"> static int drm_open_helper(struct file *filp, struct drm_minor *minor)</span>
 	mutex_lock(&amp;dev-&gt;master_mutex);
 	if (drm_is_primary_client(priv) &amp;&amp; !priv-&gt;minor-&gt;master) {
 		/* create a new master */
<span class="p_del">-		priv-&gt;minor-&gt;master = drm_master_create(priv-&gt;minor);</span>
<span class="p_del">-		if (!priv-&gt;minor-&gt;master) {</span>
<span class="p_del">-			ret = -ENOMEM;</span>
<span class="p_add">+		ret = drm_new_set_master(dev, priv);</span>
<span class="p_add">+		if (ret)</span>
 			goto out_close;
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		priv-&gt;is_master = 1;</span>
<span class="p_del">-		/* take another reference for the copy in the local file priv */</span>
<span class="p_del">-		priv-&gt;master = drm_master_get(priv-&gt;minor-&gt;master);</span>
<span class="p_del">-		priv-&gt;authenticated = 1;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (dev-&gt;driver-&gt;master_create) {</span>
<span class="p_del">-			ret = dev-&gt;driver-&gt;master_create(dev, priv-&gt;master);</span>
<span class="p_del">-			if (ret) {</span>
<span class="p_del">-				/* drop both references if this fails */</span>
<span class="p_del">-				drm_master_put(&amp;priv-&gt;minor-&gt;master);</span>
<span class="p_del">-				drm_master_put(&amp;priv-&gt;master);</span>
<span class="p_del">-				goto out_close;</span>
<span class="p_del">-			}</span>
<span class="p_del">-		}</span>
<span class="p_del">-		if (dev-&gt;driver-&gt;master_set) {</span>
<span class="p_del">-			ret = dev-&gt;driver-&gt;master_set(dev, priv, true);</span>
<span class="p_del">-			if (ret) {</span>
<span class="p_del">-				/* drop both references if this fails */</span>
<span class="p_del">-				drm_master_put(&amp;priv-&gt;minor-&gt;master);</span>
<span class="p_del">-				drm_master_put(&amp;priv-&gt;master);</span>
<span class="p_del">-				goto out_close;</span>
<span class="p_del">-			}</span>
<span class="p_del">-		}</span>
 	} else if (drm_is_primary_client(priv)) {
 		/* get a reference to the master */
 		priv-&gt;master = drm_master_get(priv-&gt;minor-&gt;master);
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_gem.c b/drivers/gpu/drm/i915/i915_gem.c</span>
<span class="p_header">index 5f61482..3655910 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_gem.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_gem.c</span>
<span class="p_chunk">@@ -3864,6 +3864,7 @@</span> <span class="p_context"> unlock:</span>
 int i915_gem_set_caching_ioctl(struct drm_device *dev, void *data,
 			       struct drm_file *file)
 {
<span class="p_add">+	struct drm_i915_private *dev_priv = dev-&gt;dev_private;</span>
 	struct drm_i915_gem_caching *args = data;
 	struct drm_i915_gem_object *obj;
 	enum i915_cache_level level;
<span class="p_chunk">@@ -3883,9 +3884,11 @@</span> <span class="p_context"> int i915_gem_set_caching_ioctl(struct drm_device *dev, void *data,</span>
 		return -EINVAL;
 	}
 
<span class="p_add">+	intel_runtime_pm_get(dev_priv);</span>
<span class="p_add">+</span>
 	ret = i915_mutex_lock_interruptible(dev);
 	if (ret)
<span class="p_del">-		return ret;</span>
<span class="p_add">+		goto rpm_put;</span>
 
 	obj = to_intel_bo(drm_gem_object_lookup(dev, file, args-&gt;handle));
 	if (&amp;obj-&gt;base == NULL) {
<span class="p_chunk">@@ -3898,6 +3901,9 @@</span> <span class="p_context"> int i915_gem_set_caching_ioctl(struct drm_device *dev, void *data,</span>
 	drm_gem_object_unreference(&amp;obj-&gt;base);
 unlock:
 	mutex_unlock(&amp;dev-&gt;struct_mutex);
<span class="p_add">+rpm_put:</span>
<span class="p_add">+	intel_runtime_pm_put(dev_priv);</span>
<span class="p_add">+</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_display.c b/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_header">index ca0ec27..48a19dc 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_chunk">@@ -13025,6 +13025,9 @@</span> <span class="p_context"> static struct intel_quirk intel_quirks[] = {</span>
 	/* Apple Macbook 2,1 (Core 2 T7400) */
 	{ 0x27a2, 0x8086, 0x7270, quirk_backlight_present },
 
<span class="p_add">+	/* Apple Macbook 4,1 */</span>
<span class="p_add">+	{ 0x2a02, 0x106b, 0x00a1, quirk_backlight_present },</span>
<span class="p_add">+</span>
 	/* Toshiba CB35 Chromebook (Celeron 2955U) */
 	{ 0x0a06, 0x1179, 0x0a88, quirk_backlight_present },
 
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_dp.c b/drivers/gpu/drm/i915/intel_dp.c</span>
<span class="p_header">index 887f2e4..fec89eb 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_dp.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_dp.c</span>
<span class="p_chunk">@@ -4410,7 +4410,8 @@</span> <span class="p_context"> intel_dp_hpd_pulse(struct intel_digital_port *intel_dig_port, bool long_hpd)</span>
 	enum intel_display_power_domain power_domain;
 	bool ret = true;
 
<span class="p_del">-	if (intel_dig_port-&gt;base.type != INTEL_OUTPUT_EDP)</span>
<span class="p_add">+	if (intel_dig_port-&gt;base.type != INTEL_OUTPUT_EDP &amp;&amp;</span>
<span class="p_add">+	    intel_dig_port-&gt;base.type != INTEL_OUTPUT_HDMI)</span>
 		intel_dig_port-&gt;base.type = INTEL_OUTPUT_DISPLAYPORT;
 
 	if (long_hpd &amp;&amp; intel_dig_port-&gt;base.type == INTEL_OUTPUT_EDP) {
<span class="p_header">diff --git a/drivers/gpu/drm/imx/ipuv3-crtc.c b/drivers/gpu/drm/imx/ipuv3-crtc.c</span>
<span class="p_header">index ebee59c..5352998 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/imx/ipuv3-crtc.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/imx/ipuv3-crtc.c</span>
<span class="p_chunk">@@ -209,7 +209,8 @@</span> <span class="p_context"> static void ipu_crtc_handle_pageflip(struct ipu_crtc *ipu_crtc)</span>
 
 	spin_lock_irqsave(&amp;drm-&gt;event_lock, flags);
 	if (ipu_crtc-&gt;page_flip_event)
<span class="p_del">-		drm_send_vblank_event(drm, -1, ipu_crtc-&gt;page_flip_event);</span>
<span class="p_add">+		drm_crtc_send_vblank_event(&amp;ipu_crtc-&gt;base,</span>
<span class="p_add">+					   ipu_crtc-&gt;page_flip_event);</span>
 	ipu_crtc-&gt;page_flip_event = NULL;
 	imx_drm_crtc_vblank_put(ipu_crtc-&gt;imx_crtc);
 	spin_unlock_irqrestore(&amp;drm-&gt;event_lock, flags);
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_object.c b/drivers/gpu/drm/radeon/radeon_object.c</span>
<span class="p_header">index 12ea1e5..826564d 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_object.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_object.c</span>
<span class="p_chunk">@@ -221,6 +221,12 @@</span> <span class="p_context"> int radeon_bo_create(struct radeon_device *rdev,</span>
 	if (!(rdev-&gt;flags &amp; RADEON_IS_PCIE))
 		bo-&gt;flags &amp;= ~(RADEON_GEM_GTT_WC | RADEON_GEM_GTT_UC);
 
<span class="p_add">+	/* Write-combined CPU mappings of GTT cause GPU hangs with RV6xx</span>
<span class="p_add">+	 * See https://bugs.freedesktop.org/show_bug.cgi?id=91268</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (rdev-&gt;family &gt;= CHIP_RV610 &amp;&amp; rdev-&gt;family &lt;= CHIP_RV635)</span>
<span class="p_add">+		bo-&gt;flags &amp;= ~(RADEON_GEM_GTT_WC | RADEON_GEM_GTT_UC);</span>
<span class="p_add">+</span>
 #ifdef CONFIG_X86_32
 	/* XXX: Write-combined CPU mappings of GTT seem broken on 32-bit
 	 * See https://bugs.freedesktop.org/show_bug.cgi?id=84627
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_pm.c b/drivers/gpu/drm/radeon/radeon_pm.c</span>
<span class="p_header">index fa537c0..5fc27e9 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_pm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_pm.c</span>
<span class="p_chunk">@@ -1404,8 +1404,7 @@</span> <span class="p_context"> int radeon_pm_late_init(struct radeon_device *rdev)</span>
 				ret = device_create_file(rdev-&gt;dev, &amp;dev_attr_power_method);
 				if (ret)
 					DRM_ERROR(&quot;failed to create device file for power method\n&quot;);
<span class="p_del">-				if (!ret)</span>
<span class="p_del">-					rdev-&gt;pm.sysfs_initialized = true;</span>
<span class="p_add">+				rdev-&gt;pm.sysfs_initialized = true;</span>
 			}
 
 			mutex_lock(&amp;rdev-&gt;pm.mutex);
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/rv730_dpm.c b/drivers/gpu/drm/radeon/rv730_dpm.c</span>
<span class="p_header">index 3f5e1cf..d37ba2c 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/rv730_dpm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/rv730_dpm.c</span>
<span class="p_chunk">@@ -464,7 +464,7 @@</span> <span class="p_context"> void rv730_stop_dpm(struct radeon_device *rdev)</span>
 	result = rv770_send_msg_to_smc(rdev, PPSMC_MSG_TwoLevelsDisabled);
 
 	if (result != PPSMC_Result_OK)
<span class="p_del">-		DRM_ERROR(&quot;Could not force DPM to low\n&quot;);</span>
<span class="p_add">+		DRM_DEBUG(&quot;Could not force DPM to low\n&quot;);</span>
 
 	WREG32_P(GENERAL_PWRMGT, 0, ~GLOBAL_PWRMGT_EN);
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/rv770_dpm.c b/drivers/gpu/drm/radeon/rv770_dpm.c</span>
<span class="p_header">index 755a8f9..24f85c6 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/rv770_dpm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/rv770_dpm.c</span>
<span class="p_chunk">@@ -193,7 +193,7 @@</span> <span class="p_context"> void rv770_stop_dpm(struct radeon_device *rdev)</span>
 	result = rv770_send_msg_to_smc(rdev, PPSMC_MSG_TwoLevelsDisabled);
 
 	if (result != PPSMC_Result_OK)
<span class="p_del">-		DRM_ERROR(&quot;Could not force DPM to low.\n&quot;);</span>
<span class="p_add">+		DRM_DEBUG(&quot;Could not force DPM to low.\n&quot;);</span>
 
 	WREG32_P(GENERAL_PWRMGT, 0, ~GLOBAL_PWRMGT_EN);
 
<span class="p_chunk">@@ -1416,7 +1416,7 @@</span> <span class="p_context"> int rv770_resume_smc(struct radeon_device *rdev)</span>
 int rv770_set_sw_state(struct radeon_device *rdev)
 {
 	if (rv770_send_msg_to_smc(rdev, PPSMC_MSG_SwitchToSwState) != PPSMC_Result_OK)
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+		DRM_DEBUG(&quot;rv770_set_sw_state failed\n&quot;);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/rockchip/rockchip_drm_gem.c b/drivers/gpu/drm/rockchip/rockchip_drm_gem.c</span>
<span class="p_header">index b79dc98..02007f0 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/rockchip/rockchip_drm_gem.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/rockchip/rockchip_drm_gem.c</span>
<span class="p_chunk">@@ -67,6 +67,7 @@</span> <span class="p_context"> static int rockchip_drm_gem_object_mmap(struct drm_gem_object *obj,</span>
 	 * VM_PFNMAP flag that was set by drm_gem_mmap_obj()/drm_gem_mmap().
 	 */
 	vma-&gt;vm_flags &amp;= ~VM_PFNMAP;
<span class="p_add">+	vma-&gt;vm_pgoff = 0;</span>
 
 	ret = dma_mmap_attrs(drm-&gt;dev, vma, rk_obj-&gt;kvaddr, rk_obj-&gt;dma_addr,
 			     obj-&gt;size, &amp;rk_obj-&gt;dma_attrs);
<span class="p_header">diff --git a/drivers/iio/adc/ad7793.c b/drivers/iio/adc/ad7793.c</span>
<span class="p_header">index 4dddeab..5da0754 100644</span>
<span class="p_header">--- a/drivers/iio/adc/ad7793.c</span>
<span class="p_header">+++ b/drivers/iio/adc/ad7793.c</span>
<span class="p_chunk">@@ -101,7 +101,7 @@</span> <span class="p_context"></span>
 #define AD7795_CH_AIN1M_AIN1M	8 /* AIN1(-) - AIN1(-) */
 
 /* ID Register Bit Designations (AD7793_REG_ID) */
<span class="p_del">-#define AD7785_ID		0xB</span>
<span class="p_add">+#define AD7785_ID		0x3</span>
 #define AD7792_ID		0xA
 #define AD7793_ID		0xB
 #define AD7794_ID		0xF
<span class="p_header">diff --git a/drivers/iio/adc/vf610_adc.c b/drivers/iio/adc/vf610_adc.c</span>
<span class="p_header">index 60617ed..cf56404 100644</span>
<span class="p_header">--- a/drivers/iio/adc/vf610_adc.c</span>
<span class="p_header">+++ b/drivers/iio/adc/vf610_adc.c</span>
<span class="p_chunk">@@ -98,6 +98,13 @@</span> <span class="p_context"></span>
 #define VF610_ADC_CALF			0x2
 #define VF610_ADC_TIMEOUT		msecs_to_jiffies(100)
 
<span class="p_add">+/* V at 25C of 696 mV */</span>
<span class="p_add">+#define VF610_VTEMP25_3V0		950</span>
<span class="p_add">+/* V at 25C of 699 mV */</span>
<span class="p_add">+#define VF610_VTEMP25_3V3		867</span>
<span class="p_add">+/* Typical sensor slope coefficient at all temperatures */</span>
<span class="p_add">+#define VF610_TEMP_SLOPE_COEFF		1840</span>
<span class="p_add">+</span>
 enum clk_sel {
 	VF610_ADCIOC_BUSCLK_SET,
 	VF610_ADCIOC_ALTCLK_SET,
<span class="p_chunk">@@ -513,11 +520,13 @@</span> <span class="p_context"> static int vf610_read_raw(struct iio_dev *indio_dev,</span>
 			break;
 		case IIO_TEMP:
 			/*
<span class="p_del">-			* Calculate in degree Celsius times 1000</span>
<span class="p_del">-			* Using sensor slope of 1.84 mV/C and</span>
<span class="p_del">-			* V at 25C of 696 mV</span>
<span class="p_del">-			*/</span>
<span class="p_del">-			*val = 25000 - ((int)info-&gt;value - 864) * 1000000 / 1840;</span>
<span class="p_add">+			 * Calculate in degree Celsius times 1000</span>
<span class="p_add">+			 * Using the typical sensor slope of 1.84 mV/C</span>
<span class="p_add">+			 * and VREFH_ADC at 3.3V, V at 25C of 699 mV</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			*val = 25000 - ((int)info-&gt;value - VF610_VTEMP25_3V3) *</span>
<span class="p_add">+					1000000 / VF610_TEMP_SLOPE_COEFF;</span>
<span class="p_add">+</span>
 			break;
 		default:
 			mutex_unlock(&amp;indio_dev-&gt;mlock);
<span class="p_header">diff --git a/drivers/iio/adc/xilinx-xadc-core.c b/drivers/iio/adc/xilinx-xadc-core.c</span>
<span class="p_header">index ce93bd8..95c0b3d 100644</span>
<span class="p_header">--- a/drivers/iio/adc/xilinx-xadc-core.c</span>
<span class="p_header">+++ b/drivers/iio/adc/xilinx-xadc-core.c</span>
<span class="p_chunk">@@ -857,6 +857,7 @@</span> <span class="p_context"> static int xadc_read_raw(struct iio_dev *indio_dev,</span>
 			case XADC_REG_VCCINT:
 			case XADC_REG_VCCAUX:
 			case XADC_REG_VREFP:
<span class="p_add">+			case XADC_REG_VREFN:</span>
 			case XADC_REG_VCCBRAM:
 			case XADC_REG_VCCPINT:
 			case XADC_REG_VCCPAUX:
<span class="p_header">diff --git a/drivers/iio/dac/ad5064.c b/drivers/iio/dac/ad5064.c</span>
<span class="p_header">index f03b92f..aac16fe 100644</span>
<span class="p_header">--- a/drivers/iio/dac/ad5064.c</span>
<span class="p_header">+++ b/drivers/iio/dac/ad5064.c</span>
<span class="p_chunk">@@ -113,12 +113,16 @@</span> <span class="p_context"> enum ad5064_type {</span>
 	ID_AD5065,
 	ID_AD5628_1,
 	ID_AD5628_2,
<span class="p_add">+	ID_AD5629_1,</span>
<span class="p_add">+	ID_AD5629_2,</span>
 	ID_AD5648_1,
 	ID_AD5648_2,
 	ID_AD5666_1,
 	ID_AD5666_2,
 	ID_AD5668_1,
 	ID_AD5668_2,
<span class="p_add">+	ID_AD5669_1,</span>
<span class="p_add">+	ID_AD5669_2,</span>
 };
 
 static int ad5064_write(struct ad5064_state *st, unsigned int cmd,
<span class="p_chunk">@@ -291,7 +295,7 @@</span> <span class="p_context"> static const struct iio_chan_spec_ext_info ad5064_ext_info[] = {</span>
 	{ },
 };
 
<span class="p_del">-#define AD5064_CHANNEL(chan, addr, bits) {			\</span>
<span class="p_add">+#define AD5064_CHANNEL(chan, addr, bits, _shift) {		\</span>
 	.type = IIO_VOLTAGE,					\
 	.indexed = 1,						\
 	.output = 1,						\
<span class="p_chunk">@@ -303,36 +307,39 @@</span> <span class="p_context"> static const struct iio_chan_spec_ext_info ad5064_ext_info[] = {</span>
 		.sign = &#39;u&#39;,					\
 		.realbits = (bits),				\
 		.storagebits = 16,				\
<span class="p_del">-		.shift = 20 - bits,				\</span>
<span class="p_add">+		.shift = (_shift),				\</span>
 	},							\
 	.ext_info = ad5064_ext_info,				\
 }
 
<span class="p_del">-#define DECLARE_AD5064_CHANNELS(name, bits) \</span>
<span class="p_add">+#define DECLARE_AD5064_CHANNELS(name, bits, shift) \</span>
 const struct iio_chan_spec name[] = { \
<span class="p_del">-	AD5064_CHANNEL(0, 0, bits), \</span>
<span class="p_del">-	AD5064_CHANNEL(1, 1, bits), \</span>
<span class="p_del">-	AD5064_CHANNEL(2, 2, bits), \</span>
<span class="p_del">-	AD5064_CHANNEL(3, 3, bits), \</span>
<span class="p_del">-	AD5064_CHANNEL(4, 4, bits), \</span>
<span class="p_del">-	AD5064_CHANNEL(5, 5, bits), \</span>
<span class="p_del">-	AD5064_CHANNEL(6, 6, bits), \</span>
<span class="p_del">-	AD5064_CHANNEL(7, 7, bits), \</span>
<span class="p_add">+	AD5064_CHANNEL(0, 0, bits, shift), \</span>
<span class="p_add">+	AD5064_CHANNEL(1, 1, bits, shift), \</span>
<span class="p_add">+	AD5064_CHANNEL(2, 2, bits, shift), \</span>
<span class="p_add">+	AD5064_CHANNEL(3, 3, bits, shift), \</span>
<span class="p_add">+	AD5064_CHANNEL(4, 4, bits, shift), \</span>
<span class="p_add">+	AD5064_CHANNEL(5, 5, bits, shift), \</span>
<span class="p_add">+	AD5064_CHANNEL(6, 6, bits, shift), \</span>
<span class="p_add">+	AD5064_CHANNEL(7, 7, bits, shift), \</span>
 }
 
<span class="p_del">-#define DECLARE_AD5065_CHANNELS(name, bits) \</span>
<span class="p_add">+#define DECLARE_AD5065_CHANNELS(name, bits, shift) \</span>
 const struct iio_chan_spec name[] = { \
<span class="p_del">-	AD5064_CHANNEL(0, 0, bits), \</span>
<span class="p_del">-	AD5064_CHANNEL(1, 3, bits), \</span>
<span class="p_add">+	AD5064_CHANNEL(0, 0, bits, shift), \</span>
<span class="p_add">+	AD5064_CHANNEL(1, 3, bits, shift), \</span>
 }
 
<span class="p_del">-static DECLARE_AD5064_CHANNELS(ad5024_channels, 12);</span>
<span class="p_del">-static DECLARE_AD5064_CHANNELS(ad5044_channels, 14);</span>
<span class="p_del">-static DECLARE_AD5064_CHANNELS(ad5064_channels, 16);</span>
<span class="p_add">+static DECLARE_AD5064_CHANNELS(ad5024_channels, 12, 8);</span>
<span class="p_add">+static DECLARE_AD5064_CHANNELS(ad5044_channels, 14, 6);</span>
<span class="p_add">+static DECLARE_AD5064_CHANNELS(ad5064_channels, 16, 4);</span>
 
<span class="p_del">-static DECLARE_AD5065_CHANNELS(ad5025_channels, 12);</span>
<span class="p_del">-static DECLARE_AD5065_CHANNELS(ad5045_channels, 14);</span>
<span class="p_del">-static DECLARE_AD5065_CHANNELS(ad5065_channels, 16);</span>
<span class="p_add">+static DECLARE_AD5065_CHANNELS(ad5025_channels, 12, 8);</span>
<span class="p_add">+static DECLARE_AD5065_CHANNELS(ad5045_channels, 14, 6);</span>
<span class="p_add">+static DECLARE_AD5065_CHANNELS(ad5065_channels, 16, 4);</span>
<span class="p_add">+</span>
<span class="p_add">+static DECLARE_AD5064_CHANNELS(ad5629_channels, 12, 4);</span>
<span class="p_add">+static DECLARE_AD5064_CHANNELS(ad5669_channels, 16, 0);</span>
 
 static const struct ad5064_chip_info ad5064_chip_info_tbl[] = {
 	[ID_AD5024] = {
<span class="p_chunk">@@ -382,6 +389,18 @@</span> <span class="p_context"> static const struct ad5064_chip_info ad5064_chip_info_tbl[] = {</span>
 		.channels = ad5024_channels,
 		.num_channels = 8,
 	},
<span class="p_add">+	[ID_AD5629_1] = {</span>
<span class="p_add">+		.shared_vref = true,</span>
<span class="p_add">+		.internal_vref = 2500000,</span>
<span class="p_add">+		.channels = ad5629_channels,</span>
<span class="p_add">+		.num_channels = 8,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	[ID_AD5629_2] = {</span>
<span class="p_add">+		.shared_vref = true,</span>
<span class="p_add">+		.internal_vref = 5000000,</span>
<span class="p_add">+		.channels = ad5629_channels,</span>
<span class="p_add">+		.num_channels = 8,</span>
<span class="p_add">+	},</span>
 	[ID_AD5648_1] = {
 		.shared_vref = true,
 		.internal_vref = 2500000,
<span class="p_chunk">@@ -418,6 +437,18 @@</span> <span class="p_context"> static const struct ad5064_chip_info ad5064_chip_info_tbl[] = {</span>
 		.channels = ad5064_channels,
 		.num_channels = 8,
 	},
<span class="p_add">+	[ID_AD5669_1] = {</span>
<span class="p_add">+		.shared_vref = true,</span>
<span class="p_add">+		.internal_vref = 2500000,</span>
<span class="p_add">+		.channels = ad5669_channels,</span>
<span class="p_add">+		.num_channels = 8,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	[ID_AD5669_2] = {</span>
<span class="p_add">+		.shared_vref = true,</span>
<span class="p_add">+		.internal_vref = 5000000,</span>
<span class="p_add">+		.channels = ad5669_channels,</span>
<span class="p_add">+		.num_channels = 8,</span>
<span class="p_add">+	},</span>
 };
 
 static inline unsigned int ad5064_num_vref(struct ad5064_state *st)
<span class="p_chunk">@@ -598,10 +629,16 @@</span> <span class="p_context"> static int ad5064_i2c_write(struct ad5064_state *st, unsigned int cmd,</span>
 	unsigned int addr, unsigned int val)
 {
 	struct i2c_client *i2c = to_i2c_client(st-&gt;dev);
<span class="p_add">+	int ret;</span>
 
 	st-&gt;data.i2c[0] = (cmd &lt;&lt; 4) | addr;
 	put_unaligned_be16(val, &amp;st-&gt;data.i2c[1]);
<span class="p_del">-	return i2c_master_send(i2c, st-&gt;data.i2c, 3);</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = i2c_master_send(i2c, st-&gt;data.i2c, 3);</span>
<span class="p_add">+	if (ret &lt; 0)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
 }
 
 static int ad5064_i2c_probe(struct i2c_client *i2c,
<span class="p_chunk">@@ -617,12 +654,12 @@</span> <span class="p_context"> static int ad5064_i2c_remove(struct i2c_client *i2c)</span>
 }
 
 static const struct i2c_device_id ad5064_i2c_ids[] = {
<span class="p_del">-	{&quot;ad5629-1&quot;, ID_AD5628_1},</span>
<span class="p_del">-	{&quot;ad5629-2&quot;, ID_AD5628_2},</span>
<span class="p_del">-	{&quot;ad5629-3&quot;, ID_AD5628_2}, /* similar enough to ad5629-2 */</span>
<span class="p_del">-	{&quot;ad5669-1&quot;, ID_AD5668_1},</span>
<span class="p_del">-	{&quot;ad5669-2&quot;, ID_AD5668_2},</span>
<span class="p_del">-	{&quot;ad5669-3&quot;, ID_AD5668_2}, /* similar enough to ad5669-2 */</span>
<span class="p_add">+	{&quot;ad5629-1&quot;, ID_AD5629_1},</span>
<span class="p_add">+	{&quot;ad5629-2&quot;, ID_AD5629_2},</span>
<span class="p_add">+	{&quot;ad5629-3&quot;, ID_AD5629_2}, /* similar enough to ad5629-2 */</span>
<span class="p_add">+	{&quot;ad5669-1&quot;, ID_AD5669_1},</span>
<span class="p_add">+	{&quot;ad5669-2&quot;, ID_AD5669_2},</span>
<span class="p_add">+	{&quot;ad5669-3&quot;, ID_AD5669_2}, /* similar enough to ad5669-2 */</span>
 	{}
 };
 MODULE_DEVICE_TABLE(i2c, ad5064_i2c_ids);
<span class="p_header">diff --git a/drivers/iio/humidity/si7020.c b/drivers/iio/humidity/si7020.c</span>
<span class="p_header">index fa3b809..1b6935d 100644</span>
<span class="p_header">--- a/drivers/iio/humidity/si7020.c</span>
<span class="p_header">+++ b/drivers/iio/humidity/si7020.c</span>
<span class="p_chunk">@@ -50,10 +50,10 @@</span> <span class="p_context"> static int si7020_read_raw(struct iio_dev *indio_dev,</span>
 
 	switch (mask) {
 	case IIO_CHAN_INFO_RAW:
<span class="p_del">-		ret = i2c_smbus_read_word_data(*client,</span>
<span class="p_del">-					       chan-&gt;type == IIO_TEMP ?</span>
<span class="p_del">-					       SI7020CMD_TEMP_HOLD :</span>
<span class="p_del">-					       SI7020CMD_RH_HOLD);</span>
<span class="p_add">+		ret = i2c_smbus_read_word_swapped(*client,</span>
<span class="p_add">+						  chan-&gt;type == IIO_TEMP ?</span>
<span class="p_add">+						  SI7020CMD_TEMP_HOLD :</span>
<span class="p_add">+						  SI7020CMD_RH_HOLD);</span>
 		if (ret &lt; 0)
 			return ret;
 		*val = ret &gt;&gt; 2;
<span class="p_header">diff --git a/drivers/isdn/hisax/config.c b/drivers/isdn/hisax/config.c</span>
<span class="p_header">index b33f53b..bf04d2a 100644</span>
<span class="p_header">--- a/drivers/isdn/hisax/config.c</span>
<span class="p_header">+++ b/drivers/isdn/hisax/config.c</span>
<span class="p_chunk">@@ -1896,7 +1896,7 @@</span> <span class="p_context"> static void EChannel_proc_rcv(struct hisax_d_if *d_if)</span>
 				ptr--;
 				*ptr++ = &#39;\n&#39;;
 				*ptr = 0;
<span class="p_del">-				HiSax_putstatus(cs, NULL, &quot;%s&quot;, cs-&gt;dlog);</span>
<span class="p_add">+				HiSax_putstatus(cs, NULL, cs-&gt;dlog);</span>
 			} else
 				HiSax_putstatus(cs, &quot;LogEcho: &quot;,
 						&quot;warning Frame too big (%d)&quot;,
<span class="p_header">diff --git a/drivers/isdn/hisax/hfc_pci.c b/drivers/isdn/hisax/hfc_pci.c</span>
<span class="p_header">index 4a48255..90449e1 100644</span>
<span class="p_header">--- a/drivers/isdn/hisax/hfc_pci.c</span>
<span class="p_header">+++ b/drivers/isdn/hisax/hfc_pci.c</span>
<span class="p_chunk">@@ -901,7 +901,7 @@</span> <span class="p_context"> Begin:</span>
 					ptr--;
 					*ptr++ = &#39;\n&#39;;
 					*ptr = 0;
<span class="p_del">-					HiSax_putstatus(cs, NULL, &quot;%s&quot;, cs-&gt;dlog);</span>
<span class="p_add">+					HiSax_putstatus(cs, NULL, cs-&gt;dlog);</span>
 				} else
 					HiSax_putstatus(cs, &quot;LogEcho: &quot;, &quot;warning Frame too big (%d)&quot;, total - 3);
 			}
<span class="p_header">diff --git a/drivers/isdn/hisax/hfc_sx.c b/drivers/isdn/hisax/hfc_sx.c</span>
<span class="p_header">index b1fad81..13b2151 100644</span>
<span class="p_header">--- a/drivers/isdn/hisax/hfc_sx.c</span>
<span class="p_header">+++ b/drivers/isdn/hisax/hfc_sx.c</span>
<span class="p_chunk">@@ -674,7 +674,7 @@</span> <span class="p_context"> receive_emsg(struct IsdnCardState *cs)</span>
 					ptr--;
 					*ptr++ = &#39;\n&#39;;
 					*ptr = 0;
<span class="p_del">-					HiSax_putstatus(cs, NULL, &quot;%s&quot;, cs-&gt;dlog);</span>
<span class="p_add">+					HiSax_putstatus(cs, NULL, cs-&gt;dlog);</span>
 				} else
 					HiSax_putstatus(cs, &quot;LogEcho: &quot;, &quot;warning Frame too big (%d)&quot;, skb-&gt;len);
 			}
<span class="p_header">diff --git a/drivers/isdn/hisax/q931.c b/drivers/isdn/hisax/q931.c</span>
<span class="p_header">index b420f8b..ba4beb2 100644</span>
<span class="p_header">--- a/drivers/isdn/hisax/q931.c</span>
<span class="p_header">+++ b/drivers/isdn/hisax/q931.c</span>
<span class="p_chunk">@@ -1179,7 +1179,7 @@</span> <span class="p_context"> LogFrame(struct IsdnCardState *cs, u_char *buf, int size)</span>
 		dp--;
 		*dp++ = &#39;\n&#39;;
 		*dp = 0;
<span class="p_del">-		HiSax_putstatus(cs, NULL, &quot;%s&quot;, cs-&gt;dlog);</span>
<span class="p_add">+		HiSax_putstatus(cs, NULL, cs-&gt;dlog);</span>
 	} else
 		HiSax_putstatus(cs, &quot;LogFrame: &quot;, &quot;warning Frame too big (%d)&quot;, size);
 }
<span class="p_chunk">@@ -1246,7 +1246,7 @@</span> <span class="p_context"> dlogframe(struct IsdnCardState *cs, struct sk_buff *skb, int dir)</span>
 	}
 	if (finish) {
 		*dp = 0;
<span class="p_del">-		HiSax_putstatus(cs, NULL, &quot;%s&quot;, cs-&gt;dlog);</span>
<span class="p_add">+		HiSax_putstatus(cs, NULL, cs-&gt;dlog);</span>
 		return;
 	}
 	if ((0xfe &amp; buf[0]) == PROTO_DIS_N0) {	/* 1TR6 */
<span class="p_chunk">@@ -1509,5 +1509,5 @@</span> <span class="p_context"> dlogframe(struct IsdnCardState *cs, struct sk_buff *skb, int dir)</span>
 		dp += sprintf(dp, &quot;Unknown protocol %x!&quot;, buf[0]);
 	}
 	*dp = 0;
<span class="p_del">-	HiSax_putstatus(cs, NULL, &quot;%s&quot;, cs-&gt;dlog);</span>
<span class="p_add">+	HiSax_putstatus(cs, NULL, cs-&gt;dlog);</span>
 }
<span class="p_header">diff --git a/drivers/md/dm-mpath.c b/drivers/md/dm-mpath.c</span>
<span class="p_header">index 7ed0e7b..35cbc2a 100644</span>
<span class="p_header">--- a/drivers/md/dm-mpath.c</span>
<span class="p_header">+++ b/drivers/md/dm-mpath.c</span>
<span class="p_chunk">@@ -1548,7 +1548,7 @@</span> <span class="p_context"> static int multipath_ioctl(struct dm_target *ti, unsigned int cmd,</span>
 	if (!r &amp;&amp; ti-&gt;len != i_size_read(bdev-&gt;bd_inode) &gt;&gt; SECTOR_SHIFT)
 		r = scsi_verify_blk_ioctl(NULL, cmd);
 
<span class="p_del">-	if (r == -ENOTCONN &amp;&amp; !fatal_signal_pending(current)) {</span>
<span class="p_add">+	if (r == -ENOTCONN) {</span>
 		spin_lock_irqsave(&amp;m-&gt;lock, flags);
 		if (!m-&gt;current_pg) {
 			/* Path status changed, redo selection */
<span class="p_header">diff --git a/drivers/md/dm-thin.c b/drivers/md/dm-thin.c</span>
<span class="p_header">index 734254f..4ada0cd 100644</span>
<span class="p_header">--- a/drivers/md/dm-thin.c</span>
<span class="p_header">+++ b/drivers/md/dm-thin.c</span>
<span class="p_chunk">@@ -2183,6 +2183,7 @@</span> <span class="p_context"> static void set_pool_mode(struct pool *pool, enum pool_mode new_mode)</span>
 	case PM_WRITE:
 		if (old_mode != new_mode)
 			notify_of_pool_mode_change(pool, &quot;write&quot;);
<span class="p_add">+		pool-&gt;pf.error_if_no_space = pt-&gt;requested_pf.error_if_no_space;</span>
 		dm_pool_metadata_read_write(pool-&gt;pmd);
 		pool-&gt;process_bio = process_bio;
 		pool-&gt;process_discard = process_discard_bio;
<span class="p_header">diff --git a/drivers/md/dm.c b/drivers/md/dm.c</span>
<span class="p_header">index df81bbd..b93f32d 100644</span>
<span class="p_header">--- a/drivers/md/dm.c</span>
<span class="p_header">+++ b/drivers/md/dm.c</span>
<span class="p_chunk">@@ -543,7 +543,7 @@</span> <span class="p_context"> retry:</span>
 out:
 	dm_put_live_table(md, srcu_idx);
 
<span class="p_del">-	if (r == -ENOTCONN) {</span>
<span class="p_add">+	if (r == -ENOTCONN &amp;&amp; !fatal_signal_pending(current)) {</span>
 		msleep(10);
 		goto retry;
 	}
<span class="p_header">diff --git a/drivers/mmc/card/block.c b/drivers/mmc/card/block.c</span>
<span class="p_header">index 28fb2ed..d1e2d3b 100644</span>
<span class="p_header">--- a/drivers/mmc/card/block.c</span>
<span class="p_header">+++ b/drivers/mmc/card/block.c</span>
<span class="p_chunk">@@ -62,8 +62,7 @@</span> <span class="p_context"> MODULE_ALIAS(&quot;mmc:block&quot;);</span>
 #define MMC_SANITIZE_REQ_TIMEOUT 240000
 #define MMC_EXTRACT_INDEX_FROM_ARG(x) ((x &amp; 0x00FF0000) &gt;&gt; 16)
 
<span class="p_del">-#define mmc_req_rel_wr(req)	(((req-&gt;cmd_flags &amp; REQ_FUA) || \</span>
<span class="p_del">-				  (req-&gt;cmd_flags &amp; REQ_META)) &amp;&amp; \</span>
<span class="p_add">+#define mmc_req_rel_wr(req)	((req-&gt;cmd_flags &amp; REQ_FUA) &amp;&amp; \</span>
 				  (rq_data_dir(req) == WRITE))
 #define PACKED_CMD_VER	0x01
 #define PACKED_CMD_WR	0x02
<span class="p_chunk">@@ -1367,13 +1366,9 @@</span> <span class="p_context"> static void mmc_blk_rw_rq_prep(struct mmc_queue_req *mqrq,</span>
 
 	/*
 	 * Reliable writes are used to implement Forced Unit Access and
<span class="p_del">-	 * REQ_META accesses, and are supported only on MMCs.</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * XXX: this really needs a good explanation of why REQ_META</span>
<span class="p_del">-	 * is treated special.</span>
<span class="p_add">+	 * are supported only on MMCs.</span>
 	 */
<span class="p_del">-	bool do_rel_wr = ((req-&gt;cmd_flags &amp; REQ_FUA) ||</span>
<span class="p_del">-			  (req-&gt;cmd_flags &amp; REQ_META)) &amp;&amp;</span>
<span class="p_add">+	bool do_rel_wr = (req-&gt;cmd_flags &amp; REQ_FUA) &amp;&amp;</span>
 		(rq_data_dir(req) == WRITE) &amp;&amp;
 		(md-&gt;flags &amp; MMC_BLK_REL_WR);
 
<span class="p_header">diff --git a/drivers/net/can/sja1000/sja1000.c b/drivers/net/can/sja1000/sja1000.c</span>
<span class="p_header">index 32bd7f4..0c048e2 100644</span>
<span class="p_header">--- a/drivers/net/can/sja1000/sja1000.c</span>
<span class="p_header">+++ b/drivers/net/can/sja1000/sja1000.c</span>
<span class="p_chunk">@@ -218,6 +218,9 @@</span> <span class="p_context"> static void sja1000_start(struct net_device *dev)</span>
 	priv-&gt;write_reg(priv, SJA1000_RXERR, 0x0);
 	priv-&gt;read_reg(priv, SJA1000_ECC);
 
<span class="p_add">+	/* clear interrupt flags */</span>
<span class="p_add">+	priv-&gt;read_reg(priv, SJA1000_IR);</span>
<span class="p_add">+</span>
 	/* leave reset mode */
 	set_normal_mode(dev);
 }
<span class="p_header">diff --git a/drivers/net/ethernet/marvell/mvneta.c b/drivers/net/ethernet/marvell/mvneta.c</span>
<span class="p_header">index 5ff18c1..3832570 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/marvell/mvneta.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/marvell/mvneta.c</span>
<span class="p_chunk">@@ -35,7 +35,7 @@</span> <span class="p_context"></span>
 
 /* Registers */
 #define MVNETA_RXQ_CONFIG_REG(q)                (0x1400 + ((q) &lt;&lt; 2))
<span class="p_del">-#define      MVNETA_RXQ_HW_BUF_ALLOC            BIT(1)</span>
<span class="p_add">+#define      MVNETA_RXQ_HW_BUF_ALLOC            BIT(0)</span>
 #define      MVNETA_RXQ_PKT_OFFSET_ALL_MASK     (0xf    &lt;&lt; 8)
 #define      MVNETA_RXQ_PKT_OFFSET_MASK(offs)   ((offs) &lt;&lt; 8)
 #define MVNETA_RXQ_THRESHOLD_REG(q)             (0x14c0 + ((q) &lt;&lt; 2))
<span class="p_chunk">@@ -61,6 +61,7 @@</span> <span class="p_context"></span>
 #define MVNETA_WIN_SIZE(w)                      (0x2204 + ((w) &lt;&lt; 3))
 #define MVNETA_WIN_REMAP(w)                     (0x2280 + ((w) &lt;&lt; 2))
 #define MVNETA_BASE_ADDR_ENABLE                 0x2290
<span class="p_add">+#define MVNETA_ACCESS_PROTECT_ENABLE            0x2294</span>
 #define MVNETA_PORT_CONFIG                      0x2400
 #define      MVNETA_UNI_PROMISC_MODE            BIT(0)
 #define      MVNETA_DEF_RXQ(q)                  ((q) &lt;&lt; 1)
<span class="p_chunk">@@ -153,7 +154,7 @@</span> <span class="p_context"></span>
 
 #define MVNETA_INTR_ENABLE                       0x25b8
 #define      MVNETA_TXQ_INTR_ENABLE_ALL_MASK     0x0000ff00
<span class="p_del">-#define      MVNETA_RXQ_INTR_ENABLE_ALL_MASK     0xff000000  // note: neta says it&#39;s 0x000000FF</span>
<span class="p_add">+#define      MVNETA_RXQ_INTR_ENABLE_ALL_MASK     0x000000ff</span>
 
 #define MVNETA_RXQ_CMD                           0x2680
 #define      MVNETA_RXQ_DISABLE_SHIFT            8
<span class="p_chunk">@@ -2899,6 +2900,7 @@</span> <span class="p_context"> static void mvneta_conf_mbus_windows(struct mvneta_port *pp,</span>
 	}
 
 	mvreg_write(pp, MVNETA_BASE_ADDR_ENABLE, win_enable);
<span class="p_add">+	mvreg_write(pp, MVNETA_ACCESS_PROTECT_ENABLE, win_protect);</span>
 }
 
 /* Power up the port */
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/main.c b/drivers/net/ethernet/mellanox/mlx4/main.c</span>
<span class="p_header">index 6e08352..e5340b2 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/main.c</span>
<span class="p_chunk">@@ -829,9 +829,10 @@</span> <span class="p_context"> static int mlx4_slave_cap(struct mlx4_dev *dev)</span>
 		dev-&gt;caps.qp1_proxy[i - 1] = func_cap.qp1_proxy_qpn;
 		dev-&gt;caps.port_mask[i] = dev-&gt;caps.port_type[i];
 		dev-&gt;caps.phys_port_id[i] = func_cap.phys_port_id;
<span class="p_del">-		if (mlx4_get_slave_pkey_gid_tbl_len(dev, i,</span>
<span class="p_del">-						    &amp;dev-&gt;caps.gid_table_len[i],</span>
<span class="p_del">-						    &amp;dev-&gt;caps.pkey_table_len[i]))</span>
<span class="p_add">+		err = mlx4_get_slave_pkey_gid_tbl_len(dev, i,</span>
<span class="p_add">+						      &amp;dev-&gt;caps.gid_table_len[i],</span>
<span class="p_add">+						      &amp;dev-&gt;caps.pkey_table_len[i]);</span>
<span class="p_add">+		if (err)</span>
 			goto err_mem;
 	}
 
<span class="p_chunk">@@ -841,6 +842,7 @@</span> <span class="p_context"> static int mlx4_slave_cap(struct mlx4_dev *dev)</span>
 		mlx4_err(dev, &quot;HCA reported UAR region size of 0x%x bigger than PCI resource 2 size of 0x%llx, aborting\n&quot;,
 			 dev-&gt;caps.uar_page_size * dev-&gt;caps.num_uars,
 			 (unsigned long long) pci_resource_len(dev-&gt;pdev, 2));
<span class="p_add">+		err = -ENOMEM;</span>
 		goto err_mem;
 	}
 
<span class="p_header">diff --git a/drivers/net/ipvlan/ipvlan_core.c b/drivers/net/ipvlan/ipvlan_core.c</span>
<span class="p_header">index 8df3268..3665a0b 100644</span>
<span class="p_header">--- a/drivers/net/ipvlan/ipvlan_core.c</span>
<span class="p_header">+++ b/drivers/net/ipvlan/ipvlan_core.c</span>
<span class="p_chunk">@@ -237,7 +237,7 @@</span> <span class="p_context"> mcast_acct:</span>
 	}
 }
 
<span class="p_del">-static int ipvlan_rcv_frame(struct ipvl_addr *addr, struct sk_buff *skb,</span>
<span class="p_add">+static int ipvlan_rcv_frame(struct ipvl_addr *addr, struct sk_buff **pskb,</span>
 			    bool local)
 {
 	struct ipvl_dev *ipvlan = addr-&gt;master;
<span class="p_chunk">@@ -245,6 +245,7 @@</span> <span class="p_context"> static int ipvlan_rcv_frame(struct ipvl_addr *addr, struct sk_buff *skb,</span>
 	unsigned int len;
 	rx_handler_result_t ret = RX_HANDLER_CONSUMED;
 	bool success = false;
<span class="p_add">+	struct sk_buff *skb = *pskb;</span>
 
 	len = skb-&gt;len + ETH_HLEN;
 	if (unlikely(!(dev-&gt;flags &amp; IFF_UP))) {
<span class="p_chunk">@@ -256,6 +257,7 @@</span> <span class="p_context"> static int ipvlan_rcv_frame(struct ipvl_addr *addr, struct sk_buff *skb,</span>
 	if (!skb)
 		goto out;
 
<span class="p_add">+	*pskb = skb;</span>
 	skb-&gt;dev = dev;
 	skb-&gt;pkt_type = PACKET_HOST;
 
<span class="p_chunk">@@ -447,7 +449,7 @@</span> <span class="p_context"> static int ipvlan_xmit_mode_l3(struct sk_buff *skb, struct net_device *dev)</span>
 
 	addr = ipvlan_addr_lookup(ipvlan-&gt;port, lyr3h, addr_type, true);
 	if (addr)
<span class="p_del">-		return ipvlan_rcv_frame(addr, skb, true);</span>
<span class="p_add">+		return ipvlan_rcv_frame(addr, &amp;skb, true);</span>
 
 out:
 	skb-&gt;dev = ipvlan-&gt;phy_dev;
<span class="p_chunk">@@ -467,7 +469,7 @@</span> <span class="p_context"> static int ipvlan_xmit_mode_l2(struct sk_buff *skb, struct net_device *dev)</span>
 		if (lyr3h) {
 			addr = ipvlan_addr_lookup(ipvlan-&gt;port, lyr3h, addr_type, true);
 			if (addr)
<span class="p_del">-				return ipvlan_rcv_frame(addr, skb, true);</span>
<span class="p_add">+				return ipvlan_rcv_frame(addr, &amp;skb, true);</span>
 		}
 		skb = skb_share_check(skb, GFP_ATOMIC);
 		if (!skb)
<span class="p_chunk">@@ -553,7 +555,7 @@</span> <span class="p_context"> static rx_handler_result_t ipvlan_handle_mode_l3(struct sk_buff **pskb,</span>
 
 	addr = ipvlan_addr_lookup(port, lyr3h, addr_type, true);
 	if (addr)
<span class="p_del">-		ret = ipvlan_rcv_frame(addr, skb, false);</span>
<span class="p_add">+		ret = ipvlan_rcv_frame(addr, pskb, false);</span>
 
 out:
 	return ret;
<span class="p_chunk">@@ -580,7 +582,7 @@</span> <span class="p_context"> static rx_handler_result_t ipvlan_handle_mode_l2(struct sk_buff **pskb,</span>
 
 		addr = ipvlan_addr_lookup(port, lyr3h, addr_type, true);
 		if (addr)
<span class="p_del">-			ret = ipvlan_rcv_frame(addr, skb, false);</span>
<span class="p_add">+			ret = ipvlan_rcv_frame(addr, pskb, false);</span>
 	}
 
 	return ret;
<span class="p_chunk">@@ -605,5 +607,5 @@</span> <span class="p_context"> rx_handler_result_t ipvlan_handle_frame(struct sk_buff **pskb)</span>
 	WARN_ONCE(true, &quot;ipvlan_handle_frame() called for mode = [%hx]\n&quot;,
 			  port-&gt;mode);
 	kfree_skb(skb);
<span class="p_del">-	return NET_RX_DROP;</span>
<span class="p_add">+	return RX_HANDLER_CONSUMED;</span>
 }
<span class="p_header">diff --git a/drivers/net/macvlan.c b/drivers/net/macvlan.c</span>
<span class="p_header">index 612e073..1d1511c 100644</span>
<span class="p_header">--- a/drivers/net/macvlan.c</span>
<span class="p_header">+++ b/drivers/net/macvlan.c</span>
<span class="p_chunk">@@ -415,6 +415,7 @@</span> <span class="p_context"> static rx_handler_result_t macvlan_handle_frame(struct sk_buff **pskb)</span>
 		skb = ip_check_defrag(skb, IP_DEFRAG_MACVLAN);
 		if (!skb)
 			return RX_HANDLER_CONSUMED;
<span class="p_add">+		*pskb = skb;</span>
 		eth = eth_hdr(skb);
 		macvlan_forward_source(skb, port, eth-&gt;h_source);
 		src = macvlan_hash_lookup(port, eth-&gt;h_source);
<span class="p_chunk">@@ -456,6 +457,7 @@</span> <span class="p_context"> static rx_handler_result_t macvlan_handle_frame(struct sk_buff **pskb)</span>
 		goto out;
 	}
 
<span class="p_add">+	*pskb = skb;</span>
 	skb-&gt;dev = dev;
 	skb-&gt;pkt_type = PACKET_HOST;
 
<span class="p_header">diff --git a/drivers/net/phy/broadcom.c b/drivers/net/phy/broadcom.c</span>
<span class="p_header">index a52afb2..ca5db60 100644</span>
<span class="p_header">--- a/drivers/net/phy/broadcom.c</span>
<span class="p_header">+++ b/drivers/net/phy/broadcom.c</span>
<span class="p_chunk">@@ -661,7 +661,7 @@</span> <span class="p_context"> static struct mdio_device_id __maybe_unused broadcom_tbl[] = {</span>
 	{ PHY_ID_BCM5421, 0xfffffff0 },
 	{ PHY_ID_BCM5461, 0xfffffff0 },
 	{ PHY_ID_BCM5464, 0xfffffff0 },
<span class="p_del">-	{ PHY_ID_BCM5482, 0xfffffff0 },</span>
<span class="p_add">+	{ PHY_ID_BCM5481, 0xfffffff0 },</span>
 	{ PHY_ID_BCM5482, 0xfffffff0 },
 	{ PHY_ID_BCM50610, 0xfffffff0 },
 	{ PHY_ID_BCM50610M, 0xfffffff0 },
<span class="p_header">diff --git a/drivers/net/wan/x25_asy.c b/drivers/net/wan/x25_asy.c</span>
<span class="p_header">index 5c47b01..cd39025 100644</span>
<span class="p_header">--- a/drivers/net/wan/x25_asy.c</span>
<span class="p_header">+++ b/drivers/net/wan/x25_asy.c</span>
<span class="p_chunk">@@ -549,16 +549,12 @@</span> <span class="p_context"> static void x25_asy_receive_buf(struct tty_struct *tty,</span>
 
 static int x25_asy_open_tty(struct tty_struct *tty)
 {
<span class="p_del">-	struct x25_asy *sl = tty-&gt;disc_data;</span>
<span class="p_add">+	struct x25_asy *sl;</span>
 	int err;
 
 	if (tty-&gt;ops-&gt;write == NULL)
 		return -EOPNOTSUPP;
 
<span class="p_del">-	/* First make sure we&#39;re not already connected. */</span>
<span class="p_del">-	if (sl &amp;&amp; sl-&gt;magic == X25_ASY_MAGIC)</span>
<span class="p_del">-		return -EEXIST;</span>
<span class="p_del">-</span>
 	/* OK.  Find a free X.25 channel to use. */
 	sl = x25_asy_alloc();
 	if (sl == NULL)
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath10k/mac.c b/drivers/net/wireless/ath/ath10k/mac.c</span>
<span class="p_header">index 05597cb..bbee156 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath10k/mac.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath10k/mac.c</span>
<span class="p_chunk">@@ -2845,7 +2845,7 @@</span> <span class="p_context"> static int ath10k_config(struct ieee80211_hw *hw, u32 changed)</span>
 
 static u32 get_nss_from_chainmask(u16 chain_mask)
 {
<span class="p_del">-	if ((chain_mask &amp; 0x15) == 0x15)</span>
<span class="p_add">+	if ((chain_mask &amp; 0xf) == 0xf)</span>
 		return 4;
 	else if ((chain_mask &amp; 0x7) == 0x7)
 		return 3;
<span class="p_header">diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c</span>
<span class="p_header">index 9261868..eead54c 100644</span>
<span class="p_header">--- a/drivers/pci/pci-sysfs.c</span>
<span class="p_header">+++ b/drivers/pci/pci-sysfs.c</span>
<span class="p_chunk">@@ -216,7 +216,10 @@</span> <span class="p_context"> static ssize_t numa_node_store(struct device *dev,</span>
 	if (ret)
 		return ret;
 
<span class="p_del">-	if (node &gt;= MAX_NUMNODES || !node_online(node))</span>
<span class="p_add">+	if ((node &lt; 0 &amp;&amp; node != NUMA_NO_NODE) || node &gt;= MAX_NUMNODES)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (node != NUMA_NO_NODE &amp;&amp; !node_online(node))</span>
 		return -EINVAL;
 
 	add_taint(TAINT_FIRMWARE_WORKAROUND, LOCKDEP_STILL_OK);
<span class="p_header">diff --git a/drivers/remoteproc/remoteproc_debugfs.c b/drivers/remoteproc/remoteproc_debugfs.c</span>
<span class="p_header">index 9d30809..916af50 100644</span>
<span class="p_header">--- a/drivers/remoteproc/remoteproc_debugfs.c</span>
<span class="p_header">+++ b/drivers/remoteproc/remoteproc_debugfs.c</span>
<span class="p_chunk">@@ -156,7 +156,7 @@</span> <span class="p_context"> rproc_recovery_write(struct file *filp, const char __user *user_buf,</span>
 	char buf[10];
 	int ret;
 
<span class="p_del">-	if (count &gt; sizeof(buf))</span>
<span class="p_add">+	if (count &lt; 1 || count &gt; sizeof(buf))</span>
 		return count;
 
 	ret = copy_from_user(buf, user_buf, count);
<span class="p_header">diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c</span>
<span class="p_header">index 8bb173e..7d647a3 100644</span>
<span class="p_header">--- a/drivers/scsi/hosts.c</span>
<span class="p_header">+++ b/drivers/scsi/hosts.c</span>
<span class="p_chunk">@@ -326,6 +326,17 @@</span> <span class="p_context"> static void scsi_host_dev_release(struct device *dev)</span>
 		kfree(queuedata);
 	}
 
<span class="p_add">+	if (shost-&gt;shost_state == SHOST_CREATED) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Free the shost_dev device name here if scsi_host_alloc()</span>
<span class="p_add">+		 * and scsi_host_put() have been called but neither</span>
<span class="p_add">+		 * scsi_host_add() nor scsi_host_remove() has been called.</span>
<span class="p_add">+		 * This avoids that the memory allocated for the shost_dev</span>
<span class="p_add">+		 * name is leaked.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		kfree(dev_name(&amp;shost-&gt;shost_dev));</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	scsi_destroy_command_freelist(shost);
 	if (shost_use_blk_mq(shost)) {
 		if (shost-&gt;tag_set.tags)
<span class="p_header">diff --git a/drivers/staging/iio/adc/lpc32xx_adc.c b/drivers/staging/iio/adc/lpc32xx_adc.c</span>
<span class="p_header">index 5331c44..ef6d0b0 100644</span>
<span class="p_header">--- a/drivers/staging/iio/adc/lpc32xx_adc.c</span>
<span class="p_header">+++ b/drivers/staging/iio/adc/lpc32xx_adc.c</span>
<span class="p_chunk">@@ -76,7 +76,7 @@</span> <span class="p_context"> static int lpc32xx_read_raw(struct iio_dev *indio_dev,</span>
 
 	if (mask == IIO_CHAN_INFO_RAW) {
 		mutex_lock(&amp;indio_dev-&gt;mlock);
<span class="p_del">-		clk_enable(info-&gt;clk);</span>
<span class="p_add">+		clk_prepare_enable(info-&gt;clk);</span>
 		/* Measurement setup */
 		__raw_writel(AD_INTERNAL | (chan-&gt;address) | AD_REFp | AD_REFm,
 			LPC32XX_ADC_SELECT(info-&gt;adc_base));
<span class="p_chunk">@@ -84,7 +84,7 @@</span> <span class="p_context"> static int lpc32xx_read_raw(struct iio_dev *indio_dev,</span>
 		__raw_writel(AD_PDN_CTRL | AD_STROBE,
 			LPC32XX_ADC_CTRL(info-&gt;adc_base));
 		wait_for_completion(&amp;info-&gt;completion); /* set by ISR */
<span class="p_del">-		clk_disable(info-&gt;clk);</span>
<span class="p_add">+		clk_disable_unprepare(info-&gt;clk);</span>
 		*val = info-&gt;value;
 		mutex_unlock(&amp;indio_dev-&gt;mlock);
 
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target.c b/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_header">index 0c508a4..78dda5a 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_chunk">@@ -4052,6 +4052,17 @@</span> <span class="p_context"> reject:</span>
 	return iscsit_add_reject(conn, ISCSI_REASON_BOOKMARK_NO_RESOURCES, buf);
 }
 
<span class="p_add">+static bool iscsi_target_check_conn_state(struct iscsi_conn *conn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	bool ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_bh(&amp;conn-&gt;state_lock);</span>
<span class="p_add">+	ret = (conn-&gt;conn_state != TARG_CONN_STATE_LOGGED_IN);</span>
<span class="p_add">+	spin_unlock_bh(&amp;conn-&gt;state_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int iscsi_target_rx_thread(void *arg)
 {
 	int ret, rc;
<span class="p_chunk">@@ -4069,7 +4080,7 @@</span> <span class="p_context"> int iscsi_target_rx_thread(void *arg)</span>
 	 * incoming iscsi/tcp socket I/O, and/or failing the connection.
 	 */
 	rc = wait_for_completion_interruptible(&amp;conn-&gt;rx_login_comp);
<span class="p_del">-	if (rc &lt; 0)</span>
<span class="p_add">+	if (rc &lt; 0 || iscsi_target_check_conn_state(conn))</span>
 		return 0;
 
 	if (conn-&gt;conn_transport-&gt;transport_type == ISCSI_INFINIBAND) {
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target_nego.c b/drivers/target/iscsi/iscsi_target_nego.c</span>
<span class="p_header">index 092112e..dcb6348 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target_nego.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target_nego.c</span>
<span class="p_chunk">@@ -393,6 +393,7 @@</span> <span class="p_context"> err:</span>
 	if (login-&gt;login_complete) {
 		if (conn-&gt;rx_thread &amp;&amp; conn-&gt;rx_thread_active) {
 			send_sig(SIGINT, conn-&gt;rx_thread, 1);
<span class="p_add">+			complete(&amp;conn-&gt;rx_login_comp);</span>
 			kthread_stop(conn-&gt;rx_thread);
 		}
 		if (conn-&gt;tx_thread &amp;&amp; conn-&gt;tx_thread_active) {
<span class="p_header">diff --git a/drivers/target/target_core_sbc.c b/drivers/target/target_core_sbc.c</span>
<span class="p_header">index 48de053..973fd98 100644</span>
<span class="p_header">--- a/drivers/target/target_core_sbc.c</span>
<span class="p_header">+++ b/drivers/target/target_core_sbc.c</span>
<span class="p_chunk">@@ -299,7 +299,8 @@</span> <span class="p_context"> sbc_setup_write_same(struct se_cmd *cmd, unsigned char *flags, struct sbc_ops *o</span>
 	return 0;
 }
 
<span class="p_del">-static sense_reason_t xdreadwrite_callback(struct se_cmd *cmd, bool success)</span>
<span class="p_add">+static sense_reason_t xdreadwrite_callback(struct se_cmd *cmd, bool success,</span>
<span class="p_add">+					   int *post_ret)</span>
 {
 	unsigned char *buf, *addr;
 	struct scatterlist *sg;
<span class="p_chunk">@@ -363,7 +364,8 @@</span> <span class="p_context"> sbc_execute_rw(struct se_cmd *cmd)</span>
 			       cmd-&gt;data_direction);
 }
 
<span class="p_del">-static sense_reason_t compare_and_write_post(struct se_cmd *cmd, bool success)</span>
<span class="p_add">+static sense_reason_t compare_and_write_post(struct se_cmd *cmd, bool success,</span>
<span class="p_add">+					     int *post_ret)</span>
 {
 	struct se_device *dev = cmd-&gt;se_dev;
 
<span class="p_chunk">@@ -373,8 +375,10 @@</span> <span class="p_context"> static sense_reason_t compare_and_write_post(struct se_cmd *cmd, bool success)</span>
 	 * sent to the backend driver.
 	 */
 	spin_lock_irq(&amp;cmd-&gt;t_state_lock);
<span class="p_del">-	if ((cmd-&gt;transport_state &amp; CMD_T_SENT) &amp;&amp; !cmd-&gt;scsi_status)</span>
<span class="p_add">+	if ((cmd-&gt;transport_state &amp; CMD_T_SENT) &amp;&amp; !cmd-&gt;scsi_status) {</span>
 		cmd-&gt;se_cmd_flags |= SCF_COMPARE_AND_WRITE_POST;
<span class="p_add">+		*post_ret = 1;</span>
<span class="p_add">+	}</span>
 	spin_unlock_irq(&amp;cmd-&gt;t_state_lock);
 
 	/*
<span class="p_chunk">@@ -386,7 +390,8 @@</span> <span class="p_context"> static sense_reason_t compare_and_write_post(struct se_cmd *cmd, bool success)</span>
 	return TCM_NO_SENSE;
 }
 
<span class="p_del">-static sense_reason_t compare_and_write_callback(struct se_cmd *cmd, bool success)</span>
<span class="p_add">+static sense_reason_t compare_and_write_callback(struct se_cmd *cmd, bool success,</span>
<span class="p_add">+						 int *post_ret)</span>
 {
 	struct se_device *dev = cmd-&gt;se_dev;
 	struct scatterlist *write_sg = NULL, *sg;
<span class="p_chunk">@@ -482,11 +487,11 @@</span> <span class="p_context"> static sense_reason_t compare_and_write_callback(struct se_cmd *cmd, bool succes</span>
 
 		if (block_size &lt; PAGE_SIZE) {
 			sg_set_page(&amp;write_sg[i], m.page, block_size,
<span class="p_del">-				    block_size);</span>
<span class="p_add">+				    m.piter.sg-&gt;offset + block_size);</span>
 		} else {
 			sg_miter_next(&amp;m);
 			sg_set_page(&amp;write_sg[i], m.page, block_size,
<span class="p_del">-				    0);</span>
<span class="p_add">+				    m.piter.sg-&gt;offset);</span>
 		}
 		len -= block_size;
 		i++;
<span class="p_header">diff --git a/drivers/target/target_core_transport.c b/drivers/target/target_core_transport.c</span>
<span class="p_header">index f786de0..a738637 100644</span>
<span class="p_header">--- a/drivers/target/target_core_transport.c</span>
<span class="p_header">+++ b/drivers/target/target_core_transport.c</span>
<span class="p_chunk">@@ -1596,7 +1596,7 @@</span> <span class="p_context"> bool target_stop_cmd(struct se_cmd *cmd, unsigned long *flags)</span>
 void transport_generic_request_failure(struct se_cmd *cmd,
 		sense_reason_t sense_reason)
 {
<span class="p_del">-	int ret = 0;</span>
<span class="p_add">+	int ret = 0, post_ret = 0;</span>
 
 	pr_debug(&quot;-----[ Storage Engine Exception for cmd: %p ITT: 0x%08x&quot;
 		&quot; CDB: 0x%02x\n&quot;, cmd, cmd-&gt;se_tfo-&gt;get_task_tag(cmd),
<span class="p_chunk">@@ -1619,7 +1619,7 @@</span> <span class="p_context"> void transport_generic_request_failure(struct se_cmd *cmd,</span>
 	 */
 	if ((cmd-&gt;se_cmd_flags &amp; SCF_COMPARE_AND_WRITE) &amp;&amp;
 	     cmd-&gt;transport_complete_callback)
<span class="p_del">-		cmd-&gt;transport_complete_callback(cmd, false);</span>
<span class="p_add">+		cmd-&gt;transport_complete_callback(cmd, false, &amp;post_ret);</span>
 
 	switch (sense_reason) {
 	case TCM_NON_EXISTENT_LUN:
<span class="p_chunk">@@ -1974,11 +1974,13 @@</span> <span class="p_context"> static void target_complete_ok_work(struct work_struct *work)</span>
 	 */
 	if (cmd-&gt;transport_complete_callback) {
 		sense_reason_t rc;
<span class="p_add">+		bool caw = (cmd-&gt;se_cmd_flags &amp; SCF_COMPARE_AND_WRITE);</span>
<span class="p_add">+		bool zero_dl = !(cmd-&gt;data_length);</span>
<span class="p_add">+		int post_ret = 0;</span>
 
<span class="p_del">-		rc = cmd-&gt;transport_complete_callback(cmd, true);</span>
<span class="p_del">-		if (!rc &amp;&amp; !(cmd-&gt;se_cmd_flags &amp; SCF_COMPARE_AND_WRITE_POST)) {</span>
<span class="p_del">-			if ((cmd-&gt;se_cmd_flags &amp; SCF_COMPARE_AND_WRITE) &amp;&amp;</span>
<span class="p_del">-			    !cmd-&gt;data_length)</span>
<span class="p_add">+		rc = cmd-&gt;transport_complete_callback(cmd, true, &amp;post_ret);</span>
<span class="p_add">+		if (!rc &amp;&amp; !post_ret) {</span>
<span class="p_add">+			if (caw &amp;&amp; zero_dl)</span>
 				goto queue_rsp;
 
 			return;
<span class="p_header">diff --git a/drivers/tty/tty_io.c b/drivers/tty/tty_io.c</span>
<span class="p_header">index 27051e29..cc7b224 100644</span>
<span class="p_header">--- a/drivers/tty/tty_io.c</span>
<span class="p_header">+++ b/drivers/tty/tty_io.c</span>
<span class="p_chunk">@@ -1281,18 +1281,22 @@</span> <span class="p_context"> int tty_send_xchar(struct tty_struct *tty, char ch)</span>
 	int	was_stopped = tty-&gt;stopped;
 
 	if (tty-&gt;ops-&gt;send_xchar) {
<span class="p_add">+		down_read(&amp;tty-&gt;termios_rwsem);</span>
 		tty-&gt;ops-&gt;send_xchar(tty, ch);
<span class="p_add">+		up_read(&amp;tty-&gt;termios_rwsem);</span>
 		return 0;
 	}
 
 	if (tty_write_lock(tty, 0) &lt; 0)
 		return -ERESTARTSYS;
 
<span class="p_add">+	down_read(&amp;tty-&gt;termios_rwsem);</span>
 	if (was_stopped)
 		start_tty(tty);
 	tty-&gt;ops-&gt;write(tty, &amp;ch, 1);
 	if (was_stopped)
 		stop_tty(tty);
<span class="p_add">+	up_read(&amp;tty-&gt;termios_rwsem);</span>
 	tty_write_unlock(tty);
 	return 0;
 }
<span class="p_header">diff --git a/drivers/tty/tty_ioctl.c b/drivers/tty/tty_ioctl.c</span>
<span class="p_header">index 552076b..a9fe807 100644</span>
<span class="p_header">--- a/drivers/tty/tty_ioctl.c</span>
<span class="p_header">+++ b/drivers/tty/tty_ioctl.c</span>
<span class="p_chunk">@@ -1144,16 +1144,12 @@</span> <span class="p_context"> int n_tty_ioctl_helper(struct tty_struct *tty, struct file *file,</span>
 			spin_unlock_irq(&amp;tty-&gt;flow_lock);
 			break;
 		case TCIOFF:
<span class="p_del">-			down_read(&amp;tty-&gt;termios_rwsem);</span>
 			if (STOP_CHAR(tty) != __DISABLED_CHAR)
 				retval = tty_send_xchar(tty, STOP_CHAR(tty));
<span class="p_del">-			up_read(&amp;tty-&gt;termios_rwsem);</span>
 			break;
 		case TCION:
<span class="p_del">-			down_read(&amp;tty-&gt;termios_rwsem);</span>
 			if (START_CHAR(tty) != __DISABLED_CHAR)
 				retval = tty_send_xchar(tty, START_CHAR(tty));
<span class="p_del">-			up_read(&amp;tty-&gt;termios_rwsem);</span>
 			break;
 		default:
 			return -EINVAL;
<span class="p_header">diff --git a/drivers/usb/chipidea/debug.c b/drivers/usb/chipidea/debug.c</span>
<span class="p_header">index 268e423..cc29dc2 100644</span>
<span class="p_header">--- a/drivers/usb/chipidea/debug.c</span>
<span class="p_header">+++ b/drivers/usb/chipidea/debug.c</span>
<span class="p_chunk">@@ -312,8 +312,10 @@</span> <span class="p_context"> static ssize_t ci_role_write(struct file *file, const char __user *ubuf,</span>
 	if (role == CI_ROLE_END || role == ci-&gt;role)
 		return -EINVAL;
 
<span class="p_add">+	disable_irq(ci-&gt;irq);</span>
 	ci_role_stop(ci);
 	ret = ci_role_start(ci, role);
<span class="p_add">+	enable_irq(ci-&gt;irq);</span>
 
 	return ret ? ret : count;
 }
<span class="p_header">diff --git a/drivers/usb/class/usblp.c b/drivers/usb/class/usblp.c</span>
<span class="p_header">index 0924ee4..b9adc2e 100644</span>
<span class="p_header">--- a/drivers/usb/class/usblp.c</span>
<span class="p_header">+++ b/drivers/usb/class/usblp.c</span>
<span class="p_chunk">@@ -869,11 +869,11 @@</span> <span class="p_context"> static int usblp_wwait(struct usblp *usblp, int nonblock)</span>
 
 	add_wait_queue(&amp;usblp-&gt;wwait, &amp;waita);
 	for (;;) {
<span class="p_del">-		set_current_state(TASK_INTERRUPTIBLE);</span>
 		if (mutex_lock_interruptible(&amp;usblp-&gt;mut)) {
 			rc = -EINTR;
 			break;
 		}
<span class="p_add">+		set_current_state(TASK_INTERRUPTIBLE);</span>
 		rc = usblp_wtest(usblp, nonblock);
 		mutex_unlock(&amp;usblp-&gt;mut);
 		if (rc &lt;= 0)
<span class="p_header">diff --git a/drivers/usb/dwc3/gadget.c b/drivers/usb/dwc3/gadget.c</span>
<span class="p_header">index 5496218..65c8791 100644</span>
<span class="p_header">--- a/drivers/usb/dwc3/gadget.c</span>
<span class="p_header">+++ b/drivers/usb/dwc3/gadget.c</span>
<span class="p_chunk">@@ -2707,12 +2707,33 @@</span> <span class="p_context"> int dwc3_gadget_init(struct dwc3 *dwc)</span>
 	}
 
 	dwc-&gt;gadget.ops			= &amp;dwc3_gadget_ops;
<span class="p_del">-	dwc-&gt;gadget.max_speed		= USB_SPEED_SUPER;</span>
 	dwc-&gt;gadget.speed		= USB_SPEED_UNKNOWN;
 	dwc-&gt;gadget.sg_supported	= true;
 	dwc-&gt;gadget.name		= &quot;dwc3-gadget&quot;;
 
 	/*
<span class="p_add">+	 * FIXME We might be setting max_speed to &lt;SUPER, however versions</span>
<span class="p_add">+	 * &lt;2.20a of dwc3 have an issue with metastability (documented</span>
<span class="p_add">+	 * elsewhere in this driver) which tells us we can&#39;t set max speed to</span>
<span class="p_add">+	 * anything lower than SUPER.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Because gadget.max_speed is only used by composite.c and function</span>
<span class="p_add">+	 * drivers (i.e. it won&#39;t go into dwc3&#39;s registers) we are allowing this</span>
<span class="p_add">+	 * to happen so we avoid sending SuperSpeed Capability descriptor</span>
<span class="p_add">+	 * together with our BOS descriptor as that could confuse host into</span>
<span class="p_add">+	 * thinking we can handle super speed.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Note that, in fact, we won&#39;t even support GetBOS requests when speed</span>
<span class="p_add">+	 * is less than super speed because we don&#39;t have means, yet, to tell</span>
<span class="p_add">+	 * composite.c that we are USB 2.0 + LPM ECN.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (dwc-&gt;revision &lt; DWC3_REVISION_220A)</span>
<span class="p_add">+		dev_vdbg(dwc-&gt;dev, &quot;Changing max_speed on rev %08x\n&quot;,</span>
<span class="p_add">+			 dwc-&gt;revision);</span>
<span class="p_add">+</span>
<span class="p_add">+	dwc-&gt;gadget.max_speed		= dwc-&gt;maximum_speed;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
 	 * Per databook, DWC3 needs buffer size to be aligned to MaxPacketSize
 	 * on ep out.
 	 */
<span class="p_header">diff --git a/drivers/usb/host/xhci-hub.c b/drivers/usb/host/xhci-hub.c</span>
<span class="p_header">index ee07ba4..d8b7b11 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-hub.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-hub.c</span>
<span class="p_chunk">@@ -665,12 +665,15 @@</span> <span class="p_context"> static u32 xhci_get_port_status(struct usb_hcd *hcd,</span>
 			status |= USB_PORT_STAT_SUSPEND;
 		}
 	}
<span class="p_del">-	if ((raw_port_status &amp; PORT_PLS_MASK) == XDEV_U0</span>
<span class="p_del">-			&amp;&amp; (raw_port_status &amp; PORT_POWER)</span>
<span class="p_del">-			&amp;&amp; (bus_state-&gt;suspended_ports &amp; (1 &lt;&lt; wIndex))) {</span>
<span class="p_del">-		bus_state-&gt;suspended_ports &amp;= ~(1 &lt;&lt; wIndex);</span>
<span class="p_del">-		if (hcd-&gt;speed != HCD_USB3)</span>
<span class="p_del">-			bus_state-&gt;port_c_suspend |= 1 &lt;&lt; wIndex;</span>
<span class="p_add">+	if ((raw_port_status &amp; PORT_PLS_MASK) == XDEV_U0 &amp;&amp;</span>
<span class="p_add">+	    (raw_port_status &amp; PORT_POWER)) {</span>
<span class="p_add">+		if (bus_state-&gt;suspended_ports &amp; (1 &lt;&lt; wIndex)) {</span>
<span class="p_add">+			bus_state-&gt;suspended_ports &amp;= ~(1 &lt;&lt; wIndex);</span>
<span class="p_add">+			if (hcd-&gt;speed != HCD_USB3)</span>
<span class="p_add">+				bus_state-&gt;port_c_suspend |= 1 &lt;&lt; wIndex;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		bus_state-&gt;resume_done[wIndex] = 0;</span>
<span class="p_add">+		clear_bit(wIndex, &amp;bus_state-&gt;resuming_ports);</span>
 	}
 	if (raw_port_status &amp; PORT_CONNECT) {
 		status |= USB_PORT_STAT_CONNECTION;
<span class="p_header">diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c</span>
<span class="p_header">index 0612a5b..6358446 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci.c</span>
<span class="p_chunk">@@ -176,6 +176,16 @@</span> <span class="p_context"> int xhci_reset(struct xhci_hcd *xhci)</span>
 	command |= CMD_RESET;
 	writel(command, &amp;xhci-&gt;op_regs-&gt;command);
 
<span class="p_add">+	/* Existing Intel xHCI controllers require a delay of 1 mS,</span>
<span class="p_add">+	 * after setting the CMD_RESET bit, and before accessing any</span>
<span class="p_add">+	 * HC registers. This allows the HC to complete the</span>
<span class="p_add">+	 * reset operation and be ready for HC register access.</span>
<span class="p_add">+	 * Without this delay, the subsequent HC register access,</span>
<span class="p_add">+	 * may result in a system hang very rarely.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (xhci-&gt;quirks &amp; XHCI_INTEL_HOST)</span>
<span class="p_add">+		udelay(1000);</span>
<span class="p_add">+</span>
 	ret = xhci_handshake(xhci, &amp;xhci-&gt;op_regs-&gt;command,
 			CMD_RESET, 0, 10 * 1000 * 1000);
 	if (ret)
<span class="p_header">diff --git a/drivers/usb/musb/musb_core.c b/drivers/usb/musb/musb_core.c</span>
<span class="p_header">index f6cd868..4dd0370 100644</span>
<span class="p_header">--- a/drivers/usb/musb/musb_core.c</span>
<span class="p_header">+++ b/drivers/usb/musb/musb_core.c</span>
<span class="p_chunk">@@ -132,7 +132,7 @@</span> <span class="p_context"> static inline struct musb *dev_to_musb(struct device *dev)</span>
 /*-------------------------------------------------------------------------*/
 
 #ifndef CONFIG_BLACKFIN
<span class="p_del">-static int musb_ulpi_read(struct usb_phy *phy, u32 offset)</span>
<span class="p_add">+static int musb_ulpi_read(struct usb_phy *phy, u32 reg)</span>
 {
 	void __iomem *addr = phy-&gt;io_priv;
 	int	i = 0;
<span class="p_chunk">@@ -151,7 +151,7 @@</span> <span class="p_context"> static int musb_ulpi_read(struct usb_phy *phy, u32 offset)</span>
 	 * ULPICarKitControlDisableUTMI after clearing POWER_SUSPENDM.
 	 */
 
<span class="p_del">-	musb_writeb(addr, MUSB_ULPI_REG_ADDR, (u8)offset);</span>
<span class="p_add">+	musb_writeb(addr, MUSB_ULPI_REG_ADDR, (u8)reg);</span>
 	musb_writeb(addr, MUSB_ULPI_REG_CONTROL,
 			MUSB_ULPI_REG_REQ | MUSB_ULPI_RDN_WR);
 
<span class="p_chunk">@@ -176,7 +176,7 @@</span> <span class="p_context"> out:</span>
 	return ret;
 }
 
<span class="p_del">-static int musb_ulpi_write(struct usb_phy *phy, u32 offset, u32 data)</span>
<span class="p_add">+static int musb_ulpi_write(struct usb_phy *phy, u32 val, u32 reg)</span>
 {
 	void __iomem *addr = phy-&gt;io_priv;
 	int	i = 0;
<span class="p_chunk">@@ -191,8 +191,8 @@</span> <span class="p_context"> static int musb_ulpi_write(struct usb_phy *phy, u32 offset, u32 data)</span>
 	power &amp;= ~MUSB_POWER_SUSPENDM;
 	musb_writeb(addr, MUSB_POWER, power);
 
<span class="p_del">-	musb_writeb(addr, MUSB_ULPI_REG_ADDR, (u8)offset);</span>
<span class="p_del">-	musb_writeb(addr, MUSB_ULPI_REG_DATA, (u8)data);</span>
<span class="p_add">+	musb_writeb(addr, MUSB_ULPI_REG_ADDR, (u8)reg);</span>
<span class="p_add">+	musb_writeb(addr, MUSB_ULPI_REG_DATA, (u8)val);</span>
 	musb_writeb(addr, MUSB_ULPI_REG_CONTROL, MUSB_ULPI_REG_REQ);
 
 	while (!(musb_readb(addr, MUSB_ULPI_REG_CONTROL)
<span class="p_header">diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c</span>
<span class="p_header">index 17d04d9..1d7f007 100644</span>
<span class="p_header">--- a/drivers/usb/serial/option.c</span>
<span class="p_header">+++ b/drivers/usb/serial/option.c</span>
<span class="p_chunk">@@ -162,6 +162,7 @@</span> <span class="p_context"> static void option_instat_callback(struct urb *urb);</span>
 #define NOVATELWIRELESS_PRODUCT_HSPA_EMBEDDED_HIGHSPEED	0x9001
 #define NOVATELWIRELESS_PRODUCT_E362		0x9010
 #define NOVATELWIRELESS_PRODUCT_E371		0x9011
<span class="p_add">+#define NOVATELWIRELESS_PRODUCT_U620L		0x9022</span>
 #define NOVATELWIRELESS_PRODUCT_G2		0xA010
 #define NOVATELWIRELESS_PRODUCT_MC551		0xB001
 
<span class="p_chunk">@@ -357,6 +358,7 @@</span> <span class="p_context"> static void option_instat_callback(struct urb *urb);</span>
 /* This is the 4G XS Stick W14 a.k.a. Mobilcom Debitel Surf-Stick *
  * It seems to contain a Qualcomm QSC6240/6290 chipset            */
 #define FOUR_G_SYSTEMS_PRODUCT_W14		0x9603
<span class="p_add">+#define FOUR_G_SYSTEMS_PRODUCT_W100		0x9b01</span>
 
 /* iBall 3.5G connect wireless modem */
 #define IBALL_3_5G_CONNECT			0x9605
<span class="p_chunk">@@ -530,6 +532,11 @@</span> <span class="p_context"> static const struct option_blacklist_info four_g_w14_blacklist = {</span>
 	.sendsetup = BIT(0) | BIT(1),
 };
 
<span class="p_add">+static const struct option_blacklist_info four_g_w100_blacklist = {</span>
<span class="p_add">+	.sendsetup = BIT(1) | BIT(2),</span>
<span class="p_add">+	.reserved = BIT(3),</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static const struct option_blacklist_info alcatel_x200_blacklist = {
 	.sendsetup = BIT(0) | BIT(1),
 	.reserved = BIT(4),
<span class="p_chunk">@@ -1068,6 +1075,7 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 	{ USB_DEVICE_AND_INTERFACE_INFO(NOVATELWIRELESS_VENDOR_ID, NOVATELWIRELESS_PRODUCT_MC551, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(NOVATELWIRELESS_VENDOR_ID, NOVATELWIRELESS_PRODUCT_E362, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(NOVATELWIRELESS_VENDOR_ID, NOVATELWIRELESS_PRODUCT_E371, 0xff, 0xff, 0xff) },
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(NOVATELWIRELESS_VENDOR_ID, NOVATELWIRELESS_PRODUCT_U620L, 0xff, 0x00, 0x00) },</span>
 
 	{ USB_DEVICE(AMOI_VENDOR_ID, AMOI_PRODUCT_H01) },
 	{ USB_DEVICE(AMOI_VENDOR_ID, AMOI_PRODUCT_H01A) },
<span class="p_chunk">@@ -1661,6 +1669,9 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 	{ USB_DEVICE(LONGCHEER_VENDOR_ID, FOUR_G_SYSTEMS_PRODUCT_W14),
   	  .driver_info = (kernel_ulong_t)&amp;four_g_w14_blacklist
   	},
<span class="p_add">+	{ USB_DEVICE(LONGCHEER_VENDOR_ID, FOUR_G_SYSTEMS_PRODUCT_W100),</span>
<span class="p_add">+	  .driver_info = (kernel_ulong_t)&amp;four_g_w100_blacklist</span>
<span class="p_add">+	},</span>
 	{ USB_DEVICE_INTERFACE_CLASS(LONGCHEER_VENDOR_ID, SPEEDUP_PRODUCT_SU9800, 0xff) },
 	{ USB_DEVICE(LONGCHEER_VENDOR_ID, ZOOM_PRODUCT_4597) },
 	{ USB_DEVICE(LONGCHEER_VENDOR_ID, IBALL_3_5G_CONNECT) },
<span class="p_header">diff --git a/drivers/usb/serial/qcserial.c b/drivers/usb/serial/qcserial.c</span>
<span class="p_header">index f49d262..514fa91 100644</span>
<span class="p_header">--- a/drivers/usb/serial/qcserial.c</span>
<span class="p_header">+++ b/drivers/usb/serial/qcserial.c</span>
<span class="p_chunk">@@ -22,6 +22,8 @@</span> <span class="p_context"></span>
 #define DRIVER_AUTHOR &quot;Qualcomm Inc&quot;
 #define DRIVER_DESC &quot;Qualcomm USB Serial driver&quot;
 
<span class="p_add">+#define QUECTEL_EC20_PID	0x9215</span>
<span class="p_add">+</span>
 /* standard device layouts supported by this driver */
 enum qcserial_layouts {
 	QCSERIAL_G2K = 0,	/* Gobi 2000 */
<span class="p_chunk">@@ -169,6 +171,38 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 };
 MODULE_DEVICE_TABLE(usb, id_table);
 
<span class="p_add">+static int handle_quectel_ec20(struct device *dev, int ifnum)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int altsetting = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Quectel EC20 Mini PCIe LTE module layout:</span>
<span class="p_add">+	 * 0: DM/DIAG (use libqcdm from ModemManager for communication)</span>
<span class="p_add">+	 * 1: NMEA</span>
<span class="p_add">+	 * 2: AT-capable modem port</span>
<span class="p_add">+	 * 3: Modem interface</span>
<span class="p_add">+	 * 4: NDIS</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	switch (ifnum) {</span>
<span class="p_add">+	case 0:</span>
<span class="p_add">+		dev_dbg(dev, &quot;Quectel EC20 DM/DIAG interface found\n&quot;);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case 1:</span>
<span class="p_add">+		dev_dbg(dev, &quot;Quectel EC20 NMEA GPS interface found\n&quot;);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case 2:</span>
<span class="p_add">+	case 3:</span>
<span class="p_add">+		dev_dbg(dev, &quot;Quectel EC20 Modem port found\n&quot;);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case 4:</span>
<span class="p_add">+		/* Don&#39;t claim the QMI/net interface */</span>
<span class="p_add">+		altsetting = -1;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return altsetting;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int qcprobe(struct usb_serial *serial, const struct usb_device_id *id)
 {
 	struct usb_host_interface *intf = serial-&gt;interface-&gt;cur_altsetting;
<span class="p_chunk">@@ -178,6 +212,10 @@</span> <span class="p_context"> static int qcprobe(struct usb_serial *serial, const struct usb_device_id *id)</span>
 	__u8 ifnum;
 	int altsetting = -1;
 
<span class="p_add">+	/* we only support vendor specific functions */</span>
<span class="p_add">+	if (intf-&gt;desc.bInterfaceClass != USB_CLASS_VENDOR_SPEC)</span>
<span class="p_add">+		goto done;</span>
<span class="p_add">+</span>
 	nintf = serial-&gt;dev-&gt;actconfig-&gt;desc.bNumInterfaces;
 	dev_dbg(dev, &quot;Num Interfaces = %d\n&quot;, nintf);
 	ifnum = intf-&gt;desc.bInterfaceNumber;
<span class="p_chunk">@@ -237,6 +275,12 @@</span> <span class="p_context"> static int qcprobe(struct usb_serial *serial, const struct usb_device_id *id)</span>
 			altsetting = -1;
 		break;
 	case QCSERIAL_G2K:
<span class="p_add">+		/* handle non-standard layouts */</span>
<span class="p_add">+		if (nintf == 5 &amp;&amp; id-&gt;idProduct == QUECTEL_EC20_PID) {</span>
<span class="p_add">+			altsetting = handle_quectel_ec20(dev, ifnum);</span>
<span class="p_add">+			goto done;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		/*
 		 * Gobi 2K+ USB layout:
 		 * 0: QMI/net
<span class="p_chunk">@@ -297,29 +341,39 @@</span> <span class="p_context"> static int qcprobe(struct usb_serial *serial, const struct usb_device_id *id)</span>
 		break;
 	case QCSERIAL_HWI:
 		/*
<span class="p_del">-		 * Huawei layout:</span>
<span class="p_del">-		 * 0: AT-capable modem port</span>
<span class="p_del">-		 * 1: DM/DIAG</span>
<span class="p_del">-		 * 2: AT-capable modem port</span>
<span class="p_del">-		 * 3: CCID-compatible PCSC interface</span>
<span class="p_del">-		 * 4: QMI/net</span>
<span class="p_del">-		 * 5: NMEA</span>
<span class="p_add">+		 * Huawei devices map functions by subclass + protocol</span>
<span class="p_add">+		 * instead of interface numbers. The protocol identify</span>
<span class="p_add">+		 * a specific function, while the subclass indicate a</span>
<span class="p_add">+		 * specific firmware source</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * This is a blacklist of functions known to be</span>
<span class="p_add">+		 * non-serial.  The rest are assumed to be serial and</span>
<span class="p_add">+		 * will be handled by this driver</span>
 		 */
<span class="p_del">-		switch (ifnum) {</span>
<span class="p_del">-		case 0:</span>
<span class="p_del">-		case 2:</span>
<span class="p_del">-			dev_dbg(dev, &quot;Modem port found\n&quot;);</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		case 1:</span>
<span class="p_del">-			dev_dbg(dev, &quot;DM/DIAG interface found\n&quot;);</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		case 5:</span>
<span class="p_del">-			dev_dbg(dev, &quot;NMEA GPS interface found\n&quot;);</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		default:</span>
<span class="p_del">-			/* don&#39;t claim any unsupported interface */</span>
<span class="p_add">+		switch (intf-&gt;desc.bInterfaceProtocol) {</span>
<span class="p_add">+			/* QMI combined (qmi_wwan) */</span>
<span class="p_add">+		case 0x07:</span>
<span class="p_add">+		case 0x37:</span>
<span class="p_add">+		case 0x67:</span>
<span class="p_add">+			/* QMI data (qmi_wwan) */</span>
<span class="p_add">+		case 0x08:</span>
<span class="p_add">+		case 0x38:</span>
<span class="p_add">+		case 0x68:</span>
<span class="p_add">+			/* QMI control (qmi_wwan) */</span>
<span class="p_add">+		case 0x09:</span>
<span class="p_add">+		case 0x39:</span>
<span class="p_add">+		case 0x69:</span>
<span class="p_add">+			/* NCM like (huawei_cdc_ncm) */</span>
<span class="p_add">+		case 0x16:</span>
<span class="p_add">+		case 0x46:</span>
<span class="p_add">+		case 0x76:</span>
 			altsetting = -1;
 			break;
<span class="p_add">+		default:</span>
<span class="p_add">+			dev_dbg(dev, &quot;Huawei type serial port found (%02x/%02x/%02x)\n&quot;,</span>
<span class="p_add">+				intf-&gt;desc.bInterfaceClass,</span>
<span class="p_add">+				intf-&gt;desc.bInterfaceSubClass,</span>
<span class="p_add">+				intf-&gt;desc.bInterfaceProtocol);</span>
 		}
 		break;
 	default:
<span class="p_header">diff --git a/drivers/usb/serial/ti_usb_3410_5052.c b/drivers/usb/serial/ti_usb_3410_5052.c</span>
<span class="p_header">index e9da41d..2694df2 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ti_usb_3410_5052.c</span>
<span class="p_header">+++ b/drivers/usb/serial/ti_usb_3410_5052.c</span>
<span class="p_chunk">@@ -159,6 +159,7 @@</span> <span class="p_context"> static const struct usb_device_id ti_id_table_3410[] = {</span>
 	{ USB_DEVICE(ABBOTT_VENDOR_ID, ABBOTT_STEREO_PLUG_ID) },
 	{ USB_DEVICE(ABBOTT_VENDOR_ID, ABBOTT_STRIP_PORT_ID) },
 	{ USB_DEVICE(TI_VENDOR_ID, FRI2_PRODUCT_ID) },
<span class="p_add">+	{ USB_DEVICE(HONEYWELL_VENDOR_ID, HONEYWELL_HGI80_PRODUCT_ID) },</span>
 	{ }	/* terminator */
 };
 
<span class="p_chunk">@@ -191,6 +192,7 @@</span> <span class="p_context"> static const struct usb_device_id ti_id_table_combined[] = {</span>
 	{ USB_DEVICE(ABBOTT_VENDOR_ID, ABBOTT_PRODUCT_ID) },
 	{ USB_DEVICE(ABBOTT_VENDOR_ID, ABBOTT_STRIP_PORT_ID) },
 	{ USB_DEVICE(TI_VENDOR_ID, FRI2_PRODUCT_ID) },
<span class="p_add">+	{ USB_DEVICE(HONEYWELL_VENDOR_ID, HONEYWELL_HGI80_PRODUCT_ID) },</span>
 	{ }	/* terminator */
 };
 
<span class="p_header">diff --git a/drivers/usb/serial/ti_usb_3410_5052.h b/drivers/usb/serial/ti_usb_3410_5052.h</span>
<span class="p_header">index 4a2423e..98f35c6 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ti_usb_3410_5052.h</span>
<span class="p_header">+++ b/drivers/usb/serial/ti_usb_3410_5052.h</span>
<span class="p_chunk">@@ -56,6 +56,10 @@</span> <span class="p_context"></span>
 #define ABBOTT_PRODUCT_ID		ABBOTT_STEREO_PLUG_ID
 #define ABBOTT_STRIP_PORT_ID		0x3420
 
<span class="p_add">+/* Honeywell vendor and product IDs */</span>
<span class="p_add">+#define HONEYWELL_VENDOR_ID		0x10ac</span>
<span class="p_add">+#define HONEYWELL_HGI80_PRODUCT_ID	0x0102  /* Honeywell HGI80 */</span>
<span class="p_add">+</span>
 /* Commands */
 #define TI_GET_VERSION			0x01
 #define TI_GET_PORT_STATUS		0x02
<span class="p_header">diff --git a/drivers/xen/gntdev.c b/drivers/xen/gntdev.c</span>
<span class="p_header">index 91cc446..7ffbb93 100644</span>
<span class="p_header">--- a/drivers/xen/gntdev.c</span>
<span class="p_header">+++ b/drivers/xen/gntdev.c</span>
<span class="p_chunk">@@ -765,7 +765,7 @@</span> <span class="p_context"> static int gntdev_mmap(struct file *flip, struct vm_area_struct *vma)</span>
 
 	vma-&gt;vm_ops = &amp;gntdev_vmops;
 
<span class="p_del">-	vma-&gt;vm_flags |= VM_DONTEXPAND | VM_DONTDUMP;</span>
<span class="p_add">+	vma-&gt;vm_flags |= VM_DONTEXPAND | VM_DONTDUMP | VM_IO;</span>
 
 	if (use_ptemod)
 		vma-&gt;vm_flags |= VM_DONTCOPY;
<span class="p_header">diff --git a/fs/btrfs/file.c b/fs/btrfs/file.c</span>
<span class="p_header">index 11ec6e5..1e54adf 100644</span>
<span class="p_header">--- a/fs/btrfs/file.c</span>
<span class="p_header">+++ b/fs/btrfs/file.c</span>
<span class="p_chunk">@@ -1884,7 +1884,13 @@</span> <span class="p_context"> int btrfs_sync_file(struct file *file, loff_t start, loff_t end, int datasync)</span>
 	struct btrfs_log_ctx ctx;
 	int ret = 0;
 	bool full_sync = 0;
<span class="p_add">+	u64 len;</span>
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The range length can be represented by u64, we have to do the typecasts</span>
<span class="p_add">+	 * to avoid signed overflow if it&#39;s [0, LLONG_MAX] eg. from fsync()</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	len = (u64)end - (u64)start + 1;</span>
 	trace_btrfs_sync_file(file, datasync);
 
 	/*
<span class="p_chunk">@@ -1912,7 +1918,7 @@</span> <span class="p_context"> int btrfs_sync_file(struct file *file, loff_t start, loff_t end, int datasync)</span>
 		 * all extents are persisted and the respective file extent
 		 * items are in the fs/subvol btree.
 		 */
<span class="p_del">-		ret = btrfs_wait_ordered_range(inode, start, end - start + 1);</span>
<span class="p_add">+		ret = btrfs_wait_ordered_range(inode, start, len);</span>
 	} else {
 		/*
 		 * Start any new ordered operations before starting to log the
<span class="p_chunk">@@ -2070,8 +2076,7 @@</span> <span class="p_context"> int btrfs_sync_file(struct file *file, loff_t start, loff_t end, int datasync)</span>
 			}
 		}
 		if (!full_sync) {
<span class="p_del">-			ret = btrfs_wait_ordered_range(inode, start,</span>
<span class="p_del">-						       end - start + 1);</span>
<span class="p_add">+			ret = btrfs_wait_ordered_range(inode, start, len);</span>
 			if (ret) {
 				btrfs_end_transaction(trans, root);
 				goto out;
<span class="p_header">diff --git a/fs/cachefiles/rdwr.c b/fs/cachefiles/rdwr.c</span>
<span class="p_header">index 12e6206..e22584a 100644</span>
<span class="p_header">--- a/fs/cachefiles/rdwr.c</span>
<span class="p_header">+++ b/fs/cachefiles/rdwr.c</span>
<span class="p_chunk">@@ -885,7 +885,7 @@</span> <span class="p_context"> int cachefiles_write_page(struct fscache_storage *op, struct page *page)</span>
 	loff_t pos, eof;
 	size_t len;
 	void *data;
<span class="p_del">-	int ret;</span>
<span class="p_add">+	int ret = -ENOBUFS;</span>
 
 	ASSERT(op != NULL);
 	ASSERT(page != NULL);
<span class="p_header">diff --git a/fs/fat/dir.c b/fs/fat/dir.c</span>
<span class="p_header">index c5d6bb9..eeda31c 100644</span>
<span class="p_header">--- a/fs/fat/dir.c</span>
<span class="p_header">+++ b/fs/fat/dir.c</span>
<span class="p_chunk">@@ -614,9 +614,9 @@</span> <span class="p_context"> parse_record:</span>
 		int status = fat_parse_long(inode, &amp;cpos, &amp;bh, &amp;de,
 					    &amp;unicode, &amp;nr_slots);
 		if (status &lt; 0) {
<span class="p_del">-			ctx-&gt;pos = cpos;</span>
<span class="p_add">+			bh = NULL;</span>
 			ret = status;
<span class="p_del">-			goto out;</span>
<span class="p_add">+			goto end_of_dir;</span>
 		} else if (status == PARSE_INVALID)
 			goto record_end;
 		else if (status == PARSE_NOT_LONGNAME)
<span class="p_chunk">@@ -658,8 +658,9 @@</span> <span class="p_context"> parse_record:</span>
 	fill_len = short_len;
 
 start_filldir:
<span class="p_del">-	if (!fake_offset)</span>
<span class="p_del">-		ctx-&gt;pos = cpos - (nr_slots + 1) * sizeof(struct msdos_dir_entry);</span>
<span class="p_add">+	ctx-&gt;pos = cpos - (nr_slots + 1) * sizeof(struct msdos_dir_entry);</span>
<span class="p_add">+	if (fake_offset &amp;&amp; ctx-&gt;pos &lt; 2)</span>
<span class="p_add">+		ctx-&gt;pos = 2;</span>
 
 	if (!memcmp(de-&gt;name, MSDOS_DOT, MSDOS_NAME)) {
 		if (!dir_emit_dot(file, ctx))
<span class="p_chunk">@@ -685,14 +686,19 @@</span> <span class="p_context"> record_end:</span>
 	fake_offset = 0;
 	ctx-&gt;pos = cpos;
 	goto get_new;
<span class="p_add">+</span>
 end_of_dir:
<span class="p_del">-	ctx-&gt;pos = cpos;</span>
<span class="p_add">+	if (fake_offset &amp;&amp; cpos &lt; 2)</span>
<span class="p_add">+		ctx-&gt;pos = 2;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		ctx-&gt;pos = cpos;</span>
 fill_failed:
 	brelse(bh);
 	if (unicode)
 		__putname(unicode);
 out:
 	mutex_unlock(&amp;sbi-&gt;s_lock);
<span class="p_add">+</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/fs/nfs/inode.c b/fs/nfs/inode.c</span>
<span class="p_header">index 53e269e..18c22b8 100644</span>
<span class="p_header">--- a/fs/nfs/inode.c</span>
<span class="p_header">+++ b/fs/nfs/inode.c</span>
<span class="p_chunk">@@ -1719,7 +1719,11 @@</span> <span class="p_context"> static int nfs_update_inode(struct inode *inode, struct nfs_fattr *fattr)</span>
 			nfsi-&gt;attrtimeo_timestamp = now;
 		}
 	}
<span class="p_del">-	invalid &amp;= ~NFS_INO_INVALID_ATTR;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Don&#39;t declare attrcache up to date if there were no attrs! */</span>
<span class="p_add">+	if (fattr-&gt;valid != 0)</span>
<span class="p_add">+		invalid &amp;= ~NFS_INO_INVALID_ATTR;</span>
<span class="p_add">+</span>
 	/* Don&#39;t invalidate the data if we were to blame */
 	if (!(S_ISREG(inode-&gt;i_mode) || S_ISDIR(inode-&gt;i_mode)
 				|| S_ISLNK(inode-&gt;i_mode)))
<span class="p_header">diff --git a/fs/nfs/nfs4client.c b/fs/nfs/nfs4client.c</span>
<span class="p_header">index 706ad10..ca7527d 100644</span>
<span class="p_header">--- a/fs/nfs/nfs4client.c</span>
<span class="p_header">+++ b/fs/nfs/nfs4client.c</span>
<span class="p_chunk">@@ -33,7 +33,7 @@</span> <span class="p_context"> static int nfs_get_cb_ident_idr(struct nfs_client *clp, int minorversion)</span>
 		return ret;
 	idr_preload(GFP_KERNEL);
 	spin_lock(&amp;nn-&gt;nfs_client_lock);
<span class="p_del">-	ret = idr_alloc(&amp;nn-&gt;cb_ident_idr, clp, 0, 0, GFP_NOWAIT);</span>
<span class="p_add">+	ret = idr_alloc(&amp;nn-&gt;cb_ident_idr, clp, 1, 0, GFP_NOWAIT);</span>
 	if (ret &gt;= 0)
 		clp-&gt;cl_cb_ident = ret;
 	spin_unlock(&amp;nn-&gt;nfs_client_lock);
<span class="p_header">diff --git a/fs/ocfs2/namei.c b/fs/ocfs2/namei.c</span>
<span class="p_header">index 914c121..9fc1dae 100644</span>
<span class="p_header">--- a/fs/ocfs2/namei.c</span>
<span class="p_header">+++ b/fs/ocfs2/namei.c</span>
<span class="p_chunk">@@ -361,6 +361,8 @@</span> <span class="p_context"> static int ocfs2_mknod(struct inode *dir,</span>
 		mlog_errno(status);
 		goto leave;
 	}
<span class="p_add">+	/* update inode-&gt;i_mode after mask with &quot;umask&quot;. */</span>
<span class="p_add">+	inode-&gt;i_mode = mode;</span>
 
 	handle = ocfs2_start_trans(osb, ocfs2_mknod_credits(osb-&gt;sb,
 							    S_ISDIR(mode),
<span class="p_header">diff --git a/fs/overlayfs/inode.c b/fs/overlayfs/inode.c</span>
<span class="p_header">index 07d74b2..8525e67 100644</span>
<span class="p_header">--- a/fs/overlayfs/inode.c</span>
<span class="p_header">+++ b/fs/overlayfs/inode.c</span>
<span class="p_chunk">@@ -49,13 +49,13 @@</span> <span class="p_context"> int ovl_setattr(struct dentry *dentry, struct iattr *attr)</span>
 	if (err)
 		goto out;
 
<span class="p_del">-	upperdentry = ovl_dentry_upper(dentry);</span>
<span class="p_del">-	if (upperdentry) {</span>
<span class="p_add">+	err = ovl_copy_up(dentry);</span>
<span class="p_add">+	if (!err) {</span>
<span class="p_add">+		upperdentry = ovl_dentry_upper(dentry);</span>
<span class="p_add">+</span>
 		mutex_lock(&amp;upperdentry-&gt;d_inode-&gt;i_mutex);
 		err = notify_change(upperdentry, attr, NULL);
 		mutex_unlock(&amp;upperdentry-&gt;d_inode-&gt;i_mutex);
<span class="p_del">-	} else {</span>
<span class="p_del">-		err = ovl_copy_up_last(dentry, attr, false);</span>
 	}
 	ovl_drop_write(dentry);
 out:
<span class="p_header">diff --git a/fs/splice.c b/fs/splice.c</span>
<span class="p_header">index 75c6058..c4b93e4 100644</span>
<span class="p_header">--- a/fs/splice.c</span>
<span class="p_header">+++ b/fs/splice.c</span>
<span class="p_chunk">@@ -806,6 +806,13 @@</span> <span class="p_context"> static int splice_from_pipe_feed(struct pipe_inode_info *pipe, struct splice_des</span>
  */
 static int splice_from_pipe_next(struct pipe_inode_info *pipe, struct splice_desc *sd)
 {
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Check for signal early to make process killable when there are</span>
<span class="p_add">+	 * always buffers available</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (signal_pending(current))</span>
<span class="p_add">+		return -ERESTARTSYS;</span>
<span class="p_add">+</span>
 	while (!pipe-&gt;nrbufs) {
 		if (!pipe-&gt;writers)
 			return 0;
<span class="p_chunk">@@ -881,6 +888,7 @@</span> <span class="p_context"> ssize_t __splice_from_pipe(struct pipe_inode_info *pipe, struct splice_desc *sd,</span>
 
 	splice_from_pipe_begin(sd);
 	do {
<span class="p_add">+		cond_resched();</span>
 		ret = splice_from_pipe_next(pipe, sd);
 		if (ret &gt; 0)
 			ret = splice_from_pipe_feed(pipe, sd, actor);
<span class="p_header">diff --git a/fs/sysv/inode.c b/fs/sysv/inode.c</span>
<span class="p_header">index 8895630..02fa1dc 100644</span>
<span class="p_header">--- a/fs/sysv/inode.c</span>
<span class="p_header">+++ b/fs/sysv/inode.c</span>
<span class="p_chunk">@@ -162,14 +162,8 @@</span> <span class="p_context"> void sysv_set_inode(struct inode *inode, dev_t rdev)</span>
 		inode-&gt;i_fop = &amp;sysv_dir_operations;
 		inode-&gt;i_mapping-&gt;a_ops = &amp;sysv_aops;
 	} else if (S_ISLNK(inode-&gt;i_mode)) {
<span class="p_del">-		if (inode-&gt;i_blocks) {</span>
<span class="p_del">-			inode-&gt;i_op = &amp;sysv_symlink_inode_operations;</span>
<span class="p_del">-			inode-&gt;i_mapping-&gt;a_ops = &amp;sysv_aops;</span>
<span class="p_del">-		} else {</span>
<span class="p_del">-			inode-&gt;i_op = &amp;sysv_fast_symlink_inode_operations;</span>
<span class="p_del">-			nd_terminate_link(SYSV_I(inode)-&gt;i_data, inode-&gt;i_size,</span>
<span class="p_del">-				sizeof(SYSV_I(inode)-&gt;i_data) - 1);</span>
<span class="p_del">-		}</span>
<span class="p_add">+		inode-&gt;i_op = &amp;sysv_symlink_inode_operations;</span>
<span class="p_add">+		inode-&gt;i_mapping-&gt;a_ops = &amp;sysv_aops;</span>
 	} else
 		init_special_inode(inode, inode-&gt;i_mode, rdev);
 }
<span class="p_header">diff --git a/include/drm/drmP.h b/include/drm/drmP.h</span>
<span class="p_header">index e1b2e8b..1da05f7 100644</span>
<span class="p_header">--- a/include/drm/drmP.h</span>
<span class="p_header">+++ b/include/drm/drmP.h</span>
<span class="p_chunk">@@ -283,6 +283,11 @@</span> <span class="p_context"> struct drm_file {</span>
 	 * in the plane list
 	 */
 	unsigned universal_planes:1;
<span class="p_add">+	/*</span>
<span class="p_add">+	 * This client is allowed to gain master privileges for @master.</span>
<span class="p_add">+	 * Protected by struct drm_device::master_mutex.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	unsigned allowed_master:1;</span>
 
 	struct pid *pid;
 	kuid_t uid;
<span class="p_chunk">@@ -875,6 +880,7 @@</span> <span class="p_context"> extern int drm_open(struct inode *inode, struct file *filp);</span>
 extern ssize_t drm_read(struct file *filp, char __user *buffer,
 			size_t count, loff_t *offset);
 extern int drm_release(struct inode *inode, struct file *filp);
<span class="p_add">+extern int drm_new_set_master(struct drm_device *dev, struct drm_file *fpriv);</span>
 
 				/* Mapping support (drm_vm.h) */
 extern unsigned int drm_poll(struct file *filp, struct poll_table_struct *wait);
<span class="p_header">diff --git a/include/linux/blkdev.h b/include/linux/blkdev.h</span>
<span class="p_header">index 92f4b4b..25ac915 100644</span>
<span class="p_header">--- a/include/linux/blkdev.h</span>
<span class="p_header">+++ b/include/linux/blkdev.h</span>
<span class="p_chunk">@@ -797,7 +797,6 @@</span> <span class="p_context"> extern void blk_rq_set_block_pc(struct request *);</span>
 extern void blk_requeue_request(struct request_queue *, struct request *);
 extern void blk_add_request_payload(struct request *rq, struct page *page,
 		unsigned int len);
<span class="p_del">-extern int blk_rq_check_limits(struct request_queue *q, struct request *rq);</span>
 extern int blk_lld_busy(struct request_queue *q);
 extern int blk_rq_prep_clone(struct request *rq, struct request *rq_src,
 			     struct bio_set *bs, gfp_t gfp_mask,
<span class="p_header">diff --git a/include/linux/kvm_host.h b/include/linux/kvm_host.h</span>
<span class="p_header">index 26f1060..c3aa8f4 100644</span>
<span class="p_header">--- a/include/linux/kvm_host.h</span>
<span class="p_header">+++ b/include/linux/kvm_host.h</span>
<span class="p_chunk">@@ -438,6 +438,17 @@</span> <span class="p_context"> static inline struct kvm_vcpu *kvm_get_vcpu(struct kvm *kvm, int i)</span>
 	     (vcpup = kvm_get_vcpu(kvm, idx)) != NULL; \
 	     idx++)
 
<span class="p_add">+static inline struct kvm_vcpu *kvm_get_vcpu_by_id(struct kvm *kvm, int id)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct kvm_vcpu *vcpu;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	kvm_for_each_vcpu(i, vcpu, kvm)</span>
<span class="p_add">+		if (vcpu-&gt;vcpu_id == id)</span>
<span class="p_add">+			return vcpu;</span>
<span class="p_add">+	return NULL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #define kvm_for_each_memslot(memslot, slots)	\
 	for (memslot = &amp;slots-&gt;memslots[0];	\
 	      memslot &lt; slots-&gt;memslots + KVM_MEM_SLOTS_NUM &amp;&amp; memslot-&gt;npages;\
<span class="p_header">diff --git a/include/linux/signal.h b/include/linux/signal.h</span>
<span class="p_header">index ab1e039..92557bb 100644</span>
<span class="p_header">--- a/include/linux/signal.h</span>
<span class="p_header">+++ b/include/linux/signal.h</span>
<span class="p_chunk">@@ -239,7 +239,6 @@</span> <span class="p_context"> extern int sigprocmask(int, sigset_t *, sigset_t *);</span>
 extern void set_current_blocked(sigset_t *);
 extern void __set_current_blocked(const sigset_t *);
 extern int show_unhandled_signals;
<span class="p_del">-extern int sigsuspend(sigset_t *);</span>
 
 struct sigaction {
 #ifndef __ARCH_HAS_IRIX_SIGACTION
<span class="p_header">diff --git a/include/net/af_unix.h b/include/net/af_unix.h</span>
<span class="p_header">index dfe4ddf..e830c3d 100644</span>
<span class="p_header">--- a/include/net/af_unix.h</span>
<span class="p_header">+++ b/include/net/af_unix.h</span>
<span class="p_chunk">@@ -63,6 +63,7 @@</span> <span class="p_context"> struct unix_sock {</span>
 #define UNIX_GC_CANDIDATE	0
 #define UNIX_GC_MAYBE_CYCLE	1
 	struct socket_wq	peer_wq;
<span class="p_add">+	wait_queue_t		peer_wake;</span>
 };
 
 static inline struct unix_sock *unix_sk(struct sock *sk)
<span class="p_header">diff --git a/include/target/target_core_base.h b/include/target/target_core_base.h</span>
<span class="p_header">index 985ca4c..08f581b 100644</span>
<span class="p_header">--- a/include/target/target_core_base.h</span>
<span class="p_header">+++ b/include/target/target_core_base.h</span>
<span class="p_chunk">@@ -524,7 +524,7 @@</span> <span class="p_context"> struct se_cmd {</span>
 	sense_reason_t		(*execute_cmd)(struct se_cmd *);
 	sense_reason_t		(*execute_rw)(struct se_cmd *, struct scatterlist *,
 					      u32, enum dma_data_direction);
<span class="p_del">-	sense_reason_t (*transport_complete_callback)(struct se_cmd *, bool);</span>
<span class="p_add">+	sense_reason_t (*transport_complete_callback)(struct se_cmd *, bool, int *);</span>
 
 	unsigned char		*t_task_cdb;
 	unsigned char		__t_task_cdb[TCM_MAX_COMMAND_SIZE];
<span class="p_header">diff --git a/kernel/bpf/arraymap.c b/kernel/bpf/arraymap.c</span>
<span class="p_header">index 9eb4d8a..264073e 100644</span>
<span class="p_header">--- a/kernel/bpf/arraymap.c</span>
<span class="p_header">+++ b/kernel/bpf/arraymap.c</span>
<span class="p_chunk">@@ -109,7 +109,7 @@</span> <span class="p_context"> static int array_map_update_elem(struct bpf_map *map, void *key, void *value,</span>
 		/* all elements already exist */
 		return -EEXIST;
 
<span class="p_del">-	memcpy(array-&gt;value + array-&gt;elem_size * index, value, array-&gt;elem_size);</span>
<span class="p_add">+	memcpy(array-&gt;value + array-&gt;elem_size * index, value, map-&gt;value_size);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/kernel/sched/core.c b/kernel/sched/core.c</span>
<span class="p_header">index 7ee38f6..6b5909b 100644</span>
<span class="p_header">--- a/kernel/sched/core.c</span>
<span class="p_header">+++ b/kernel/sched/core.c</span>
<span class="p_chunk">@@ -1812,7 +1812,6 @@</span> <span class="p_context"> out:</span>
  */
 int wake_up_process(struct task_struct *p)
 {
<span class="p_del">-	WARN_ON(task_is_stopped_or_traced(p));</span>
 	return try_to_wake_up(p, TASK_NORMAL, 0);
 }
 EXPORT_SYMBOL(wake_up_process);
<span class="p_chunk">@@ -5694,13 +5693,13 @@</span> <span class="p_context"> static int init_rootdomain(struct root_domain *rd)</span>
 {
 	memset(rd, 0, sizeof(*rd));
 
<span class="p_del">-	if (!alloc_cpumask_var(&amp;rd-&gt;span, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;rd-&gt;span, GFP_KERNEL))</span>
 		goto out;
<span class="p_del">-	if (!alloc_cpumask_var(&amp;rd-&gt;online, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;rd-&gt;online, GFP_KERNEL))</span>
 		goto free_span;
<span class="p_del">-	if (!alloc_cpumask_var(&amp;rd-&gt;dlo_mask, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;rd-&gt;dlo_mask, GFP_KERNEL))</span>
 		goto free_online;
<span class="p_del">-	if (!alloc_cpumask_var(&amp;rd-&gt;rto_mask, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;rd-&gt;rto_mask, GFP_KERNEL))</span>
 		goto free_dlo_mask;
 
 	init_dl_bw(&amp;rd-&gt;dl_bw);
<span class="p_header">diff --git a/kernel/signal.c b/kernel/signal.c</span>
<span class="p_header">index 16a3052..c4dc622 100644</span>
<span class="p_header">--- a/kernel/signal.c</span>
<span class="p_header">+++ b/kernel/signal.c</span>
<span class="p_chunk">@@ -3558,7 +3558,7 @@</span> <span class="p_context"> SYSCALL_DEFINE0(pause)</span>
 
 #endif
 
<span class="p_del">-int sigsuspend(sigset_t *set)</span>
<span class="p_add">+static int sigsuspend(sigset_t *set)</span>
 {
 	current-&gt;saved_sigmask = current-&gt;blocked;
 	set_current_blocked(set);
<span class="p_header">diff --git a/kernel/trace/ring_buffer.c b/kernel/trace/ring_buffer.c</span>
<span class="p_header">index e896a58..3dd43de 100644</span>
<span class="p_header">--- a/kernel/trace/ring_buffer.c</span>
<span class="p_header">+++ b/kernel/trace/ring_buffer.c</span>
<span class="p_chunk">@@ -1979,12 +1979,6 @@</span> <span class="p_context"> rb_set_commit_to_write(struct ring_buffer_per_cpu *cpu_buffer)</span>
 		goto again;
 }
 
<span class="p_del">-static void rb_reset_reader_page(struct ring_buffer_per_cpu *cpu_buffer)</span>
<span class="p_del">-{</span>
<span class="p_del">-	cpu_buffer-&gt;read_stamp = cpu_buffer-&gt;reader_page-&gt;page-&gt;time_stamp;</span>
<span class="p_del">-	cpu_buffer-&gt;reader_page-&gt;read = 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static void rb_inc_iter(struct ring_buffer_iter *iter)
 {
 	struct ring_buffer_per_cpu *cpu_buffer = iter-&gt;cpu_buffer;
<span class="p_chunk">@@ -3633,7 +3627,7 @@</span> <span class="p_context"> rb_get_reader_page(struct ring_buffer_per_cpu *cpu_buffer)</span>
 
 	/* Finally update the reader page to the new head */
 	cpu_buffer-&gt;reader_page = reader;
<span class="p_del">-	rb_reset_reader_page(cpu_buffer);</span>
<span class="p_add">+	cpu_buffer-&gt;reader_page-&gt;read = 0;</span>
 
 	if (overwrite != cpu_buffer-&gt;last_overrun) {
 		cpu_buffer-&gt;lost_events = overwrite - cpu_buffer-&gt;last_overrun;
<span class="p_chunk">@@ -3643,6 +3637,10 @@</span> <span class="p_context"> rb_get_reader_page(struct ring_buffer_per_cpu *cpu_buffer)</span>
 	goto again;
 
  out:
<span class="p_add">+	/* Update the read_stamp on the first event */</span>
<span class="p_add">+	if (reader &amp;&amp; reader-&gt;read == 0)</span>
<span class="p_add">+		cpu_buffer-&gt;read_stamp = reader-&gt;page-&gt;time_stamp;</span>
<span class="p_add">+</span>
 	arch_spin_unlock(&amp;cpu_buffer-&gt;lock);
 	local_irq_restore(flags);
 
<span class="p_header">diff --git a/net/bluetooth/smp.c b/net/bluetooth/smp.c</span>
<span class="p_header">index 757ae32..e7162a4 100644</span>
<span class="p_header">--- a/net/bluetooth/smp.c</span>
<span class="p_header">+++ b/net/bluetooth/smp.c</span>
<span class="p_chunk">@@ -2812,8 +2812,13 @@</span> <span class="p_context"> static void smp_ready_cb(struct l2cap_chan *chan)</span>
 
 	BT_DBG(&quot;chan %p&quot;, chan);
 
<span class="p_add">+	/* No need to call l2cap_chan_hold() here since we already own</span>
<span class="p_add">+	 * the reference taken in smp_new_conn_cb(). This is just the</span>
<span class="p_add">+	 * first time that we tie it to a specific pointer. The code in</span>
<span class="p_add">+	 * l2cap_core.c ensures that there&#39;s no risk this function wont</span>
<span class="p_add">+	 * get called if smp_new_conn_cb was previously called.</span>
<span class="p_add">+	 */</span>
 	conn-&gt;smp = chan;
<span class="p_del">-	l2cap_chan_hold(chan);</span>
 
 	if (hcon-&gt;type == ACL_LINK &amp;&amp; test_bit(HCI_CONN_ENCRYPT, &amp;hcon-&gt;flags))
 		bredr_pairing(chan);
<span class="p_header">diff --git a/net/core/neighbour.c b/net/core/neighbour.c</span>
<span class="p_header">index 0385351..9b1870d 100644</span>
<span class="p_header">--- a/net/core/neighbour.c</span>
<span class="p_header">+++ b/net/core/neighbour.c</span>
<span class="p_chunk">@@ -2239,7 +2239,7 @@</span> <span class="p_context"> static int pneigh_fill_info(struct sk_buff *skb, struct pneigh_entry *pn,</span>
 	ndm-&gt;ndm_pad2    = 0;
 	ndm-&gt;ndm_flags	 = pn-&gt;flags | NTF_PROXY;
 	ndm-&gt;ndm_type	 = RTN_UNICAST;
<span class="p_del">-	ndm-&gt;ndm_ifindex = pn-&gt;dev-&gt;ifindex;</span>
<span class="p_add">+	ndm-&gt;ndm_ifindex = pn-&gt;dev ? pn-&gt;dev-&gt;ifindex : 0;</span>
 	ndm-&gt;ndm_state	 = NUD_NONE;
 
 	if (nla_put(skb, NDA_DST, tbl-&gt;key_len, pn-&gt;key))
<span class="p_chunk">@@ -2313,7 +2313,7 @@</span> <span class="p_context"> static int pneigh_dump_table(struct neigh_table *tbl, struct sk_buff *skb,</span>
 		if (h &gt; s_h)
 			s_idx = 0;
 		for (n = tbl-&gt;phash_buckets[h], idx = 0; n; n = n-&gt;next) {
<span class="p_del">-			if (dev_net(n-&gt;dev) != net)</span>
<span class="p_add">+			if (pneigh_net(n) != net)</span>
 				continue;
 			if (idx &lt; s_idx)
 				goto next;
<span class="p_header">diff --git a/net/ipv4/igmp.c b/net/ipv4/igmp.c</span>
<span class="p_header">index 666cf36..9ffa231 100644</span>
<span class="p_header">--- a/net/ipv4/igmp.c</span>
<span class="p_header">+++ b/net/ipv4/igmp.c</span>
<span class="p_chunk">@@ -1942,7 +1942,7 @@</span> <span class="p_context"> int ip_mc_leave_group(struct sock *sk, struct ip_mreqn *imr)</span>
 
 	rtnl_lock();
 	in_dev = ip_mc_find_dev(net, imr);
<span class="p_del">-	if (!in_dev) {</span>
<span class="p_add">+	if (!imr-&gt;imr_ifindex &amp;&amp; !imr-&gt;imr_address.s_addr &amp;&amp; !in_dev) {</span>
 		ret = -ENODEV;
 		goto out;
 	}
<span class="p_chunk">@@ -1963,7 +1963,8 @@</span> <span class="p_context"> int ip_mc_leave_group(struct sock *sk, struct ip_mreqn *imr)</span>
 
 		*imlp = iml-&gt;next_rcu;
 
<span class="p_del">-		ip_mc_dec_group(in_dev, group);</span>
<span class="p_add">+		if (in_dev)</span>
<span class="p_add">+			ip_mc_dec_group(in_dev, group);</span>
 		rtnl_unlock();
 		/* decrease mem now to avoid the memleak warning */
 		atomic_sub(sizeof(*iml), &amp;sk-&gt;sk_omem_alloc);
<span class="p_header">diff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c</span>
<span class="p_header">index 8e967ef..a2782c1 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_input.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_input.c</span>
<span class="p_chunk">@@ -4354,19 +4354,34 @@</span> <span class="p_context"> static int __must_check tcp_queue_rcv(struct sock *sk, struct sk_buff *skb, int</span>
 int tcp_send_rcvq(struct sock *sk, struct msghdr *msg, size_t size)
 {
 	struct sk_buff *skb;
<span class="p_add">+	int err = -ENOMEM;</span>
<span class="p_add">+	int data_len = 0;</span>
 	bool fragstolen;
 
 	if (size == 0)
 		return 0;
 
<span class="p_del">-	skb = alloc_skb(size, sk-&gt;sk_allocation);</span>
<span class="p_add">+	if (size &gt; PAGE_SIZE) {</span>
<span class="p_add">+		int npages = min_t(size_t, size &gt;&gt; PAGE_SHIFT, MAX_SKB_FRAGS);</span>
<span class="p_add">+</span>
<span class="p_add">+		data_len = npages &lt;&lt; PAGE_SHIFT;</span>
<span class="p_add">+		size = data_len + (size &amp; ~PAGE_MASK);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	skb = alloc_skb_with_frags(size - data_len, data_len,</span>
<span class="p_add">+				   PAGE_ALLOC_COSTLY_ORDER,</span>
<span class="p_add">+				   &amp;err, sk-&gt;sk_allocation);</span>
 	if (!skb)
 		goto err;
 
<span class="p_add">+	skb_put(skb, size - data_len);</span>
<span class="p_add">+	skb-&gt;data_len = data_len;</span>
<span class="p_add">+	skb-&gt;len = size;</span>
<span class="p_add">+</span>
 	if (tcp_try_rmem_schedule(sk, skb, skb-&gt;truesize))
 		goto err_free;
 
<span class="p_del">-	if (memcpy_from_msg(skb_put(skb, size), msg, size))</span>
<span class="p_add">+	err = skb_copy_datagram_from_iter(skb, 0, &amp;msg-&gt;msg_iter, size);</span>
<span class="p_add">+	if (err)</span>
 		goto err_free;
 
 	TCP_SKB_CB(skb)-&gt;seq = tcp_sk(sk)-&gt;rcv_nxt;
<span class="p_chunk">@@ -4382,7 +4397,8 @@</span> <span class="p_context"> int tcp_send_rcvq(struct sock *sk, struct msghdr *msg, size_t size)</span>
 err_free:
 	kfree_skb(skb);
 err:
<span class="p_del">-	return -ENOMEM;</span>
<span class="p_add">+	return err;</span>
<span class="p_add">+</span>
 }
 
 static void tcp_data_queue(struct sock *sk, struct sk_buff *skb)
<span class="p_header">diff --git a/net/ipv4/tcp_ipv4.c b/net/ipv4/tcp_ipv4.c</span>
<span class="p_header">index 4441dd9..1f3943f 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_ipv4.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_ipv4.c</span>
<span class="p_chunk">@@ -959,7 +959,8 @@</span> <span class="p_context"> int tcp_md5_do_add(struct sock *sk, const union tcp_md5_addr *addr,</span>
 	}
 
 	md5sig = rcu_dereference_protected(tp-&gt;md5sig_info,
<span class="p_del">-					   sock_owned_by_user(sk));</span>
<span class="p_add">+					   sock_owned_by_user(sk) ||</span>
<span class="p_add">+					   lockdep_is_held(&amp;sk-&gt;sk_lock.slock));</span>
 	if (!md5sig) {
 		md5sig = kmalloc(sizeof(*md5sig), gfp);
 		if (!md5sig)
<span class="p_header">diff --git a/net/ipv6/ip6mr.c b/net/ipv6/ip6mr.c</span>
<span class="p_header">index c7a69e8..b301606 100644</span>
<span class="p_header">--- a/net/ipv6/ip6mr.c</span>
<span class="p_header">+++ b/net/ipv6/ip6mr.c</span>
<span class="p_chunk">@@ -120,7 +120,7 @@</span> <span class="p_context"> static void mr6_netlink_event(struct mr6_table *mrt, struct mfc6_cache *mfc,</span>
 			      int cmd);
 static int ip6mr_rtm_dumproute(struct sk_buff *skb,
 			       struct netlink_callback *cb);
<span class="p_del">-static void mroute_clean_tables(struct mr6_table *mrt);</span>
<span class="p_add">+static void mroute_clean_tables(struct mr6_table *mrt, bool all);</span>
 static void ipmr_expire_process(unsigned long arg);
 
 #ifdef CONFIG_IPV6_MROUTE_MULTIPLE_TABLES
<span class="p_chunk">@@ -337,7 +337,7 @@</span> <span class="p_context"> static struct mr6_table *ip6mr_new_table(struct net *net, u32 id)</span>
 static void ip6mr_free_table(struct mr6_table *mrt)
 {
 	del_timer(&amp;mrt-&gt;ipmr_expire_timer);
<span class="p_del">-	mroute_clean_tables(mrt);</span>
<span class="p_add">+	mroute_clean_tables(mrt, true);</span>
 	kfree(mrt);
 }
 
<span class="p_chunk">@@ -1540,7 +1540,7 @@</span> <span class="p_context"> static int ip6mr_mfc_add(struct net *net, struct mr6_table *mrt,</span>
  *	Close the multicast socket, and clear the vif tables etc
  */
 
<span class="p_del">-static void mroute_clean_tables(struct mr6_table *mrt)</span>
<span class="p_add">+static void mroute_clean_tables(struct mr6_table *mrt, bool all)</span>
 {
 	int i;
 	LIST_HEAD(list);
<span class="p_chunk">@@ -1550,8 +1550,9 @@</span> <span class="p_context"> static void mroute_clean_tables(struct mr6_table *mrt)</span>
 	 *	Shut down all active vif entries
 	 */
 	for (i = 0; i &lt; mrt-&gt;maxvif; i++) {
<span class="p_del">-		if (!(mrt-&gt;vif6_table[i].flags &amp; VIFF_STATIC))</span>
<span class="p_del">-			mif6_delete(mrt, i, &amp;list);</span>
<span class="p_add">+		if (!all &amp;&amp; (mrt-&gt;vif6_table[i].flags &amp; VIFF_STATIC))</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		mif6_delete(mrt, i, &amp;list);</span>
 	}
 	unregister_netdevice_many(&amp;list);
 
<span class="p_chunk">@@ -1560,7 +1561,7 @@</span> <span class="p_context"> static void mroute_clean_tables(struct mr6_table *mrt)</span>
 	 */
 	for (i = 0; i &lt; MFC6_LINES; i++) {
 		list_for_each_entry_safe(c, next, &amp;mrt-&gt;mfc6_cache_array[i], list) {
<span class="p_del">-			if (c-&gt;mfc_flags &amp; MFC_STATIC)</span>
<span class="p_add">+			if (!all &amp;&amp; (c-&gt;mfc_flags &amp; MFC_STATIC))</span>
 				continue;
 			write_lock_bh(&amp;mrt_lock);
 			list_del(&amp;c-&gt;list);
<span class="p_chunk">@@ -1623,7 +1624,7 @@</span> <span class="p_context"> int ip6mr_sk_done(struct sock *sk)</span>
 						     net-&gt;ipv6.devconf_all);
 			write_unlock_bh(&amp;mrt_lock);
 
<span class="p_del">-			mroute_clean_tables(mrt);</span>
<span class="p_add">+			mroute_clean_tables(mrt, false);</span>
 			err = 0;
 			break;
 		}
<span class="p_header">diff --git a/net/mac80211/mesh_pathtbl.c b/net/mac80211/mesh_pathtbl.c</span>
<span class="p_header">index b890e22..b3b44a5 100644</span>
<span class="p_header">--- a/net/mac80211/mesh_pathtbl.c</span>
<span class="p_header">+++ b/net/mac80211/mesh_pathtbl.c</span>
<span class="p_chunk">@@ -779,10 +779,8 @@</span> <span class="p_context"> void mesh_plink_broken(struct sta_info *sta)</span>
 static void mesh_path_node_reclaim(struct rcu_head *rp)
 {
 	struct mpath_node *node = container_of(rp, struct mpath_node, rcu);
<span class="p_del">-	struct ieee80211_sub_if_data *sdata = node-&gt;mpath-&gt;sdata;</span>
 
 	del_timer_sync(&amp;node-&gt;mpath-&gt;timer);
<span class="p_del">-	atomic_dec(&amp;sdata-&gt;u.mesh.mpaths);</span>
 	kfree(node-&gt;mpath);
 	kfree(node);
 }
<span class="p_chunk">@@ -790,8 +788,9 @@</span> <span class="p_context"> static void mesh_path_node_reclaim(struct rcu_head *rp)</span>
 /* needs to be called with the corresponding hashwlock taken */
 static void __mesh_path_del(struct mesh_table *tbl, struct mpath_node *node)
 {
<span class="p_del">-	struct mesh_path *mpath;</span>
<span class="p_del">-	mpath = node-&gt;mpath;</span>
<span class="p_add">+	struct mesh_path *mpath = node-&gt;mpath;</span>
<span class="p_add">+	struct ieee80211_sub_if_data *sdata = node-&gt;mpath-&gt;sdata;</span>
<span class="p_add">+</span>
 	spin_lock(&amp;mpath-&gt;state_lock);
 	mpath-&gt;flags |= MESH_PATH_RESOLVING;
 	if (mpath-&gt;is_gate)
<span class="p_chunk">@@ -799,6 +798,7 @@</span> <span class="p_context"> static void __mesh_path_del(struct mesh_table *tbl, struct mpath_node *node)</span>
 	hlist_del_rcu(&amp;node-&gt;list);
 	call_rcu(&amp;node-&gt;rcu, mesh_path_node_reclaim);
 	spin_unlock(&amp;mpath-&gt;state_lock);
<span class="p_add">+	atomic_dec(&amp;sdata-&gt;u.mesh.mpaths);</span>
 	atomic_dec(&amp;tbl-&gt;entries);
 }
 
<span class="p_header">diff --git a/net/mac80211/scan.c b/net/mac80211/scan.c</span>
<span class="p_header">index ae84267..34b4050 100644</span>
<span class="p_header">--- a/net/mac80211/scan.c</span>
<span class="p_header">+++ b/net/mac80211/scan.c</span>
<span class="p_chunk">@@ -593,8 +593,8 @@</span> <span class="p_context"> static int __ieee80211_start_scan(struct ieee80211_sub_if_data *sdata,</span>
 		/* We need to ensure power level is at max for scanning. */
 		ieee80211_hw_config(local, 0);
 
<span class="p_del">-		if ((req-&gt;channels[0]-&gt;flags &amp;</span>
<span class="p_del">-		     IEEE80211_CHAN_NO_IR) ||</span>
<span class="p_add">+		if ((req-&gt;channels[0]-&gt;flags &amp; (IEEE80211_CHAN_NO_IR |</span>
<span class="p_add">+						IEEE80211_CHAN_RADAR)) ||</span>
 		    !req-&gt;n_ssids) {
 			next_delay = IEEE80211_PASSIVE_CHANNEL_TIME;
 		} else {
<span class="p_chunk">@@ -641,7 +641,7 @@</span> <span class="p_context"> ieee80211_scan_get_channel_time(struct ieee80211_channel *chan)</span>
 	 * TODO: channel switching also consumes quite some time,
 	 * add that delay as well to get a better estimation
 	 */
<span class="p_del">-	if (chan-&gt;flags &amp; IEEE80211_CHAN_NO_IR)</span>
<span class="p_add">+	if (chan-&gt;flags &amp; (IEEE80211_CHAN_NO_IR | IEEE80211_CHAN_RADAR))</span>
 		return IEEE80211_PASSIVE_CHANNEL_TIME;
 	return IEEE80211_PROBE_DELAY + IEEE80211_CHANNEL_TIME;
 }
<span class="p_chunk">@@ -773,7 +773,8 @@</span> <span class="p_context"> static void ieee80211_scan_state_set_channel(struct ieee80211_local *local,</span>
 	 *
 	 * In any case, it is not necessary for a passive scan.
 	 */
<span class="p_del">-	if (chan-&gt;flags &amp; IEEE80211_CHAN_NO_IR || !scan_req-&gt;n_ssids) {</span>
<span class="p_add">+	if ((chan-&gt;flags &amp; (IEEE80211_CHAN_NO_IR | IEEE80211_CHAN_RADAR)) ||</span>
<span class="p_add">+	    !scan_req-&gt;n_ssids) {</span>
 		*next_delay = IEEE80211_PASSIVE_CHANNEL_TIME;
 		local-&gt;next_scan_state = SCAN_DECISION;
 		return;
<span class="p_header">diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c</span>
<span class="p_header">index ca5c040..fe3f86d 100644</span>
<span class="p_header">--- a/net/packet/af_packet.c</span>
<span class="p_header">+++ b/net/packet/af_packet.c</span>
<span class="p_chunk">@@ -1510,6 +1510,20 @@</span> <span class="p_context"> static void fanout_release(struct sock *sk)</span>
 	mutex_unlock(&amp;fanout_mutex);
 }
 
<span class="p_add">+static bool packet_extra_vlan_len_allowed(const struct net_device *dev,</span>
<span class="p_add">+					  struct sk_buff *skb)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* Earlier code assumed this would be a VLAN pkt, double-check</span>
<span class="p_add">+	 * this now that we have the actual packet in hand. We can only</span>
<span class="p_add">+	 * do this check on Ethernet devices.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (unlikely(dev-&gt;type != ARPHRD_ETHER))</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	skb_reset_mac_header(skb);</span>
<span class="p_add">+	return likely(eth_hdr(skb)-&gt;h_proto == htons(ETH_P_8021Q));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static const struct proto_ops packet_ops;
 
 static const struct proto_ops packet_ops_spkt;
<span class="p_chunk">@@ -1671,18 +1685,10 @@</span> <span class="p_context"> retry:</span>
 		goto retry;
 	}
 
<span class="p_del">-	if (len &gt; (dev-&gt;mtu + dev-&gt;hard_header_len + extra_len)) {</span>
<span class="p_del">-		/* Earlier code assumed this would be a VLAN pkt,</span>
<span class="p_del">-		 * double-check this now that we have the actual</span>
<span class="p_del">-		 * packet in hand.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		struct ethhdr *ehdr;</span>
<span class="p_del">-		skb_reset_mac_header(skb);</span>
<span class="p_del">-		ehdr = eth_hdr(skb);</span>
<span class="p_del">-		if (ehdr-&gt;h_proto != htons(ETH_P_8021Q)) {</span>
<span class="p_del">-			err = -EMSGSIZE;</span>
<span class="p_del">-			goto out_unlock;</span>
<span class="p_del">-		}</span>
<span class="p_add">+	if (len &gt; (dev-&gt;mtu + dev-&gt;hard_header_len + extra_len) &amp;&amp;</span>
<span class="p_add">+	    !packet_extra_vlan_len_allowed(dev, skb)) {</span>
<span class="p_add">+		err = -EMSGSIZE;</span>
<span class="p_add">+		goto out_unlock;</span>
 	}
 
 	skb-&gt;protocol = proto;
<span class="p_chunk">@@ -2132,8 +2138,6 @@</span> <span class="p_context"> static int tpacket_fill_skb(struct packet_sock *po, struct sk_buff *skb,</span>
 	skb_reserve(skb, hlen);
 	skb_reset_network_header(skb);
 
<span class="p_del">-	if (!packet_use_direct_xmit(po))</span>
<span class="p_del">-		skb_probe_transport_header(skb, 0);</span>
 	if (unlikely(po-&gt;tp_tx_has_off)) {
 		int off_min, off_max, off;
 		off_min = po-&gt;tp_hdrlen - sizeof(struct sockaddr_ll);
<span class="p_chunk">@@ -2213,6 +2217,9 @@</span> <span class="p_context"> static int tpacket_fill_skb(struct packet_sock *po, struct sk_buff *skb,</span>
 		len = ((to_write &gt; len_max) ? len_max : to_write);
 	}
 
<span class="p_add">+	if (!packet_use_direct_xmit(po))</span>
<span class="p_add">+		skb_probe_transport_header(skb, 0);</span>
<span class="p_add">+</span>
 	return tp_len;
 }
 
<span class="p_chunk">@@ -2257,12 +2264,13 @@</span> <span class="p_context"> static int tpacket_snd(struct packet_sock *po, struct msghdr *msg)</span>
 	if (unlikely(!(dev-&gt;flags &amp; IFF_UP)))
 		goto out_put;
 
<span class="p_del">-	reserve = dev-&gt;hard_header_len + VLAN_HLEN;</span>
<span class="p_add">+	if (po-&gt;sk.sk_socket-&gt;type == SOCK_RAW)</span>
<span class="p_add">+		reserve = dev-&gt;hard_header_len;</span>
 	size_max = po-&gt;tx_ring.frame_size
 		- (po-&gt;tp_hdrlen - sizeof(struct sockaddr_ll));
 
<span class="p_del">-	if (size_max &gt; dev-&gt;mtu + reserve)</span>
<span class="p_del">-		size_max = dev-&gt;mtu + reserve;</span>
<span class="p_add">+	if (size_max &gt; dev-&gt;mtu + reserve + VLAN_HLEN)</span>
<span class="p_add">+		size_max = dev-&gt;mtu + reserve + VLAN_HLEN;</span>
 
 	do {
 		ph = packet_current_frame(po, &amp;po-&gt;tx_ring,
<span class="p_chunk">@@ -2286,18 +2294,10 @@</span> <span class="p_context"> static int tpacket_snd(struct packet_sock *po, struct msghdr *msg)</span>
 		tp_len = tpacket_fill_skb(po, skb, ph, dev, size_max, proto,
 					  addr, hlen);
 		if (likely(tp_len &gt;= 0) &amp;&amp;
<span class="p_del">-		    tp_len &gt; dev-&gt;mtu + dev-&gt;hard_header_len) {</span>
<span class="p_del">-			struct ethhdr *ehdr;</span>
<span class="p_del">-			/* Earlier code assumed this would be a VLAN pkt,</span>
<span class="p_del">-			 * double-check this now that we have the actual</span>
<span class="p_del">-			 * packet in hand.</span>
<span class="p_del">-			 */</span>
<span class="p_add">+		    tp_len &gt; dev-&gt;mtu + reserve &amp;&amp;</span>
<span class="p_add">+		    !packet_extra_vlan_len_allowed(dev, skb))</span>
<span class="p_add">+			tp_len = -EMSGSIZE;</span>
 
<span class="p_del">-			skb_reset_mac_header(skb);</span>
<span class="p_del">-			ehdr = eth_hdr(skb);</span>
<span class="p_del">-			if (ehdr-&gt;h_proto != htons(ETH_P_8021Q))</span>
<span class="p_del">-				tp_len = -EMSGSIZE;</span>
<span class="p_del">-		}</span>
 		if (unlikely(tp_len &lt; 0)) {
 			if (po-&gt;tp_loss) {
 				__packet_set_status(po, ph,
<span class="p_chunk">@@ -2518,18 +2518,10 @@</span> <span class="p_context"> static int packet_snd(struct socket *sock, struct msghdr *msg, size_t len)</span>
 
 	sock_tx_timestamp(sk, &amp;skb_shinfo(skb)-&gt;tx_flags);
 
<span class="p_del">-	if (!gso_type &amp;&amp; (len &gt; dev-&gt;mtu + reserve + extra_len)) {</span>
<span class="p_del">-		/* Earlier code assumed this would be a VLAN pkt,</span>
<span class="p_del">-		 * double-check this now that we have the actual</span>
<span class="p_del">-		 * packet in hand.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		struct ethhdr *ehdr;</span>
<span class="p_del">-		skb_reset_mac_header(skb);</span>
<span class="p_del">-		ehdr = eth_hdr(skb);</span>
<span class="p_del">-		if (ehdr-&gt;h_proto != htons(ETH_P_8021Q)) {</span>
<span class="p_del">-			err = -EMSGSIZE;</span>
<span class="p_del">-			goto out_free;</span>
<span class="p_del">-		}</span>
<span class="p_add">+	if (!gso_type &amp;&amp; (len &gt; dev-&gt;mtu + reserve + extra_len) &amp;&amp;</span>
<span class="p_add">+	    !packet_extra_vlan_len_allowed(dev, skb)) {</span>
<span class="p_add">+		err = -EMSGSIZE;</span>
<span class="p_add">+		goto out_free;</span>
 	}
 
 	skb-&gt;protocol = proto;
<span class="p_header">diff --git a/net/rds/connection.c b/net/rds/connection.c</span>
<span class="p_header">index f5fb7d6..378c3a6 100644</span>
<span class="p_header">--- a/net/rds/connection.c</span>
<span class="p_header">+++ b/net/rds/connection.c</span>
<span class="p_chunk">@@ -183,12 +183,6 @@</span> <span class="p_context"> static struct rds_connection *__rds_conn_create(__be32 laddr, __be32 faddr,</span>
 		}
 	}
 
<span class="p_del">-	if (trans == NULL) {</span>
<span class="p_del">-		kmem_cache_free(rds_conn_slab, conn);</span>
<span class="p_del">-		conn = ERR_PTR(-ENODEV);</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	conn-&gt;c_trans = trans;
 
 	ret = trans-&gt;conn_alloc(conn, gfp);
<span class="p_header">diff --git a/net/rds/send.c b/net/rds/send.c</span>
<span class="p_header">index 42f65d4..e1937d35 100644</span>
<span class="p_header">--- a/net/rds/send.c</span>
<span class="p_header">+++ b/net/rds/send.c</span>
<span class="p_chunk">@@ -958,11 +958,13 @@</span> <span class="p_context"> int rds_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,</span>
 		release_sock(sk);
 	}
 
<span class="p_del">-	/* racing with another thread binding seems ok here */</span>
<span class="p_add">+	lock_sock(sk);</span>
 	if (daddr == 0 || rs-&gt;rs_bound_addr == 0) {
<span class="p_add">+		release_sock(sk);</span>
 		ret = -ENOTCONN; /* XXX not a great errno */
 		goto out;
 	}
<span class="p_add">+	release_sock(sk);</span>
 
 	/* size of rm including all sgs */
 	ret = rds_rm_size(msg, payload_len);
<span class="p_header">diff --git a/net/sctp/auth.c b/net/sctp/auth.c</span>
<span class="p_header">index fb7976a..603c3bb 100644</span>
<span class="p_header">--- a/net/sctp/auth.c</span>
<span class="p_header">+++ b/net/sctp/auth.c</span>
<span class="p_chunk">@@ -800,8 +800,8 @@</span> <span class="p_context"> int sctp_auth_ep_set_hmacs(struct sctp_endpoint *ep,</span>
 	if (!has_sha1)
 		return -EINVAL;
 
<span class="p_del">-	memcpy(ep-&gt;auth_hmacs_list-&gt;hmac_ids, &amp;hmacs-&gt;shmac_idents[0],</span>
<span class="p_del">-		hmacs-&gt;shmac_num_idents * sizeof(__u16));</span>
<span class="p_add">+	for (i = 0; i &lt; hmacs-&gt;shmac_num_idents; i++)</span>
<span class="p_add">+		ep-&gt;auth_hmacs_list-&gt;hmac_ids[i] = htons(hmacs-&gt;shmac_idents[i]);</span>
 	ep-&gt;auth_hmacs_list-&gt;param_hdr.length = htons(sizeof(sctp_paramhdr_t) +
 				hmacs-&gt;shmac_num_idents * sizeof(__u16));
 	return 0;
<span class="p_header">diff --git a/net/sunrpc/svc.c b/net/sunrpc/svc.c</span>
<span class="p_header">index 91eaef1..afb732a 100644</span>
<span class="p_header">--- a/net/sunrpc/svc.c</span>
<span class="p_header">+++ b/net/sunrpc/svc.c</span>
<span class="p_chunk">@@ -1362,6 +1362,19 @@</span> <span class="p_context"> bc_svc_process(struct svc_serv *serv, struct rpc_rqst *req,</span>
 	memcpy(&amp;rqstp-&gt;rq_arg, &amp;req-&gt;rq_rcv_buf, sizeof(rqstp-&gt;rq_arg));
 	memcpy(&amp;rqstp-&gt;rq_res, &amp;req-&gt;rq_snd_buf, sizeof(rqstp-&gt;rq_res));
 
<span class="p_add">+	/* Adjust the argument buffer length */</span>
<span class="p_add">+	rqstp-&gt;rq_arg.len = req-&gt;rq_private_buf.len;</span>
<span class="p_add">+	if (rqstp-&gt;rq_arg.len &lt;= rqstp-&gt;rq_arg.head[0].iov_len) {</span>
<span class="p_add">+		rqstp-&gt;rq_arg.head[0].iov_len = rqstp-&gt;rq_arg.len;</span>
<span class="p_add">+		rqstp-&gt;rq_arg.page_len = 0;</span>
<span class="p_add">+	} else if (rqstp-&gt;rq_arg.len &lt;= rqstp-&gt;rq_arg.head[0].iov_len +</span>
<span class="p_add">+			rqstp-&gt;rq_arg.page_len)</span>
<span class="p_add">+		rqstp-&gt;rq_arg.page_len = rqstp-&gt;rq_arg.len -</span>
<span class="p_add">+			rqstp-&gt;rq_arg.head[0].iov_len;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		rqstp-&gt;rq_arg.len = rqstp-&gt;rq_arg.head[0].iov_len +</span>
<span class="p_add">+			rqstp-&gt;rq_arg.page_len;</span>
<span class="p_add">+</span>
 	/* reset result send buffer &quot;put&quot; position */
 	resv-&gt;iov_len = 0;
 
<span class="p_header">diff --git a/net/unix/af_unix.c b/net/unix/af_unix.c</span>
<span class="p_header">index 6fab713..d02f3dc 100644</span>
<span class="p_header">--- a/net/unix/af_unix.c</span>
<span class="p_header">+++ b/net/unix/af_unix.c</span>
<span class="p_chunk">@@ -316,6 +316,118 @@</span> <span class="p_context"> found:</span>
 	return s;
 }
 
<span class="p_add">+/* Support code for asymmetrically connected dgram sockets</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * If a datagram socket is connected to a socket not itself connected</span>
<span class="p_add">+ * to the first socket (eg, /dev/log), clients may only enqueue more</span>
<span class="p_add">+ * messages if the present receive queue of the server socket is not</span>
<span class="p_add">+ * &quot;too large&quot;. This means there&#39;s a second writeability condition</span>
<span class="p_add">+ * poll and sendmsg need to test. The dgram recv code will do a wake</span>
<span class="p_add">+ * up on the peer_wait wait queue of a socket upon reception of a</span>
<span class="p_add">+ * datagram which needs to be propagated to sleeping would-be writers</span>
<span class="p_add">+ * since these might not have sent anything so far. This can&#39;t be</span>
<span class="p_add">+ * accomplished via poll_wait because the lifetime of the server</span>
<span class="p_add">+ * socket might be less than that of its clients if these break their</span>
<span class="p_add">+ * association with it or if the server socket is closed while clients</span>
<span class="p_add">+ * are still connected to it and there&#39;s no way to inform &quot;a polling</span>
<span class="p_add">+ * implementation&quot; that it should let go of a certain wait queue</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * In order to propagate a wake up, a wait_queue_t of the client</span>
<span class="p_add">+ * socket is enqueued on the peer_wait queue of the server socket</span>
<span class="p_add">+ * whose wake function does a wake_up on the ordinary client socket</span>
<span class="p_add">+ * wait queue. This connection is established whenever a write (or</span>
<span class="p_add">+ * poll for write) hit the flow control condition and broken when the</span>
<span class="p_add">+ * association to the server socket is dissolved or after a wake up</span>
<span class="p_add">+ * was relayed.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+static int unix_dgram_peer_wake_relay(wait_queue_t *q, unsigned mode, int flags,</span>
<span class="p_add">+				      void *key)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct unix_sock *u;</span>
<span class="p_add">+	wait_queue_head_t *u_sleep;</span>
<span class="p_add">+</span>
<span class="p_add">+	u = container_of(q, struct unix_sock, peer_wake);</span>
<span class="p_add">+</span>
<span class="p_add">+	__remove_wait_queue(&amp;unix_sk(u-&gt;peer_wake.private)-&gt;peer_wait,</span>
<span class="p_add">+			    q);</span>
<span class="p_add">+	u-&gt;peer_wake.private = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* relaying can only happen while the wq still exists */</span>
<span class="p_add">+	u_sleep = sk_sleep(&amp;u-&gt;sk);</span>
<span class="p_add">+	if (u_sleep)</span>
<span class="p_add">+		wake_up_interruptible_poll(u_sleep, key);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int unix_dgram_peer_wake_connect(struct sock *sk, struct sock *other)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct unix_sock *u, *u_other;</span>
<span class="p_add">+	int rc;</span>
<span class="p_add">+</span>
<span class="p_add">+	u = unix_sk(sk);</span>
<span class="p_add">+	u_other = unix_sk(other);</span>
<span class="p_add">+	rc = 0;</span>
<span class="p_add">+	spin_lock(&amp;u_other-&gt;peer_wait.lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!u-&gt;peer_wake.private) {</span>
<span class="p_add">+		u-&gt;peer_wake.private = other;</span>
<span class="p_add">+		__add_wait_queue(&amp;u_other-&gt;peer_wait, &amp;u-&gt;peer_wake);</span>
<span class="p_add">+</span>
<span class="p_add">+		rc = 1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_unlock(&amp;u_other-&gt;peer_wait.lock);</span>
<span class="p_add">+	return rc;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void unix_dgram_peer_wake_disconnect(struct sock *sk,</span>
<span class="p_add">+					    struct sock *other)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct unix_sock *u, *u_other;</span>
<span class="p_add">+</span>
<span class="p_add">+	u = unix_sk(sk);</span>
<span class="p_add">+	u_other = unix_sk(other);</span>
<span class="p_add">+	spin_lock(&amp;u_other-&gt;peer_wait.lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (u-&gt;peer_wake.private == other) {</span>
<span class="p_add">+		__remove_wait_queue(&amp;u_other-&gt;peer_wait, &amp;u-&gt;peer_wake);</span>
<span class="p_add">+		u-&gt;peer_wake.private = NULL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_unlock(&amp;u_other-&gt;peer_wait.lock);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void unix_dgram_peer_wake_disconnect_wakeup(struct sock *sk,</span>
<span class="p_add">+						   struct sock *other)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unix_dgram_peer_wake_disconnect(sk, other);</span>
<span class="p_add">+	wake_up_interruptible_poll(sk_sleep(sk),</span>
<span class="p_add">+				   POLLOUT |</span>
<span class="p_add">+				   POLLWRNORM |</span>
<span class="p_add">+				   POLLWRBAND);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* preconditions:</span>
<span class="p_add">+ *	- unix_peer(sk) == other</span>
<span class="p_add">+ *	- association is stable</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int unix_dgram_peer_wake_me(struct sock *sk, struct sock *other)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int connected;</span>
<span class="p_add">+</span>
<span class="p_add">+	connected = unix_dgram_peer_wake_connect(sk, other);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (unix_recvq_full(other))</span>
<span class="p_add">+		return 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (connected)</span>
<span class="p_add">+		unix_dgram_peer_wake_disconnect(sk, other);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline int unix_writable(struct sock *sk)
 {
 	return (atomic_read(&amp;sk-&gt;sk_wmem_alloc) &lt;&lt; 2) &lt;= sk-&gt;sk_sndbuf;
<span class="p_chunk">@@ -420,6 +532,8 @@</span> <span class="p_context"> static void unix_release_sock(struct sock *sk, int embrion)</span>
 			skpair-&gt;sk_state_change(skpair);
 			sk_wake_async(skpair, SOCK_WAKE_WAITD, POLL_HUP);
 		}
<span class="p_add">+</span>
<span class="p_add">+		unix_dgram_peer_wake_disconnect(sk, skpair);</span>
 		sock_put(skpair); /* It may now die */
 		unix_peer(sk) = NULL;
 	}
<span class="p_chunk">@@ -653,6 +767,7 @@</span> <span class="p_context"> static struct sock *unix_create1(struct net *net, struct socket *sock)</span>
 	INIT_LIST_HEAD(&amp;u-&gt;link);
 	mutex_init(&amp;u-&gt;readlock); /* single task reading lock */
 	init_waitqueue_head(&amp;u-&gt;peer_wait);
<span class="p_add">+	init_waitqueue_func_entry(&amp;u-&gt;peer_wake, unix_dgram_peer_wake_relay);</span>
 	unix_insert_socket(unix_sockets_unbound(sk), sk);
 out:
 	if (sk == NULL)
<span class="p_chunk">@@ -1020,6 +1135,8 @@</span> <span class="p_context"> restart:</span>
 	if (unix_peer(sk)) {
 		struct sock *old_peer = unix_peer(sk);
 		unix_peer(sk) = other;
<span class="p_add">+		unix_dgram_peer_wake_disconnect_wakeup(sk, old_peer);</span>
<span class="p_add">+</span>
 		unix_state_double_unlock(sk, other);
 
 		if (other != old_peer)
<span class="p_chunk">@@ -1459,6 +1576,7 @@</span> <span class="p_context"> static int unix_dgram_sendmsg(struct kiocb *kiocb, struct socket *sock,</span>
 	struct scm_cookie tmp_scm;
 	int max_level;
 	int data_len = 0;
<span class="p_add">+	int sk_locked;</span>
 
 	if (NULL == siocb-&gt;scm)
 		siocb-&gt;scm = &amp;tmp_scm;
<span class="p_chunk">@@ -1540,12 +1658,14 @@</span> <span class="p_context"> restart:</span>
 		goto out_free;
 	}
 
<span class="p_add">+	sk_locked = 0;</span>
 	unix_state_lock(other);
<span class="p_add">+restart_locked:</span>
 	err = -EPERM;
 	if (!unix_may_send(sk, other))
 		goto out_unlock;
 
<span class="p_del">-	if (sock_flag(other, SOCK_DEAD)) {</span>
<span class="p_add">+	if (unlikely(sock_flag(other, SOCK_DEAD))) {</span>
 		/*
 		 *	Check with 1003.1g - what should
 		 *	datagram error
<span class="p_chunk">@@ -1553,10 +1673,14 @@</span> <span class="p_context"> restart:</span>
 		unix_state_unlock(other);
 		sock_put(other);
 
<span class="p_add">+		if (!sk_locked)</span>
<span class="p_add">+			unix_state_lock(sk);</span>
<span class="p_add">+</span>
 		err = 0;
<span class="p_del">-		unix_state_lock(sk);</span>
 		if (unix_peer(sk) == other) {
 			unix_peer(sk) = NULL;
<span class="p_add">+			unix_dgram_peer_wake_disconnect_wakeup(sk, other);</span>
<span class="p_add">+</span>
 			unix_state_unlock(sk);
 
 			unix_dgram_disconnected(sk, other);
<span class="p_chunk">@@ -1582,21 +1706,38 @@</span> <span class="p_context"> restart:</span>
 			goto out_unlock;
 	}
 
<span class="p_del">-	if (unix_peer(other) != sk &amp;&amp; unix_recvq_full(other)) {</span>
<span class="p_del">-		if (!timeo) {</span>
<span class="p_del">-			err = -EAGAIN;</span>
<span class="p_del">-			goto out_unlock;</span>
<span class="p_add">+	if (unlikely(unix_peer(other) != sk &amp;&amp; unix_recvq_full(other))) {</span>
<span class="p_add">+		if (timeo) {</span>
<span class="p_add">+			timeo = unix_wait_for_peer(other, timeo);</span>
<span class="p_add">+</span>
<span class="p_add">+			err = sock_intr_errno(timeo);</span>
<span class="p_add">+			if (signal_pending(current))</span>
<span class="p_add">+				goto out_free;</span>
<span class="p_add">+</span>
<span class="p_add">+			goto restart;</span>
 		}
 
<span class="p_del">-		timeo = unix_wait_for_peer(other, timeo);</span>
<span class="p_add">+		if (!sk_locked) {</span>
<span class="p_add">+			unix_state_unlock(other);</span>
<span class="p_add">+			unix_state_double_lock(sk, other);</span>
<span class="p_add">+		}</span>
 
<span class="p_del">-		err = sock_intr_errno(timeo);</span>
<span class="p_del">-		if (signal_pending(current))</span>
<span class="p_del">-			goto out_free;</span>
<span class="p_add">+		if (unix_peer(sk) != other ||</span>
<span class="p_add">+		    unix_dgram_peer_wake_me(sk, other)) {</span>
<span class="p_add">+			err = -EAGAIN;</span>
<span class="p_add">+			sk_locked = 1;</span>
<span class="p_add">+			goto out_unlock;</span>
<span class="p_add">+		}</span>
 
<span class="p_del">-		goto restart;</span>
<span class="p_add">+		if (!sk_locked) {</span>
<span class="p_add">+			sk_locked = 1;</span>
<span class="p_add">+			goto restart_locked;</span>
<span class="p_add">+		}</span>
 	}
 
<span class="p_add">+	if (unlikely(sk_locked))</span>
<span class="p_add">+		unix_state_unlock(sk);</span>
<span class="p_add">+</span>
 	if (sock_flag(other, SOCK_RCVTSTAMP))
 		__net_timestamp(skb);
 	maybe_add_creds(skb, sock, other);
<span class="p_chunk">@@ -1610,6 +1751,8 @@</span> <span class="p_context"> restart:</span>
 	return len;
 
 out_unlock:
<span class="p_add">+	if (sk_locked)</span>
<span class="p_add">+		unix_state_unlock(sk);</span>
 	unix_state_unlock(other);
 out_free:
 	kfree_skb(skb);
<span class="p_chunk">@@ -2268,14 +2411,16 @@</span> <span class="p_context"> static unsigned int unix_dgram_poll(struct file *file, struct socket *sock,</span>
 		return mask;
 
 	writable = unix_writable(sk);
<span class="p_del">-	other = unix_peer_get(sk);</span>
<span class="p_del">-	if (other) {</span>
<span class="p_del">-		if (unix_peer(other) != sk) {</span>
<span class="p_del">-			sock_poll_wait(file, &amp;unix_sk(other)-&gt;peer_wait, wait);</span>
<span class="p_del">-			if (unix_recvq_full(other))</span>
<span class="p_del">-				writable = 0;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		sock_put(other);</span>
<span class="p_add">+	if (writable) {</span>
<span class="p_add">+		unix_state_lock(sk);</span>
<span class="p_add">+</span>
<span class="p_add">+		other = unix_peer(sk);</span>
<span class="p_add">+		if (other &amp;&amp; unix_peer(other) != sk &amp;&amp;</span>
<span class="p_add">+		    unix_recvq_full(other) &amp;&amp;</span>
<span class="p_add">+		    unix_dgram_peer_wake_me(sk, other))</span>
<span class="p_add">+			writable = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+		unix_state_unlock(sk);</span>
 	}
 
 	if (writable)
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index e851832..d449979 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -1768,6 +1768,7 @@</span> <span class="p_context"> enum {</span>
 	ALC882_FIXUP_NO_PRIMARY_HP,
 	ALC887_FIXUP_ASUS_BASS,
 	ALC887_FIXUP_BASS_CHMAP,
<span class="p_add">+	ALC882_FIXUP_DISABLE_AAMIX,</span>
 };
 
 static void alc889_fixup_coef(struct hda_codec *codec,
<span class="p_chunk">@@ -1929,6 +1930,8 @@</span> <span class="p_context"> static void alc882_fixup_no_primary_hp(struct hda_codec *codec,</span>
 
 static void alc_fixup_bass_chmap(struct hda_codec *codec,
 				 const struct hda_fixup *fix, int action);
<span class="p_add">+static void alc_fixup_disable_aamix(struct hda_codec *codec,</span>
<span class="p_add">+				    const struct hda_fixup *fix, int action);</span>
 
 static const struct hda_fixup alc882_fixups[] = {
 	[ALC882_FIXUP_ABIT_AW9D_MAX] = {
<span class="p_chunk">@@ -2160,6 +2163,10 @@</span> <span class="p_context"> static const struct hda_fixup alc882_fixups[] = {</span>
 		.type = HDA_FIXUP_FUNC,
 		.v.func = alc_fixup_bass_chmap,
 	},
<span class="p_add">+	[ALC882_FIXUP_DISABLE_AAMIX] = {</span>
<span class="p_add">+		.type = HDA_FIXUP_FUNC,</span>
<span class="p_add">+		.v.func = alc_fixup_disable_aamix,</span>
<span class="p_add">+	},</span>
 };
 
 static const struct snd_pci_quirk alc882_fixup_tbl[] = {
<span class="p_chunk">@@ -2227,6 +2234,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc882_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x1462, 0x7350, &quot;MSI-7350&quot;, ALC889_FIXUP_CD),
 	SND_PCI_QUIRK_VENDOR(0x1462, &quot;MSI&quot;, ALC882_FIXUP_GPIO3),
 	SND_PCI_QUIRK(0x1458, 0xa002, &quot;Gigabyte EP45-DS3/Z87X-UD3H&quot;, ALC889_FIXUP_FRONT_HP_NO_PRESENCE),
<span class="p_add">+	SND_PCI_QUIRK(0x1458, 0xa182, &quot;Gigabyte Z170X-UD3&quot;, ALC882_FIXUP_DISABLE_AAMIX),</span>
 	SND_PCI_QUIRK(0x147b, 0x107a, &quot;Abit AW9D-MAX&quot;, ALC882_FIXUP_ABIT_AW9D_MAX),
 	SND_PCI_QUIRK_VENDOR(0x1558, &quot;Clevo laptop&quot;, ALC882_FIXUP_EAPD),
 	SND_PCI_QUIRK(0x161f, 0x2054, &quot;Medion laptop&quot;, ALC883_FIXUP_EAPD),
<span class="p_chunk">@@ -4355,6 +4363,7 @@</span> <span class="p_context"> enum {</span>
 	ALC280_FIXUP_HP_GPIO4,
 	ALC286_FIXUP_HP_GPIO_LED,
 	ALC275_FIXUP_DELL_XPS,
<span class="p_add">+	ALC256_FIXUP_DELL_XPS_13_HEADPHONE_NOISE,</span>
 };
 
 static const struct hda_fixup alc269_fixups[] = {
<span class="p_chunk">@@ -4865,6 +4874,17 @@</span> <span class="p_context"> static const struct hda_fixup alc269_fixups[] = {</span>
 			{}
 		}
 	},
<span class="p_add">+	[ALC256_FIXUP_DELL_XPS_13_HEADPHONE_NOISE] = {</span>
<span class="p_add">+		.type = HDA_FIXUP_VERBS,</span>
<span class="p_add">+		.v.verbs = (const struct hda_verb[]) {</span>
<span class="p_add">+			/* Disable pass-through path for FRONT 14h */</span>
<span class="p_add">+			{0x20, AC_VERB_SET_COEF_INDEX, 0x36},</span>
<span class="p_add">+			{0x20, AC_VERB_SET_PROC_COEF, 0x1737},</span>
<span class="p_add">+			{}</span>
<span class="p_add">+		},</span>
<span class="p_add">+		.chained = true,</span>
<span class="p_add">+		.chain_id = ALC255_FIXUP_DELL1_MIC_NO_PRESENCE</span>
<span class="p_add">+	},</span>
 };
 
 static const struct snd_pci_quirk alc269_fixup_tbl[] = {
<span class="p_chunk">@@ -4878,6 +4898,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc269_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x1025, 0x0742, &quot;Acer AO756&quot;, ALC271_FIXUP_HP_GATE_MIC_JACK),
 	SND_PCI_QUIRK(0x1025, 0x0775, &quot;Acer Aspire E1-572&quot;, ALC271_FIXUP_HP_GATE_MIC_JACK_E1_572),
 	SND_PCI_QUIRK(0x1025, 0x079b, &quot;Acer Aspire V5-573G&quot;, ALC282_FIXUP_ASPIRE_V5_PINS),
<span class="p_add">+	SND_PCI_QUIRK(0x1025, 0x106d, &quot;Acer Cloudbook 14&quot;, ALC283_FIXUP_CHROME_BOOK),</span>
 	SND_PCI_QUIRK(0x1028, 0x0470, &quot;Dell M101z&quot;, ALC269_FIXUP_DELL_M101Z),
 	SND_PCI_QUIRK(0x1028, 0x054b, &quot;Dell XPS one 2710&quot;, ALC275_FIXUP_DELL_XPS),
 	SND_PCI_QUIRK(0x1028, 0x05da, &quot;Dell Vostro 5460&quot;, ALC290_FIXUP_SUBWOOFER),
<span class="p_chunk">@@ -4893,6 +4914,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc269_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x1028, 0x06c7, &quot;Dell&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x1028, 0x06d9, &quot;Dell&quot;, ALC293_FIXUP_DELL1_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x1028, 0x06da, &quot;Dell&quot;, ALC293_FIXUP_DELL1_MIC_NO_PRESENCE),
<span class="p_add">+	SND_PCI_QUIRK(0x1028, 0x0704, &quot;Dell XPS 13&quot;, ALC256_FIXUP_DELL_XPS_13_HEADPHONE_NOISE),</span>
 	SND_PCI_QUIRK(0x1028, 0x164a, &quot;Dell&quot;, ALC293_FIXUP_DELL1_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x1028, 0x164b, &quot;Dell&quot;, ALC293_FIXUP_DELL1_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x103c, 0x1586, &quot;HP&quot;, ALC269_FIXUP_HP_MUTE_LED_MIC2),
<span class="p_header">diff --git a/sound/pci/hda/patch_sigmatel.c b/sound/pci/hda/patch_sigmatel.c</span>
<span class="p_header">index 7eb9705..4478d35 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_sigmatel.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_sigmatel.c</span>
<span class="p_chunk">@@ -3109,6 +3109,29 @@</span> <span class="p_context"> static void stac92hd71bxx_fixup_hp_hdx(struct hda_codec *codec,</span>
 	spec-&gt;gpio_led = 0x08;
 }
 
<span class="p_add">+static bool is_hp_output(struct hda_codec *codec, hda_nid_t pin)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned int pin_cfg = snd_hda_codec_get_pincfg(codec, pin);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* count line-out, too, as BIOS sets often so */</span>
<span class="p_add">+	return get_defcfg_connect(pin_cfg) != AC_JACK_PORT_NONE &amp;&amp;</span>
<span class="p_add">+		(get_defcfg_device(pin_cfg) == AC_JACK_LINE_OUT ||</span>
<span class="p_add">+		 get_defcfg_device(pin_cfg) == AC_JACK_HP_OUT);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void fixup_hp_headphone(struct hda_codec *codec, hda_nid_t pin)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned int pin_cfg = snd_hda_codec_get_pincfg(codec, pin);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* It was changed in the BIOS to just satisfy MS DTM.</span>
<span class="p_add">+	 * Lets turn it back into slaved HP</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	pin_cfg = (pin_cfg &amp; (~AC_DEFCFG_DEVICE)) |</span>
<span class="p_add">+		(AC_JACK_HP_OUT &lt;&lt; AC_DEFCFG_DEVICE_SHIFT);</span>
<span class="p_add">+	pin_cfg = (pin_cfg &amp; (~(AC_DEFCFG_DEF_ASSOC | AC_DEFCFG_SEQUENCE))) |</span>
<span class="p_add">+		0x1f;</span>
<span class="p_add">+	snd_hda_codec_set_pincfg(codec, pin, pin_cfg);</span>
<span class="p_add">+}</span>
 
 static void stac92hd71bxx_fixup_hp(struct hda_codec *codec,
 				   const struct hda_fixup *fix, int action)
<span class="p_chunk">@@ -3118,22 +3141,12 @@</span> <span class="p_context"> static void stac92hd71bxx_fixup_hp(struct hda_codec *codec,</span>
 	if (action != HDA_FIXUP_ACT_PRE_PROBE)
 		return;
 
<span class="p_del">-	if (hp_blike_system(codec-&gt;subsystem_id)) {</span>
<span class="p_del">-		unsigned int pin_cfg = snd_hda_codec_get_pincfg(codec, 0x0f);</span>
<span class="p_del">-		if (get_defcfg_device(pin_cfg) == AC_JACK_LINE_OUT ||</span>
<span class="p_del">-			get_defcfg_device(pin_cfg) == AC_JACK_SPEAKER  ||</span>
<span class="p_del">-			get_defcfg_device(pin_cfg) == AC_JACK_HP_OUT) {</span>
<span class="p_del">-			/* It was changed in the BIOS to just satisfy MS DTM.</span>
<span class="p_del">-			 * Lets turn it back into slaved HP</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			pin_cfg = (pin_cfg &amp; (~AC_DEFCFG_DEVICE))</span>
<span class="p_del">-					| (AC_JACK_HP_OUT &lt;&lt;</span>
<span class="p_del">-						AC_DEFCFG_DEVICE_SHIFT);</span>
<span class="p_del">-			pin_cfg = (pin_cfg &amp; (~(AC_DEFCFG_DEF_ASSOC</span>
<span class="p_del">-							| AC_DEFCFG_SEQUENCE)))</span>
<span class="p_del">-								| 0x1f;</span>
<span class="p_del">-			snd_hda_codec_set_pincfg(codec, 0x0f, pin_cfg);</span>
<span class="p_del">-		}</span>
<span class="p_add">+	/* when both output A and F are assigned, these are supposedly</span>
<span class="p_add">+	 * dock and built-in headphones; fix both pin configs</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (is_hp_output(codec, 0x0a) &amp;&amp; is_hp_output(codec, 0x0f)) {</span>
<span class="p_add">+		fixup_hp_headphone(codec, 0x0a);</span>
<span class="p_add">+		fixup_hp_headphone(codec, 0x0f);</span>
 	}
 
 	if (find_mute_led_cfg(codec, 1))
<span class="p_header">diff --git a/sound/soc/codecs/wm8962.c b/sound/soc/codecs/wm8962.c</span>
<span class="p_header">index d32d554..89bc952 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8962.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8962.c</span>
<span class="p_chunk">@@ -365,8 +365,8 @@</span> <span class="p_context"> static struct reg_default wm8962_reg[] = {</span>
 	{ 16924, 0x0059 },   /* R16924 - HDBASS_PG_1 */
 	{ 16925, 0x999A },   /* R16925 - HDBASS_PG_0 */
 
<span class="p_del">-	{ 17048, 0x0083 },   /* R17408 - HPF_C_1 */</span>
<span class="p_del">-	{ 17049, 0x98AD },   /* R17409 - HPF_C_0 */</span>
<span class="p_add">+	{ 17408, 0x0083 },   /* R17408 - HPF_C_1 */</span>
<span class="p_add">+	{ 17409, 0x98AD },   /* R17409 - HPF_C_0 */</span>
 
 	{ 17920, 0x007F },   /* R17920 - ADCL_RETUNE_C1_1 */
 	{ 17921, 0xFFFF },   /* R17921 - ADCL_RETUNE_C1_0 */
<span class="p_header">diff --git a/sound/usb/midi.c b/sound/usb/midi.c</span>
<span class="p_header">index 5bfb695..a074f1c 100644</span>
<span class="p_header">--- a/sound/usb/midi.c</span>
<span class="p_header">+++ b/sound/usb/midi.c</span>
<span class="p_chunk">@@ -174,6 +174,8 @@</span> <span class="p_context"> struct snd_usb_midi_in_endpoint {</span>
 		u8 running_status_length;
 	} ports[0x10];
 	u8 seen_f5;
<span class="p_add">+	bool in_sysex;</span>
<span class="p_add">+	u8 last_cin;</span>
 	u8 error_resubmit;
 	int current_port;
 };
<span class="p_chunk">@@ -468,6 +470,39 @@</span> <span class="p_context"> static void snd_usbmidi_maudio_broken_running_status_input(</span>
 }
 
 /*
<span class="p_add">+ * QinHeng CH345 is buggy: every second packet inside a SysEx has not CIN 4</span>
<span class="p_add">+ * but the previously seen CIN, but still with three data bytes.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void ch345_broken_sysex_input(struct snd_usb_midi_in_endpoint *ep,</span>
<span class="p_add">+				     uint8_t *buffer, int buffer_length)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned int i, cin, length;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i + 3 &lt; buffer_length; i += 4) {</span>
<span class="p_add">+		if (buffer[i] == 0 &amp;&amp; i &gt; 0)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		cin = buffer[i] &amp; 0x0f;</span>
<span class="p_add">+		if (ep-&gt;in_sysex &amp;&amp;</span>
<span class="p_add">+		    cin == ep-&gt;last_cin &amp;&amp;</span>
<span class="p_add">+		    (buffer[i + 1 + (cin == 0x6)] &amp; 0x80) == 0)</span>
<span class="p_add">+			cin = 0x4;</span>
<span class="p_add">+#if 0</span>
<span class="p_add">+		if (buffer[i + 1] == 0x90) {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Either a corrupted running status or a real note-on</span>
<span class="p_add">+			 * message; impossible to detect reliably.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+		}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+		length = snd_usbmidi_cin_length[cin];</span>
<span class="p_add">+		snd_usbmidi_input_data(ep, 0, &amp;buffer[i + 1], length);</span>
<span class="p_add">+		ep-&gt;in_sysex = cin == 0x4;</span>
<span class="p_add">+		if (!ep-&gt;in_sysex)</span>
<span class="p_add">+			ep-&gt;last_cin = cin;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * CME protocol: like the standard protocol, but SysEx commands are sent as a
  * single USB packet preceded by a 0x0F byte.
  */
<span class="p_chunk">@@ -660,6 +695,12 @@</span> <span class="p_context"> static struct usb_protocol_ops snd_usbmidi_cme_ops = {</span>
 	.output_packet = snd_usbmidi_output_standard_packet,
 };
 
<span class="p_add">+static struct usb_protocol_ops snd_usbmidi_ch345_broken_sysex_ops = {</span>
<span class="p_add">+	.input = ch345_broken_sysex_input,</span>
<span class="p_add">+	.output = snd_usbmidi_standard_output,</span>
<span class="p_add">+	.output_packet = snd_usbmidi_output_standard_packet,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 /*
  * AKAI MPD16 protocol:
  *
<span class="p_chunk">@@ -1341,6 +1382,7 @@</span> <span class="p_context"> static int snd_usbmidi_out_endpoint_create(struct snd_usb_midi *umidi,</span>
 		 * Various chips declare a packet size larger than 4 bytes, but
 		 * do not actually work with larger packets:
 		 */
<span class="p_add">+	case USB_ID(0x0a67, 0x5011): /* Medeli DD305 */</span>
 	case USB_ID(0x0a92, 0x1020): /* ESI M4U */
 	case USB_ID(0x1430, 0x474b): /* RedOctane GH MIDI INTERFACE */
 	case USB_ID(0x15ca, 0x0101): /* Textech USB Midi Cable */
<span class="p_chunk">@@ -2376,6 +2418,10 @@</span> <span class="p_context"> int snd_usbmidi_create(struct snd_card *card,</span>
 
 		err = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);
 		break;
<span class="p_add">+	case QUIRK_MIDI_CH345:</span>
<span class="p_add">+		umidi-&gt;usb_protocol_ops = &amp;snd_usbmidi_ch345_broken_sysex_ops;</span>
<span class="p_add">+		err = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);</span>
<span class="p_add">+		break;</span>
 	default:
 		dev_err(&amp;umidi-&gt;dev-&gt;dev, &quot;invalid quirk type %d\n&quot;,
 			quirk-&gt;type);
<span class="p_header">diff --git a/sound/usb/quirks-table.h b/sound/usb/quirks-table.h</span>
<span class="p_header">index b531993..f968c67 100644</span>
<span class="p_header">--- a/sound/usb/quirks-table.h</span>
<span class="p_header">+++ b/sound/usb/quirks-table.h</span>
<span class="p_chunk">@@ -2824,6 +2824,17 @@</span> <span class="p_context"> YAMAHA_DEVICE(0x7010, &quot;UB99&quot;),</span>
 	.idProduct = 0x1020,
 },
 
<span class="p_add">+/* QinHeng devices */</span>
<span class="p_add">+{</span>
<span class="p_add">+	USB_DEVICE(0x1a86, 0x752d),</span>
<span class="p_add">+	.driver_info = (unsigned long) &amp;(const struct snd_usb_audio_quirk) {</span>
<span class="p_add">+		.vendor_name = &quot;QinHeng&quot;,</span>
<span class="p_add">+		.product_name = &quot;CH345&quot;,</span>
<span class="p_add">+		.ifnum = 1,</span>
<span class="p_add">+		.type = QUIRK_MIDI_CH345</span>
<span class="p_add">+	}</span>
<span class="p_add">+},</span>
<span class="p_add">+</span>
 /* KeithMcMillen Stringport */
 {
 	USB_DEVICE(0x1f38, 0x0001),
<span class="p_header">diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c</span>
<span class="p_header">index 449555c..9032510b 100644</span>
<span class="p_header">--- a/sound/usb/quirks.c</span>
<span class="p_header">+++ b/sound/usb/quirks.c</span>
<span class="p_chunk">@@ -535,6 +535,7 @@</span> <span class="p_context"> int snd_usb_create_quirk(struct snd_usb_audio *chip,</span>
 		[QUIRK_MIDI_CME] = create_any_midi_quirk,
 		[QUIRK_MIDI_AKAI] = create_any_midi_quirk,
 		[QUIRK_MIDI_FTDI] = create_any_midi_quirk,
<span class="p_add">+		[QUIRK_MIDI_CH345] = create_any_midi_quirk,</span>
 		[QUIRK_AUDIO_STANDARD_INTERFACE] = create_standard_audio_quirk,
 		[QUIRK_AUDIO_FIXED_ENDPOINT] = create_fixed_stream_quirk,
 		[QUIRK_AUDIO_EDIROL_UAXX] = create_uaxx_quirk,
<span class="p_header">diff --git a/sound/usb/usbaudio.h b/sound/usb/usbaudio.h</span>
<span class="p_header">index 91d0380..991aa84 100644</span>
<span class="p_header">--- a/sound/usb/usbaudio.h</span>
<span class="p_header">+++ b/sound/usb/usbaudio.h</span>
<span class="p_chunk">@@ -94,6 +94,7 @@</span> <span class="p_context"> enum quirk_type {</span>
 	QUIRK_MIDI_AKAI,
 	QUIRK_MIDI_US122L,
 	QUIRK_MIDI_FTDI,
<span class="p_add">+	QUIRK_MIDI_CH345,</span>
 	QUIRK_AUDIO_STANDARD_INTERFACE,
 	QUIRK_AUDIO_FIXED_ENDPOINT,
 	QUIRK_AUDIO_EDIROL_UAXX,
<span class="p_header">diff --git a/tools/net/Makefile b/tools/net/Makefile</span>
<span class="p_header">index ee577ea..ddf8880 100644</span>
<span class="p_header">--- a/tools/net/Makefile</span>
<span class="p_header">+++ b/tools/net/Makefile</span>
<span class="p_chunk">@@ -4,6 +4,9 @@</span> <span class="p_context"> CC = gcc</span>
 LEX = flex
 YACC = bison
 
<span class="p_add">+CFLAGS += -Wall -O2</span>
<span class="p_add">+CFLAGS += -D__EXPORTED_HEADERS__ -I../../include/uapi -I../../include</span>
<span class="p_add">+</span>
 %.yacc.c: %.y
 	$(YACC) -o $@ -d $&lt;
 
<span class="p_chunk">@@ -12,15 +15,13 @@</span> <span class="p_context"> YACC = bison</span>
 
 all : bpf_jit_disasm bpf_dbg bpf_asm
 
<span class="p_del">-bpf_jit_disasm : CFLAGS = -Wall -O2 -DPACKAGE=&#39;bpf_jit_disasm&#39;</span>
<span class="p_add">+bpf_jit_disasm : CFLAGS += -DPACKAGE=&#39;bpf_jit_disasm&#39;</span>
 bpf_jit_disasm : LDLIBS = -lopcodes -lbfd -ldl
 bpf_jit_disasm : bpf_jit_disasm.o
 
<span class="p_del">-bpf_dbg : CFLAGS = -Wall -O2</span>
 bpf_dbg : LDLIBS = -lreadline
 bpf_dbg : bpf_dbg.o
 
<span class="p_del">-bpf_asm : CFLAGS = -Wall -O2 -I.</span>
 bpf_asm : LDLIBS =
 bpf_asm : bpf_asm.o bpf_exp.yacc.o bpf_exp.lex.o
 bpf_exp.lex.o : bpf_exp.yacc.c
<span class="p_header">diff --git a/tools/perf/util/dso.c b/tools/perf/util/dso.c</span>
<span class="p_header">index 45be944..1991ca7 100644</span>
<span class="p_header">--- a/tools/perf/util/dso.c</span>
<span class="p_header">+++ b/tools/perf/util/dso.c</span>
<span class="p_chunk">@@ -773,6 +773,7 @@</span> <span class="p_context"> static struct dso *dso__findlink_by_longname(struct rb_root *root,</span>
 		/* Add new node and rebalance tree */
 		rb_link_node(&amp;dso-&gt;rb_node, parent, p);
 		rb_insert_color(&amp;dso-&gt;rb_node, root);
<span class="p_add">+		dso-&gt;root = root;</span>
 	}
 	return NULL;
 }
<span class="p_chunk">@@ -785,15 +786,30 @@</span> <span class="p_context"> dso__find_by_longname(const struct rb_root *root, const char *name)</span>
 
 void dso__set_long_name(struct dso *dso, const char *name, bool name_allocated)
 {
<span class="p_add">+	struct rb_root *root = dso-&gt;root;</span>
<span class="p_add">+</span>
 	if (name == NULL)
 		return;
 
 	if (dso-&gt;long_name_allocated)
 		free((char *)dso-&gt;long_name);
 
<span class="p_add">+	if (root) {</span>
<span class="p_add">+		rb_erase(&amp;dso-&gt;rb_node, root);</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * __dso__findlink_by_longname() isn&#39;t guaranteed to add it</span>
<span class="p_add">+		 * back, so a clean removal is required here.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		RB_CLEAR_NODE(&amp;dso-&gt;rb_node);</span>
<span class="p_add">+		dso-&gt;root = NULL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	dso-&gt;long_name		 = name;
 	dso-&gt;long_name_len	 = strlen(name);
 	dso-&gt;long_name_allocated = name_allocated;
<span class="p_add">+</span>
<span class="p_add">+	if (root)</span>
<span class="p_add">+		__dso__findlink_by_longname(root, dso, NULL);</span>
 }
 
 void dso__set_short_name(struct dso *dso, const char *name, bool name_allocated)
<span class="p_chunk">@@ -886,6 +902,7 @@</span> <span class="p_context"> struct dso *dso__new(const char *name)</span>
 		dso-&gt;kernel = DSO_TYPE_USER;
 		dso-&gt;needs_swap = DSO_SWAP__UNSET;
 		RB_CLEAR_NODE(&amp;dso-&gt;rb_node);
<span class="p_add">+		dso-&gt;root = NULL;</span>
 		INIT_LIST_HEAD(&amp;dso-&gt;node);
 		INIT_LIST_HEAD(&amp;dso-&gt;data.open_entry);
 	}
<span class="p_header">diff --git a/tools/perf/util/dso.h b/tools/perf/util/dso.h</span>
<span class="p_header">index 3782c82..159848b 100644</span>
<span class="p_header">--- a/tools/perf/util/dso.h</span>
<span class="p_header">+++ b/tools/perf/util/dso.h</span>
<span class="p_chunk">@@ -104,6 +104,7 @@</span> <span class="p_context"> struct dsos {</span>
 struct dso {
 	struct list_head node;
 	struct rb_node	 rb_node;	/* rbtree node sorted by long name */
<span class="p_add">+	struct rb_root	 *root;		/* root of rbtree that rb_node is in */</span>
 	struct rb_root	 symbols[MAP__NR_TYPES];
 	struct rb_root	 symbol_names[MAP__NR_TYPES];
 	void		 *a2l;
<span class="p_header">diff --git a/tools/perf/util/machine.c b/tools/perf/util/machine.c</span>
<span class="p_header">index 1bca3a9..7d6ca2f 100644</span>
<span class="p_header">--- a/tools/perf/util/machine.c</span>
<span class="p_header">+++ b/tools/perf/util/machine.c</span>
<span class="p_chunk">@@ -84,6 +84,7 @@</span> <span class="p_context"> static void dsos__delete(struct dsos *dsos)</span>
 
 	list_for_each_entry_safe(pos, n, &amp;dsos-&gt;head, node) {
 		RB_CLEAR_NODE(&amp;pos-&gt;rb_node);
<span class="p_add">+		pos-&gt;root = NULL;</span>
 		list_del(&amp;pos-&gt;node);
 		dso__delete(pos);
 	}

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



