
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[3.16.y-ckt,stable] Linux 3.16.7-ckt23 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [3.16.y-ckt,stable] Linux 3.16.7-ckt23</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=45061">Luis Henriques</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Jan. 28, 2016, 10 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1453975226-6859-2-git-send-email-luis.henriques@canonical.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/8148181/mbox/"
   >mbox</a>
|
   <a href="/patch/8148181/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/8148181/">/patch/8148181/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork1.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork1.web.kernel.org (Postfix) with ESMTP id C40559F818
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 28 Jan 2016 10:01:42 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id A56F1201F2
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 28 Jan 2016 10:01:34 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 88FF220328
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 28 Jan 2016 10:01:22 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S967012AbcA1KBK (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 28 Jan 2016 05:01:10 -0500
Received: from youngberry.canonical.com ([91.189.89.112]:51468 &quot;EHLO
	youngberry.canonical.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S966133AbcA1KAa (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 28 Jan 2016 05:00:30 -0500
Received: from av-217-129-142-138.netvisao.pt ([217.129.142.138]
	helo=localhost) by youngberry.canonical.com with esmtpsa
	(TLS1.0:RSA_AES_128_CBC_SHA1:16) (Exim 4.76)
	(envelope-from &lt;luis.henriques@canonical.com&gt;)
	id 1aOjNM-0005YX-7V; Thu, 28 Jan 2016 10:00:28 +0000
From: Luis Henriques &lt;luis.henriques@canonical.com&gt;
To: linux-kernel@vger.kernel.org, stable@vger.kernel.org,
	kernel-team@lists.ubuntu.com
Cc: lwn@lwn.net
Subject: Re: [3.16.y-ckt stable] Linux 3.16.7-ckt23
Date: Thu, 28 Jan 2016 10:00:26 +0000
Message-Id: &lt;1453975226-6859-2-git-send-email-luis.henriques@canonical.com&gt;
In-Reply-To: &lt;1453975226-6859-1-git-send-email-luis.henriques@canonical.com&gt;
References: &lt;1453975226-6859-1-git-send-email-luis.henriques@canonical.com&gt;
MIME-Version: 1.0
X-Extended-Stable: 3.16
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-6.9 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=45061">Luis Henriques</a> - Jan. 28, 2016, 10 a.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index c267ae635636..312bfd2de8f1 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,7 +1,7 @@</span> <span class="p_context"></span>
 VERSION = 3
 PATCHLEVEL = 16
 SUBLEVEL = 7
<span class="p_del">-EXTRAVERSION =-ckt22</span>
<span class="p_add">+EXTRAVERSION =-ckt23</span>
 NAME = Museum of Fishiegoodies
 
 # *DOCUMENTATION*
<span class="p_header">diff --git a/arch/arc/include/asm/unwind.h b/arch/arc/include/asm/unwind.h</span>
<span class="p_header">index 7ca628b6ee2a..c11a25bb8158 100644</span>
<span class="p_header">--- a/arch/arc/include/asm/unwind.h</span>
<span class="p_header">+++ b/arch/arc/include/asm/unwind.h</span>
<span class="p_chunk">@@ -112,7 +112,6 @@</span> <span class="p_context"> struct unwind_frame_info {</span>
 
 extern int arc_unwind(struct unwind_frame_info *frame);
 extern void arc_unwind_init(void);
<span class="p_del">-extern void arc_unwind_setup(void);</span>
 extern void *unwind_add_table(struct module *module, const void *table_start,
 			      unsigned long table_size);
 extern void unwind_remove_table(void *handle, int init_only);
<span class="p_chunk">@@ -152,9 +151,6 @@</span> <span class="p_context"> static inline void arc_unwind_init(void)</span>
 {
 }
 
<span class="p_del">-static inline void arc_unwind_setup(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-}</span>
 #define unwind_add_table(a, b, c)
 #define unwind_remove_table(a, b)
 
<span class="p_header">diff --git a/arch/arc/kernel/setup.c b/arch/arc/kernel/setup.c</span>
<span class="p_header">index 119dddb752b2..cfae438520af 100644</span>
<span class="p_header">--- a/arch/arc/kernel/setup.c</span>
<span class="p_header">+++ b/arch/arc/kernel/setup.c</span>
<span class="p_chunk">@@ -380,7 +380,6 @@</span> <span class="p_context"> void __init setup_arch(char **cmdline_p)</span>
 #endif
 
 	arc_unwind_init();
<span class="p_del">-	arc_unwind_setup();</span>
 }
 
 static int __init customize_machine(void)
<span class="p_header">diff --git a/arch/arc/kernel/unwind.c b/arch/arc/kernel/unwind.c</span>
<span class="p_header">index 2d6a36ea8aaf..9bfbd0a01b95 100644</span>
<span class="p_header">--- a/arch/arc/kernel/unwind.c</span>
<span class="p_header">+++ b/arch/arc/kernel/unwind.c</span>
<span class="p_chunk">@@ -170,6 +170,23 @@</span> <span class="p_context"> static struct unwind_table *find_table(unsigned long pc)</span>
 
 static unsigned long read_pointer(const u8 **pLoc,
 				  const void *end, signed ptrType);
<span class="p_add">+static void init_unwind_hdr(struct unwind_table *table,</span>
<span class="p_add">+			    void *(*alloc) (unsigned long));</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * wrappers for header alloc (vs. calling one vs. other at call site)</span>
<span class="p_add">+ * to elide section mismatches warnings</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void *__init unw_hdr_alloc_early(unsigned long sz)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return __alloc_bootmem_nopanic(sz, sizeof(unsigned int),</span>
<span class="p_add">+				       MAX_DMA_ADDRESS);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void *unw_hdr_alloc(unsigned long sz)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return kmalloc(sz, GFP_KERNEL);</span>
<span class="p_add">+}</span>
 
 static void init_unwind_table(struct unwind_table *table, const char *name,
 			      const void *core_start, unsigned long core_size,
<span class="p_chunk">@@ -209,6 +226,8 @@</span> <span class="p_context"> void __init arc_unwind_init(void)</span>
 			  __start_unwind, __end_unwind - __start_unwind,
 			  NULL, 0);
 	  /*__start_unwind_hdr, __end_unwind_hdr - __start_unwind_hdr);*/
<span class="p_add">+</span>
<span class="p_add">+	init_unwind_hdr(&amp;root_table, unw_hdr_alloc_early);</span>
 }
 
 static const u32 bad_cie, not_fde;
<span class="p_chunk">@@ -241,8 +260,8 @@</span> <span class="p_context"> static void swap_eh_frame_hdr_table_entries(void *p1, void *p2, int size)</span>
 	e2-&gt;fde = v;
 }
 
<span class="p_del">-static void __init setup_unwind_table(struct unwind_table *table,</span>
<span class="p_del">-				      void *(*alloc) (unsigned long))</span>
<span class="p_add">+static void init_unwind_hdr(struct unwind_table *table,</span>
<span class="p_add">+			    void *(*alloc) (unsigned long))</span>
 {
 	const u8 *ptr;
 	unsigned long tableSize = table-&gt;size, hdrSize;
<span class="p_chunk">@@ -274,13 +293,13 @@</span> <span class="p_context"> static void __init setup_unwind_table(struct unwind_table *table,</span>
 		const u32 *cie = cie_for_fde(fde, table);
 		signed ptrType;
 
<span class="p_del">-		if (cie == &amp;not_fde)</span>
<span class="p_add">+		if (cie == &amp;not_fde)	/* only process FDE here */</span>
 			continue;
 		if (cie == NULL || cie == &amp;bad_cie)
<span class="p_del">-			return;</span>
<span class="p_add">+			continue;	/* say FDE-&gt;CIE.version != 1 */</span>
 		ptrType = fde_pointer_type(cie);
 		if (ptrType &lt; 0)
<span class="p_del">-			return;</span>
<span class="p_add">+			continue;</span>
 
 		ptr = (const u8 *)(fde + 2);
 		if (!read_pointer(&amp;ptr, (const u8 *)(fde + 1) + *fde,
<span class="p_chunk">@@ -300,9 +319,11 @@</span> <span class="p_context"> static void __init setup_unwind_table(struct unwind_table *table,</span>
 
 	hdrSize = 4 + sizeof(unsigned long) + sizeof(unsigned int)
 	    + 2 * n * sizeof(unsigned long);
<span class="p_add">+</span>
 	header = alloc(hdrSize);
 	if (!header)
 		return;
<span class="p_add">+</span>
 	header-&gt;version = 1;
 	header-&gt;eh_frame_ptr_enc = DW_EH_PE_abs | DW_EH_PE_native;
 	header-&gt;fde_count_enc = DW_EH_PE_abs | DW_EH_PE_data4;
<span class="p_chunk">@@ -322,6 +343,10 @@</span> <span class="p_context"> static void __init setup_unwind_table(struct unwind_table *table,</span>
 
 		if (fde[1] == 0xffffffff)
 			continue;	/* this is a CIE */
<span class="p_add">+</span>
<span class="p_add">+		if (*(u8 *)(cie + 2) != 1)</span>
<span class="p_add">+			continue;	/* FDE-&gt;CIE.version not supported */</span>
<span class="p_add">+</span>
 		ptr = (const u8 *)(fde + 2);
 		header-&gt;table[n].start = read_pointer(&amp;ptr,
 						      (const u8 *)(fde + 1) +
<span class="p_chunk">@@ -342,18 +367,6 @@</span> <span class="p_context"> static void __init setup_unwind_table(struct unwind_table *table,</span>
 	table-&gt;header = (const void *)header;
 }
 
<span class="p_del">-static void *__init balloc(unsigned long sz)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return __alloc_bootmem_nopanic(sz,</span>
<span class="p_del">-				       sizeof(unsigned int),</span>
<span class="p_del">-				       __pa(MAX_DMA_ADDRESS));</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void __init arc_unwind_setup(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	setup_unwind_table(&amp;root_table, balloc);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 #ifdef CONFIG_MODULES
 
 static struct unwind_table *last_table;
<span class="p_chunk">@@ -377,6 +390,8 @@</span> <span class="p_context"> void *unwind_add_table(struct module *module, const void *table_start,</span>
 			  table_start, table_size,
 			  NULL, 0);
 
<span class="p_add">+	init_unwind_hdr(table, unw_hdr_alloc);</span>
<span class="p_add">+</span>
 #ifdef UNWIND_DEBUG
 	unw_debug(&quot;Table added for [%s] %lx %lx\n&quot;,
 		module-&gt;name, table-&gt;core.pc, table-&gt;core.range);
<span class="p_chunk">@@ -439,6 +454,7 @@</span> <span class="p_context"> void unwind_remove_table(void *handle, int init_only)</span>
 	info.init_only = init_only;
 
 	unlink_table(&amp;info); /* XXX: SMP */
<span class="p_add">+	kfree(table-&gt;header);</span>
 	kfree(table);
 }
 
<span class="p_chunk">@@ -507,7 +523,8 @@</span> <span class="p_context"> static const u32 *cie_for_fde(const u32 *fde, const struct unwind_table *table)</span>
 
 	if (*cie &lt;= sizeof(*cie) + 4 || *cie &gt;= fde[1] - sizeof(*fde)
 	    || (*cie &amp; (sizeof(*cie) - 1))
<span class="p_del">-	    || (cie[1] != 0xffffffff))</span>
<span class="p_add">+	    || (cie[1] != 0xffffffff)</span>
<span class="p_add">+	    || ( *(u8 *)(cie + 2) != 1))   /* version 1 supported */</span>
 		return NULL;	/* this is not a (valid) CIE */
 	return cie;
 }
<span class="p_header">diff --git a/arch/arm/boot/dts/imx6q-gw5400-a.dts b/arch/arm/boot/dts/imx6q-gw5400-a.dts</span>
<span class="p_header">index 3689eaa58826..5e59ed27513d 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx6q-gw5400-a.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx6q-gw5400-a.dts</span>
<span class="p_chunk">@@ -152,7 +152,7 @@</span> <span class="p_context"></span>
 &amp;fec {
 	pinctrl-names = &quot;default&quot;;
 	pinctrl-0 = &lt;&amp;pinctrl_enet&gt;;
<span class="p_del">-	phy-mode = &quot;rgmii&quot;;</span>
<span class="p_add">+	phy-mode = &quot;rgmii-id&quot;;</span>
 	phy-reset-gpios = &lt;&amp;gpio1 30 0&gt;;
 	status = &quot;okay&quot;;
 };
<span class="p_header">diff --git a/arch/arm/boot/dts/imx6qdl-gw51xx.dtsi b/arch/arm/boot/dts/imx6qdl-gw51xx.dtsi</span>
<span class="p_header">index 0db15af41cb1..1ad3d9ec799b 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx6qdl-gw51xx.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx6qdl-gw51xx.dtsi</span>
<span class="p_chunk">@@ -90,7 +90,7 @@</span> <span class="p_context"></span>
 &amp;fec {
 	pinctrl-names = &quot;default&quot;;
 	pinctrl-0 = &lt;&amp;pinctrl_enet&gt;;
<span class="p_del">-	phy-mode = &quot;rgmii&quot;;</span>
<span class="p_add">+	phy-mode = &quot;rgmii-id&quot;;</span>
 	phy-reset-gpios = &lt;&amp;gpio1 30 0&gt;;
 	status = &quot;okay&quot;;
 };
<span class="p_header">diff --git a/arch/arm/boot/dts/imx6qdl-gw52xx.dtsi b/arch/arm/boot/dts/imx6qdl-gw52xx.dtsi</span>
<span class="p_header">index 744c8a2d81f6..1c8c333bd1fb 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx6qdl-gw52xx.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx6qdl-gw52xx.dtsi</span>
<span class="p_chunk">@@ -144,7 +144,7 @@</span> <span class="p_context"></span>
 &amp;fec {
 	pinctrl-names = &quot;default&quot;;
 	pinctrl-0 = &lt;&amp;pinctrl_enet&gt;;
<span class="p_del">-	phy-mode = &quot;rgmii&quot;;</span>
<span class="p_add">+	phy-mode = &quot;rgmii-id&quot;;</span>
 	phy-reset-gpios = &lt;&amp;gpio1 30 0&gt;;
 	status = &quot;okay&quot;;
 };
<span class="p_header">diff --git a/arch/arm/boot/dts/imx6qdl-gw53xx.dtsi b/arch/arm/boot/dts/imx6qdl-gw53xx.dtsi</span>
<span class="p_header">index adf150c1be90..1000d1403255 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx6qdl-gw53xx.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx6qdl-gw53xx.dtsi</span>
<span class="p_chunk">@@ -153,7 +153,7 @@</span> <span class="p_context"></span>
 &amp;fec {
 	pinctrl-names = &quot;default&quot;;
 	pinctrl-0 = &lt;&amp;pinctrl_enet&gt;;
<span class="p_del">-	phy-mode = &quot;rgmii&quot;;</span>
<span class="p_add">+	phy-mode = &quot;rgmii-id&quot;;</span>
 	phy-reset-gpios = &lt;&amp;gpio1 30 0&gt;;
 	status = &quot;okay&quot;;
 };
<span class="p_header">diff --git a/arch/arm/boot/dts/imx6qdl-gw54xx.dtsi b/arch/arm/boot/dts/imx6qdl-gw54xx.dtsi</span>
<span class="p_header">index 698d3063b295..f993f5194135 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx6qdl-gw54xx.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx6qdl-gw54xx.dtsi</span>
<span class="p_chunk">@@ -143,7 +143,7 @@</span> <span class="p_context"></span>
 &amp;fec {
 	pinctrl-names = &quot;default&quot;;
 	pinctrl-0 = &lt;&amp;pinctrl_enet&gt;;
<span class="p_del">-	phy-mode = &quot;rgmii&quot;;</span>
<span class="p_add">+	phy-mode = &quot;rgmii-id&quot;;</span>
 	phy-reset-gpios = &lt;&amp;gpio1 30 0&gt;;
 	status = &quot;okay&quot;;
 };
<span class="p_header">diff --git a/arch/arm/boot/dts/wm8650.dtsi b/arch/arm/boot/dts/wm8650.dtsi</span>
<span class="p_header">index b1c59a766a13..e12213d16693 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/wm8650.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/wm8650.dtsi</span>
<span class="p_chunk">@@ -187,6 +187,15 @@</span> <span class="p_context"></span>
 			interrupts = &lt;43&gt;;
 		};
 
<span class="p_add">+		sdhc@d800a000 {</span>
<span class="p_add">+			compatible = &quot;wm,wm8505-sdhc&quot;;</span>
<span class="p_add">+			reg = &lt;0xd800a000 0x400&gt;;</span>
<span class="p_add">+			interrupts = &lt;20&gt;, &lt;21&gt;;</span>
<span class="p_add">+			clocks = &lt;&amp;clksdhc&gt;;</span>
<span class="p_add">+			bus-width = &lt;4&gt;;</span>
<span class="p_add">+			sdon-inverted;</span>
<span class="p_add">+		};</span>
<span class="p_add">+</span>
 		fb: fb@d8050800 {
 			compatible = &quot;wm,wm8505-fb&quot;;
 			reg = &lt;0xd8050800 0x200&gt;;
<span class="p_header">diff --git a/arch/arm/kernel/sys_oabi-compat.c b/arch/arm/kernel/sys_oabi-compat.c</span>
<span class="p_header">index e90a3148f385..eb821e7b80f9 100644</span>
<span class="p_header">--- a/arch/arm/kernel/sys_oabi-compat.c</span>
<span class="p_header">+++ b/arch/arm/kernel/sys_oabi-compat.c</span>
<span class="p_chunk">@@ -193,15 +193,44 @@</span> <span class="p_context"> struct oabi_flock64 {</span>
 	pid_t	l_pid;
 } __attribute__ ((packed,aligned(4)));
 
<span class="p_del">-asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,</span>
<span class="p_add">+static long do_locks(unsigned int fd, unsigned int cmd,</span>
 				 unsigned long arg)
 {
<span class="p_del">-	struct oabi_flock64 user;</span>
 	struct flock64 kernel;
<span class="p_del">-	mm_segment_t fs = USER_DS; /* initialized to kill a warning */</span>
<span class="p_del">-	unsigned long local_arg = arg;</span>
<span class="p_del">-	int ret;</span>
<span class="p_add">+	struct oabi_flock64 user;</span>
<span class="p_add">+	mm_segment_t fs;</span>
<span class="p_add">+	long ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (copy_from_user(&amp;user, (struct oabi_flock64 __user *)arg,</span>
<span class="p_add">+			   sizeof(user)))</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+	kernel.l_type	= user.l_type;</span>
<span class="p_add">+	kernel.l_whence	= user.l_whence;</span>
<span class="p_add">+	kernel.l_start	= user.l_start;</span>
<span class="p_add">+	kernel.l_len	= user.l_len;</span>
<span class="p_add">+	kernel.l_pid	= user.l_pid;</span>
<span class="p_add">+</span>
<span class="p_add">+	fs = get_fs();</span>
<span class="p_add">+	set_fs(KERNEL_DS);</span>
<span class="p_add">+	ret = sys_fcntl64(fd, cmd, (unsigned long)&amp;kernel);</span>
<span class="p_add">+	set_fs(fs);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!ret &amp;&amp; (cmd == F_GETLK64 || cmd == F_OFD_GETLK)) {</span>
<span class="p_add">+		user.l_type	= kernel.l_type;</span>
<span class="p_add">+		user.l_whence	= kernel.l_whence;</span>
<span class="p_add">+		user.l_start	= kernel.l_start;</span>
<span class="p_add">+		user.l_len	= kernel.l_len;</span>
<span class="p_add">+		user.l_pid	= kernel.l_pid;</span>
<span class="p_add">+		if (copy_to_user((struct oabi_flock64 __user *)arg,</span>
<span class="p_add">+				 &amp;user, sizeof(user)))</span>
<span class="p_add">+			ret = -EFAULT;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
 
<span class="p_add">+asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,</span>
<span class="p_add">+				 unsigned long arg)</span>
<span class="p_add">+{</span>
 	switch (cmd) {
 	case F_OFD_GETLK:
 	case F_OFD_SETLK:
<span class="p_chunk">@@ -209,39 +238,11 @@</span> <span class="p_context"> asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,</span>
 	case F_GETLK64:
 	case F_SETLK64:
 	case F_SETLKW64:
<span class="p_del">-		if (copy_from_user(&amp;user, (struct oabi_flock64 __user *)arg,</span>
<span class="p_del">-				   sizeof(user)))</span>
<span class="p_del">-			return -EFAULT;</span>
<span class="p_del">-		kernel.l_type	= user.l_type;</span>
<span class="p_del">-		kernel.l_whence	= user.l_whence;</span>
<span class="p_del">-		kernel.l_start	= user.l_start;</span>
<span class="p_del">-		kernel.l_len	= user.l_len;</span>
<span class="p_del">-		kernel.l_pid	= user.l_pid;</span>
<span class="p_del">-		local_arg = (unsigned long)&amp;kernel;</span>
<span class="p_del">-		fs = get_fs();</span>
<span class="p_del">-		set_fs(KERNEL_DS);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = sys_fcntl64(fd, cmd, local_arg);</span>
<span class="p_add">+		return do_locks(fd, cmd, arg);</span>
 
<span class="p_del">-	switch (cmd) {</span>
<span class="p_del">-	case F_GETLK64:</span>
<span class="p_del">-		if (!ret) {</span>
<span class="p_del">-			user.l_type	= kernel.l_type;</span>
<span class="p_del">-			user.l_whence	= kernel.l_whence;</span>
<span class="p_del">-			user.l_start	= kernel.l_start;</span>
<span class="p_del">-			user.l_len	= kernel.l_len;</span>
<span class="p_del">-			user.l_pid	= kernel.l_pid;</span>
<span class="p_del">-			if (copy_to_user((struct oabi_flock64 __user *)arg,</span>
<span class="p_del">-					 &amp;user, sizeof(user)))</span>
<span class="p_del">-				ret = -EFAULT;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	case F_SETLK64:</span>
<span class="p_del">-	case F_SETLKW64:</span>
<span class="p_del">-		set_fs(fs);</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		return sys_fcntl64(fd, cmd, arg);</span>
 	}
<span class="p_del">-</span>
<span class="p_del">-	return ret;</span>
 }
 
 struct oabi_epoll_event {
<span class="p_header">diff --git a/arch/arm/mm/proc-v7.S b/arch/arm/mm/proc-v7.S</span>
<span class="p_header">index 0eba0d1fd65a..ce9444e9d001 100644</span>
<span class="p_header">--- a/arch/arm/mm/proc-v7.S</span>
<span class="p_header">+++ b/arch/arm/mm/proc-v7.S</span>
<span class="p_chunk">@@ -95,7 +95,7 @@</span> <span class="p_context"> ENDPROC(cpu_v7_dcache_clean_area)</span>
 .equ	cpu_v7_suspend_size, 4 * 9
 #ifdef CONFIG_ARM_CPU_SUSPEND
 ENTRY(cpu_v7_do_suspend)
<span class="p_del">-	stmfd	sp!, {r4 - r10, lr}</span>
<span class="p_add">+	stmfd	sp!, {r4 - r11, lr}</span>
 	mrc	p15, 0, r4, c13, c0, 0	@ FCSE/PID
 	mrc	p15, 0, r5, c13, c0, 3	@ User r/o thread ID
 	stmia	r0!, {r4 - r5}
<span class="p_chunk">@@ -112,7 +112,7 @@</span> <span class="p_context"> ENTRY(cpu_v7_do_suspend)</span>
 	mrc	p15, 0, r9, c1, c0, 1	@ Auxiliary control register
 	mrc	p15, 0, r10, c1, c0, 2	@ Co-processor access control
 	stmia	r0, {r5 - r11}
<span class="p_del">-	ldmfd	sp!, {r4 - r10, pc}</span>
<span class="p_add">+	ldmfd	sp!, {r4 - r11, pc}</span>
 ENDPROC(cpu_v7_do_suspend)
 
 ENTRY(cpu_v7_do_resume)
<span class="p_header">diff --git a/arch/arm/net/bpf_jit_32.c b/arch/arm/net/bpf_jit_32.c</span>
<span class="p_header">index 75ee31c95ff3..4a7fe29635ea 100644</span>
<span class="p_header">--- a/arch/arm/net/bpf_jit_32.c</span>
<span class="p_header">+++ b/arch/arm/net/bpf_jit_32.c</span>
<span class="p_chunk">@@ -161,23 +161,9 @@</span> <span class="p_context"> static inline int mem_words_used(struct jit_ctx *ctx)</span>
 	return fls(ctx-&gt;seen &amp; SEEN_MEM);
 }
 
<span class="p_del">-static inline bool is_load_to_a(u16 inst)</span>
<span class="p_del">-{</span>
<span class="p_del">-	switch (inst) {</span>
<span class="p_del">-	case BPF_LD | BPF_W | BPF_LEN:</span>
<span class="p_del">-	case BPF_LD | BPF_W | BPF_ABS:</span>
<span class="p_del">-	case BPF_LD | BPF_H | BPF_ABS:</span>
<span class="p_del">-	case BPF_LD | BPF_B | BPF_ABS:</span>
<span class="p_del">-		return true;</span>
<span class="p_del">-	default:</span>
<span class="p_del">-		return false;</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static void build_prologue(struct jit_ctx *ctx)
 {
 	u16 reg_set = saved_regs(ctx);
<span class="p_del">-	u16 first_inst = ctx-&gt;skf-&gt;insns[0].code;</span>
 	u16 off;
 
 #ifdef CONFIG_FRAME_POINTER
<span class="p_chunk">@@ -207,7 +193,7 @@</span> <span class="p_context"> static void build_prologue(struct jit_ctx *ctx)</span>
 		emit(ARM_MOV_I(r_X, 0), ctx);
 
 	/* do not leak kernel data to userspace */
<span class="p_del">-	if ((first_inst != (BPF_RET | BPF_K)) &amp;&amp; !(is_load_to_a(first_inst)))</span>
<span class="p_add">+	if (bpf_needs_clear_a(&amp;ctx-&gt;skf-&gt;insns[0]))</span>
 		emit(ARM_MOV_I(r_A, 0), ctx);
 
 	/* stack space for the BPF_MEM words */
<span class="p_header">diff --git a/arch/mips/include/asm/uaccess.h b/arch/mips/include/asm/uaccess.h</span>
<span class="p_header">index b9ab717e3619..16e0ea6b99d8 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/uaccess.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/uaccess.h</span>
<span class="p_chunk">@@ -1092,9 +1092,15 @@</span> <span class="p_context"> extern size_t __copy_in_user_eva(void *__to, const void *__from, size_t __n);</span>
 	__cu_to = (to);							\
 	__cu_from = (from);						\
 	__cu_len = (n);							\
<span class="p_del">-	might_fault();							\</span>
<span class="p_del">-	__cu_len = __invoke_copy_from_user(__cu_to, __cu_from,		\</span>
<span class="p_del">-					   __cu_len);			\</span>
<span class="p_add">+	if (segment_eq(get_fs(), get_ds())) {				\</span>
<span class="p_add">+		__cu_len = __invoke_copy_from_kernel(__cu_to,		\</span>
<span class="p_add">+						     __cu_from,		\</span>
<span class="p_add">+						     __cu_len);		\</span>
<span class="p_add">+	} else {							\</span>
<span class="p_add">+		might_fault();						\</span>
<span class="p_add">+		__cu_len = __invoke_copy_from_user(__cu_to, __cu_from,	\</span>
<span class="p_add">+						   __cu_len);		\</span>
<span class="p_add">+	}								\</span>
 	__cu_len;							\
 })
 
<span class="p_chunk">@@ -1198,16 +1204,28 @@</span> <span class="p_context"> __clear_user(void __user *addr, __kernel_size_t size)</span>
 {
 	__kernel_size_t res;
 
<span class="p_del">-	might_fault();</span>
<span class="p_del">-	__asm__ __volatile__(</span>
<span class="p_del">-		&quot;move\t$4, %1\n\t&quot;</span>
<span class="p_del">-		&quot;move\t$5, $0\n\t&quot;</span>
<span class="p_del">-		&quot;move\t$6, %2\n\t&quot;</span>
<span class="p_del">-		__MODULE_JAL(__bzero)</span>
<span class="p_del">-		&quot;move\t%0, $6&quot;</span>
<span class="p_del">-		: &quot;=r&quot; (res)</span>
<span class="p_del">-		: &quot;r&quot; (addr), &quot;r&quot; (size)</span>
<span class="p_del">-		: &quot;$4&quot;, &quot;$5&quot;, &quot;$6&quot;, __UA_t0, __UA_t1, &quot;$31&quot;);</span>
<span class="p_add">+	if (config_enabled(CONFIG_EVA) &amp;&amp; segment_eq(get_fs(), get_ds())) {</span>
<span class="p_add">+		__asm__ __volatile__(</span>
<span class="p_add">+			&quot;move\t$4, %1\n\t&quot;</span>
<span class="p_add">+			&quot;move\t$5, $0\n\t&quot;</span>
<span class="p_add">+			&quot;move\t$6, %2\n\t&quot;</span>
<span class="p_add">+			__MODULE_JAL(__bzero_kernel)</span>
<span class="p_add">+			&quot;move\t%0, $6&quot;</span>
<span class="p_add">+			: &quot;=r&quot; (res)</span>
<span class="p_add">+			: &quot;r&quot; (addr), &quot;r&quot; (size)</span>
<span class="p_add">+			: &quot;$4&quot;, &quot;$5&quot;, &quot;$6&quot;, __UA_t0, __UA_t1, &quot;$31&quot;);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		might_fault();</span>
<span class="p_add">+		__asm__ __volatile__(</span>
<span class="p_add">+			&quot;move\t$4, %1\n\t&quot;</span>
<span class="p_add">+			&quot;move\t$5, $0\n\t&quot;</span>
<span class="p_add">+			&quot;move\t$6, %2\n\t&quot;</span>
<span class="p_add">+			__MODULE_JAL(__bzero)</span>
<span class="p_add">+			&quot;move\t%0, $6&quot;</span>
<span class="p_add">+			: &quot;=r&quot; (res)</span>
<span class="p_add">+			: &quot;r&quot; (addr), &quot;r&quot; (size)</span>
<span class="p_add">+			: &quot;$4&quot;, &quot;$5&quot;, &quot;$6&quot;, __UA_t0, __UA_t1, &quot;$31&quot;);</span>
<span class="p_add">+	}</span>
 
 	return res;
 }
<span class="p_chunk">@@ -1379,7 +1397,7 @@</span> <span class="p_context"> static inline long strlen_user(const char __user *s)</span>
 		might_fault();
 		__asm__ __volatile__(
 			&quot;move\t$4, %1\n\t&quot;
<span class="p_del">-			__MODULE_JAL(__strlen_kernel_asm)</span>
<span class="p_add">+			__MODULE_JAL(__strlen_user_asm)</span>
 			&quot;move\t%0, $2&quot;
 			: &quot;=r&quot; (res)
 			: &quot;r&quot; (s)
<span class="p_header">diff --git a/arch/mips/kernel/mips_ksyms.c b/arch/mips/kernel/mips_ksyms.c</span>
<span class="p_header">index 1b2452e2be67..c1e152a27b17 100644</span>
<span class="p_header">--- a/arch/mips/kernel/mips_ksyms.c</span>
<span class="p_header">+++ b/arch/mips/kernel/mips_ksyms.c</span>
<span class="p_chunk">@@ -17,6 +17,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/fpu.h&gt;
 #include &lt;asm/msa.h&gt;
 
<span class="p_add">+extern void *__bzero_kernel(void *__s, size_t __count);</span>
 extern void *__bzero(void *__s, size_t __count);
 extern long __strncpy_from_kernel_nocheck_asm(char *__to,
 					      const char *__from, long __len);
<span class="p_chunk">@@ -66,6 +67,7 @@</span> <span class="p_context"> EXPORT_SYMBOL(__copy_from_user_eva);</span>
 EXPORT_SYMBOL(__copy_in_user_eva);
 EXPORT_SYMBOL(__copy_to_user_eva);
 EXPORT_SYMBOL(__copy_user_inatomic_eva);
<span class="p_add">+EXPORT_SYMBOL(__bzero_kernel);</span>
 #endif
 EXPORT_SYMBOL(__bzero);
 EXPORT_SYMBOL(__strncpy_from_kernel_nocheck_asm);
<span class="p_header">diff --git a/arch/mips/lib/memset.S b/arch/mips/lib/memset.S</span>
<span class="p_header">index 7b0e5462ca51..fd83406ceccc 100644</span>
<span class="p_header">--- a/arch/mips/lib/memset.S</span>
<span class="p_header">+++ b/arch/mips/lib/memset.S</span>
<span class="p_chunk">@@ -238,6 +238,8 @@</span> <span class="p_context"> LEAF(memset)</span>
 1:
 #ifndef CONFIG_EVA
 FEXPORT(__bzero)
<span class="p_add">+#else</span>
<span class="p_add">+FEXPORT(__bzero_kernel)</span>
 #endif
 	__BUILD_BZERO LEGACY_MODE
 
<span class="p_header">diff --git a/arch/mips/net/bpf_jit.c b/arch/mips/net/bpf_jit.c</span>
<span class="p_header">index 965f1c116cc5..32751a0bba58 100644</span>
<span class="p_header">--- a/arch/mips/net/bpf_jit.c</span>
<span class="p_header">+++ b/arch/mips/net/bpf_jit.c</span>
<span class="p_chunk">@@ -566,19 +566,6 @@</span> <span class="p_context"> static inline u16 align_sp(unsigned int num)</span>
 	return num;
 }
 
<span class="p_del">-static bool is_load_to_a(u16 inst)</span>
<span class="p_del">-{</span>
<span class="p_del">-	switch (inst) {</span>
<span class="p_del">-	case BPF_LD | BPF_W | BPF_LEN:</span>
<span class="p_del">-	case BPF_LD | BPF_W | BPF_ABS:</span>
<span class="p_del">-	case BPF_LD | BPF_H | BPF_ABS:</span>
<span class="p_del">-	case BPF_LD | BPF_B | BPF_ABS:</span>
<span class="p_del">-		return true;</span>
<span class="p_del">-	default:</span>
<span class="p_del">-		return false;</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static void save_bpf_jit_regs(struct jit_ctx *ctx, unsigned offset)
 {
 	int i = 0, real_off = 0;
<span class="p_chunk">@@ -703,7 +690,6 @@</span> <span class="p_context"> static unsigned int get_stack_depth(struct jit_ctx *ctx)</span>
 
 static void build_prologue(struct jit_ctx *ctx)
 {
<span class="p_del">-	u16 first_inst = ctx-&gt;skf-&gt;insns[0].code;</span>
 	int sp_off;
 
 	/* Calculate the total offset for the stack pointer */
<span class="p_chunk">@@ -717,7 +703,7 @@</span> <span class="p_context"> static void build_prologue(struct jit_ctx *ctx)</span>
 		emit_jit_reg_move(r_X, r_zero, ctx);
 
 	/* Do not leak kernel data to userspace */
<span class="p_del">-	if ((first_inst != (BPF_RET | BPF_K)) &amp;&amp; !(is_load_to_a(first_inst)))</span>
<span class="p_add">+	if (bpf_needs_clear_a(&amp;ctx-&gt;skf-&gt;insns[0]))</span>
 		emit_jit_reg_move(r_A, r_zero, ctx);
 }
 
<span class="p_header">diff --git a/arch/parisc/kernel/signal.c b/arch/parisc/kernel/signal.c</span>
<span class="p_header">index 1cba8f29bb49..78bb6dd88e03 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/signal.c</span>
<span class="p_header">+++ b/arch/parisc/kernel/signal.c</span>
<span class="p_chunk">@@ -442,6 +442,55 @@</span> <span class="p_context"> handle_signal(unsigned long sig, siginfo_t *info, struct k_sigaction *ka,</span>
 		regs-&gt;gr[28]);
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Check how the syscall number gets loaded into %r20 within</span>
<span class="p_add">+ * the delay branch in userspace and adjust as needed.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+static void check_syscallno_in_delay_branch(struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 opcode, source_reg;</span>
<span class="p_add">+	u32 __user *uaddr;</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Usually we don&#39;t have to restore %r20 (the system call number)</span>
<span class="p_add">+	 * because it gets loaded in the delay slot of the branch external</span>
<span class="p_add">+	 * instruction via the ldi instruction.</span>
<span class="p_add">+	 * In some cases a register-to-register copy instruction might have</span>
<span class="p_add">+	 * been used instead, in which case we need to copy the syscall</span>
<span class="p_add">+	 * number into the source register before returning to userspace.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
<span class="p_add">+	/* A syscall is just a branch, so all we have to do is fiddle the</span>
<span class="p_add">+	 * return pointer so that the ble instruction gets executed again.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	regs-&gt;gr[31] -= 8; /* delayed branching */</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Get assembler opcode of code in delay branch */</span>
<span class="p_add">+	uaddr = (unsigned int *) ((regs-&gt;gr[31] &amp; ~3) + 4);</span>
<span class="p_add">+	err = get_user(opcode, uaddr);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Check if delay branch uses &quot;ldi int,%r20&quot; */</span>
<span class="p_add">+	if ((opcode &amp; 0xffff0000) == 0x34140000)</span>
<span class="p_add">+		return;	/* everything ok, just return */</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Check if delay branch uses &quot;nop&quot; */</span>
<span class="p_add">+	if (opcode == INSN_NOP)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Check if delay branch uses &quot;copy %rX,%r20&quot; */</span>
<span class="p_add">+	if ((opcode &amp; 0xffe0ffff) == 0x08000254) {</span>
<span class="p_add">+		source_reg = (opcode &gt;&gt; 16) &amp; 31;</span>
<span class="p_add">+		regs-&gt;gr[source_reg] = regs-&gt;gr[20];</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_warn(&quot;syscall restart: %s (pid %d): unexpected opcode 0x%08x\n&quot;,</span>
<span class="p_add">+		current-&gt;comm, task_pid_nr(current), opcode);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline void
 syscall_restart(struct pt_regs *regs, struct k_sigaction *ka)
 {
<span class="p_chunk">@@ -464,10 +513,7 @@</span> <span class="p_context"> syscall_restart(struct pt_regs *regs, struct k_sigaction *ka)</span>
 		}
 		/* fallthrough */
 	case -ERESTARTNOINTR:
<span class="p_del">-		/* A syscall is just a branch, so all</span>
<span class="p_del">-		 * we have to do is fiddle the return pointer.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		regs-&gt;gr[31] -= 8; /* delayed branching */</span>
<span class="p_add">+		check_syscallno_in_delay_branch(regs);</span>
 		break;
 	}
 }
<span class="p_chunk">@@ -516,15 +562,9 @@</span> <span class="p_context"> insert_restart_trampoline(struct pt_regs *regs)</span>
 	}
 	case -ERESTARTNOHAND:
 	case -ERESTARTSYS:
<span class="p_del">-	case -ERESTARTNOINTR: {</span>
<span class="p_del">-		/* Hooray for delayed branching.  We don&#39;t</span>
<span class="p_del">-		 * have to restore %r20 (the system call</span>
<span class="p_del">-		 * number) because it gets loaded in the delay</span>
<span class="p_del">-		 * slot of the branch external instruction.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		regs-&gt;gr[31] -= 8;</span>
<span class="p_add">+	case -ERESTARTNOINTR:</span>
<span class="p_add">+		check_syscallno_in_delay_branch(regs);</span>
 		return;
<span class="p_del">-	}</span>
 	default:
 		break;
 	}
<span class="p_header">diff --git a/arch/powerpc/kvm/book3s_hv.c b/arch/powerpc/kvm/book3s_hv.c</span>
<span class="p_header">index 0f3a19237444..89d4ebd8152b 100644</span>
<span class="p_header">--- a/arch/powerpc/kvm/book3s_hv.c</span>
<span class="p_header">+++ b/arch/powerpc/kvm/book3s_hv.c</span>
<span class="p_chunk">@@ -166,6 +166,12 @@</span> <span class="p_context"> static void kvmppc_core_vcpu_put_hv(struct kvm_vcpu *vcpu)</span>
 
 static void kvmppc_set_msr_hv(struct kvm_vcpu *vcpu, u64 msr)
 {
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Check for illegal transactional state bit combination</span>
<span class="p_add">+	 * and if we find it, force the TS field to a safe state.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if ((msr &amp; MSR_TS_MASK) == MSR_TS_MASK)</span>
<span class="p_add">+		msr &amp;= ~MSR_TS_MASK;</span>
 	vcpu-&gt;arch.shregs.msr = msr;
 	kvmppc_end_cede(vcpu);
 }
<span class="p_header">diff --git a/arch/powerpc/net/bpf_jit_comp.c b/arch/powerpc/net/bpf_jit_comp.c</span>
<span class="p_header">index 82e82cadcde5..6a1c7ecfdd2c 100644</span>
<span class="p_header">--- a/arch/powerpc/net/bpf_jit_comp.c</span>
<span class="p_header">+++ b/arch/powerpc/net/bpf_jit_comp.c</span>
<span class="p_chunk">@@ -78,18 +78,9 @@</span> <span class="p_context"> static void bpf_jit_build_prologue(struct sk_filter *fp, u32 *image,</span>
 		PPC_LI(r_X, 0);
 	}
 
<span class="p_del">-	switch (filter[0].code) {</span>
<span class="p_del">-	case BPF_RET | BPF_K:</span>
<span class="p_del">-	case BPF_LD | BPF_W | BPF_LEN:</span>
<span class="p_del">-	case BPF_LD | BPF_W | BPF_ABS:</span>
<span class="p_del">-	case BPF_LD | BPF_H | BPF_ABS:</span>
<span class="p_del">-	case BPF_LD | BPF_B | BPF_ABS:</span>
<span class="p_del">-		/* first instruction sets A register (or is RET &#39;constant&#39;) */</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	default:</span>
<span class="p_del">-		/* make sure we dont leak kernel information to user */</span>
<span class="p_add">+	/* make sure we dont leak kernel information to user */</span>
<span class="p_add">+	if (bpf_needs_clear_a(&amp;filter[0]))</span>
 		PPC_LI(r_A, 0);
<span class="p_del">-	}</span>
 }
 
 static void bpf_jit_build_epilogue(u32 *image, struct codegen_context *ctx)
<span class="p_header">diff --git a/arch/powerpc/platforms/powernv/opal.c b/arch/powerpc/platforms/powernv/opal.c</span>
<span class="p_header">index 199975613fe9..0fa7178d36dc 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/powernv/opal.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/powernv/opal.c</span>
<span class="p_chunk">@@ -286,16 +286,12 @@</span> <span class="p_context"> void opal_notifier_disable(void)</span>
 int opal_message_notifier_register(enum OpalMessageType msg_type,
 					struct notifier_block *nb)
 {
<span class="p_del">-	if (!nb) {</span>
<span class="p_del">-		pr_warning(&quot;%s: Invalid argument (%p)\n&quot;,</span>
<span class="p_del">-			   __func__, nb);</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	if (msg_type &gt; OPAL_MSG_TYPE_MAX) {</span>
<span class="p_del">-		pr_warning(&quot;%s: Invalid message type argument (%d)\n&quot;,</span>
<span class="p_add">+	if (!nb || msg_type &gt;= OPAL_MSG_TYPE_MAX) {</span>
<span class="p_add">+		pr_warning(&quot;%s: Invalid arguments, msg_type:%d\n&quot;,</span>
 			   __func__, msg_type);
 		return -EINVAL;
 	}
<span class="p_add">+</span>
 	return atomic_notifier_chain_register(
 				&amp;opal_msg_notifier_head[msg_type], nb);
 }
<span class="p_chunk">@@ -332,8 +328,8 @@</span> <span class="p_context"> static void opal_handle_message(void)</span>
 	type = be32_to_cpu(msg.msg_type);
 
 	/* Sanity check */
<span class="p_del">-	if (type &gt; OPAL_MSG_TYPE_MAX) {</span>
<span class="p_del">-		pr_warning(&quot;%s: Unknown message type: %u\n&quot;, __func__, type);</span>
<span class="p_add">+	if (type &gt;= OPAL_MSG_TYPE_MAX) {</span>
<span class="p_add">+		pr_warn_once(&quot;%s: Unknown message type: %u\n&quot;, __func__, type);</span>
 		return;
 	}
 	opal_message_do_notify(type, (void *)&amp;msg);
<span class="p_header">diff --git a/arch/s390/kernel/dis.c b/arch/s390/kernel/dis.c</span>
<span class="p_header">index 993efe6a887c..3d942314818b 100644</span>
<span class="p_header">--- a/arch/s390/kernel/dis.c</span>
<span class="p_header">+++ b/arch/s390/kernel/dis.c</span>
<span class="p_chunk">@@ -1726,14 +1726,21 @@</span> <span class="p_context"> static int print_insn(char *buffer, unsigned char *code, unsigned long addr)</span>
 			}
 			if (separator)
 				ptr += sprintf(ptr, &quot;%c&quot;, separator);
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Use four &#39;%&#39; characters below because of the</span>
<span class="p_add">+			 * following two conversions:</span>
<span class="p_add">+			 *</span>
<span class="p_add">+			 *  1) sprintf: %%%%r -&gt; %%r</span>
<span class="p_add">+			 *  2) printk : %%r   -&gt; %r</span>
<span class="p_add">+			 */</span>
 			if (operand-&gt;flags &amp; OPERAND_GPR)
<span class="p_del">-				ptr += sprintf(ptr, &quot;%%r%i&quot;, value);</span>
<span class="p_add">+				ptr += sprintf(ptr, &quot;%%%%r%i&quot;, value);</span>
 			else if (operand-&gt;flags &amp; OPERAND_FPR)
<span class="p_del">-				ptr += sprintf(ptr, &quot;%%f%i&quot;, value);</span>
<span class="p_add">+				ptr += sprintf(ptr, &quot;%%%%f%i&quot;, value);</span>
 			else if (operand-&gt;flags &amp; OPERAND_AR)
<span class="p_del">-				ptr += sprintf(ptr, &quot;%%a%i&quot;, value);</span>
<span class="p_add">+				ptr += sprintf(ptr, &quot;%%%%a%i&quot;, value);</span>
 			else if (operand-&gt;flags &amp; OPERAND_CR)
<span class="p_del">-				ptr += sprintf(ptr, &quot;%%c%i&quot;, value);</span>
<span class="p_add">+				ptr += sprintf(ptr, &quot;%%%%c%i&quot;, value);</span>
 			else if (operand-&gt;flags &amp; OPERAND_PCREL)
 				ptr += sprintf(ptr, &quot;%lx&quot;, (signed int) value
 								      + addr);
<span class="p_header">diff --git a/arch/sh/include/uapi/asm/unistd_64.h b/arch/sh/include/uapi/asm/unistd_64.h</span>
<span class="p_header">index e6820c86e8c7..47ebd5b5ed55 100644</span>
<span class="p_header">--- a/arch/sh/include/uapi/asm/unistd_64.h</span>
<span class="p_header">+++ b/arch/sh/include/uapi/asm/unistd_64.h</span>
<span class="p_chunk">@@ -278,7 +278,7 @@</span> <span class="p_context"></span>
 #define __NR_fsetxattr		256
 #define __NR_getxattr		257
 #define __NR_lgetxattr		258
<span class="p_del">-#define __NR_fgetxattr		269</span>
<span class="p_add">+#define __NR_fgetxattr		259</span>
 #define __NR_listxattr		260
 #define __NR_llistxattr		261
 #define __NR_flistxattr		262
<span class="p_header">diff --git a/arch/sparc/net/bpf_jit_comp.c b/arch/sparc/net/bpf_jit_comp.c</span>
<span class="p_header">index 8d4152f94c5a..ae966f86dcec 100644</span>
<span class="p_header">--- a/arch/sparc/net/bpf_jit_comp.c</span>
<span class="p_header">+++ b/arch/sparc/net/bpf_jit_comp.c</span>
<span class="p_chunk">@@ -420,22 +420,9 @@</span> <span class="p_context"> void bpf_jit_compile(struct sk_filter *fp)</span>
 		}
 		emit_reg_move(O7, r_saved_O7);
 
<span class="p_del">-		switch (filter[0].code) {</span>
<span class="p_del">-		case BPF_RET | BPF_K:</span>
<span class="p_del">-		case BPF_LD | BPF_W | BPF_LEN:</span>
<span class="p_del">-		case BPF_LD | BPF_W | BPF_ABS:</span>
<span class="p_del">-		case BPF_LD | BPF_H | BPF_ABS:</span>
<span class="p_del">-		case BPF_LD | BPF_B | BPF_ABS:</span>
<span class="p_del">-			/* The first instruction sets the A register (or is</span>
<span class="p_del">-			 * a &quot;RET &#39;constant&#39;&quot;)</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		default:</span>
<span class="p_del">-			/* Make sure we dont leak kernel information to the</span>
<span class="p_del">-			 * user.</span>
<span class="p_del">-			 */</span>
<span class="p_add">+		/* Make sure we dont leak kernel information to the user. */</span>
<span class="p_add">+		if (bpf_needs_clear_a(&amp;filter[0]))</span>
 			emit_clear(r_A); /* A = 0 */
<span class="p_del">-		}</span>
 
 		for (i = 0; i &lt; flen; i++) {
 			unsigned int K = filter[i].k;
<span class="p_header">diff --git a/arch/x86/kernel/cpu/mcheck/mce.c b/arch/x86/kernel/cpu/mcheck/mce.c</span>
<span class="p_header">index 5648b506f3ae..8ae7e3f27b1b 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/mcheck/mce.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/mcheck/mce.c</span>
<span class="p_chunk">@@ -1042,6 +1042,17 @@</span> <span class="p_context"> void do_machine_check(struct pt_regs *regs, long error_code)</span>
 	DECLARE_BITMAP(valid_banks, MAX_NR_BANKS);
 	char *msg = &quot;Unknown&quot;;
 
<span class="p_add">+	/* If this CPU is offline, just bail out. */</span>
<span class="p_add">+	if (cpu_is_offline(smp_processor_id())) {</span>
<span class="p_add">+		u64 mcgstatus;</span>
<span class="p_add">+</span>
<span class="p_add">+		mcgstatus = mce_rdmsrl(MSR_IA32_MCG_STATUS);</span>
<span class="p_add">+		if (mcgstatus &amp; MCG_STATUS_RIPV) {</span>
<span class="p_add">+			mce_wrmsrl(MSR_IA32_MCG_STATUS, 0);</span>
<span class="p_add">+			return;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	this_cpu_inc(mce_exception_count);
 
 	if (!cfg-&gt;banks)
<span class="p_header">diff --git a/arch/x86/kvm/i8254.c b/arch/x86/kvm/i8254.c</span>
<span class="p_header">index 1406ffde3e35..f2006e65a238 100644</span>
<span class="p_header">--- a/arch/x86/kvm/i8254.c</span>
<span class="p_header">+++ b/arch/x86/kvm/i8254.c</span>
<span class="p_chunk">@@ -418,6 +418,7 @@</span> <span class="p_context"> void kvm_pit_load_count(struct kvm *kvm, int channel, u32 val, int hpet_legacy_s</span>
 	u8 saved_mode;
 	if (hpet_legacy_start) {
 		/* save existing mode for later reenablement */
<span class="p_add">+		WARN_ON(channel != 0);</span>
 		saved_mode = kvm-&gt;arch.vpit-&gt;pit_state.channels[0].mode;
 		kvm-&gt;arch.vpit-&gt;pit_state.channels[0].mode = 0xff; /* disable timer */
 		pit_load_count(kvm, channel, val);
<span class="p_header">diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c</span>
<span class="p_header">index e336615e0aae..14bd5c079ca3 100644</span>
<span class="p_header">--- a/arch/x86/kvm/x86.c</span>
<span class="p_header">+++ b/arch/x86/kvm/x86.c</span>
<span class="p_chunk">@@ -3596,7 +3596,8 @@</span> <span class="p_context"> static int kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)</span>
 	       sizeof(kvm-&gt;arch.vpit-&gt;pit_state.channels));
 	kvm-&gt;arch.vpit-&gt;pit_state.flags = ps-&gt;flags;
 	for (i = 0; i &lt; 3; i++)
<span class="p_del">-		kvm_pit_load_count(kvm, i, kvm-&gt;arch.vpit-&gt;pit_state.channels[i].count, start);</span>
<span class="p_add">+		kvm_pit_load_count(kvm, i, kvm-&gt;arch.vpit-&gt;pit_state.channels[i].count,</span>
<span class="p_add">+				   start &amp;&amp; i == 0);</span>
 	mutex_unlock(&amp;kvm-&gt;arch.vpit-&gt;pit_state.lock);
 	return r;
 }
<span class="p_header">diff --git a/arch/x86/platform/efi/efi.c b/arch/x86/platform/efi/efi.c</span>
<span class="p_header">index 5bbb477f5c2a..09c8ac286cd5 100644</span>
<span class="p_header">--- a/arch/x86/platform/efi/efi.c</span>
<span class="p_header">+++ b/arch/x86/platform/efi/efi.c</span>
<span class="p_chunk">@@ -236,12 +236,19 @@</span> <span class="p_context"> static efi_status_t __init phys_efi_set_virtual_address_map(</span>
 	efi_memory_desc_t *virtual_map)
 {
 	efi_status_t status;
<span class="p_add">+	unsigned long flags;</span>
 
 	efi_call_phys_prelog();
<span class="p_add">+</span>
<span class="p_add">+	/* Disable interrupts around EFI calls: */</span>
<span class="p_add">+	local_irq_save(flags);</span>
 	status = efi_call_phys(efi_phys.set_virtual_address_map,
 			       memory_map_size, descriptor_size,
 			       descriptor_version, virtual_map);
<span class="p_add">+	local_irq_restore(flags);</span>
<span class="p_add">+</span>
 	efi_call_phys_epilog();
<span class="p_add">+</span>
 	return status;
 }
 
<span class="p_header">diff --git a/arch/x86/platform/efi/efi_32.c b/arch/x86/platform/efi/efi_32.c</span>
<span class="p_header">index 9ee3491e31fb..be4e7eb41674 100644</span>
<span class="p_header">--- a/arch/x86/platform/efi/efi_32.c</span>
<span class="p_header">+++ b/arch/x86/platform/efi/efi_32.c</span>
<span class="p_chunk">@@ -33,11 +33,10 @@</span> <span class="p_context"></span>
 
 /*
  * To make EFI call EFI runtime service in physical addressing mode we need
<span class="p_del">- * prelog/epilog before/after the invocation to disable interrupt, to</span>
<span class="p_del">- * claim EFI runtime service handler exclusively and to duplicate a memory in</span>
<span class="p_del">- * low memory space say 0 - 3G.</span>
<span class="p_add">+ * prolog/epilog before/after the invocation to claim the EFI runtime service</span>
<span class="p_add">+ * handler exclusively and to duplicate a memory mapping in low memory space,</span>
<span class="p_add">+ * say 0 - 3G.</span>
  */
<span class="p_del">-static unsigned long efi_rt_eflags;</span>
 
 void efi_sync_low_kernel_mappings(void) {}
 void __init efi_dump_pagetable(void) {}
<span class="p_chunk">@@ -59,8 +58,6 @@</span> <span class="p_context"> void efi_call_phys_prelog(void)</span>
 {
 	struct desc_ptr gdt_descr;
 
<span class="p_del">-	local_irq_save(efi_rt_eflags);</span>
<span class="p_del">-</span>
 	load_cr3(initial_page_table);
 	__flush_tlb_all();
 
<span class="p_chunk">@@ -79,8 +76,6 @@</span> <span class="p_context"> void efi_call_phys_epilog(void)</span>
 
 	load_cr3(swapper_pg_dir);
 	__flush_tlb_all();
<span class="p_del">-</span>
<span class="p_del">-	local_irq_restore(efi_rt_eflags);</span>
 }
 
 void __init efi_runtime_mkexec(void)
<span class="p_header">diff --git a/arch/x86/platform/efi/efi_64.c b/arch/x86/platform/efi/efi_64.c</span>
<span class="p_header">index 290d397e1dd9..8139b4858403 100644</span>
<span class="p_header">--- a/arch/x86/platform/efi/efi_64.c</span>
<span class="p_header">+++ b/arch/x86/platform/efi/efi_64.c</span>
<span class="p_chunk">@@ -42,7 +42,6 @@</span> <span class="p_context"></span>
 #include &lt;asm/time.h&gt;
 
 static pgd_t *save_pgd __initdata;
<span class="p_del">-static unsigned long efi_flags __initdata;</span>
 
 /*
  * We allocate runtime services regions bottom-up, starting from -4G, i.e.
<span class="p_chunk">@@ -89,7 +88,6 @@</span> <span class="p_context"> void __init efi_call_phys_prelog(void)</span>
 		return;
 
 	early_code_mapping_set_exec(1);
<span class="p_del">-	local_irq_save(efi_flags);</span>
 
 	n_pgds = DIV_ROUND_UP((max_pfn &lt;&lt; PAGE_SHIFT), PGDIR_SIZE);
 	save_pgd = kmalloc(n_pgds * sizeof(pgd_t), GFP_KERNEL);
<span class="p_chunk">@@ -117,7 +115,6 @@</span> <span class="p_context"> void __init efi_call_phys_epilog(void)</span>
 		set_pgd(pgd_offset_k(pgd * PGDIR_SIZE), save_pgd[pgd]);
 	kfree(save_pgd);
 	__flush_tlb_all();
<span class="p_del">-	local_irq_restore(efi_flags);</span>
 	early_code_mapping_set_exec(0);
 }
 
<span class="p_header">diff --git a/block/blk-core.c b/block/blk-core.c</span>
<span class="p_header">index 72a4cdaa083c..0b4831a556fc 100644</span>
<span class="p_header">--- a/block/blk-core.c</span>
<span class="p_header">+++ b/block/blk-core.c</span>
<span class="p_chunk">@@ -3214,6 +3214,9 @@</span> <span class="p_context"> int blk_pre_runtime_suspend(struct request_queue *q)</span>
 {
 	int ret = 0;
 
<span class="p_add">+	if (!q-&gt;dev)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
 	spin_lock_irq(q-&gt;queue_lock);
 	if (q-&gt;nr_pending) {
 		ret = -EBUSY;
<span class="p_chunk">@@ -3241,6 +3244,9 @@</span> <span class="p_context"> EXPORT_SYMBOL(blk_pre_runtime_suspend);</span>
  */
 void blk_post_runtime_suspend(struct request_queue *q, int err)
 {
<span class="p_add">+	if (!q-&gt;dev)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	spin_lock_irq(q-&gt;queue_lock);
 	if (!err) {
 		q-&gt;rpm_status = RPM_SUSPENDED;
<span class="p_chunk">@@ -3265,6 +3271,9 @@</span> <span class="p_context"> EXPORT_SYMBOL(blk_post_runtime_suspend);</span>
  */
 void blk_pre_runtime_resume(struct request_queue *q)
 {
<span class="p_add">+	if (!q-&gt;dev)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	spin_lock_irq(q-&gt;queue_lock);
 	q-&gt;rpm_status = RPM_RESUMING;
 	spin_unlock_irq(q-&gt;queue_lock);
<span class="p_chunk">@@ -3287,6 +3296,9 @@</span> <span class="p_context"> EXPORT_SYMBOL(blk_pre_runtime_resume);</span>
  */
 void blk_post_runtime_resume(struct request_queue *q, int err)
 {
<span class="p_add">+	if (!q-&gt;dev)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	spin_lock_irq(q-&gt;queue_lock);
 	if (!err) {
 		q-&gt;rpm_status = RPM_ACTIVE;
<span class="p_header">diff --git a/crypto/ablkcipher.c b/crypto/ablkcipher.c</span>
<span class="p_header">index 520729d898fe..f02fdbefb2c6 100644</span>
<span class="p_header">--- a/crypto/ablkcipher.c</span>
<span class="p_header">+++ b/crypto/ablkcipher.c</span>
<span class="p_chunk">@@ -276,12 +276,12 @@</span> <span class="p_context"> static int ablkcipher_walk_first(struct ablkcipher_request *req,</span>
 	if (WARN_ON_ONCE(in_irq()))
 		return -EDEADLK;
 
<span class="p_add">+	walk-&gt;iv = req-&gt;info;</span>
 	walk-&gt;nbytes = walk-&gt;total;
 	if (unlikely(!walk-&gt;total))
 		return 0;
 
 	walk-&gt;iv_buffer = NULL;
<span class="p_del">-	walk-&gt;iv = req-&gt;info;</span>
 	if (unlikely(((unsigned long)walk-&gt;iv &amp; alignmask))) {
 		int err = ablkcipher_copy_iv(walk, tfm, alignmask);
 		if (err)
<span class="p_header">diff --git a/crypto/async_tx/async_memcpy.c b/crypto/async_tx/async_memcpy.c</span>
<span class="p_header">index f8c0b8dbeb75..88bc8e6b2a54 100644</span>
<span class="p_header">--- a/crypto/async_tx/async_memcpy.c</span>
<span class="p_header">+++ b/crypto/async_tx/async_memcpy.c</span>
<span class="p_chunk">@@ -53,7 +53,7 @@</span> <span class="p_context"> async_memcpy(struct page *dest, struct page *src, unsigned int dest_offset,</span>
 	struct dmaengine_unmap_data *unmap = NULL;
 
 	if (device)
<span class="p_del">-		unmap = dmaengine_get_unmap_data(device-&gt;dev, 2, GFP_NOIO);</span>
<span class="p_add">+		unmap = dmaengine_get_unmap_data(device-&gt;dev, 2, GFP_NOWAIT);</span>
 
 	if (unmap &amp;&amp; is_dma_copy_aligned(device, src_offset, dest_offset, len)) {
 		unsigned long dma_prep_flags = 0;
<span class="p_header">diff --git a/crypto/async_tx/async_pq.c b/crypto/async_tx/async_pq.c</span>
<span class="p_header">index d05327caf69d..7eb264e65267 100644</span>
<span class="p_header">--- a/crypto/async_tx/async_pq.c</span>
<span class="p_header">+++ b/crypto/async_tx/async_pq.c</span>
<span class="p_chunk">@@ -176,7 +176,7 @@</span> <span class="p_context"> async_gen_syndrome(struct page **blocks, unsigned int offset, int disks,</span>
 	BUG_ON(disks &gt; 255 || !(P(blocks, disks) || Q(blocks, disks)));
 
 	if (device)
<span class="p_del">-		unmap = dmaengine_get_unmap_data(device-&gt;dev, disks, GFP_NOIO);</span>
<span class="p_add">+		unmap = dmaengine_get_unmap_data(device-&gt;dev, disks, GFP_NOWAIT);</span>
 
 	if (unmap &amp;&amp;
 	    (src_cnt &lt;= dma_maxpq(device, 0) ||
<span class="p_chunk">@@ -294,7 +294,7 @@</span> <span class="p_context"> async_syndrome_val(struct page **blocks, unsigned int offset, int disks,</span>
 	BUG_ON(disks &lt; 4);
 
 	if (device)
<span class="p_del">-		unmap = dmaengine_get_unmap_data(device-&gt;dev, disks, GFP_NOIO);</span>
<span class="p_add">+		unmap = dmaengine_get_unmap_data(device-&gt;dev, disks, GFP_NOWAIT);</span>
 
 	if (unmap &amp;&amp; disks &lt;= dma_maxpq(device, 0) &amp;&amp;
 	    is_dma_pq_aligned(device, offset, 0, len)) {
<span class="p_header">diff --git a/crypto/async_tx/async_raid6_recov.c b/crypto/async_tx/async_raid6_recov.c</span>
<span class="p_header">index 934a84981495..8fab6275ea1f 100644</span>
<span class="p_header">--- a/crypto/async_tx/async_raid6_recov.c</span>
<span class="p_header">+++ b/crypto/async_tx/async_raid6_recov.c</span>
<span class="p_chunk">@@ -41,7 +41,7 @@</span> <span class="p_context"> async_sum_product(struct page *dest, struct page **srcs, unsigned char *coef,</span>
 	u8 *a, *b, *c;
 
 	if (dma)
<span class="p_del">-		unmap = dmaengine_get_unmap_data(dma-&gt;dev, 3, GFP_NOIO);</span>
<span class="p_add">+		unmap = dmaengine_get_unmap_data(dma-&gt;dev, 3, GFP_NOWAIT);</span>
 
 	if (unmap) {
 		struct device *dev = dma-&gt;dev;
<span class="p_chunk">@@ -105,7 +105,7 @@</span> <span class="p_context"> async_mult(struct page *dest, struct page *src, u8 coef, size_t len,</span>
 	u8 *d, *s;
 
 	if (dma)
<span class="p_del">-		unmap = dmaengine_get_unmap_data(dma-&gt;dev, 3, GFP_NOIO);</span>
<span class="p_add">+		unmap = dmaengine_get_unmap_data(dma-&gt;dev, 3, GFP_NOWAIT);</span>
 
 	if (unmap) {
 		dma_addr_t dma_dest[2];
<span class="p_header">diff --git a/crypto/async_tx/async_xor.c b/crypto/async_tx/async_xor.c</span>
<span class="p_header">index e1bce26cd4f9..da75777f2b3f 100644</span>
<span class="p_header">--- a/crypto/async_tx/async_xor.c</span>
<span class="p_header">+++ b/crypto/async_tx/async_xor.c</span>
<span class="p_chunk">@@ -182,7 +182,7 @@</span> <span class="p_context"> async_xor(struct page *dest, struct page **src_list, unsigned int offset,</span>
 	BUG_ON(src_cnt &lt;= 1);
 
 	if (device)
<span class="p_del">-		unmap = dmaengine_get_unmap_data(device-&gt;dev, src_cnt+1, GFP_NOIO);</span>
<span class="p_add">+		unmap = dmaengine_get_unmap_data(device-&gt;dev, src_cnt+1, GFP_NOWAIT);</span>
 
 	if (unmap &amp;&amp; is_dma_xor_aligned(device, offset, 0, len)) {
 		struct dma_async_tx_descriptor *tx;
<span class="p_chunk">@@ -278,7 +278,7 @@</span> <span class="p_context"> async_xor_val(struct page *dest, struct page **src_list, unsigned int offset,</span>
 	BUG_ON(src_cnt &lt;= 1);
 
 	if (device)
<span class="p_del">-		unmap = dmaengine_get_unmap_data(device-&gt;dev, src_cnt, GFP_NOIO);</span>
<span class="p_add">+		unmap = dmaengine_get_unmap_data(device-&gt;dev, src_cnt, GFP_NOWAIT);</span>
 
 	if (unmap &amp;&amp; src_cnt &lt;= device-&gt;max_xor &amp;&amp;
 	    is_dma_xor_aligned(device, offset, 0, len)) {
<span class="p_header">diff --git a/crypto/blkcipher.c b/crypto/blkcipher.c</span>
<span class="p_header">index 0122bec38564..7180cb2fe026 100644</span>
<span class="p_header">--- a/crypto/blkcipher.c</span>
<span class="p_header">+++ b/crypto/blkcipher.c</span>
<span class="p_chunk">@@ -325,12 +325,12 @@</span> <span class="p_context"> static int blkcipher_walk_first(struct blkcipher_desc *desc,</span>
 	if (WARN_ON_ONCE(in_irq()))
 		return -EDEADLK;
 
<span class="p_add">+	walk-&gt;iv = desc-&gt;info;</span>
 	walk-&gt;nbytes = walk-&gt;total;
 	if (unlikely(!walk-&gt;total))
 		return 0;
 
 	walk-&gt;buffer = NULL;
<span class="p_del">-	walk-&gt;iv = desc-&gt;info;</span>
 	if (unlikely(((unsigned long)walk-&gt;iv &amp; walk-&gt;alignmask))) {
 		int err = blkcipher_copy_iv(walk);
 		if (err)
<span class="p_header">diff --git a/drivers/ata/libahci.c b/drivers/ata/libahci.c</span>
<span class="p_header">index 86c3c24b835f..a0bfdcfafd92 100644</span>
<span class="p_header">--- a/drivers/ata/libahci.c</span>
<span class="p_header">+++ b/drivers/ata/libahci.c</span>
<span class="p_chunk">@@ -1271,6 +1271,15 @@</span> <span class="p_context"> static int ahci_exec_polled_cmd(struct ata_port *ap, int pmp,</span>
 	ata_tf_to_fis(tf, pmp, is_cmd, fis);
 	ahci_fill_cmd_slot(pp, 0, cmd_fis_len | flags | (pmp &lt;&lt; 12));
 
<span class="p_add">+	/* set port value for softreset of Port Multiplier */</span>
<span class="p_add">+	if (pp-&gt;fbs_enabled &amp;&amp; pp-&gt;fbs_last_dev != pmp) {</span>
<span class="p_add">+		tmp = readl(port_mmio + PORT_FBS);</span>
<span class="p_add">+		tmp &amp;= ~(PORT_FBS_DEV_MASK | PORT_FBS_DEC);</span>
<span class="p_add">+		tmp |= pmp &lt;&lt; PORT_FBS_DEV_OFFSET;</span>
<span class="p_add">+		writel(tmp, port_mmio + PORT_FBS);</span>
<span class="p_add">+		pp-&gt;fbs_last_dev = pmp;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* issue &amp; wait */
 	writel(1, port_mmio + PORT_CMD_ISSUE);
 
<span class="p_header">diff --git a/drivers/ata/sata_sil.c b/drivers/ata/sata_sil.c</span>
<span class="p_header">index 40b76b2d18c6..1fd6873d28c3 100644</span>
<span class="p_header">--- a/drivers/ata/sata_sil.c</span>
<span class="p_header">+++ b/drivers/ata/sata_sil.c</span>
<span class="p_chunk">@@ -630,6 +630,9 @@</span> <span class="p_context"> static void sil_dev_config(struct ata_device *dev)</span>
 	unsigned int n, quirks = 0;
 	unsigned char model_num[ATA_ID_PROD_LEN + 1];
 
<span class="p_add">+	/* This controller doesn&#39;t support trim */</span>
<span class="p_add">+	dev-&gt;horkage |= ATA_HORKAGE_NOTRIM;</span>
<span class="p_add">+</span>
 	ata_id_c_string(dev-&gt;id, model_num, ATA_ID_PROD, sizeof(model_num));
 
 	for (n = 0; sil_blacklist[n].product; n++)
<span class="p_header">diff --git a/drivers/base/memory.c b/drivers/base/memory.c</span>
<span class="p_header">index 89f752dd8465..0b5c02ab1ef0 100644</span>
<span class="p_header">--- a/drivers/base/memory.c</span>
<span class="p_header">+++ b/drivers/base/memory.c</span>
<span class="p_chunk">@@ -301,6 +301,10 @@</span> <span class="p_context"> static int memory_subsys_offline(struct device *dev)</span>
 	if (mem-&gt;state == MEM_OFFLINE)
 		return 0;
 
<span class="p_add">+	/* Can&#39;t offline block with non-present sections */</span>
<span class="p_add">+	if (mem-&gt;section_count != sections_per_block)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	return memory_block_change_state(mem, MEM_OFFLINE, MEM_ONLINE);
 }
 
<span class="p_header">diff --git a/drivers/block/xen-blkback/blkback.c b/drivers/block/xen-blkback/blkback.c</span>
<span class="p_header">index 02004e101678..c42c22e778d8 100644</span>
<span class="p_header">--- a/drivers/block/xen-blkback/blkback.c</span>
<span class="p_header">+++ b/drivers/block/xen-blkback/blkback.c</span>
<span class="p_chunk">@@ -861,6 +861,8 @@</span> <span class="p_context"> static int xen_blkbk_parse_indirect(struct blkif_request *req,</span>
 		goto unmap;
 
 	for (n = 0, i = 0; n &lt; nseg; n++) {
<span class="p_add">+		uint8_t first_sect, last_sect;</span>
<span class="p_add">+</span>
 		if ((n % SEGS_PER_INDIRECT_FRAME) == 0) {
 			/* Map indirect segments */
 			if (segments)
<span class="p_chunk">@@ -868,15 +870,18 @@</span> <span class="p_context"> static int xen_blkbk_parse_indirect(struct blkif_request *req,</span>
 			segments = kmap_atomic(pages[n/SEGS_PER_INDIRECT_FRAME]-&gt;page);
 		}
 		i = n % SEGS_PER_INDIRECT_FRAME;
<span class="p_add">+</span>
 		pending_req-&gt;segments[n]-&gt;gref = segments[i].gref;
<span class="p_del">-		seg[n].nsec = segments[i].last_sect -</span>
<span class="p_del">-			segments[i].first_sect + 1;</span>
<span class="p_del">-		seg[n].offset = (segments[i].first_sect &lt;&lt; 9);</span>
<span class="p_del">-		if ((segments[i].last_sect &gt;= (PAGE_SIZE &gt;&gt; 9)) ||</span>
<span class="p_del">-		    (segments[i].last_sect &lt; segments[i].first_sect)) {</span>
<span class="p_add">+</span>
<span class="p_add">+		first_sect = ACCESS_ONCE(segments[i].first_sect);</span>
<span class="p_add">+		last_sect = ACCESS_ONCE(segments[i].last_sect);</span>
<span class="p_add">+		if (last_sect &gt;= (PAGE_SIZE &gt;&gt; 9) || last_sect &lt; first_sect) {</span>
 			rc = -EINVAL;
 			goto unmap;
 		}
<span class="p_add">+</span>
<span class="p_add">+		seg[n].nsec = last_sect - first_sect + 1;</span>
<span class="p_add">+		seg[n].offset = first_sect &lt;&lt; 9;</span>
 		preq-&gt;nr_sects += seg[n].nsec;
 	}
 
<span class="p_header">diff --git a/drivers/block/xen-blkback/common.h b/drivers/block/xen-blkback/common.h</span>
<span class="p_header">index f65b807e3236..ef64f59921a7 100644</span>
<span class="p_header">--- a/drivers/block/xen-blkback/common.h</span>
<span class="p_header">+++ b/drivers/block/xen-blkback/common.h</span>
<span class="p_chunk">@@ -391,8 +391,8 @@</span> <span class="p_context"> static inline void blkif_get_x86_32_req(struct blkif_request *dst,</span>
 					struct blkif_x86_32_request *src)
 {
 	int i, n = BLKIF_MAX_SEGMENTS_PER_REQUEST, j;
<span class="p_del">-	dst-&gt;operation = src-&gt;operation;</span>
<span class="p_del">-	switch (src-&gt;operation) {</span>
<span class="p_add">+	dst-&gt;operation = ACCESS_ONCE(src-&gt;operation);</span>
<span class="p_add">+	switch (dst-&gt;operation) {</span>
 	case BLKIF_OP_READ:
 	case BLKIF_OP_WRITE:
 	case BLKIF_OP_WRITE_BARRIER:
<span class="p_chunk">@@ -439,8 +439,8 @@</span> <span class="p_context"> static inline void blkif_get_x86_64_req(struct blkif_request *dst,</span>
 					struct blkif_x86_64_request *src)
 {
 	int i, n = BLKIF_MAX_SEGMENTS_PER_REQUEST, j;
<span class="p_del">-	dst-&gt;operation = src-&gt;operation;</span>
<span class="p_del">-	switch (src-&gt;operation) {</span>
<span class="p_add">+	dst-&gt;operation = ACCESS_ONCE(src-&gt;operation);</span>
<span class="p_add">+	switch (dst-&gt;operation) {</span>
 	case BLKIF_OP_READ:
 	case BLKIF_OP_WRITE:
 	case BLKIF_OP_WRITE_BARRIER:
<span class="p_header">diff --git a/drivers/char/ipmi/ipmi_si_intf.c b/drivers/char/ipmi/ipmi_si_intf.c</span>
<span class="p_header">index 5d665680ae33..d89137a0224f 100644</span>
<span class="p_header">--- a/drivers/char/ipmi/ipmi_si_intf.c</span>
<span class="p_header">+++ b/drivers/char/ipmi/ipmi_si_intf.c</span>
<span class="p_chunk">@@ -1176,14 +1176,14 @@</span> <span class="p_context"> static int smi_start_processing(void       *send_info,</span>
 
 	new_smi-&gt;intf = intf;
 
<span class="p_del">-	/* Try to claim any interrupts. */</span>
<span class="p_del">-	if (new_smi-&gt;irq_setup)</span>
<span class="p_del">-		new_smi-&gt;irq_setup(new_smi);</span>
<span class="p_del">-</span>
 	/* Set up the timer that drives the interface. */
 	setup_timer(&amp;new_smi-&gt;si_timer, smi_timeout, (long)new_smi);
 	smi_mod_timer(new_smi, jiffies + SI_TIMEOUT_JIFFIES);
 
<span class="p_add">+	/* Try to claim any interrupts. */</span>
<span class="p_add">+	if (new_smi-&gt;irq_setup)</span>
<span class="p_add">+		new_smi-&gt;irq_setup(new_smi);</span>
<span class="p_add">+</span>
 	/*
 	 * Check if the user forcefully enabled the daemon.
 	 */
<span class="p_header">diff --git a/drivers/firmware/dmi_scan.c b/drivers/firmware/dmi_scan.c</span>
<span class="p_header">index 35286fe52823..48142b88e672 100644</span>
<span class="p_header">--- a/drivers/firmware/dmi_scan.c</span>
<span class="p_header">+++ b/drivers/firmware/dmi_scan.c</span>
<span class="p_chunk">@@ -493,6 +493,7 @@</span> <span class="p_context"> static int __init dmi_present(const u8 *buf)</span>
 			dmi_ver = smbios_ver;
 		else
 			dmi_ver = (buf[14] &amp; 0xF0) &lt;&lt; 4 | (buf[14] &amp; 0x0F);
<span class="p_add">+		dmi_ver &lt;&lt;= 8;</span>
 		dmi_num = (buf[13] &lt;&lt; 8) | buf[12];
 		dmi_len = (buf[7] &lt;&lt; 8) | buf[6];
 		dmi_base = (buf[11] &lt;&lt; 24) | (buf[10] &lt;&lt; 16) |
<span class="p_chunk">@@ -501,10 +502,10 @@</span> <span class="p_context"> static int __init dmi_present(const u8 *buf)</span>
 		if (dmi_walk_early(dmi_decode) == 0) {
 			if (smbios_ver) {
 				pr_info(&quot;SMBIOS %d.%d present.\n&quot;,
<span class="p_del">-				       dmi_ver &gt;&gt; 8, dmi_ver &amp; 0xFF);</span>
<span class="p_add">+					dmi_ver &gt;&gt; 16, (dmi_ver &gt;&gt; 8) &amp; 0xFF);</span>
 			} else {
 				pr_info(&quot;Legacy DMI %d.%d present.\n&quot;,
<span class="p_del">-				       dmi_ver &gt;&gt; 8, dmi_ver &amp; 0xFF);</span>
<span class="p_add">+					dmi_ver &gt;&gt; 16, (dmi_ver &gt;&gt; 8) &amp; 0xFF);</span>
 			}
 			dmi_format_ids(dmi_ids_string, sizeof(dmi_ids_string));
 			printk(KERN_DEBUG &quot;DMI: %s\n&quot;, dmi_ids_string);
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_ringbuffer.c b/drivers/gpu/drm/i915/intel_ringbuffer.c</span>
<span class="p_header">index 6a7a35acdfa7..b849fde1ea74 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_ringbuffer.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_ringbuffer.c</span>
<span class="p_chunk">@@ -1284,7 +1284,7 @@</span> <span class="p_context"> i830_dispatch_execbuffer(struct intel_engine_cs *ring,</span>
 		 */
 		intel_ring_emit(ring, SRC_COPY_BLT_CMD | BLT_WRITE_RGBA);
 		intel_ring_emit(ring, BLT_DEPTH_32 | BLT_ROP_SRC_COPY | 4096);
<span class="p_del">-		intel_ring_emit(ring, DIV_ROUND_UP(len, 4096) &lt;&lt; 16 | 1024);</span>
<span class="p_add">+		intel_ring_emit(ring, DIV_ROUND_UP(len, 4096) &lt;&lt; 16 | 4096);</span>
 		intel_ring_emit(ring, cs_offset);
 		intel_ring_emit(ring, 4096);
 		intel_ring_emit(ring, offset);
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/cik.c b/drivers/gpu/drm/radeon/cik.c</span>
<span class="p_header">index 19c9925b17ed..4db031e92628 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/cik.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/cik.c</span>
<span class="p_chunk">@@ -3854,11 +3854,7 @@</span> <span class="p_context"> void cik_ring_ib_execute(struct radeon_device *rdev, struct radeon_ib *ib)</span>
 		(ib-&gt;vm ? (ib-&gt;vm-&gt;id &lt;&lt; 24) : 0);
 
 	radeon_ring_write(ring, header);
<span class="p_del">-	radeon_ring_write(ring,</span>
<span class="p_del">-#ifdef __BIG_ENDIAN</span>
<span class="p_del">-			  (2 &lt;&lt; 0) |</span>
<span class="p_del">-#endif</span>
<span class="p_del">-			  (ib-&gt;gpu_addr &amp; 0xFFFFFFFC));</span>
<span class="p_add">+	radeon_ring_write(ring, (ib-&gt;gpu_addr &amp; 0xFFFFFFFC));</span>
 	radeon_ring_write(ring, upper_32_bits(ib-&gt;gpu_addr) &amp; 0xFFFF);
 	radeon_ring_write(ring, control);
 }
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_vce.c b/drivers/gpu/drm/radeon/radeon_vce.c</span>
<span class="p_header">index 2944637b8b44..1405251af5fb 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_vce.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_vce.c</span>
<span class="p_chunk">@@ -342,31 +342,31 @@</span> <span class="p_context"> int radeon_vce_get_create_msg(struct radeon_device *rdev, int ring,</span>
 
 	/* stitch together an VCE create msg */
 	ib.length_dw = 0;
<span class="p_del">-	ib.ptr[ib.length_dw++] = 0x0000000c; /* len */</span>
<span class="p_del">-	ib.ptr[ib.length_dw++] = 0x00000001; /* session cmd */</span>
<span class="p_del">-	ib.ptr[ib.length_dw++] = handle;</span>
<span class="p_del">-</span>
<span class="p_del">-	ib.ptr[ib.length_dw++] = 0x00000030; /* len */</span>
<span class="p_del">-	ib.ptr[ib.length_dw++] = 0x01000001; /* create cmd */</span>
<span class="p_del">-	ib.ptr[ib.length_dw++] = 0x00000000;</span>
<span class="p_del">-	ib.ptr[ib.length_dw++] = 0x00000042;</span>
<span class="p_del">-	ib.ptr[ib.length_dw++] = 0x0000000a;</span>
<span class="p_del">-	ib.ptr[ib.length_dw++] = 0x00000001;</span>
<span class="p_del">-	ib.ptr[ib.length_dw++] = 0x00000080;</span>
<span class="p_del">-	ib.ptr[ib.length_dw++] = 0x00000060;</span>
<span class="p_del">-	ib.ptr[ib.length_dw++] = 0x00000100;</span>
<span class="p_del">-	ib.ptr[ib.length_dw++] = 0x00000100;</span>
<span class="p_del">-	ib.ptr[ib.length_dw++] = 0x0000000c;</span>
<span class="p_del">-	ib.ptr[ib.length_dw++] = 0x00000000;</span>
<span class="p_del">-</span>
<span class="p_del">-	ib.ptr[ib.length_dw++] = 0x00000014; /* len */</span>
<span class="p_del">-	ib.ptr[ib.length_dw++] = 0x05000005; /* feedback buffer */</span>
<span class="p_del">-	ib.ptr[ib.length_dw++] = upper_32_bits(dummy);</span>
<span class="p_del">-	ib.ptr[ib.length_dw++] = dummy;</span>
<span class="p_del">-	ib.ptr[ib.length_dw++] = 0x00000001;</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(0x0000000c); /* len */</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(0x00000001); /* session cmd */</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(handle);</span>
<span class="p_add">+</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(0x00000030); /* len */</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(0x01000001); /* create cmd */</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(0x00000000);</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(0x00000042);</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(0x0000000a);</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(0x00000001);</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(0x00000080);</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(0x00000060);</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(0x00000100);</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(0x00000100);</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(0x0000000c);</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(0x00000000);</span>
<span class="p_add">+</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(0x00000014); /* len */</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(0x05000005); /* feedback buffer */</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(upper_32_bits(dummy));</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(dummy);</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(0x00000001);</span>
 
 	for (i = ib.length_dw; i &lt; ib_size_dw; ++i)
<span class="p_del">-		ib.ptr[i] = 0x0;</span>
<span class="p_add">+		ib.ptr[i] = cpu_to_le32(0x0);</span>
 
 	r = radeon_ib_schedule(rdev, &amp;ib, NULL);
 	if (r) {
<span class="p_chunk">@@ -409,21 +409,21 @@</span> <span class="p_context"> int radeon_vce_get_destroy_msg(struct radeon_device *rdev, int ring,</span>
 
 	/* stitch together an VCE destroy msg */
 	ib.length_dw = 0;
<span class="p_del">-	ib.ptr[ib.length_dw++] = 0x0000000c; /* len */</span>
<span class="p_del">-	ib.ptr[ib.length_dw++] = 0x00000001; /* session cmd */</span>
<span class="p_del">-	ib.ptr[ib.length_dw++] = handle;</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(0x0000000c); /* len */</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(0x00000001); /* session cmd */</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(handle);</span>
 
<span class="p_del">-	ib.ptr[ib.length_dw++] = 0x00000014; /* len */</span>
<span class="p_del">-	ib.ptr[ib.length_dw++] = 0x05000005; /* feedback buffer */</span>
<span class="p_del">-	ib.ptr[ib.length_dw++] = upper_32_bits(dummy);</span>
<span class="p_del">-	ib.ptr[ib.length_dw++] = dummy;</span>
<span class="p_del">-	ib.ptr[ib.length_dw++] = 0x00000001;</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(0x00000014); /* len */</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(0x05000005); /* feedback buffer */</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(upper_32_bits(dummy));</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(dummy);</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(0x00000001);</span>
 
<span class="p_del">-	ib.ptr[ib.length_dw++] = 0x00000008; /* len */</span>
<span class="p_del">-	ib.ptr[ib.length_dw++] = 0x02000001; /* destroy cmd */</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(0x00000008); /* len */</span>
<span class="p_add">+	ib.ptr[ib.length_dw++] = cpu_to_le32(0x02000001); /* destroy cmd */</span>
 
 	for (i = ib.length_dw; i &lt; ib_size_dw; ++i)
<span class="p_del">-		ib.ptr[i] = 0x0;</span>
<span class="p_add">+		ib.ptr[i] = cpu_to_le32(0x0);</span>
 
 	r = radeon_ib_schedule(rdev, &amp;ib, NULL);
 	if (r) {
<span class="p_chunk">@@ -679,12 +679,12 @@</span> <span class="p_context"> bool radeon_vce_semaphore_emit(struct radeon_device *rdev,</span>
 {
 	uint64_t addr = semaphore-&gt;gpu_addr;
 
<span class="p_del">-	radeon_ring_write(ring, VCE_CMD_SEMAPHORE);</span>
<span class="p_del">-	radeon_ring_write(ring, (addr &gt;&gt; 3) &amp; 0x000FFFFF);</span>
<span class="p_del">-	radeon_ring_write(ring, (addr &gt;&gt; 23) &amp; 0x000FFFFF);</span>
<span class="p_del">-	radeon_ring_write(ring, 0x01003000 | (emit_wait ? 1 : 0));</span>
<span class="p_add">+	radeon_ring_write(ring, cpu_to_le32(VCE_CMD_SEMAPHORE));</span>
<span class="p_add">+	radeon_ring_write(ring, cpu_to_le32((addr &gt;&gt; 3) &amp; 0x000FFFFF));</span>
<span class="p_add">+	radeon_ring_write(ring, cpu_to_le32((addr &gt;&gt; 23) &amp; 0x000FFFFF));</span>
<span class="p_add">+	radeon_ring_write(ring, cpu_to_le32(0x01003000 | (emit_wait ? 1 : 0)));</span>
 	if (!emit_wait)
<span class="p_del">-		radeon_ring_write(ring, VCE_CMD_END);</span>
<span class="p_add">+		radeon_ring_write(ring, cpu_to_le32(VCE_CMD_END));</span>
 
 	return true;
 }
<span class="p_chunk">@@ -699,10 +699,10 @@</span> <span class="p_context"> bool radeon_vce_semaphore_emit(struct radeon_device *rdev,</span>
 void radeon_vce_ib_execute(struct radeon_device *rdev, struct radeon_ib *ib)
 {
 	struct radeon_ring *ring = &amp;rdev-&gt;ring[ib-&gt;ring];
<span class="p_del">-	radeon_ring_write(ring, VCE_CMD_IB);</span>
<span class="p_del">-	radeon_ring_write(ring, ib-&gt;gpu_addr);</span>
<span class="p_del">-	radeon_ring_write(ring, upper_32_bits(ib-&gt;gpu_addr));</span>
<span class="p_del">-	radeon_ring_write(ring, ib-&gt;length_dw);</span>
<span class="p_add">+	radeon_ring_write(ring, cpu_to_le32(VCE_CMD_IB));</span>
<span class="p_add">+	radeon_ring_write(ring, cpu_to_le32(ib-&gt;gpu_addr));</span>
<span class="p_add">+	radeon_ring_write(ring, cpu_to_le32(upper_32_bits(ib-&gt;gpu_addr)));</span>
<span class="p_add">+	radeon_ring_write(ring, cpu_to_le32(ib-&gt;length_dw));</span>
 }
 
 /**
<span class="p_chunk">@@ -718,12 +718,12 @@</span> <span class="p_context"> void radeon_vce_fence_emit(struct radeon_device *rdev,</span>
 	struct radeon_ring *ring = &amp;rdev-&gt;ring[fence-&gt;ring];
 	uint64_t addr = rdev-&gt;fence_drv[fence-&gt;ring].gpu_addr;
 
<span class="p_del">-	radeon_ring_write(ring, VCE_CMD_FENCE);</span>
<span class="p_del">-	radeon_ring_write(ring, addr);</span>
<span class="p_del">-	radeon_ring_write(ring, upper_32_bits(addr));</span>
<span class="p_del">-	radeon_ring_write(ring, fence-&gt;seq);</span>
<span class="p_del">-	radeon_ring_write(ring, VCE_CMD_TRAP);</span>
<span class="p_del">-	radeon_ring_write(ring, VCE_CMD_END);</span>
<span class="p_add">+	radeon_ring_write(ring, cpu_to_le32(VCE_CMD_FENCE));</span>
<span class="p_add">+	radeon_ring_write(ring, cpu_to_le32(addr));</span>
<span class="p_add">+	radeon_ring_write(ring, cpu_to_le32(upper_32_bits(addr)));</span>
<span class="p_add">+	radeon_ring_write(ring, cpu_to_le32(fence-&gt;seq));</span>
<span class="p_add">+	radeon_ring_write(ring, cpu_to_le32(VCE_CMD_TRAP));</span>
<span class="p_add">+	radeon_ring_write(ring, cpu_to_le32(VCE_CMD_END));</span>
 }
 
 /**
<span class="p_chunk">@@ -745,7 +745,7 @@</span> <span class="p_context"> int radeon_vce_ring_test(struct radeon_device *rdev, struct radeon_ring *ring)</span>
 			  ring-&gt;idx, r);
 		return r;
 	}
<span class="p_del">-	radeon_ring_write(ring, VCE_CMD_END);</span>
<span class="p_add">+	radeon_ring_write(ring, cpu_to_le32(VCE_CMD_END));</span>
 	radeon_ring_unlock_commit(rdev, ring);
 
 	for (i = 0; i &lt; rdev-&gt;usec_timeout; i++) {
<span class="p_header">diff --git a/drivers/gpu/drm/ttm/ttm_lock.c b/drivers/gpu/drm/ttm/ttm_lock.c</span>
<span class="p_header">index 6a954544727f..f154fb1929bd 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/ttm/ttm_lock.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/ttm/ttm_lock.c</span>
<span class="p_chunk">@@ -180,7 +180,7 @@</span> <span class="p_context"> int ttm_write_lock(struct ttm_lock *lock, bool interruptible)</span>
 			spin_unlock(&amp;lock-&gt;lock);
 		}
 	} else
<span class="p_del">-		wait_event(lock-&gt;queue, __ttm_read_lock(lock));</span>
<span class="p_add">+		wait_event(lock-&gt;queue, __ttm_write_lock(lock));</span>
 
 	return ret;
 }
<span class="p_header">diff --git a/drivers/gpu/vga/vgaarb.c b/drivers/gpu/vga/vgaarb.c</span>
<span class="p_header">index 366641d0483f..5b9eccd3e9ff 100644</span>
<span class="p_header">--- a/drivers/gpu/vga/vgaarb.c</span>
<span class="p_header">+++ b/drivers/gpu/vga/vgaarb.c</span>
<span class="p_chunk">@@ -393,8 +393,10 @@</span> <span class="p_context"> int vga_get(struct pci_dev *pdev, unsigned int rsrc, int interruptible)</span>
 		set_current_state(interruptible ?
 				  TASK_INTERRUPTIBLE :
 				  TASK_UNINTERRUPTIBLE);
<span class="p_del">-		if (signal_pending(current)) {</span>
<span class="p_del">-			rc = -EINTR;</span>
<span class="p_add">+		if (interruptible &amp;&amp; signal_pending(current)) {</span>
<span class="p_add">+			__set_current_state(TASK_RUNNING);</span>
<span class="p_add">+			remove_wait_queue(&amp;vga_wait_queue, &amp;wait);</span>
<span class="p_add">+			rc = -ERESTARTSYS;</span>
 			break;
 		}
 		schedule();
<span class="p_header">diff --git a/drivers/i2c/busses/i2c-mv64xxx.c b/drivers/i2c/busses/i2c-mv64xxx.c</span>
<span class="p_header">index 8cc08d4f5f40..82e43656825a 100644</span>
<span class="p_header">--- a/drivers/i2c/busses/i2c-mv64xxx.c</span>
<span class="p_header">+++ b/drivers/i2c/busses/i2c-mv64xxx.c</span>
<span class="p_chunk">@@ -146,6 +146,8 @@</span> <span class="p_context"> struct mv64xxx_i2c_data {</span>
 	bool			errata_delay;
 	struct reset_control	*rstc;
 	bool			irq_clear_inverted;
<span class="p_add">+	/* Clk div is 2 to the power n, not 2 to the power n + 1 */</span>
<span class="p_add">+	bool			clk_n_base_0;</span>
 };
 
 static struct mv64xxx_i2c_regs mv64xxx_i2c_regs_mv64xxx = {
<span class="p_chunk">@@ -757,25 +759,29 @@</span> <span class="p_context"> MODULE_DEVICE_TABLE(of, mv64xxx_i2c_of_match_table);</span>
 #ifdef CONFIG_OF
 #ifdef CONFIG_HAVE_CLK
 static int
<span class="p_del">-mv64xxx_calc_freq(const int tclk, const int n, const int m)</span>
<span class="p_add">+mv64xxx_calc_freq(struct mv64xxx_i2c_data *drv_data,</span>
<span class="p_add">+		  const int tclk, const int n, const int m)</span>
 {
<span class="p_del">-	return tclk / (10 * (m + 1) * (2 &lt;&lt; n));</span>
<span class="p_add">+	if (drv_data-&gt;clk_n_base_0)</span>
<span class="p_add">+		return tclk / (10 * (m + 1) * (1 &lt;&lt; n));</span>
<span class="p_add">+	else</span>
<span class="p_add">+		return tclk / (10 * (m + 1) * (2 &lt;&lt; n));</span>
 }
 
 static bool
<span class="p_del">-mv64xxx_find_baud_factors(const u32 req_freq, const u32 tclk, u32 *best_n,</span>
<span class="p_del">-			  u32 *best_m)</span>
<span class="p_add">+mv64xxx_find_baud_factors(struct mv64xxx_i2c_data *drv_data,</span>
<span class="p_add">+			  const u32 req_freq, const u32 tclk)</span>
 {
 	int freq, delta, best_delta = INT_MAX;
 	int m, n;
 
 	for (n = 0; n &lt;= 7; n++)
 		for (m = 0; m &lt;= 15; m++) {
<span class="p_del">-			freq = mv64xxx_calc_freq(tclk, n, m);</span>
<span class="p_add">+			freq = mv64xxx_calc_freq(drv_data, tclk, n, m);</span>
 			delta = req_freq - freq;
 			if (delta &gt;= 0 &amp;&amp; delta &lt; best_delta) {
<span class="p_del">-				*best_m = m;</span>
<span class="p_del">-				*best_n = n;</span>
<span class="p_add">+				drv_data-&gt;freq_m = m;</span>
<span class="p_add">+				drv_data-&gt;freq_n = n;</span>
 				best_delta = delta;
 			}
 			if (best_delta == 0)
<span class="p_chunk">@@ -813,8 +819,11 @@</span> <span class="p_context"> mv64xxx_of_config(struct mv64xxx_i2c_data *drv_data,</span>
 	if (of_property_read_u32(np, &quot;clock-frequency&quot;, &amp;bus_freq))
 		bus_freq = 100000; /* 100kHz by default */
 
<span class="p_del">-	if (!mv64xxx_find_baud_factors(bus_freq, tclk,</span>
<span class="p_del">-				       &amp;drv_data-&gt;freq_n, &amp;drv_data-&gt;freq_m)) {</span>
<span class="p_add">+	if (of_device_is_compatible(np, &quot;allwinner,sun4i-a10-i2c&quot;) ||</span>
<span class="p_add">+	    of_device_is_compatible(np, &quot;allwinner,sun6i-a31-i2c&quot;))</span>
<span class="p_add">+		drv_data-&gt;clk_n_base_0 = true;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!mv64xxx_find_baud_factors(drv_data, bus_freq, tclk)) {</span>
 		rc = -EINVAL;
 		goto out;
 	}
<span class="p_header">diff --git a/drivers/iio/industrialio-buffer.c b/drivers/iio/industrialio-buffer.c</span>
<span class="p_header">index b8af417e7b93..d495b2e82810 100644</span>
<span class="p_header">--- a/drivers/iio/industrialio-buffer.c</span>
<span class="p_header">+++ b/drivers/iio/industrialio-buffer.c</span>
<span class="p_chunk">@@ -843,7 +843,7 @@</span> <span class="p_context"> int iio_scan_mask_set(struct iio_dev *indio_dev,</span>
 	if (trialmask == NULL)
 		return -ENOMEM;
 	if (!indio_dev-&gt;masklength) {
<span class="p_del">-		WARN_ON(&quot;Trying to set scanmask prior to registering buffer\n&quot;);</span>
<span class="p_add">+		WARN(1, &quot;Trying to set scanmask prior to registering buffer\n&quot;);</span>
 		goto err_invalid_mask;
 	}
 	bitmap_copy(trialmask, buffer-&gt;scan_mask, indio_dev-&gt;masklength);
<span class="p_header">diff --git a/drivers/iio/industrialio-core.c b/drivers/iio/industrialio-core.c</span>
<span class="p_header">index fa061972a2fe..7995c68c2a34 100644</span>
<span class="p_header">--- a/drivers/iio/industrialio-core.c</span>
<span class="p_header">+++ b/drivers/iio/industrialio-core.c</span>
<span class="p_chunk">@@ -612,7 +612,7 @@</span> <span class="p_context"> int __iio_device_attr_init(struct device_attribute *dev_attr,</span>
 			break;
 		case IIO_SEPARATE:
 			if (!chan-&gt;indexed) {
<span class="p_del">-				WARN_ON(&quot;Differential channels must be indexed\n&quot;);</span>
<span class="p_add">+				WARN(1, &quot;Differential channels must be indexed\n&quot;);</span>
 				ret = -EINVAL;
 				goto error_free_full_postfix;
 			}
<span class="p_header">diff --git a/drivers/infiniband/ulp/srp/ib_srp.c b/drivers/infiniband/ulp/srp/ib_srp.c</span>
<span class="p_header">index 767000811cf9..36876960f97e 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/srp/ib_srp.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/srp/ib_srp.c</span>
<span class="p_chunk">@@ -451,7 +451,7 @@</span> <span class="p_context"> static int srp_create_target_ib(struct srp_target_port *target)</span>
 	struct ib_qp *qp;
 	struct ib_fmr_pool *fmr_pool = NULL;
 	struct srp_fr_pool *fr_pool = NULL;
<span class="p_del">-	const int m = 1 + dev-&gt;use_fast_reg;</span>
<span class="p_add">+	const int m = dev-&gt;use_fast_reg ? 3 : 1;</span>
 	int ret;
 
 	init_attr = kzalloc(sizeof *init_attr, GFP_KERNEL);
<span class="p_header">diff --git a/drivers/irqchip/irq-versatile-fpga.c b/drivers/irqchip/irq-versatile-fpga.c</span>
<span class="p_header">index 3ae2bb8d9cf2..21a44b168d46 100644</span>
<span class="p_header">--- a/drivers/irqchip/irq-versatile-fpga.c</span>
<span class="p_header">+++ b/drivers/irqchip/irq-versatile-fpga.c</span>
<span class="p_chunk">@@ -204,7 +204,12 @@</span> <span class="p_context"> int __init fpga_irq_of_init(struct device_node *node,</span>
 	if (!parent_irq)
 		parent_irq = -1;
 
<span class="p_add">+#ifdef CONFIG_ARCH_VERSATILE</span>
<span class="p_add">+	fpga_irq_init(base, node-&gt;name, IRQ_SIC_START, parent_irq, valid_mask,</span>
<span class="p_add">+				  node);</span>
<span class="p_add">+#else</span>
 	fpga_irq_init(base, node-&gt;name, 0, parent_irq, valid_mask, node);
<span class="p_add">+#endif</span>
 
 	writel(clear_mask, base + IRQ_ENABLE_CLEAR);
 	writel(clear_mask, base + FIQ_ENABLE_CLEAR);
<span class="p_header">diff --git a/drivers/isdn/gigaset/ser-gigaset.c b/drivers/isdn/gigaset/ser-gigaset.c</span>
<span class="p_header">index 3ac9c4194814..0ebb52b0336d 100644</span>
<span class="p_header">--- a/drivers/isdn/gigaset/ser-gigaset.c</span>
<span class="p_header">+++ b/drivers/isdn/gigaset/ser-gigaset.c</span>
<span class="p_chunk">@@ -370,19 +370,23 @@</span> <span class="p_context"> static void gigaset_freecshw(struct cardstate *cs)</span>
 	tasklet_kill(&amp;cs-&gt;write_tasklet);
 	if (!cs-&gt;hw.ser)
 		return;
<span class="p_del">-	dev_set_drvdata(&amp;cs-&gt;hw.ser-&gt;dev.dev, NULL);</span>
 	platform_device_unregister(&amp;cs-&gt;hw.ser-&gt;dev);
<span class="p_del">-	kfree(cs-&gt;hw.ser);</span>
<span class="p_del">-	cs-&gt;hw.ser = NULL;</span>
 }
 
 static void gigaset_device_release(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
<span class="p_add">+	struct cardstate *cs = dev_get_drvdata(dev);</span>
 
 	/* adapted from platform_device_release() in drivers/base/platform.c */
 	kfree(dev-&gt;platform_data);
 	kfree(pdev-&gt;resource);
<span class="p_add">+</span>
<span class="p_add">+	if (!cs)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	dev_set_drvdata(dev, NULL);</span>
<span class="p_add">+	kfree(cs-&gt;hw.ser);</span>
<span class="p_add">+	cs-&gt;hw.ser = NULL;</span>
 }
 
 /*
<span class="p_header">diff --git a/drivers/isdn/hardware/mISDN/mISDNipac.c b/drivers/isdn/hardware/mISDN/mISDNipac.c</span>
<span class="p_header">index ccd7d851be26..92cf6fcd20ac 100644</span>
<span class="p_header">--- a/drivers/isdn/hardware/mISDN/mISDNipac.c</span>
<span class="p_header">+++ b/drivers/isdn/hardware/mISDN/mISDNipac.c</span>
<span class="p_chunk">@@ -1164,7 +1164,7 @@</span> <span class="p_context"> mISDNipac_irq(struct ipac_hw *ipac, int maxloop)</span>
 
 	if (ipac-&gt;type &amp; IPAC_TYPE_IPACX) {
 		ista = ReadIPAC(ipac, ISACX_ISTA);
<span class="p_del">-		while (ista &amp;&amp; cnt--) {</span>
<span class="p_add">+		while (ista &amp;&amp; --cnt) {</span>
 			pr_debug(&quot;%s: ISTA %02x\n&quot;, ipac-&gt;name, ista);
 			if (ista &amp; IPACX__ICA)
 				ipac_irq(&amp;ipac-&gt;hscx[0], ista);
<span class="p_chunk">@@ -1176,7 +1176,7 @@</span> <span class="p_context"> mISDNipac_irq(struct ipac_hw *ipac, int maxloop)</span>
 		}
 	} else if (ipac-&gt;type &amp; IPAC_TYPE_IPAC) {
 		ista = ReadIPAC(ipac, IPAC_ISTA);
<span class="p_del">-		while (ista &amp;&amp; cnt--) {</span>
<span class="p_add">+		while (ista &amp;&amp; --cnt) {</span>
 			pr_debug(&quot;%s: ISTA %02x\n&quot;, ipac-&gt;name, ista);
 			if (ista &amp; (IPAC__ICD | IPAC__EXD)) {
 				istad = ReadISAC(isac, ISAC_ISTA);
<span class="p_chunk">@@ -1194,7 +1194,7 @@</span> <span class="p_context"> mISDNipac_irq(struct ipac_hw *ipac, int maxloop)</span>
 			ista = ReadIPAC(ipac, IPAC_ISTA);
 		}
 	} else if (ipac-&gt;type &amp; IPAC_TYPE_HSCX) {
<span class="p_del">-		while (cnt) {</span>
<span class="p_add">+		while (--cnt) {</span>
 			ista = ReadIPAC(ipac, IPAC_ISTAB + ipac-&gt;hscx[1].off);
 			pr_debug(&quot;%s: B2 ISTA %02x\n&quot;, ipac-&gt;name, ista);
 			if (ista)
<span class="p_chunk">@@ -1205,7 +1205,6 @@</span> <span class="p_context"> mISDNipac_irq(struct ipac_hw *ipac, int maxloop)</span>
 				mISDNisac_irq(isac, istad);
 			if (0 == (ista | istad))
 				break;
<span class="p_del">-			cnt--;</span>
 		}
 	}
 	if (cnt &gt; maxloop) /* only for ISAC/HSCX without PCI IRQ test */
<span class="p_header">diff --git a/drivers/md/dm-thin-metadata.c b/drivers/md/dm-thin-metadata.c</span>
<span class="p_header">index 3412b86e79fd..7768de60f699 100644</span>
<span class="p_header">--- a/drivers/md/dm-thin-metadata.c</span>
<span class="p_header">+++ b/drivers/md/dm-thin-metadata.c</span>
<span class="p_chunk">@@ -1205,6 +1205,12 @@</span> <span class="p_context"> static int __reserve_metadata_snap(struct dm_pool_metadata *pmd)</span>
 	dm_block_t held_root;
 
 	/*
<span class="p_add">+	 * We commit to ensure the btree roots which we increment in a</span>
<span class="p_add">+	 * moment are up to date.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	__commit_transaction(pmd);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
 	 * Copy the superblock.
 	 */
 	dm_sm_inc_block(pmd-&gt;metadata_sm, THIN_SUPERBLOCK_LOCATION);
<span class="p_header">diff --git a/drivers/md/persistent-data/dm-btree.c b/drivers/md/persistent-data/dm-btree.c</span>
<span class="p_header">index d6e47033b5e0..7b4bb1f09b01 100644</span>
<span class="p_header">--- a/drivers/md/persistent-data/dm-btree.c</span>
<span class="p_header">+++ b/drivers/md/persistent-data/dm-btree.c</span>
<span class="p_chunk">@@ -250,6 +250,16 @@</span> <span class="p_context"> static void pop_frame(struct del_stack *s)</span>
 	dm_tm_unlock(s-&gt;tm, f-&gt;b);
 }
 
<span class="p_add">+static void unlock_all_frames(struct del_stack *s)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct frame *f;</span>
<span class="p_add">+</span>
<span class="p_add">+	while (unprocessed_frames(s)) {</span>
<span class="p_add">+		f = s-&gt;spine + s-&gt;top--;</span>
<span class="p_add">+		dm_tm_unlock(s-&gt;tm, f-&gt;b);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int dm_btree_del(struct dm_btree_info *info, dm_block_t root)
 {
 	int r;
<span class="p_chunk">@@ -306,9 +316,13 @@</span> <span class="p_context"> int dm_btree_del(struct dm_btree_info *info, dm_block_t root)</span>
 			pop_frame(s);
 		}
 	}
<span class="p_del">-</span>
 out:
<span class="p_add">+	if (r) {</span>
<span class="p_add">+		/* cleanup all frames of del_stack */</span>
<span class="p_add">+		unlock_all_frames(s);</span>
<span class="p_add">+	}</span>
 	kfree(s);
<span class="p_add">+</span>
 	return r;
 }
 EXPORT_SYMBOL_GPL(dm_btree_del);
<span class="p_chunk">@@ -471,8 +485,10 @@</span> <span class="p_context"> static int btree_split_sibling(struct shadow_spine *s, dm_block_t root,</span>
 
 	r = insert_at(sizeof(__le64), pn, parent_index + 1,
 		      le64_to_cpu(rn-&gt;keys[0]), &amp;location);
<span class="p_del">-	if (r)</span>
<span class="p_add">+	if (r) {</span>
<span class="p_add">+		unlock_block(s-&gt;info, right);</span>
 		return r;
<span class="p_add">+	}</span>
 
 	if (key &lt; le64_to_cpu(rn-&gt;keys[0])) {
 		unlock_block(s-&gt;info, right);
<span class="p_header">diff --git a/drivers/md/persistent-data/dm-space-map-metadata.c b/drivers/md/persistent-data/dm-space-map-metadata.c</span>
<span class="p_header">index 199c9ccd1f5d..8ec5ac5b9d63 100644</span>
<span class="p_header">--- a/drivers/md/persistent-data/dm-space-map-metadata.c</span>
<span class="p_header">+++ b/drivers/md/persistent-data/dm-space-map-metadata.c</span>
<span class="p_chunk">@@ -136,7 +136,7 @@</span> <span class="p_context"> static int brb_push(struct bop_ring_buffer *brb,</span>
 	return 0;
 }
 
<span class="p_del">-static int brb_pop(struct bop_ring_buffer *brb, struct block_op *result)</span>
<span class="p_add">+static int brb_peek(struct bop_ring_buffer *brb, struct block_op *result)</span>
 {
 	struct block_op *bop;
 
<span class="p_chunk">@@ -147,6 +147,17 @@</span> <span class="p_context"> static int brb_pop(struct bop_ring_buffer *brb, struct block_op *result)</span>
 	result-&gt;type = bop-&gt;type;
 	result-&gt;block = bop-&gt;block;
 
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int brb_pop(struct bop_ring_buffer *brb)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct block_op *bop;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (brb_empty(brb))</span>
<span class="p_add">+		return -ENODATA;</span>
<span class="p_add">+</span>
<span class="p_add">+	bop = brb-&gt;bops + brb-&gt;begin;</span>
 	brb-&gt;begin = brb_next(brb, brb-&gt;begin);
 
 	return 0;
<span class="p_chunk">@@ -211,7 +222,7 @@</span> <span class="p_context"> static int apply_bops(struct sm_metadata *smm)</span>
 	while (!brb_empty(&amp;smm-&gt;uncommitted)) {
 		struct block_op bop;
 
<span class="p_del">-		r = brb_pop(&amp;smm-&gt;uncommitted, &amp;bop);</span>
<span class="p_add">+		r = brb_peek(&amp;smm-&gt;uncommitted, &amp;bop);</span>
 		if (r) {
 			DMERR(&quot;bug in bop ring buffer&quot;);
 			break;
<span class="p_chunk">@@ -220,6 +231,8 @@</span> <span class="p_context"> static int apply_bops(struct sm_metadata *smm)</span>
 		r = commit_bop(smm, &amp;bop);
 		if (r)
 			break;
<span class="p_add">+</span>
<span class="p_add">+		brb_pop(&amp;smm-&gt;uncommitted);</span>
 	}
 
 	return r;
<span class="p_chunk">@@ -681,7 +694,6 @@</span> <span class="p_context"> static struct dm_space_map bootstrap_ops = {</span>
 static int sm_metadata_extend(struct dm_space_map *sm, dm_block_t extra_blocks)
 {
 	int r, i;
<span class="p_del">-	enum allocation_event ev;</span>
 	struct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);
 	dm_block_t old_len = smm-&gt;ll.nr_blocks;
 
<span class="p_chunk">@@ -703,11 +715,12 @@</span> <span class="p_context"> static int sm_metadata_extend(struct dm_space_map *sm, dm_block_t extra_blocks)</span>
 	 * allocate any new blocks.
 	 */
 	do {
<span class="p_del">-		for (i = old_len; !r &amp;&amp; i &lt; smm-&gt;begin; i++) {</span>
<span class="p_del">-			r = sm_ll_inc(&amp;smm-&gt;ll, i, &amp;ev);</span>
<span class="p_del">-			if (r)</span>
<span class="p_del">-				goto out;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		for (i = old_len; !r &amp;&amp; i &lt; smm-&gt;begin; i++)</span>
<span class="p_add">+			r = add_bop(smm, BOP_INC, i);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (r)</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+</span>
 		old_len = smm-&gt;begin;
 
 		r = apply_bops(smm);
<span class="p_chunk">@@ -752,7 +765,6 @@</span> <span class="p_context"> int dm_sm_metadata_create(struct dm_space_map *sm,</span>
 {
 	int r;
 	dm_block_t i;
<span class="p_del">-	enum allocation_event ev;</span>
 	struct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);
 
 	smm-&gt;begin = superblock + 1;
<span class="p_chunk">@@ -780,7 +792,7 @@</span> <span class="p_context"> int dm_sm_metadata_create(struct dm_space_map *sm,</span>
 	 * allocated blocks that they were built from.
 	 */
 	for (i = superblock; !r &amp;&amp; i &lt; smm-&gt;begin; i++)
<span class="p_del">-		r = sm_ll_inc(&amp;smm-&gt;ll, i, &amp;ev);</span>
<span class="p_add">+		r = add_bop(smm, BOP_INC, i);</span>
 
 	if (r)
 		return r;
<span class="p_header">diff --git a/drivers/net/ethernet/amd/xgbe/xgbe-dev.c b/drivers/net/ethernet/amd/xgbe/xgbe-dev.c</span>
<span class="p_header">index 002293b0819d..7038ff66807b 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/amd/xgbe/xgbe-dev.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/amd/xgbe/xgbe-dev.c</span>
<span class="p_chunk">@@ -1296,7 +1296,7 @@</span> <span class="p_context"> static int xgbe_exit(struct xgbe_prv_data *pdata)</span>
 	usleep_range(10, 15);
 
 	/* Poll Until Poll Condition */
<span class="p_del">-	while (count-- &amp;&amp; XGMAC_IOREAD_BITS(pdata, DMA_MR, SWR))</span>
<span class="p_add">+	while (--count &amp;&amp; XGMAC_IOREAD_BITS(pdata, DMA_MR, SWR))</span>
 		usleep_range(500, 600);
 
 	if (!count)
<span class="p_chunk">@@ -1317,7 +1317,7 @@</span> <span class="p_context"> static int xgbe_flush_tx_queues(struct xgbe_prv_data *pdata)</span>
 	/* Poll Until Poll Condition */
 	for (i = 0; i &lt; pdata-&gt;hw_feat.tx_q_cnt; i++) {
 		count = 2000;
<span class="p_del">-		while (count-- &amp;&amp; XGMAC_MTL_IOREAD_BITS(pdata, i,</span>
<span class="p_add">+		while (--count &amp;&amp; XGMAC_MTL_IOREAD_BITS(pdata, i,</span>
 							MTL_Q_TQOMR, FTQ))
 			usleep_range(500, 600);
 
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/en_clock.c b/drivers/net/ethernet/mellanox/mlx4/en_clock.c</span>
<span class="p_header">index 57dda95b67d8..74ed9f8fd267 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/en_clock.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/en_clock.c</span>
<span class="p_chunk">@@ -291,6 +291,13 @@</span> <span class="p_context"> void mlx4_en_init_timestamp(struct mlx4_en_dev *mdev)</span>
 	unsigned long flags;
 	u64 ns;
 
<span class="p_add">+	/* mlx4_en_init_timestamp is called for each netdev.</span>
<span class="p_add">+	 * mdev-&gt;ptp_clock is common for all ports, skip initialization if</span>
<span class="p_add">+	 * was done for other port.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (mdev-&gt;ptp_clock)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	rwlock_init(&amp;mdev-&gt;clock_lock);
 
 	memset(&amp;mdev-&gt;cycles, 0, sizeof(mdev-&gt;cycles));
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/en_main.c b/drivers/net/ethernet/mellanox/mlx4/en_main.c</span>
<span class="p_header">index f953c1d7eae6..80af090463eb 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/en_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/en_main.c</span>
<span class="p_chunk">@@ -206,9 +206,6 @@</span> <span class="p_context"> static void mlx4_en_remove(struct mlx4_dev *dev, void *endev_ptr)</span>
 		if (mdev-&gt;pndev[i])
 			mlx4_en_destroy_netdev(mdev-&gt;pndev[i]);
 
<span class="p_del">-	if (mdev-&gt;dev-&gt;caps.flags2 &amp; MLX4_DEV_CAP_FLAG2_TS)</span>
<span class="p_del">-		mlx4_en_remove_timestamp(mdev);</span>
<span class="p_del">-</span>
 	flush_workqueue(mdev-&gt;workqueue);
 	destroy_workqueue(mdev-&gt;workqueue);
 	(void) mlx4_mr_free(dev, &amp;mdev-&gt;mr);
<span class="p_chunk">@@ -276,10 +273,6 @@</span> <span class="p_context"> static void *mlx4_en_add(struct mlx4_dev *dev)</span>
 	mlx4_foreach_port(i, dev, MLX4_PORT_TYPE_ETH)
 		mdev-&gt;port_cnt++;
 
<span class="p_del">-	/* Initialize time stamp mechanism */</span>
<span class="p_del">-	if (mdev-&gt;dev-&gt;caps.flags2 &amp; MLX4_DEV_CAP_FLAG2_TS)</span>
<span class="p_del">-		mlx4_en_init_timestamp(mdev);</span>
<span class="p_del">-</span>
 	/* Set default number of RX rings*/
 	mlx4_en_set_num_rx_rings(mdev);
 
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c</span>
<span class="p_header">index 8be0c179e25d..bf3878823c96 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c</span>
<span class="p_chunk">@@ -2091,6 +2091,9 @@</span> <span class="p_context"> void mlx4_en_destroy_netdev(struct net_device *dev)</span>
 	/* flush any pending task for this netdev */
 	flush_workqueue(mdev-&gt;workqueue);
 
<span class="p_add">+	if (mdev-&gt;dev-&gt;caps.flags2 &amp; MLX4_DEV_CAP_FLAG2_TS)</span>
<span class="p_add">+		mlx4_en_remove_timestamp(mdev);</span>
<span class="p_add">+</span>
 	/* Detach the netdev so tasks would not attempt to access it */
 	mutex_lock(&amp;mdev-&gt;state_lock);
 	mdev-&gt;pndev[priv-&gt;port] = NULL;
<span class="p_chunk">@@ -2655,9 +2658,12 @@</span> <span class="p_context"> int mlx4_en_init_netdev(struct mlx4_en_dev *mdev, int port,</span>
 	}
 	queue_delayed_work(mdev-&gt;workqueue, &amp;priv-&gt;stats_task, STATS_DELAY);
 
<span class="p_add">+	/* Initialize time stamp mechanism */</span>
 	if (mdev-&gt;dev-&gt;caps.flags2 &amp; MLX4_DEV_CAP_FLAG2_TS)
<span class="p_del">-		queue_delayed_work(mdev-&gt;workqueue, &amp;priv-&gt;service_task,</span>
<span class="p_del">-				   SERVICE_TASK_DELAY);</span>
<span class="p_add">+		mlx4_en_init_timestamp(mdev);</span>
<span class="p_add">+</span>
<span class="p_add">+	queue_delayed_work(mdev-&gt;workqueue, &amp;priv-&gt;service_task,</span>
<span class="p_add">+			   SERVICE_TASK_DELAY);</span>
 
 	err = register_netdev(dev);
 	if (err) {
<span class="p_header">diff --git a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_vnic.c b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_vnic.c</span>
<span class="p_header">index be7d7a62cc0d..34906750b7e7 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_vnic.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_vnic.c</span>
<span class="p_chunk">@@ -246,12 +246,13 @@</span> <span class="p_context"> int qlcnic_83xx_check_vnic_state(struct qlcnic_adapter *adapter)</span>
 	u32 state;
 
 	state = QLCRDX(ahw, QLC_83XX_VNIC_STATE);
<span class="p_del">-	while (state != QLCNIC_DEV_NPAR_OPER &amp;&amp; idc-&gt;vnic_wait_limit--) {</span>
<span class="p_add">+	while (state != QLCNIC_DEV_NPAR_OPER &amp;&amp; idc-&gt;vnic_wait_limit) {</span>
<span class="p_add">+		idc-&gt;vnic_wait_limit--;</span>
 		msleep(1000);
 		state = QLCRDX(ahw, QLC_83XX_VNIC_STATE);
 	}
 
<span class="p_del">-	if (!idc-&gt;vnic_wait_limit) {</span>
<span class="p_add">+	if (state != QLCNIC_DEV_NPAR_OPER) {</span>
 		dev_err(&amp;adapter-&gt;pdev-&gt;dev,
 			&quot;vNIC mode not operational, state check timed out.\n&quot;);
 		return -EIO;
<span class="p_header">diff --git a/drivers/net/ethernet/renesas/sh_eth.c b/drivers/net/ethernet/renesas/sh_eth.c</span>
<span class="p_header">index d11546c2e902..64bb1edb5ef7 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/renesas/sh_eth.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/renesas/sh_eth.c</span>
<span class="p_chunk">@@ -2115,8 +2115,7 @@</span> <span class="p_context"> static int sh_eth_start_xmit(struct sk_buff *skb, struct net_device *ndev)</span>
 	txdesc = &amp;mdp-&gt;tx_ring[entry];
 	/* soft swap. */
 	if (!mdp-&gt;cd-&gt;hw_swap)
<span class="p_del">-		sh_eth_soft_swap(phys_to_virt(ALIGN(txdesc-&gt;addr, 4)),</span>
<span class="p_del">-				 skb-&gt;len + 2);</span>
<span class="p_add">+		sh_eth_soft_swap(PTR_ALIGN(skb-&gt;data, 4), skb-&gt;len + 2);</span>
 	txdesc-&gt;addr = dma_map_single(&amp;ndev-&gt;dev, skb-&gt;data, skb-&gt;len,
 				      DMA_TO_DEVICE);
 	if (skb-&gt;len &lt; ETH_ZLEN)
<span class="p_header">diff --git a/drivers/net/phy/mdio-mux.c b/drivers/net/phy/mdio-mux.c</span>
<span class="p_header">index 4d4d25efc1e1..ac8a82371f3b 100644</span>
<span class="p_header">--- a/drivers/net/phy/mdio-mux.c</span>
<span class="p_header">+++ b/drivers/net/phy/mdio-mux.c</span>
<span class="p_chunk">@@ -148,9 +148,14 @@</span> <span class="p_context"> int mdio_mux_init(struct device *dev,</span>
 		}
 		cb-&gt;bus_number = v;
 		cb-&gt;parent = pb;
<span class="p_add">+</span>
 		cb-&gt;mii_bus = mdiobus_alloc();
<span class="p_add">+		if (!cb-&gt;mii_bus) {</span>
<span class="p_add">+			ret_val = -ENOMEM;</span>
<span class="p_add">+			of_node_put(child_bus_node);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
 		cb-&gt;mii_bus-&gt;priv = cb;
<span class="p_del">-</span>
 		cb-&gt;mii_bus-&gt;irq = cb-&gt;phy_irq;
 		cb-&gt;mii_bus-&gt;name = &quot;mdio_mux&quot;;
 		snprintf(cb-&gt;mii_bus-&gt;id, MII_BUS_ID_SIZE, &quot;%x.%x&quot;,
<span class="p_header">diff --git a/drivers/net/xen-netback/netback.c b/drivers/net/xen-netback/netback.c</span>
<span class="p_header">index 09e4f4ef4eb8..0c1574212162 100644</span>
<span class="p_header">--- a/drivers/net/xen-netback/netback.c</span>
<span class="p_header">+++ b/drivers/net/xen-netback/netback.c</span>
<span class="p_chunk">@@ -221,18 +221,18 @@</span> <span class="p_context"> static struct xenvif_rx_meta *get_next_rx_buffer(struct xenvif_queue *queue,</span>
 						 struct netrx_pending_operations *npo)
 {
 	struct xenvif_rx_meta *meta;
<span class="p_del">-	struct xen_netif_rx_request *req;</span>
<span class="p_add">+	struct xen_netif_rx_request req;</span>
 
<span class="p_del">-	req = RING_GET_REQUEST(&amp;queue-&gt;rx, queue-&gt;rx.req_cons++);</span>
<span class="p_add">+	RING_COPY_REQUEST(&amp;queue-&gt;rx, queue-&gt;rx.req_cons++, &amp;req);</span>
 
 	meta = npo-&gt;meta + npo-&gt;meta_prod++;
 	meta-&gt;gso_type = XEN_NETIF_GSO_TYPE_NONE;
 	meta-&gt;gso_size = 0;
 	meta-&gt;size = 0;
<span class="p_del">-	meta-&gt;id = req-&gt;id;</span>
<span class="p_add">+	meta-&gt;id = req.id;</span>
 
 	npo-&gt;copy_off = 0;
<span class="p_del">-	npo-&gt;copy_gref = req-&gt;gref;</span>
<span class="p_add">+	npo-&gt;copy_gref = req.gref;</span>
 
 	return meta;
 }
<span class="p_chunk">@@ -390,7 +390,7 @@</span> <span class="p_context"> static int xenvif_gop_skb(struct sk_buff *skb,</span>
 	struct xenvif *vif = netdev_priv(skb-&gt;dev);
 	int nr_frags = skb_shinfo(skb)-&gt;nr_frags;
 	int i;
<span class="p_del">-	struct xen_netif_rx_request *req;</span>
<span class="p_add">+	struct xen_netif_rx_request req;</span>
 	struct xenvif_rx_meta *meta;
 	unsigned char *data;
 	int head = 1;
<span class="p_chunk">@@ -411,15 +411,15 @@</span> <span class="p_context"> static int xenvif_gop_skb(struct sk_buff *skb,</span>
 
 	/* Set up a GSO prefix descriptor, if necessary */
 	if ((1 &lt;&lt; gso_type) &amp; vif-&gt;gso_prefix_mask) {
<span class="p_del">-		req = RING_GET_REQUEST(&amp;queue-&gt;rx, queue-&gt;rx.req_cons++);</span>
<span class="p_add">+		RING_COPY_REQUEST(&amp;queue-&gt;rx, queue-&gt;rx.req_cons++, &amp;req);</span>
 		meta = npo-&gt;meta + npo-&gt;meta_prod++;
 		meta-&gt;gso_type = gso_type;
 		meta-&gt;gso_size = skb_shinfo(skb)-&gt;gso_size;
 		meta-&gt;size = 0;
<span class="p_del">-		meta-&gt;id = req-&gt;id;</span>
<span class="p_add">+		meta-&gt;id = req.id;</span>
 	}
 
<span class="p_del">-	req = RING_GET_REQUEST(&amp;queue-&gt;rx, queue-&gt;rx.req_cons++);</span>
<span class="p_add">+	RING_COPY_REQUEST(&amp;queue-&gt;rx, queue-&gt;rx.req_cons++, &amp;req);</span>
 	meta = npo-&gt;meta + npo-&gt;meta_prod++;
 
 	if ((1 &lt;&lt; gso_type) &amp; vif-&gt;gso_mask) {
<span class="p_chunk">@@ -431,9 +431,9 @@</span> <span class="p_context"> static int xenvif_gop_skb(struct sk_buff *skb,</span>
 	}
 
 	meta-&gt;size = 0;
<span class="p_del">-	meta-&gt;id = req-&gt;id;</span>
<span class="p_add">+	meta-&gt;id = req.id;</span>
 	npo-&gt;copy_off = 0;
<span class="p_del">-	npo-&gt;copy_gref = req-&gt;gref;</span>
<span class="p_add">+	npo-&gt;copy_gref = req.gref;</span>
 
 	data = skb-&gt;data;
 	while (data &lt; skb_tail_pointer(skb)) {
<span class="p_chunk">@@ -755,9 +755,7 @@</span> <span class="p_context"> static void tx_add_credit(struct xenvif_queue *queue)</span>
 	 * Allow a burst big enough to transmit a jumbo packet of up to 128kB.
 	 * Otherwise the interface can seize up due to insufficient credit.
 	 */
<span class="p_del">-	max_burst = RING_GET_REQUEST(&amp;queue-&gt;tx, queue-&gt;tx.req_cons)-&gt;size;</span>
<span class="p_del">-	max_burst = min(max_burst, 131072UL);</span>
<span class="p_del">-	max_burst = max(max_burst, queue-&gt;credit_bytes);</span>
<span class="p_add">+	max_burst = max(131072UL, queue-&gt;credit_bytes);</span>
 
 	/* Take care that adding a new chunk of credit doesn&#39;t wrap to zero. */
 	max_credit = queue-&gt;remaining_credit + queue-&gt;credit_bytes;
<span class="p_chunk">@@ -786,7 +784,7 @@</span> <span class="p_context"> static void xenvif_tx_err(struct xenvif_queue *queue,</span>
 		spin_unlock_irqrestore(&amp;queue-&gt;response_lock, flags);
 		if (cons == end)
 			break;
<span class="p_del">-		txp = RING_GET_REQUEST(&amp;queue-&gt;tx, cons++);</span>
<span class="p_add">+		RING_COPY_REQUEST(&amp;queue-&gt;tx, cons++, txp);</span>
 	} while (1);
 	queue-&gt;tx.req_cons = cons;
 }
<span class="p_chunk">@@ -853,8 +851,7 @@</span> <span class="p_context"> static int xenvif_count_requests(struct xenvif_queue *queue,</span>
 		if (drop_err)
 			txp = &amp;dropped_tx;
 
<span class="p_del">-		memcpy(txp, RING_GET_REQUEST(&amp;queue-&gt;tx, cons + slots),</span>
<span class="p_del">-		       sizeof(*txp));</span>
<span class="p_add">+		RING_COPY_REQUEST(&amp;queue-&gt;tx, cons + slots, txp);</span>
 
 		/* If the guest submitted a frame &gt;= 64 KiB then
 		 * first-&gt;size overflowed and following slots will
<span class="p_chunk">@@ -1206,8 +1203,7 @@</span> <span class="p_context"> static int xenvif_get_extras(struct xenvif_queue *queue,</span>
 			return -EBADR;
 		}
 
<span class="p_del">-		memcpy(&amp;extra, RING_GET_REQUEST(&amp;queue-&gt;tx, cons),</span>
<span class="p_del">-		       sizeof(extra));</span>
<span class="p_add">+		RING_COPY_REQUEST(&amp;queue-&gt;tx, cons, &amp;extra);</span>
 		if (unlikely(!extra.type ||
 			     extra.type &gt;= XEN_NETIF_EXTRA_TYPE_MAX)) {
 			queue-&gt;tx.req_cons = ++cons;
<span class="p_chunk">@@ -1343,7 +1339,7 @@</span> <span class="p_context"> static void xenvif_tx_build_gops(struct xenvif_queue *queue,</span>
 
 		idx = queue-&gt;tx.req_cons;
 		rmb(); /* Ensure that we see the request before we copy it. */
<span class="p_del">-		memcpy(&amp;txreq, RING_GET_REQUEST(&amp;queue-&gt;tx, idx), sizeof(txreq));</span>
<span class="p_add">+		RING_COPY_REQUEST(&amp;queue-&gt;tx, idx, &amp;txreq);</span>
 
 		/* Credit-based scheduling. */
 		if (txreq.size &gt; queue-&gt;remaining_credit &amp;&amp;
<span class="p_header">diff --git a/drivers/parisc/iommu-helpers.h b/drivers/parisc/iommu-helpers.h</span>
<span class="p_header">index 8c33491b21fe..c6aa38883466 100644</span>
<span class="p_header">--- a/drivers/parisc/iommu-helpers.h</span>
<span class="p_header">+++ b/drivers/parisc/iommu-helpers.h</span>
<span class="p_chunk">@@ -104,7 +104,11 @@</span> <span class="p_context"> iommu_coalesce_chunks(struct ioc *ioc, struct device *dev,</span>
 	struct scatterlist *contig_sg;	   /* contig chunk head */
 	unsigned long dma_offset, dma_len; /* start/len of DMA stream */
 	unsigned int n_mappings = 0;
<span class="p_del">-	unsigned int max_seg_size = dma_get_max_seg_size(dev);</span>
<span class="p_add">+	unsigned int max_seg_size = min(dma_get_max_seg_size(dev),</span>
<span class="p_add">+					(unsigned)DMA_CHUNK_SIZE);</span>
<span class="p_add">+	unsigned int max_seg_boundary = dma_get_seg_boundary(dev) + 1;</span>
<span class="p_add">+	if (max_seg_boundary)	/* check if the addition above didn&#39;t overflow */</span>
<span class="p_add">+		max_seg_size = min(max_seg_size, max_seg_boundary);</span>
 
 	while (nents &gt; 0) {
 
<span class="p_chunk">@@ -139,14 +143,11 @@</span> <span class="p_context"> iommu_coalesce_chunks(struct ioc *ioc, struct device *dev,</span>
 
 			/*
 			** First make sure current dma stream won&#39;t
<span class="p_del">-			** exceed DMA_CHUNK_SIZE if we coalesce the</span>
<span class="p_add">+			** exceed max_seg_size if we coalesce the</span>
 			** next entry.
 			*/   
<span class="p_del">-			if(unlikely(ALIGN(dma_len + dma_offset + startsg-&gt;length,</span>
<span class="p_del">-					    IOVP_SIZE) &gt; DMA_CHUNK_SIZE))</span>
<span class="p_del">-				break;</span>
<span class="p_del">-</span>
<span class="p_del">-			if (startsg-&gt;length + dma_len &gt; max_seg_size)</span>
<span class="p_add">+			if (unlikely(ALIGN(dma_len + dma_offset + startsg-&gt;length, IOVP_SIZE) &gt;</span>
<span class="p_add">+				     max_seg_size))</span>
 				break;
 
 			/*
<span class="p_header">diff --git a/drivers/pinctrl/pinctrl-bcm2835.c b/drivers/pinctrl/pinctrl-bcm2835.c</span>
<span class="p_header">index 3d907de9bc91..1ad7caf08b6c 100644</span>
<span class="p_header">--- a/drivers/pinctrl/pinctrl-bcm2835.c</span>
<span class="p_header">+++ b/drivers/pinctrl/pinctrl-bcm2835.c</span>
<span class="p_chunk">@@ -352,12 +352,6 @@</span> <span class="p_context"> static int bcm2835_gpio_get(struct gpio_chip *chip, unsigned offset)</span>
 	return bcm2835_gpio_get_bit(pc, GPLEV0, offset);
 }
 
<span class="p_del">-static int bcm2835_gpio_direction_output(struct gpio_chip *chip,</span>
<span class="p_del">-		unsigned offset, int value)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return pinctrl_gpio_direction_output(chip-&gt;base + offset);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static void bcm2835_gpio_set(struct gpio_chip *chip, unsigned offset, int value)
 {
 	struct bcm2835_pinctrl *pc = dev_get_drvdata(chip-&gt;dev);
<span class="p_chunk">@@ -365,6 +359,13 @@</span> <span class="p_context"> static void bcm2835_gpio_set(struct gpio_chip *chip, unsigned offset, int value)</span>
 	bcm2835_gpio_set_bit(pc, value ? GPSET0 : GPCLR0, offset);
 }
 
<span class="p_add">+static int bcm2835_gpio_direction_output(struct gpio_chip *chip,</span>
<span class="p_add">+		unsigned offset, int value)</span>
<span class="p_add">+{</span>
<span class="p_add">+	bcm2835_gpio_set(chip, offset, value);</span>
<span class="p_add">+	return pinctrl_gpio_direction_output(chip-&gt;base + offset);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int bcm2835_gpio_to_irq(struct gpio_chip *chip, unsigned offset)
 {
 	struct bcm2835_pinctrl *pc = dev_get_drvdata(chip-&gt;dev);
<span class="p_header">diff --git a/drivers/powercap/intel_rapl.c b/drivers/powercap/intel_rapl.c</span>
<span class="p_header">index a362dcc20ec0..ccb6768a352b 100644</span>
<span class="p_header">--- a/drivers/powercap/intel_rapl.c</span>
<span class="p_header">+++ b/drivers/powercap/intel_rapl.c</span>
<span class="p_chunk">@@ -1191,10 +1191,13 @@</span> <span class="p_context"> static int rapl_detect_domains(struct rapl_package *rp, int cpu)</span>
 
 	for (rd = rp-&gt;domains; rd &lt; rp-&gt;domains + rp-&gt;nr_domains; rd++) {
 		/* check if the domain is locked by BIOS */
<span class="p_del">-		if (rapl_read_data_raw(rd, FW_LOCK, false, &amp;locked)) {</span>
<span class="p_add">+		ret = rapl_read_data_raw(rd, FW_LOCK, false, &amp;locked);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+		if (locked) {</span>
 			pr_info(&quot;RAPL package %d domain %s locked by BIOS\n&quot;,
 				rp-&gt;id, rd-&gt;name);
<span class="p_del">-				rd-&gt;state |= DOMAIN_STATE_BIOS_LOCKED;</span>
<span class="p_add">+			rd-&gt;state |= DOMAIN_STATE_BIOS_LOCKED;</span>
 		}
 	}
 
<span class="p_header">diff --git a/drivers/scsi/scsi_pm.c b/drivers/scsi/scsi_pm.c</span>
<span class="p_header">index a2dcf6a54ec6..75320dad9677 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_pm.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_pm.c</span>
<span class="p_chunk">@@ -221,13 +221,13 @@</span> <span class="p_context"> static int sdev_runtime_suspend(struct device *dev)</span>
 	struct scsi_device *sdev = to_scsi_device(dev);
 	int err = 0;
 
<span class="p_del">-	if (pm &amp;&amp; pm-&gt;runtime_suspend) {</span>
<span class="p_del">-		err = blk_pre_runtime_suspend(sdev-&gt;request_queue);</span>
<span class="p_del">-		if (err)</span>
<span class="p_del">-			return err;</span>
<span class="p_add">+	err = blk_pre_runtime_suspend(sdev-&gt;request_queue);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+	if (pm &amp;&amp; pm-&gt;runtime_suspend)</span>
 		err = pm-&gt;runtime_suspend(dev);
<span class="p_del">-		blk_post_runtime_suspend(sdev-&gt;request_queue, err);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	blk_post_runtime_suspend(sdev-&gt;request_queue, err);</span>
<span class="p_add">+</span>
 	return err;
 }
 
<span class="p_chunk">@@ -250,11 +250,11 @@</span> <span class="p_context"> static int sdev_runtime_resume(struct device *dev)</span>
 	const struct dev_pm_ops *pm = dev-&gt;driver ? dev-&gt;driver-&gt;pm : NULL;
 	int err = 0;
 
<span class="p_del">-	if (pm &amp;&amp; pm-&gt;runtime_resume) {</span>
<span class="p_del">-		blk_pre_runtime_resume(sdev-&gt;request_queue);</span>
<span class="p_add">+	blk_pre_runtime_resume(sdev-&gt;request_queue);</span>
<span class="p_add">+	if (pm &amp;&amp; pm-&gt;runtime_resume)</span>
 		err = pm-&gt;runtime_resume(dev);
<span class="p_del">-		blk_post_runtime_resume(sdev-&gt;request_queue, err);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	blk_post_runtime_resume(sdev-&gt;request_queue, err);</span>
<span class="p_add">+</span>
 	return err;
 }
 
<span class="p_header">diff --git a/drivers/scsi/ses.c b/drivers/scsi/ses.c</span>
<span class="p_header">index 80bfece1a2de..6465f8edf713 100644</span>
<span class="p_header">--- a/drivers/scsi/ses.c</span>
<span class="p_header">+++ b/drivers/scsi/ses.c</span>
<span class="p_chunk">@@ -71,6 +71,7 @@</span> <span class="p_context"> static int ses_probe(struct device *dev)</span>
 static int ses_recv_diag(struct scsi_device *sdev, int page_code,
 			 void *buf, int bufflen)
 {
<span class="p_add">+	int ret;</span>
 	unsigned char cmd[] = {
 		RECEIVE_DIAGNOSTIC,
 		1,		/* Set PCV bit */
<span class="p_chunk">@@ -79,9 +80,26 @@</span> <span class="p_context"> static int ses_recv_diag(struct scsi_device *sdev, int page_code,</span>
 		bufflen &amp; 0xff,
 		0
 	};
<span class="p_add">+	unsigned char recv_page_code;</span>
 
<span class="p_del">-	return scsi_execute_req(sdev, cmd, DMA_FROM_DEVICE, buf, bufflen,</span>
<span class="p_add">+	ret =  scsi_execute_req(sdev, cmd, DMA_FROM_DEVICE, buf, bufflen,</span>
 				NULL, SES_TIMEOUT, SES_RETRIES, NULL);
<span class="p_add">+	if (unlikely(!ret))</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	recv_page_code = ((unsigned char *)buf)[0];</span>
<span class="p_add">+</span>
<span class="p_add">+	if (likely(recv_page_code == page_code))</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* successful diagnostic but wrong page code.  This happens to some</span>
<span class="p_add">+	 * USB devices, just print a message and pretend there was an error */</span>
<span class="p_add">+</span>
<span class="p_add">+	sdev_printk(KERN_ERR, sdev,</span>
<span class="p_add">+		    &quot;Wrong diagnostic page; asked for %d got %u\n&quot;,</span>
<span class="p_add">+		    page_code, recv_page_code);</span>
<span class="p_add">+</span>
<span class="p_add">+	return -EINVAL;</span>
 }
 
 static int ses_send_diag(struct scsi_device *sdev, int page_code,
<span class="p_chunk">@@ -437,7 +455,15 @@</span> <span class="p_context"> static void ses_enclosure_data_process(struct enclosure_device *edev,</span>
 			if (desc_ptr)
 				desc_ptr += len;
 
<span class="p_del">-			if (addl_desc_ptr)</span>
<span class="p_add">+			if (addl_desc_ptr &amp;&amp;</span>
<span class="p_add">+			    /* only find additional descriptions for specific devices */</span>
<span class="p_add">+			    (type_ptr[0] == ENCLOSURE_COMPONENT_DEVICE ||</span>
<span class="p_add">+			     type_ptr[0] == ENCLOSURE_COMPONENT_ARRAY_DEVICE ||</span>
<span class="p_add">+			     type_ptr[0] == ENCLOSURE_COMPONENT_SAS_EXPANDER ||</span>
<span class="p_add">+			     /* these elements are optional */</span>
<span class="p_add">+			     type_ptr[0] == ENCLOSURE_COMPONENT_SCSI_TARGET_PORT ||</span>
<span class="p_add">+			     type_ptr[0] == ENCLOSURE_COMPONENT_SCSI_INITIATOR_PORT ||</span>
<span class="p_add">+			     type_ptr[0] == ENCLOSURE_COMPONENT_CONTROLLER_ELECTRONICS))</span>
 				addl_desc_ptr += addl_desc_ptr[1] + 2;
 
 		}
<span class="p_header">diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c</span>
<span class="p_header">index 8f2c442eb1e1..f8e4ca6be300 100644</span>
<span class="p_header">--- a/drivers/spi/spi.c</span>
<span class="p_header">+++ b/drivers/spi/spi.c</span>
<span class="p_chunk">@@ -1475,7 +1475,7 @@</span> <span class="p_context"> struct spi_master *spi_alloc_master(struct device *dev, unsigned size)</span>
 	master-&gt;bus_num = -1;
 	master-&gt;num_chipselect = 1;
 	master-&gt;dev.class = &amp;spi_master_class;
<span class="p_del">-	master-&gt;dev.parent = get_device(dev);</span>
<span class="p_add">+	master-&gt;dev.parent = dev;</span>
 	spi_master_set_devdata(master, &amp;master[1]);
 
 	return master;
<span class="p_header">diff --git a/drivers/staging/lustre/lustre/obdecho/echo_client.c b/drivers/staging/lustre/lustre/obdecho/echo_client.c</span>
<span class="p_header">index cdc46719bbd4..95c0bdb45d2a 100644</span>
<span class="p_header">--- a/drivers/staging/lustre/lustre/obdecho/echo_client.c</span>
<span class="p_header">+++ b/drivers/staging/lustre/lustre/obdecho/echo_client.c</span>
<span class="p_chunk">@@ -1380,6 +1380,7 @@</span> <span class="p_context"> static int</span>
 echo_copyout_lsm (struct lov_stripe_md *lsm, void *_ulsm, int ulsm_nob)
 {
 	struct lov_stripe_md *ulsm = _ulsm;
<span class="p_add">+	struct lov_oinfo **p;</span>
 	int nob, i;
 
 	nob = offsetof (struct lov_stripe_md, lsm_oinfo[lsm-&gt;lsm_stripe_count]);
<span class="p_chunk">@@ -1389,9 +1390,10 @@</span> <span class="p_context"> echo_copyout_lsm (struct lov_stripe_md *lsm, void *_ulsm, int ulsm_nob)</span>
 	if (copy_to_user (ulsm, lsm, sizeof(*ulsm)))
 		return (-EFAULT);
 
<span class="p_del">-	for (i = 0; i &lt; lsm-&gt;lsm_stripe_count; i++) {</span>
<span class="p_del">-		if (copy_to_user (ulsm-&gt;lsm_oinfo[i], lsm-&gt;lsm_oinfo[i],</span>
<span class="p_del">-				      sizeof(lsm-&gt;lsm_oinfo[0])))</span>
<span class="p_add">+	for (i = 0, p = lsm-&gt;lsm_oinfo; i &lt; lsm-&gt;lsm_stripe_count; i++, p++) {</span>
<span class="p_add">+		struct lov_oinfo __user *up;</span>
<span class="p_add">+		if (get_user(up, ulsm-&gt;lsm_oinfo + i) ||</span>
<span class="p_add">+		    copy_to_user(up, *p, sizeof(struct lov_oinfo)))</span>
 			return (-EFAULT);
 	}
 	return 0;
<span class="p_chunk">@@ -1399,9 +1401,10 @@</span> <span class="p_context"> echo_copyout_lsm (struct lov_stripe_md *lsm, void *_ulsm, int ulsm_nob)</span>
 
 static int
 echo_copyin_lsm (struct echo_device *ed, struct lov_stripe_md *lsm,
<span class="p_del">-		 void *ulsm, int ulsm_nob)</span>
<span class="p_add">+		struct lov_stripe_md __user *ulsm, int ulsm_nob)</span>
 {
 	struct echo_client_obd *ec = ed-&gt;ed_ec;
<span class="p_add">+	struct lov_oinfo **p;</span>
 	int		     i;
 
 	if (ulsm_nob &lt; sizeof (*lsm))
<span class="p_chunk">@@ -1417,11 +1420,10 @@</span> <span class="p_context"> echo_copyin_lsm (struct echo_device *ed, struct lov_stripe_md *lsm,</span>
 		return (-EINVAL);
 
 
<span class="p_del">-	for (i = 0; i &lt; lsm-&gt;lsm_stripe_count; i++) {</span>
<span class="p_del">-		if (copy_from_user(lsm-&gt;lsm_oinfo[i],</span>
<span class="p_del">-				       ((struct lov_stripe_md *)ulsm)-&gt; \</span>
<span class="p_del">-				       lsm_oinfo[i],</span>
<span class="p_del">-				       sizeof(lsm-&gt;lsm_oinfo[0])))</span>
<span class="p_add">+	for (i = 0, p = lsm-&gt;lsm_oinfo; i &lt; lsm-&gt;lsm_stripe_count; i++, p++) {</span>
<span class="p_add">+		struct lov_oinfo __user *up;</span>
<span class="p_add">+		if (get_user(up, ulsm-&gt;lsm_oinfo + i) ||</span>
<span class="p_add">+		    copy_from_user(*p, up, sizeof(struct lov_oinfo)))</span>
 			return (-EFAULT);
 	}
 	return (0);
<span class="p_header">diff --git a/drivers/tty/n_tty.c b/drivers/tty/n_tty.c</span>
<span class="p_header">index 29de4bfe5c70..d239fdba29d6 100644</span>
<span class="p_header">--- a/drivers/tty/n_tty.c</span>
<span class="p_header">+++ b/drivers/tty/n_tty.c</span>
<span class="p_chunk">@@ -2048,13 +2048,13 @@</span> <span class="p_context"> static int canon_copy_from_read_buf(struct tty_struct *tty,</span>
 	size_t eol;
 	size_t tail;
 	int ret, found = 0;
<span class="p_del">-	bool eof_push = 0;</span>
 
 	/* N.B. avoid overrun if nr == 0 */
<span class="p_del">-	n = min(*nr, read_cnt(ldata));</span>
<span class="p_del">-	if (!n)</span>
<span class="p_add">+	if (!*nr)</span>
 		return 0;
 
<span class="p_add">+	n = min(*nr + 1, read_cnt(ldata));</span>
<span class="p_add">+</span>
 	tail = ldata-&gt;read_tail &amp; (N_TTY_BUF_SIZE - 1);
 	size = min_t(size_t, tail + n, N_TTY_BUF_SIZE);
 
<span class="p_chunk">@@ -2075,12 +2075,11 @@</span> <span class="p_context"> static int canon_copy_from_read_buf(struct tty_struct *tty,</span>
 	n = eol - tail;
 	if (n &gt; 4096)
 		n += 4096;
<span class="p_del">-	n += found;</span>
<span class="p_del">-	c = n;</span>
<span class="p_add">+	c = n + found;</span>
 
<span class="p_del">-	if (found &amp;&amp; !ldata-&gt;push &amp;&amp; read_buf(ldata, eol) == __DISABLED_CHAR) {</span>
<span class="p_del">-		n--;</span>
<span class="p_del">-		eof_push = !n &amp;&amp; ldata-&gt;read_tail != ldata-&gt;line_start;</span>
<span class="p_add">+	if (!found || read_buf(ldata, eol) != __DISABLED_CHAR) {</span>
<span class="p_add">+		c = min(*nr, c);</span>
<span class="p_add">+		n = c;</span>
 	}
 
 	n_tty_trace(&quot;%s: eol:%zu found:%d n:%zu c:%zu size:%zu more:%zu\n&quot;,
<span class="p_chunk">@@ -2111,7 +2110,7 @@</span> <span class="p_context"> static int canon_copy_from_read_buf(struct tty_struct *tty,</span>
 			ldata-&gt;push = 0;
 		tty_audit_push(tty);
 	}
<span class="p_del">-	return eof_push ? -EAGAIN : 0;</span>
<span class="p_add">+	return 0;</span>
 }
 
 extern ssize_t redirected_tty_write(struct file *, const char __user *,
<span class="p_chunk">@@ -2299,10 +2298,7 @@</span> <span class="p_context"> static ssize_t n_tty_read(struct tty_struct *tty, struct file *file,</span>
 
 		if (ldata-&gt;icanon &amp;&amp; !L_EXTPROC(tty)) {
 			retval = canon_copy_from_read_buf(tty, &amp;b, &amp;nr);
<span class="p_del">-			if (retval == -EAGAIN) {</span>
<span class="p_del">-				retval = 0;</span>
<span class="p_del">-				continue;</span>
<span class="p_del">-			} else if (retval)</span>
<span class="p_add">+			if (retval)</span>
 				break;
 		} else {
 			int uncopied;
<span class="p_header">diff --git a/drivers/tty/tty_buffer.c b/drivers/tty/tty_buffer.c</span>
<span class="p_header">index 143deb62467d..12446e9a4435 100644</span>
<span class="p_header">--- a/drivers/tty/tty_buffer.c</span>
<span class="p_header">+++ b/drivers/tty/tty_buffer.c</span>
<span class="p_chunk">@@ -411,7 +411,7 @@</span> <span class="p_context"> receive_buf(struct tty_struct *tty, struct tty_buffer *head, int count)</span>
 		count = disc-&gt;ops-&gt;receive_buf2(tty, p, f, count);
 	else {
 		count = min_t(int, count, tty-&gt;receive_room);
<span class="p_del">-		if (count)</span>
<span class="p_add">+		if (count &amp;&amp; disc-&gt;ops-&gt;receive_buf)</span>
 			disc-&gt;ops-&gt;receive_buf(tty, p, f, count);
 	}
 	head-&gt;read += count;
<span class="p_header">diff --git a/drivers/usb/class/cdc-acm.c b/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">index 54c79f7fdaf5..f2dc4628fb05 100644</span>
<span class="p_header">--- a/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">+++ b/drivers/usb/class/cdc-acm.c</span>
<span class="p_chunk">@@ -1856,6 +1856,11 @@</span> <span class="p_context"> static const struct usb_device_id acm_ids[] = {</span>
 	},
 #endif
 
<span class="p_add">+	/* Exclude Infineon Flash Loader utility */</span>
<span class="p_add">+	{ USB_DEVICE(0x058b, 0x0041),</span>
<span class="p_add">+	.driver_info = IGNORE_DEVICE,</span>
<span class="p_add">+	},</span>
<span class="p_add">+</span>
 	/* control interfaces without any protocol set */
 	{ USB_INTERFACE_INFO(USB_CLASS_COMM, USB_CDC_SUBCLASS_ACM,
 		USB_CDC_PROTO_NONE) },
<span class="p_header">diff --git a/drivers/usb/core/config.c b/drivers/usb/core/config.c</span>
<span class="p_header">index b9ddf0c1ffe5..894894f2ff93 100644</span>
<span class="p_header">--- a/drivers/usb/core/config.c</span>
<span class="p_header">+++ b/drivers/usb/core/config.c</span>
<span class="p_chunk">@@ -115,7 +115,8 @@</span> <span class="p_context"> static void usb_parse_ss_endpoint_companion(struct device *ddev, int cfgno,</span>
 		   USB_SS_MULT(desc-&gt;bmAttributes) &gt; 3) {
 		dev_warn(ddev, &quot;Isoc endpoint has Mult of %d in &quot;
 				&quot;config %d interface %d altsetting %d ep %d: &quot;
<span class="p_del">-				&quot;setting to 3\n&quot;, desc-&gt;bmAttributes + 1,</span>
<span class="p_add">+				&quot;setting to 3\n&quot;,</span>
<span class="p_add">+				USB_SS_MULT(desc-&gt;bmAttributes),</span>
 				cfgno, inum, asnum, ep-&gt;desc.bEndpointAddress);
 		ep-&gt;ss_ep_comp.bmAttributes = 2;
 	}
<span class="p_header">diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c</span>
<span class="p_header">index 962fdf5c621b..673d426de13f 100644</span>
<span class="p_header">--- a/drivers/usb/core/hub.c</span>
<span class="p_header">+++ b/drivers/usb/core/hub.c</span>
<span class="p_chunk">@@ -104,6 +104,7 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(ehci_cf_port_reset_rwsem);</span>
 #define HUB_DEBOUNCE_STEP	  25
 #define HUB_DEBOUNCE_STABLE	 100
 
<span class="p_add">+static void hub_release(struct kref *kref);</span>
 static int usb_reset_and_verify_device(struct usb_device *udev);
 
 static inline char *portspeed(struct usb_hub *hub, int portstatus)
<span class="p_chunk">@@ -128,6 +129,10 @@</span> <span class="p_context"> struct usb_hub *usb_hub_to_struct_hub(struct usb_device *hdev)</span>
 
 int usb_device_supports_lpm(struct usb_device *udev)
 {
<span class="p_add">+	/* Some devices have trouble with LPM */</span>
<span class="p_add">+	if (udev-&gt;quirks &amp; USB_QUIRK_NO_LPM)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	/* USB 2.1 (and greater) devices indicate LPM support through
 	 * their USB 2.0 Extended Capabilities BOS descriptor.
 	 */
<span class="p_chunk">@@ -1023,10 +1028,20 @@</span> <span class="p_context"> static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)</span>
 	unsigned delay;
 
 	/* Continue a partial initialization */
<span class="p_del">-	if (type == HUB_INIT2)</span>
<span class="p_del">-		goto init2;</span>
<span class="p_del">-	if (type == HUB_INIT3)</span>
<span class="p_add">+	if (type == HUB_INIT2 || type == HUB_INIT3) {</span>
<span class="p_add">+		device_lock(hub-&gt;intfdev);</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Was the hub disconnected while we were waiting? */</span>
<span class="p_add">+		if (hub-&gt;disconnected) {</span>
<span class="p_add">+			device_unlock(hub-&gt;intfdev);</span>
<span class="p_add">+			kref_put(&amp;hub-&gt;kref, hub_release);</span>
<span class="p_add">+			return;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		if (type == HUB_INIT2)</span>
<span class="p_add">+			goto init2;</span>
 		goto init3;
<span class="p_add">+	}</span>
<span class="p_add">+	kref_get(&amp;hub-&gt;kref);</span>
 
 	/* The superspeed hub except for root hub has to use Hub Depth
 	 * value as an offset into the route string to locate the bits
<span class="p_chunk">@@ -1224,6 +1239,7 @@</span> <span class="p_context"> static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)</span>
 			queue_delayed_work(system_power_efficient_wq,
 					&amp;hub-&gt;init_work,
 					msecs_to_jiffies(delay));
<span class="p_add">+			device_unlock(hub-&gt;intfdev);</span>
 			return;		/* Continues at init3: below */
 		} else {
 			msleep(delay);
<span class="p_chunk">@@ -1245,6 +1261,11 @@</span> <span class="p_context"> static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)</span>
 	/* Allow autosuspend if it was suppressed */
 	if (type &lt;= HUB_INIT3)
 		usb_autopm_put_interface_async(to_usb_interface(hub-&gt;intfdev));
<span class="p_add">+</span>
<span class="p_add">+	if (type == HUB_INIT2 || type == HUB_INIT3)</span>
<span class="p_add">+		device_unlock(hub-&gt;intfdev);</span>
<span class="p_add">+</span>
<span class="p_add">+	kref_put(&amp;hub-&gt;kref, hub_release);</span>
 }
 
 /* Implement the continuations for the delays above */
<span class="p_chunk">@@ -4479,6 +4500,8 @@</span> <span class="p_context"> hub_port_init (struct usb_hub *hub, struct usb_device *udev, int port1,</span>
 		goto fail;
 	}
 
<span class="p_add">+	usb_detect_quirks(udev);</span>
<span class="p_add">+</span>
 	if (udev-&gt;wusb == 0 &amp;&amp; le16_to_cpu(udev-&gt;descriptor.bcdUSB) &gt;= 0x0201) {
 		retval = usb_get_bos_descriptor(udev);
 		if (!retval) {
<span class="p_chunk">@@ -4674,7 +4697,6 @@</span> <span class="p_context"> static void hub_port_connect(struct usb_hub *hub, int port1, u16 portstatus,</span>
 		if (status &lt; 0)
 			goto loop;
 
<span class="p_del">-		usb_detect_quirks(udev);</span>
 		if (udev-&gt;quirks &amp; USB_QUIRK_DELAY_INIT)
 			msleep(1000);
 
<span class="p_chunk">@@ -5347,9 +5369,6 @@</span> <span class="p_context"> static int usb_reset_and_verify_device(struct usb_device *udev)</span>
 	if (udev-&gt;usb2_hw_lpm_enabled == 1)
 		usb_set_usb2_hardware_lpm(udev, 0);
 
<span class="p_del">-	bos = udev-&gt;bos;</span>
<span class="p_del">-	udev-&gt;bos = NULL;</span>
<span class="p_del">-</span>
 	/* Disable LPM and LTM while we reset the device and reinstall the alt
 	 * settings.  Device-initiated LPM settings, and system exit latency
 	 * settings are cleared when the device is reset, so we have to set
<span class="p_chunk">@@ -5358,15 +5377,18 @@</span> <span class="p_context"> static int usb_reset_and_verify_device(struct usb_device *udev)</span>
 	ret = usb_unlocked_disable_lpm(udev);
 	if (ret) {
 		dev_err(&amp;udev-&gt;dev, &quot;%s Failed to disable LPM\n.&quot;, __func__);
<span class="p_del">-		goto re_enumerate;</span>
<span class="p_add">+		goto re_enumerate_no_bos;</span>
 	}
 	ret = usb_disable_ltm(udev);
 	if (ret) {
 		dev_err(&amp;udev-&gt;dev, &quot;%s Failed to disable LTM\n.&quot;,
 				__func__);
<span class="p_del">-		goto re_enumerate;</span>
<span class="p_add">+		goto re_enumerate_no_bos;</span>
 	}
 
<span class="p_add">+	bos = udev-&gt;bos;</span>
<span class="p_add">+	udev-&gt;bos = NULL;</span>
<span class="p_add">+</span>
 	for (i = 0; i &lt; SET_CONFIG_TRIES; ++i) {
 
 		/* ep0 maxpacket size may change; let the HCD know about it.
<span class="p_chunk">@@ -5463,10 +5485,11 @@</span> <span class="p_context"> done:</span>
 	return 0;
 
 re_enumerate:
<span class="p_del">-	/* LPM state doesn&#39;t matter when we&#39;re about to destroy the device. */</span>
<span class="p_del">-	hub_port_logical_disconnect(parent_hub, port1);</span>
 	usb_release_bos_descriptor(udev);
 	udev-&gt;bos = bos;
<span class="p_add">+re_enumerate_no_bos:</span>
<span class="p_add">+	/* LPM state doesn&#39;t matter when we&#39;re about to destroy the device. */</span>
<span class="p_add">+	hub_port_logical_disconnect(parent_hub, port1);</span>
 	return -ENODEV;
 }
 
<span class="p_header">diff --git a/drivers/usb/core/quirks.c b/drivers/usb/core/quirks.c</span>
<span class="p_header">index 2b978ad9d9ef..0e8e656a045f 100644</span>
<span class="p_header">--- a/drivers/usb/core/quirks.c</span>
<span class="p_header">+++ b/drivers/usb/core/quirks.c</span>
<span class="p_chunk">@@ -188,6 +188,12 @@</span> <span class="p_context"> static const struct usb_device_id usb_quirk_list[] = {</span>
 	/* USB3503 */
 	{ USB_DEVICE(0x0424, 0x3503), .driver_info = USB_QUIRK_RESET_RESUME },
 
<span class="p_add">+	/* Blackmagic Design Intensity Shuttle */</span>
<span class="p_add">+	{ USB_DEVICE(0x1edb, 0xbd3b), .driver_info = USB_QUIRK_NO_LPM },</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Blackmagic Design UltraStudio SDI */</span>
<span class="p_add">+	{ USB_DEVICE(0x1edb, 0xbd4f), .driver_info = USB_QUIRK_NO_LPM },</span>
<span class="p_add">+</span>
 	{ }  /* terminating entry must be last */
 };
 
<span class="p_header">diff --git a/drivers/usb/gadget/pxa27x_udc.c b/drivers/usb/gadget/pxa27x_udc.c</span>
<span class="p_header">index cdf4d678be96..a63dee15bdc7 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/pxa27x_udc.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/pxa27x_udc.c</span>
<span class="p_chunk">@@ -2558,6 +2558,9 @@</span> <span class="p_context"> static int pxa_udc_suspend(struct platform_device *_dev, pm_message_t state)</span>
 	udc-&gt;pullup_resume = udc-&gt;pullup_on;
 	dplus_pullup(udc, 0);
 
<span class="p_add">+	if (udc-&gt;driver)</span>
<span class="p_add">+		udc-&gt;driver-&gt;disconnect(&amp;udc-&gt;gadget);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/usb/host/whci/qset.c b/drivers/usb/host/whci/qset.c</span>
<span class="p_header">index dc31c425ce01..9f1c0538b211 100644</span>
<span class="p_header">--- a/drivers/usb/host/whci/qset.c</span>
<span class="p_header">+++ b/drivers/usb/host/whci/qset.c</span>
<span class="p_chunk">@@ -377,6 +377,10 @@</span> <span class="p_context"> static int qset_fill_page_list(struct whc *whc, struct whc_std *std, gfp_t mem_f</span>
 	if (std-&gt;pl_virt == NULL)
 		return -ENOMEM;
 	std-&gt;dma_addr = dma_map_single(whc-&gt;wusbhc.dev, std-&gt;pl_virt, pl_len, DMA_TO_DEVICE);
<span class="p_add">+	if (dma_mapping_error(whc-&gt;wusbhc.dev, std-&gt;dma_addr)) {</span>
<span class="p_add">+		kfree(std-&gt;pl_virt);</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+	}</span>
 
 	for (p = 0; p &lt; std-&gt;num_pointers; p++) {
 		std-&gt;pl_virt[p].buf_ptr = cpu_to_le64(dma_addr);
<span class="p_header">diff --git a/drivers/usb/host/xhci-hub.c b/drivers/usb/host/xhci-hub.c</span>
<span class="p_header">index 625fdd8b3537..69a70f880429 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-hub.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-hub.c</span>
<span class="p_chunk">@@ -609,8 +609,30 @@</span> <span class="p_context"> static u32 xhci_get_port_status(struct usb_hcd *hcd,</span>
 		if ((raw_port_status &amp; PORT_RESET) ||
 				!(raw_port_status &amp; PORT_PE))
 			return 0xffffffff;
<span class="p_del">-		if (time_after_eq(jiffies,</span>
<span class="p_del">-					bus_state-&gt;resume_done[wIndex])) {</span>
<span class="p_add">+		/* did port event handler already start resume timing? */</span>
<span class="p_add">+		if (!bus_state-&gt;resume_done[wIndex]) {</span>
<span class="p_add">+			/* If not, maybe we are in a host initated resume? */</span>
<span class="p_add">+			if (test_bit(wIndex, &amp;bus_state-&gt;resuming_ports)) {</span>
<span class="p_add">+				/* Host initated resume doesn&#39;t time the resume</span>
<span class="p_add">+				 * signalling using resume_done[].</span>
<span class="p_add">+				 * It manually sets RESUME state, sleeps 20ms</span>
<span class="p_add">+				 * and sets U0 state. This should probably be</span>
<span class="p_add">+				 * changed, but not right now.</span>
<span class="p_add">+				 */</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				/* port resume was discovered now and here,</span>
<span class="p_add">+				 * start resume timing</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				unsigned long timeout = jiffies +</span>
<span class="p_add">+					msecs_to_jiffies(USB_RESUME_TIMEOUT);</span>
<span class="p_add">+</span>
<span class="p_add">+				set_bit(wIndex, &amp;bus_state-&gt;resuming_ports);</span>
<span class="p_add">+				bus_state-&gt;resume_done[wIndex] = timeout;</span>
<span class="p_add">+				mod_timer(&amp;hcd-&gt;rh_timer, timeout);</span>
<span class="p_add">+			}</span>
<span class="p_add">+		/* Has resume been signalled for USB_RESUME_TIME yet? */</span>
<span class="p_add">+		} else if (time_after_eq(jiffies,</span>
<span class="p_add">+					 bus_state-&gt;resume_done[wIndex])) {</span>
 			int time_left;
 
 			xhci_dbg(xhci, &quot;Resume USB2 port %d\n&quot;,
<span class="p_chunk">@@ -651,13 +673,26 @@</span> <span class="p_context"> static u32 xhci_get_port_status(struct usb_hcd *hcd,</span>
 		} else {
 			/*
 			 * The resume has been signaling for less than
<span class="p_del">-			 * 20ms. Report the port status as SUSPEND,</span>
<span class="p_del">-			 * let the usbcore check port status again</span>
<span class="p_del">-			 * and clear resume signaling later.</span>
<span class="p_add">+			 * USB_RESUME_TIME. Report the port status as SUSPEND,</span>
<span class="p_add">+			 * let the usbcore check port status again and clear</span>
<span class="p_add">+			 * resume signaling later.</span>
 			 */
 			status |= USB_PORT_STAT_SUSPEND;
 		}
 	}
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Clear stale usb2 resume signalling variables in case port changed</span>
<span class="p_add">+	 * state during resume signalling. For example on error</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if ((bus_state-&gt;resume_done[wIndex] ||</span>
<span class="p_add">+	     test_bit(wIndex, &amp;bus_state-&gt;resuming_ports)) &amp;&amp;</span>
<span class="p_add">+	    (raw_port_status &amp; PORT_PLS_MASK) != XDEV_U3 &amp;&amp;</span>
<span class="p_add">+	    (raw_port_status &amp; PORT_PLS_MASK) != XDEV_RESUME) {</span>
<span class="p_add">+		bus_state-&gt;resume_done[wIndex] = 0;</span>
<span class="p_add">+		clear_bit(wIndex, &amp;bus_state-&gt;resuming_ports);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
 	if ((raw_port_status &amp; PORT_PLS_MASK) == XDEV_U0 &amp;&amp;
 	    (raw_port_status &amp; PORT_POWER)) {
 		if (bus_state-&gt;suspended_ports &amp; (1 &lt;&lt; wIndex)) {
<span class="p_chunk">@@ -991,6 +1026,7 @@</span> <span class="p_context"> int xhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,</span>
 				if ((temp &amp; PORT_PE) == 0)
 					goto error;
 
<span class="p_add">+				set_bit(wIndex, &amp;bus_state-&gt;resuming_ports);</span>
 				xhci_set_link_state(xhci, port_array, wIndex,
 							XDEV_RESUME);
 				spin_unlock_irqrestore(&amp;xhci-&gt;lock, flags);
<span class="p_chunk">@@ -998,6 +1034,7 @@</span> <span class="p_context"> int xhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,</span>
 				spin_lock_irqsave(&amp;xhci-&gt;lock, flags);
 				xhci_set_link_state(xhci, port_array, wIndex,
 							XDEV_U0);
<span class="p_add">+				clear_bit(wIndex, &amp;bus_state-&gt;resuming_ports);</span>
 			}
 			bus_state-&gt;port_c_suspend |= 1 &lt;&lt; wIndex;
 
<span class="p_header">diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">index 93cbefdacd31..22c9bca66569 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-ring.c</span>
<span class="p_chunk">@@ -1620,7 +1620,8 @@</span> <span class="p_context"> static void handle_port_status(struct xhci_hcd *xhci,</span>
 			 */
 			bogus_port_status = true;
 			goto cleanup;
<span class="p_del">-		} else {</span>
<span class="p_add">+		} else if (!test_bit(faked_port_index,</span>
<span class="p_add">+				     &amp;bus_state-&gt;resuming_ports)) {</span>
 			xhci_dbg(xhci, &quot;resume HS port %d\n&quot;, port_id);
 			bus_state-&gt;resume_done[faked_port_index] = jiffies +
 				msecs_to_jiffies(USB_RESUME_TIMEOUT);
<span class="p_header">diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c</span>
<span class="p_header">index ddece5ecd6fb..20209e870a99 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci.c</span>
<span class="p_chunk">@@ -4758,8 +4758,16 @@</span> <span class="p_context"> int xhci_update_hub_device(struct usb_hcd *hcd, struct usb_device *hdev,</span>
 	ctrl_ctx-&gt;add_flags |= cpu_to_le32(SLOT_FLAG);
 	slot_ctx = xhci_get_slot_ctx(xhci, config_cmd-&gt;in_ctx);
 	slot_ctx-&gt;dev_info |= cpu_to_le32(DEV_HUB);
<span class="p_add">+	/*</span>
<span class="p_add">+	 * refer to section 6.2.2: MTT should be 0 for full speed hub,</span>
<span class="p_add">+	 * but it may be already set to 1 when setup an xHCI virtual</span>
<span class="p_add">+	 * device, so clear it anyway.</span>
<span class="p_add">+	 */</span>
 	if (tt-&gt;multi)
 		slot_ctx-&gt;dev_info |= cpu_to_le32(DEV_MTT);
<span class="p_add">+	else if (hdev-&gt;speed == USB_SPEED_FULL)</span>
<span class="p_add">+		slot_ctx-&gt;dev_info &amp;= cpu_to_le32(~DEV_MTT);</span>
<span class="p_add">+</span>
 	if (xhci-&gt;hci_version &gt; 0x95) {
 		xhci_dbg(xhci, &quot;xHCI version %x needs hub &quot;
 				&quot;TT think time and number of ports\n&quot;,
<span class="p_header">diff --git a/drivers/usb/musb/Kconfig b/drivers/usb/musb/Kconfig</span>
<span class="p_header">index 06cc5d6ea681..dbc56eb5eee4 100644</span>
<span class="p_header">--- a/drivers/usb/musb/Kconfig</span>
<span class="p_header">+++ b/drivers/usb/musb/Kconfig</span>
<span class="p_chunk">@@ -140,7 +140,7 @@</span> <span class="p_context"> config USB_TI_CPPI_DMA</span>
 
 config USB_TI_CPPI41_DMA
 	bool &#39;TI CPPI 4.1 (AM335x)&#39;
<span class="p_del">-	depends on ARCH_OMAP</span>
<span class="p_add">+	depends on ARCH_OMAP &amp;&amp; DMADEVICES</span>
 	select TI_CPPI41
 
 config USB_TUSB_OMAP_DMA
<span class="p_header">diff --git a/drivers/usb/serial/cp210x.c b/drivers/usb/serial/cp210x.c</span>
<span class="p_header">index d11335d4395d..c2bdc5f2a4b1 100644</span>
<span class="p_header">--- a/drivers/usb/serial/cp210x.c</span>
<span class="p_header">+++ b/drivers/usb/serial/cp210x.c</span>
<span class="p_chunk">@@ -132,7 +132,6 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{ USB_DEVICE(0x10C4, 0xEA60) }, /* Silicon Labs factory default */
 	{ USB_DEVICE(0x10C4, 0xEA61) }, /* Silicon Labs factory default */
 	{ USB_DEVICE(0x10C4, 0xEA70) }, /* Silicon Labs factory default */
<span class="p_del">-	{ USB_DEVICE(0x10C4, 0xEA80) }, /* Silicon Labs factory default */</span>
 	{ USB_DEVICE(0x10C4, 0xEA71) }, /* Infinity GPS-MIC-1 Radio Monophone */
 	{ USB_DEVICE(0x10C4, 0xF001) }, /* Elan Digital Systems USBscope50 */
 	{ USB_DEVICE(0x10C4, 0xF002) }, /* Elan Digital Systems USBwave12 */
<span class="p_header">diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c</span>
<span class="p_header">index f51a5d52c0ed..ec1b8f2c1183 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ipaq.c</span>
<span class="p_header">+++ b/drivers/usb/serial/ipaq.c</span>
<span class="p_chunk">@@ -531,7 +531,8 @@</span> <span class="p_context"> static int ipaq_open(struct tty_struct *tty,</span>
 	 * through. Since this has a reasonably high failure rate, we retry
 	 * several times.
 	 */
<span class="p_del">-	while (retries--) {</span>
<span class="p_add">+	while (retries) {</span>
<span class="p_add">+		retries--;</span>
 		result = usb_control_msg(serial-&gt;dev,
 				usb_sndctrlpipe(serial-&gt;dev, 0), 0x22, 0x21,
 				0x1, 0, NULL, 0, 100);
<span class="p_header">diff --git a/drivers/usb/serial/usb-serial-simple.c b/drivers/usb/serial/usb-serial-simple.c</span>
<span class="p_header">index e5ad1ee6cb5f..5c19d3e7b4b8 100644</span>
<span class="p_header">--- a/drivers/usb/serial/usb-serial-simple.c</span>
<span class="p_header">+++ b/drivers/usb/serial/usb-serial-simple.c</span>
<span class="p_chunk">@@ -47,6 +47,7 @@</span> <span class="p_context"> DEVICE(funsoft, FUNSOFT_IDS);</span>
 
 /* Infineon Flashloader driver */
 #define FLASHLOADER_IDS()		\
<span class="p_add">+	{ USB_DEVICE_INTERFACE_CLASS(0x058b, 0x0041, USB_CLASS_CDC_DATA) }, \</span>
 	{ USB_DEVICE(0x8087, 0x0716) }
 DEVICE(flashloader, FLASHLOADER_IDS);
 
<span class="p_header">diff --git a/drivers/usb/storage/uas.c b/drivers/usb/storage/uas.c</span>
<span class="p_header">index 22b3b92ceda2..46aeebde72b9 100644</span>
<span class="p_header">--- a/drivers/usb/storage/uas.c</span>
<span class="p_header">+++ b/drivers/usb/storage/uas.c</span>
<span class="p_chunk">@@ -973,6 +973,10 @@</span> <span class="p_context"> static int uas_slave_configure(struct scsi_device *sdev)</span>
 	if (devinfo-&gt;flags &amp; US_FL_NO_REPORT_OPCODES)
 		sdev-&gt;no_report_opcodes = 1;
 
<span class="p_add">+	/* A few buggy USB-ATA bridges don&#39;t understand FUA */</span>
<span class="p_add">+	if (devinfo-&gt;flags &amp; US_FL_BROKEN_FUA)</span>
<span class="p_add">+		sdev-&gt;broken_fua = 1;</span>
<span class="p_add">+</span>
 	scsi_set_tag_type(sdev, MSG_ORDERED_TAG);
 	scsi_activate_tcq(sdev, devinfo-&gt;qdepth - 2);
 	return 0;
<span class="p_header">diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h</span>
<span class="p_header">index 092de140ef1e..8a49c47657f4 100644</span>
<span class="p_header">--- a/drivers/usb/storage/unusual_devs.h</span>
<span class="p_header">+++ b/drivers/usb/storage/unusual_devs.h</span>
<span class="p_chunk">@@ -1968,7 +1968,7 @@</span> <span class="p_context"> UNUSUAL_DEV(  0x14cd, 0x6600, 0x0201, 0x0201,</span>
 		US_FL_IGNORE_RESIDUE ),
 
 /* Reported by Michael Bsch &lt;m@bues.ch&gt; */
<span class="p_del">-UNUSUAL_DEV(  0x152d, 0x0567, 0x0114, 0x0114,</span>
<span class="p_add">+UNUSUAL_DEV(  0x152d, 0x0567, 0x0114, 0x0116,</span>
 		&quot;JMicron&quot;,
 		&quot;USB to ATA/ATAPI Bridge&quot;,
 		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
<span class="p_header">diff --git a/drivers/usb/storage/unusual_uas.h b/drivers/usb/storage/unusual_uas.h</span>
<span class="p_header">index 30ec9be3b198..ac2f9d491419 100644</span>
<span class="p_header">--- a/drivers/usb/storage/unusual_uas.h</span>
<span class="p_header">+++ b/drivers/usb/storage/unusual_uas.h</span>
<span class="p_chunk">@@ -122,7 +122,7 @@</span> <span class="p_context"> UNUSUAL_DEV(0x152d, 0x0567, 0x0000, 0x9999,</span>
 		&quot;JMicron&quot;,
 		&quot;JMS567&quot;,
 		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
<span class="p_del">-		US_FL_NO_REPORT_OPCODES),</span>
<span class="p_add">+		US_FL_BROKEN_FUA | US_FL_NO_REPORT_OPCODES),</span>
 
 /* Reported-by: Hans de Goede &lt;hdegoede@redhat.com&gt; */
 UNUSUAL_DEV(0x2109, 0x0711, 0x0000, 0x9999,
<span class="p_header">diff --git a/drivers/video/fbdev/fsl-diu-fb.c b/drivers/video/fbdev/fsl-diu-fb.c</span>
<span class="p_header">index e8758b9c3bcc..7b1fa06f4b72 100644</span>
<span class="p_header">--- a/drivers/video/fbdev/fsl-diu-fb.c</span>
<span class="p_header">+++ b/drivers/video/fbdev/fsl-diu-fb.c</span>
<span class="p_chunk">@@ -479,7 +479,10 @@</span> <span class="p_context"> static enum fsl_diu_monitor_port fsl_diu_name_to_port(const char *s)</span>
 			port = FSL_DIU_PORT_DLVDS;
 	}
 
<span class="p_del">-	return diu_ops.valid_monitor_port(port);</span>
<span class="p_add">+	if (diu_ops.valid_monitor_port)</span>
<span class="p_add">+		port = diu_ops.valid_monitor_port(port);</span>
<span class="p_add">+</span>
<span class="p_add">+	return port;</span>
 }
 
 /*
<span class="p_chunk">@@ -1909,6 +1912,14 @@</span> <span class="p_context"> static int __init fsl_diu_init(void)</span>
 #else
 	monitor_port = fsl_diu_name_to_port(monitor_string);
 #endif
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Must to verify set_pixel_clock. If not implement on platform,</span>
<span class="p_add">+	 * then that means that there is no platform support for the DIU.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!diu_ops.set_pixel_clock)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	pr_info(&quot;Freescale Display Interface Unit (DIU) framebuffer driver\n&quot;);
 
 #ifdef CONFIG_NOT_COHERENT_CACHE
<span class="p_header">diff --git a/drivers/virtio/virtio.c b/drivers/virtio/virtio.c</span>
<span class="p_header">index fed0ce198ae3..64eba4f51f71 100644</span>
<span class="p_header">--- a/drivers/virtio/virtio.c</span>
<span class="p_header">+++ b/drivers/virtio/virtio.c</span>
<span class="p_chunk">@@ -249,6 +249,7 @@</span> <span class="p_context"> static int virtio_init(void)</span>
 static void __exit virtio_exit(void)
 {
 	bus_unregister(&amp;virtio_bus);
<span class="p_add">+	ida_destroy(&amp;virtio_index_ida);</span>
 }
 core_initcall(virtio_init);
 module_exit(virtio_exit);
<span class="p_header">diff --git a/drivers/xen/events/events_fifo.c b/drivers/xen/events/events_fifo.c</span>
<span class="p_header">index 48dcb2e97b90..e208af22b182 100644</span>
<span class="p_header">--- a/drivers/xen/events/events_fifo.c</span>
<span class="p_header">+++ b/drivers/xen/events/events_fifo.c</span>
<span class="p_chunk">@@ -281,7 +281,8 @@</span> <span class="p_context"> static void handle_irq_for_port(unsigned port)</span>
 
 static void consume_one_event(unsigned cpu,
 			      struct evtchn_fifo_control_block *control_block,
<span class="p_del">-			      unsigned priority, unsigned long *ready)</span>
<span class="p_add">+			      unsigned priority, unsigned long *ready,</span>
<span class="p_add">+			      bool drop)</span>
 {
 	struct evtchn_fifo_queue *q = &amp;per_cpu(cpu_queue, cpu);
 	uint32_t head;
<span class="p_chunk">@@ -313,13 +314,17 @@</span> <span class="p_context"> static void consume_one_event(unsigned cpu,</span>
 	if (head == 0)
 		clear_bit(priority, ready);
 
<span class="p_del">-	if (evtchn_fifo_is_pending(port) &amp;&amp; !evtchn_fifo_is_masked(port))</span>
<span class="p_del">-		handle_irq_for_port(port);</span>
<span class="p_add">+	if (evtchn_fifo_is_pending(port) &amp;&amp; !evtchn_fifo_is_masked(port)) {</span>
<span class="p_add">+		if (unlikely(drop))</span>
<span class="p_add">+			pr_warn(&quot;Dropping pending event for port %u\n&quot;, port);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			handle_irq_for_port(port);</span>
<span class="p_add">+	}</span>
 
 	q-&gt;head[priority] = head;
 }
 
<span class="p_del">-static void evtchn_fifo_handle_events(unsigned cpu)</span>
<span class="p_add">+static void __evtchn_fifo_handle_events(unsigned cpu, bool drop)</span>
 {
 	struct evtchn_fifo_control_block *control_block;
 	unsigned long ready;
<span class="p_chunk">@@ -331,11 +336,16 @@</span> <span class="p_context"> static void evtchn_fifo_handle_events(unsigned cpu)</span>
 
 	while (ready) {
 		q = find_first_bit(BM(&amp;ready), EVTCHN_FIFO_MAX_QUEUES);
<span class="p_del">-		consume_one_event(cpu, control_block, q, &amp;ready);</span>
<span class="p_add">+		consume_one_event(cpu, control_block, q, &amp;ready, drop);</span>
 		ready |= xchg(&amp;control_block-&gt;ready, 0);
 	}
 }
 
<span class="p_add">+static void evtchn_fifo_handle_events(unsigned cpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	__evtchn_fifo_handle_events(cpu, false);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void evtchn_fifo_resume(void)
 {
 	unsigned cpu;
<span class="p_chunk">@@ -420,6 +430,9 @@</span> <span class="p_context"> static int evtchn_fifo_cpu_notification(struct notifier_block *self,</span>
 		if (!per_cpu(cpu_control_block, cpu))
 			ret = evtchn_fifo_alloc_control_block(cpu);
 		break;
<span class="p_add">+	case CPU_DEAD:</span>
<span class="p_add">+		__evtchn_fifo_handle_events(cpu, true);</span>
<span class="p_add">+		break;</span>
 	default:
 		break;
 	}
<span class="p_header">diff --git a/drivers/xen/xen-pciback/pciback.h b/drivers/xen/xen-pciback/pciback.h</span>
<span class="p_header">index f72af87640e0..560b3ecbcba8 100644</span>
<span class="p_header">--- a/drivers/xen/xen-pciback/pciback.h</span>
<span class="p_header">+++ b/drivers/xen/xen-pciback/pciback.h</span>
<span class="p_chunk">@@ -37,6 +37,7 @@</span> <span class="p_context"> struct xen_pcibk_device {</span>
 	struct xen_pci_sharedinfo *sh_info;
 	unsigned long flags;
 	struct work_struct op_work;
<span class="p_add">+	struct xen_pci_op op;</span>
 };
 
 struct xen_pcibk_dev_data {
<span class="p_header">diff --git a/drivers/xen/xen-pciback/pciback_ops.c b/drivers/xen/xen-pciback/pciback_ops.c</span>
<span class="p_header">index c4a0666de6f5..73dafdc494aa 100644</span>
<span class="p_header">--- a/drivers/xen/xen-pciback/pciback_ops.c</span>
<span class="p_header">+++ b/drivers/xen/xen-pciback/pciback_ops.c</span>
<span class="p_chunk">@@ -70,6 +70,13 @@</span> <span class="p_context"> static void xen_pcibk_control_isr(struct pci_dev *dev, int reset)</span>
 		enable ? &quot;enable&quot; : &quot;disable&quot;);
 
 	if (enable) {
<span class="p_add">+		/*</span>
<span class="p_add">+		 * The MSI or MSI-X should not have an IRQ handler. Otherwise</span>
<span class="p_add">+		 * if the guest terminates we BUG_ON in free_msi_irqs.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (dev-&gt;msi_enabled || dev-&gt;msix_enabled)</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+</span>
 		rc = request_irq(dev_data-&gt;irq,
 				xen_pcibk_guest_interrupt, IRQF_SHARED,
 				dev_data-&gt;irq_name, dev);
<span class="p_chunk">@@ -144,7 +151,12 @@</span> <span class="p_context"> int xen_pcibk_enable_msi(struct xen_pcibk_device *pdev,</span>
 	if (unlikely(verbose_request))
 		printk(KERN_DEBUG DRV_NAME &quot;: %s: enable MSI\n&quot;, pci_name(dev));
 
<span class="p_del">-	status = pci_enable_msi(dev);</span>
<span class="p_add">+	if (dev-&gt;msi_enabled)</span>
<span class="p_add">+		status = -EALREADY;</span>
<span class="p_add">+	else if (dev-&gt;msix_enabled)</span>
<span class="p_add">+		status = -ENXIO;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		status = pci_enable_msi(dev);</span>
 
 	if (status) {
 		pr_warn_ratelimited(&quot;%s: error enabling MSI for guest %u: err %d\n&quot;,
<span class="p_chunk">@@ -173,20 +185,23 @@</span> <span class="p_context"> static</span>
 int xen_pcibk_disable_msi(struct xen_pcibk_device *pdev,
 			  struct pci_dev *dev, struct xen_pci_op *op)
 {
<span class="p_del">-	struct xen_pcibk_dev_data *dev_data;</span>
<span class="p_del">-</span>
 	if (unlikely(verbose_request))
 		printk(KERN_DEBUG DRV_NAME &quot;: %s: disable MSI\n&quot;,
 		       pci_name(dev));
<span class="p_del">-	pci_disable_msi(dev);</span>
 
<span class="p_add">+	if (dev-&gt;msi_enabled) {</span>
<span class="p_add">+		struct xen_pcibk_dev_data *dev_data;</span>
<span class="p_add">+</span>
<span class="p_add">+		pci_disable_msi(dev);</span>
<span class="p_add">+</span>
<span class="p_add">+		dev_data = pci_get_drvdata(dev);</span>
<span class="p_add">+		if (dev_data)</span>
<span class="p_add">+			dev_data-&gt;ack_intr = 1;</span>
<span class="p_add">+	}</span>
 	op-&gt;value = dev-&gt;irq ? xen_pirq_from_irq(dev-&gt;irq) : 0;
 	if (unlikely(verbose_request))
 		printk(KERN_DEBUG DRV_NAME &quot;: %s: MSI: %d\n&quot;, pci_name(dev),
 			op-&gt;value);
<span class="p_del">-	dev_data = pci_get_drvdata(dev);</span>
<span class="p_del">-	if (dev_data)</span>
<span class="p_del">-		dev_data-&gt;ack_intr = 1;</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -197,13 +212,26 @@</span> <span class="p_context"> int xen_pcibk_enable_msix(struct xen_pcibk_device *pdev,</span>
 	struct xen_pcibk_dev_data *dev_data;
 	int i, result;
 	struct msix_entry *entries;
<span class="p_add">+	u16 cmd;</span>
 
 	if (unlikely(verbose_request))
 		printk(KERN_DEBUG DRV_NAME &quot;: %s: enable MSI-X\n&quot;,
 		       pci_name(dev));
<span class="p_add">+</span>
 	if (op-&gt;value &gt; SH_INFO_MAX_VEC)
 		return -EINVAL;
 
<span class="p_add">+	if (dev-&gt;msix_enabled)</span>
<span class="p_add">+		return -EALREADY;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * PCI_COMMAND_MEMORY must be enabled, otherwise we may not be able</span>
<span class="p_add">+	 * to access the BARs where the MSI-X entries reside.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	pci_read_config_word(dev, PCI_COMMAND, &amp;cmd);</span>
<span class="p_add">+	if (dev-&gt;msi_enabled || !(cmd &amp; PCI_COMMAND_MEMORY))</span>
<span class="p_add">+		return -ENXIO;</span>
<span class="p_add">+</span>
 	entries = kmalloc(op-&gt;value * sizeof(*entries), GFP_KERNEL);
 	if (entries == NULL)
 		return -ENOMEM;
<span class="p_chunk">@@ -245,23 +273,27 @@</span> <span class="p_context"> static</span>
 int xen_pcibk_disable_msix(struct xen_pcibk_device *pdev,
 			   struct pci_dev *dev, struct xen_pci_op *op)
 {
<span class="p_del">-	struct xen_pcibk_dev_data *dev_data;</span>
 	if (unlikely(verbose_request))
 		printk(KERN_DEBUG DRV_NAME &quot;: %s: disable MSI-X\n&quot;,
 			pci_name(dev));
<span class="p_del">-	pci_disable_msix(dev);</span>
 
<span class="p_add">+	if (dev-&gt;msix_enabled) {</span>
<span class="p_add">+		struct xen_pcibk_dev_data *dev_data;</span>
<span class="p_add">+</span>
<span class="p_add">+		pci_disable_msix(dev);</span>
<span class="p_add">+</span>
<span class="p_add">+		dev_data = pci_get_drvdata(dev);</span>
<span class="p_add">+		if (dev_data)</span>
<span class="p_add">+			dev_data-&gt;ack_intr = 1;</span>
<span class="p_add">+	}</span>
 	/*
 	 * SR-IOV devices (which don&#39;t have any legacy IRQ) have
 	 * an undefined IRQ value of zero.
 	 */
 	op-&gt;value = dev-&gt;irq ? xen_pirq_from_irq(dev-&gt;irq) : 0;
 	if (unlikely(verbose_request))
<span class="p_del">-		printk(KERN_DEBUG DRV_NAME &quot;: %s: MSI-X: %d\n&quot;, pci_name(dev),</span>
<span class="p_del">-			op-&gt;value);</span>
<span class="p_del">-	dev_data = pci_get_drvdata(dev);</span>
<span class="p_del">-	if (dev_data)</span>
<span class="p_del">-		dev_data-&gt;ack_intr = 1;</span>
<span class="p_add">+		printk(KERN_DEBUG DRV_NAME &quot;: %s: MSI-X: %d\n&quot;,</span>
<span class="p_add">+		       pci_name(dev), op-&gt;value);</span>
 	return 0;
 }
 #endif
<span class="p_chunk">@@ -298,9 +330,11 @@</span> <span class="p_context"> void xen_pcibk_do_op(struct work_struct *data)</span>
 		container_of(data, struct xen_pcibk_device, op_work);
 	struct pci_dev *dev;
 	struct xen_pcibk_dev_data *dev_data = NULL;
<span class="p_del">-	struct xen_pci_op *op = &amp;pdev-&gt;sh_info-&gt;op;</span>
<span class="p_add">+	struct xen_pci_op *op = &amp;pdev-&gt;op;</span>
 	int test_intx = 0;
 
<span class="p_add">+	*op = pdev-&gt;sh_info-&gt;op;</span>
<span class="p_add">+	barrier();</span>
 	dev = xen_pcibk_get_pci_dev(pdev, op-&gt;domain, op-&gt;bus, op-&gt;devfn);
 
 	if (dev == NULL)
<span class="p_chunk">@@ -342,6 +376,17 @@</span> <span class="p_context"> void xen_pcibk_do_op(struct work_struct *data)</span>
 		if ((dev_data-&gt;enable_intx != test_intx))
 			xen_pcibk_control_isr(dev, 0 /* no reset */);
 	}
<span class="p_add">+	pdev-&gt;sh_info-&gt;op.err = op-&gt;err;</span>
<span class="p_add">+	pdev-&gt;sh_info-&gt;op.value = op-&gt;value;</span>
<span class="p_add">+#ifdef CONFIG_PCI_MSI</span>
<span class="p_add">+	if (op-&gt;cmd == XEN_PCI_OP_enable_msix &amp;&amp; op-&gt;err == 0) {</span>
<span class="p_add">+		unsigned int i;</span>
<span class="p_add">+</span>
<span class="p_add">+		for (i = 0; i &lt; op-&gt;value; i++)</span>
<span class="p_add">+			pdev-&gt;sh_info-&gt;op.msix_entries[i].vector =</span>
<span class="p_add">+				op-&gt;msix_entries[i].vector;</span>
<span class="p_add">+	}</span>
<span class="p_add">+#endif</span>
 	/* Tell the driver domain that we&#39;re done. */
 	wmb();
 	clear_bit(_XEN_PCIF_active, (unsigned long *)&amp;pdev-&gt;sh_info-&gt;flags);
<span class="p_header">diff --git a/fs/9p/vfs_inode.c b/fs/9p/vfs_inode.c</span>
<span class="p_header">index 509459d71ed0..bdfcea010c9f 100644</span>
<span class="p_header">--- a/fs/9p/vfs_inode.c</span>
<span class="p_header">+++ b/fs/9p/vfs_inode.c</span>
<span class="p_chunk">@@ -451,9 +451,9 @@</span> <span class="p_context"> void v9fs_evict_inode(struct inode *inode)</span>
 {
 	struct v9fs_inode *v9inode = V9FS_I(inode);
 
<span class="p_del">-	truncate_inode_pages_final(inode-&gt;i_mapping);</span>
<span class="p_add">+	truncate_inode_pages_final(&amp;inode-&gt;i_data);</span>
 	clear_inode(inode);
<span class="p_del">-	filemap_fdatawrite(inode-&gt;i_mapping);</span>
<span class="p_add">+	filemap_fdatawrite(&amp;inode-&gt;i_data);</span>
 
 	v9fs_cache_inode_put_cookie(inode);
 	/* clunk the fid stashed in writeback_fid */
<span class="p_header">diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h</span>
<span class="p_header">index e00dc9772402..0798c0bfe57b 100644</span>
<span class="p_header">--- a/fs/ext4/ext4.h</span>
<span class="p_header">+++ b/fs/ext4/ext4.h</span>
<span class="p_chunk">@@ -26,6 +26,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/seqlock.h&gt;
 #include &lt;linux/mutex.h&gt;
 #include &lt;linux/timer.h&gt;
<span class="p_add">+#include &lt;linux/version.h&gt;</span>
 #include &lt;linux/wait.h&gt;
 #include &lt;linux/blockgroup_lock.h&gt;
 #include &lt;linux/percpu_counter.h&gt;
<span class="p_chunk">@@ -727,19 +728,55 @@</span> <span class="p_context"> struct move_extent {</span>
 	&lt;= (EXT4_GOOD_OLD_INODE_SIZE +			\
 	    (einode)-&gt;i_extra_isize))			\
 
<span class="p_add">+/*</span>
<span class="p_add">+ * We use an encoding that preserves the times for extra epoch &quot;00&quot;:</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * extra  msb of                         adjust for signed</span>
<span class="p_add">+ * epoch  32-bit                         32-bit tv_sec to</span>
<span class="p_add">+ * bits   time    decoded 64-bit tv_sec  64-bit tv_sec      valid time range</span>
<span class="p_add">+ * 0 0    1    -0x80000000..-0x00000001  0x000000000 1901-12-13..1969-12-31</span>
<span class="p_add">+ * 0 0    0    0x000000000..0x07fffffff  0x000000000 1970-01-01..2038-01-19</span>
<span class="p_add">+ * 0 1    1    0x080000000..0x0ffffffff  0x100000000 2038-01-19..2106-02-07</span>
<span class="p_add">+ * 0 1    0    0x100000000..0x17fffffff  0x100000000 2106-02-07..2174-02-25</span>
<span class="p_add">+ * 1 0    1    0x180000000..0x1ffffffff  0x200000000 2174-02-25..2242-03-16</span>
<span class="p_add">+ * 1 0    0    0x200000000..0x27fffffff  0x200000000 2242-03-16..2310-04-04</span>
<span class="p_add">+ * 1 1    1    0x280000000..0x2ffffffff  0x300000000 2310-04-04..2378-04-22</span>
<span class="p_add">+ * 1 1    0    0x300000000..0x37fffffff  0x300000000 2378-04-22..2446-05-10</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Note that previous versions of the kernel on 64-bit systems would</span>
<span class="p_add">+ * incorrectly use extra epoch bits 1,1 for dates between 1901 and</span>
<span class="p_add">+ * 1970.  e2fsck will correct this, assuming that it is run on the</span>
<span class="p_add">+ * affected filesystem before 2242.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
 static inline __le32 ext4_encode_extra_time(struct timespec *time)
 {
<span class="p_del">-       return cpu_to_le32((sizeof(time-&gt;tv_sec) &gt; 4 ?</span>
<span class="p_del">-			   (time-&gt;tv_sec &gt;&gt; 32) &amp; EXT4_EPOCH_MASK : 0) |</span>
<span class="p_del">-                          ((time-&gt;tv_nsec &lt;&lt; EXT4_EPOCH_BITS) &amp; EXT4_NSEC_MASK));</span>
<span class="p_add">+	u32 extra = sizeof(time-&gt;tv_sec) &gt; 4 ?</span>
<span class="p_add">+		((time-&gt;tv_sec - (s32)time-&gt;tv_sec) &gt;&gt; 32) &amp; EXT4_EPOCH_MASK : 0;</span>
<span class="p_add">+	return cpu_to_le32(extra | (time-&gt;tv_nsec &lt;&lt; EXT4_EPOCH_BITS));</span>
 }
 
 static inline void ext4_decode_extra_time(struct timespec *time, __le32 extra)
 {
<span class="p_del">-       if (sizeof(time-&gt;tv_sec) &gt; 4)</span>
<span class="p_del">-	       time-&gt;tv_sec |= (__u64)(le32_to_cpu(extra) &amp; EXT4_EPOCH_MASK)</span>
<span class="p_del">-			       &lt;&lt; 32;</span>
<span class="p_del">-       time-&gt;tv_nsec = (le32_to_cpu(extra) &amp; EXT4_NSEC_MASK) &gt;&gt; EXT4_EPOCH_BITS;</span>
<span class="p_add">+	if (unlikely(sizeof(time-&gt;tv_sec) &gt; 4 &amp;&amp;</span>
<span class="p_add">+			(extra &amp; cpu_to_le32(EXT4_EPOCH_MASK)))) {</span>
<span class="p_add">+#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(4,20,0)</span>
<span class="p_add">+		/* Handle legacy encoding of pre-1970 dates with epoch</span>
<span class="p_add">+		 * bits 1,1.  We assume that by kernel version 4.20,</span>
<span class="p_add">+		 * everyone will have run fsck over the affected</span>
<span class="p_add">+		 * filesystems to correct the problem.  (This</span>
<span class="p_add">+		 * backwards compatibility may be removed before this</span>
<span class="p_add">+		 * time, at the discretion of the ext4 developers.)</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		u64 extra_bits = le32_to_cpu(extra) &amp; EXT4_EPOCH_MASK;</span>
<span class="p_add">+		if (extra_bits == 3 &amp;&amp; ((time-&gt;tv_sec) &amp; 0x80000000) != 0)</span>
<span class="p_add">+			extra_bits = 0;</span>
<span class="p_add">+		time-&gt;tv_sec += extra_bits &lt;&lt; 32;</span>
<span class="p_add">+#else</span>
<span class="p_add">+		time-&gt;tv_sec += (u64)(le32_to_cpu(extra) &amp; EXT4_EPOCH_MASK) &lt;&lt; 32;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	}</span>
<span class="p_add">+	time-&gt;tv_nsec = (le32_to_cpu(extra) &amp; EXT4_NSEC_MASK) &gt;&gt; EXT4_EPOCH_BITS;</span>
 }
 
 #define EXT4_INODE_SET_XTIME(xtime, inode, raw_inode)			       \
<span class="p_header">diff --git a/fs/fuse/file.c b/fs/fuse/file.c</span>
<span class="p_header">index caa8d95b24e8..e2a2c14a90ee 100644</span>
<span class="p_header">--- a/fs/fuse/file.c</span>
<span class="p_header">+++ b/fs/fuse/file.c</span>
<span class="p_chunk">@@ -1088,6 +1088,7 @@</span> <span class="p_context"> static ssize_t fuse_fill_write_pages(struct fuse_req *req,</span>
 		tmp = iov_iter_copy_from_user_atomic(page, ii, offset, bytes);
 		flush_dcache_page(page);
 
<span class="p_add">+		iov_iter_advance(ii, tmp);</span>
 		if (!tmp) {
 			unlock_page(page);
 			page_cache_release(page);
<span class="p_chunk">@@ -1100,7 +1101,6 @@</span> <span class="p_context"> static ssize_t fuse_fill_write_pages(struct fuse_req *req,</span>
 		req-&gt;page_descs[req-&gt;num_pages].length = tmp;
 		req-&gt;num_pages++;
 
<span class="p_del">-		iov_iter_advance(ii, tmp);</span>
 		count += tmp;
 		pos += tmp;
 		offset += tmp;
<span class="p_header">diff --git a/fs/jbd2/transaction.c b/fs/jbd2/transaction.c</span>
<span class="p_header">index 99ebbd72a064..77303ba0c270 100644</span>
<span class="p_header">--- a/fs/jbd2/transaction.c</span>
<span class="p_header">+++ b/fs/jbd2/transaction.c</span>
<span class="p_chunk">@@ -2064,6 +2064,7 @@</span> <span class="p_context"> static int journal_unmap_buffer(journal_t *journal, struct buffer_head *bh,</span>
 
 		if (!buffer_dirty(bh)) {
 			/* bdflush has written it.  We can drop it now */
<span class="p_add">+			__jbd2_journal_remove_checkpoint(jh);</span>
 			goto zap_buffer;
 		}
 
<span class="p_chunk">@@ -2093,6 +2094,7 @@</span> <span class="p_context"> static int journal_unmap_buffer(journal_t *journal, struct buffer_head *bh,</span>
 				/* The orphan record&#39;s transaction has
 				 * committed.  We can cleanse this buffer */
 				clear_buffer_jbddirty(bh);
<span class="p_add">+				__jbd2_journal_remove_checkpoint(jh);</span>
 				goto zap_buffer;
 			}
 		}
<span class="p_header">diff --git a/fs/ocfs2/namei.c b/fs/ocfs2/namei.c</span>
<span class="p_header">index dbf21ca69ee8..e2f3a6c5224f 100644</span>
<span class="p_header">--- a/fs/ocfs2/namei.c</span>
<span class="p_header">+++ b/fs/ocfs2/namei.c</span>
<span class="p_chunk">@@ -356,13 +356,11 @@</span> <span class="p_context"> static int ocfs2_mknod(struct inode *dir,</span>
 		goto leave;
 	}
 
<span class="p_del">-	status = posix_acl_create(dir, &amp;mode, &amp;default_acl, &amp;acl);</span>
<span class="p_add">+	status = posix_acl_create(dir, &amp;inode-&gt;i_mode, &amp;default_acl, &amp;acl);</span>
 	if (status) {
 		mlog_errno(status);
 		goto leave;
 	}
<span class="p_del">-	/* update inode-&gt;i_mode after mask with &quot;umask&quot;. */</span>
<span class="p_del">-	inode-&gt;i_mode = mode;</span>
 
 	handle = ocfs2_start_trans(osb, ocfs2_mknod_credits(osb-&gt;sb,
 							    S_ISDIR(mode),
<span class="p_header">diff --git a/fs/ocfs2/resize.c b/fs/ocfs2/resize.c</span>
<span class="p_header">index d5da6f624142..79b8021302b3 100644</span>
<span class="p_header">--- a/fs/ocfs2/resize.c</span>
<span class="p_header">+++ b/fs/ocfs2/resize.c</span>
<span class="p_chunk">@@ -54,11 +54,12 @@</span> <span class="p_context"></span>
 static u16 ocfs2_calc_new_backup_super(struct inode *inode,
 				       struct ocfs2_group_desc *gd,
 				       u16 cl_cpg,
<span class="p_add">+				       u16 old_bg_clusters,</span>
 				       int set)
 {
 	int i;
 	u16 backups = 0;
<span class="p_del">-	u32 cluster;</span>
<span class="p_add">+	u32 cluster, lgd_cluster;</span>
 	u64 blkno, gd_blkno, lgd_blkno = le64_to_cpu(gd-&gt;bg_blkno);
 
 	for (i = 0; i &lt; OCFS2_MAX_BACKUP_SUPERBLOCKS; i++) {
<span class="p_chunk">@@ -71,6 +72,12 @@</span> <span class="p_context"> static u16 ocfs2_calc_new_backup_super(struct inode *inode,</span>
 		else if (gd_blkno &gt; lgd_blkno)
 			break;
 
<span class="p_add">+		/* check if already done backup super */</span>
<span class="p_add">+		lgd_cluster = ocfs2_blocks_to_clusters(inode-&gt;i_sb, lgd_blkno);</span>
<span class="p_add">+		lgd_cluster += old_bg_clusters;</span>
<span class="p_add">+		if (lgd_cluster &gt;= cluster)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
 		if (set)
 			ocfs2_set_bit(cluster % cl_cpg,
 				      (unsigned long *)gd-&gt;bg_bitmap);
<span class="p_chunk">@@ -99,6 +106,7 @@</span> <span class="p_context"> static int ocfs2_update_last_group_and_inode(handle_t *handle,</span>
 	u16 chain, num_bits, backups = 0;
 	u16 cl_bpc = le16_to_cpu(cl-&gt;cl_bpc);
 	u16 cl_cpg = le16_to_cpu(cl-&gt;cl_cpg);
<span class="p_add">+	u16 old_bg_clusters;</span>
 
 	trace_ocfs2_update_last_group_and_inode(new_clusters,
 						first_new_cluster);
<span class="p_chunk">@@ -112,6 +120,7 @@</span> <span class="p_context"> static int ocfs2_update_last_group_and_inode(handle_t *handle,</span>
 
 	group = (struct ocfs2_group_desc *)group_bh-&gt;b_data;
 
<span class="p_add">+	old_bg_clusters = le16_to_cpu(group-&gt;bg_bits) / cl_bpc;</span>
 	/* update the group first. */
 	num_bits = new_clusters * cl_bpc;
 	le16_add_cpu(&amp;group-&gt;bg_bits, num_bits);
<span class="p_chunk">@@ -125,7 +134,7 @@</span> <span class="p_context"> static int ocfs2_update_last_group_and_inode(handle_t *handle,</span>
 				     OCFS2_FEATURE_COMPAT_BACKUP_SB)) {
 		backups = ocfs2_calc_new_backup_super(bm_inode,
 						     group,
<span class="p_del">-						     cl_cpg, 1);</span>
<span class="p_add">+						     cl_cpg, old_bg_clusters, 1);</span>
 		le16_add_cpu(&amp;group-&gt;bg_free_bits_count, -1 * backups);
 	}
 
<span class="p_chunk">@@ -163,7 +172,7 @@</span> <span class="p_context"> out_rollback:</span>
 	if (ret &lt; 0) {
 		ocfs2_calc_new_backup_super(bm_inode,
 					    group,
<span class="p_del">-					    cl_cpg, 0);</span>
<span class="p_add">+					    cl_cpg, old_bg_clusters, 0);</span>
 		le16_add_cpu(&amp;group-&gt;bg_free_bits_count, backups);
 		le16_add_cpu(&amp;group-&gt;bg_bits, -1 * num_bits);
 		le16_add_cpu(&amp;group-&gt;bg_free_bits_count, -1 * num_bits);
<span class="p_header">diff --git a/include/linux/enclosure.h b/include/linux/enclosure.h</span>
<span class="p_header">index 9a33c5f7e126..f6c229e2bffa 100644</span>
<span class="p_header">--- a/include/linux/enclosure.h</span>
<span class="p_header">+++ b/include/linux/enclosure.h</span>
<span class="p_chunk">@@ -29,7 +29,11 @@</span> <span class="p_context"></span>
 /* A few generic types ... taken from ses-2 */
 enum enclosure_component_type {
 	ENCLOSURE_COMPONENT_DEVICE = 0x01,
<span class="p_add">+	ENCLOSURE_COMPONENT_CONTROLLER_ELECTRONICS = 0x07,</span>
<span class="p_add">+	ENCLOSURE_COMPONENT_SCSI_TARGET_PORT = 0x14,</span>
<span class="p_add">+	ENCLOSURE_COMPONENT_SCSI_INITIATOR_PORT = 0x15,</span>
 	ENCLOSURE_COMPONENT_ARRAY_DEVICE = 0x17,
<span class="p_add">+	ENCLOSURE_COMPONENT_SAS_EXPANDER = 0x18,</span>
 };
 
 /* ses-2 common element status */
<span class="p_header">diff --git a/include/linux/filter.h b/include/linux/filter.h</span>
<span class="p_header">index a7e3c48d73a7..02f857260bcb 100644</span>
<span class="p_header">--- a/include/linux/filter.h</span>
<span class="p_header">+++ b/include/linux/filter.h</span>
<span class="p_chunk">@@ -373,6 +373,25 @@</span> <span class="p_context"> void bpf_int_jit_compile(struct sk_filter *fp);</span>
 
 #define BPF_ANC		BIT(15)
 
<span class="p_add">+static inline bool bpf_needs_clear_a(const struct sock_filter *first)</span>
<span class="p_add">+{</span>
<span class="p_add">+	switch (first-&gt;code) {</span>
<span class="p_add">+	case BPF_RET | BPF_K:</span>
<span class="p_add">+	case BPF_LD | BPF_W | BPF_LEN:</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	case BPF_LD | BPF_W | BPF_ABS:</span>
<span class="p_add">+	case BPF_LD | BPF_H | BPF_ABS:</span>
<span class="p_add">+	case BPF_LD | BPF_B | BPF_ABS:</span>
<span class="p_add">+		if (first-&gt;k == SKF_AD_OFF + SKF_AD_ALU_XOR_X)</span>
<span class="p_add">+			return true;</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline u16 bpf_anc_helper(const struct sock_filter *ftest)
 {
 	BUG_ON(ftest-&gt;code &amp; BPF_ANC);
<span class="p_header">diff --git a/include/linux/ftrace.h b/include/linux/ftrace.h</span>
<span class="p_header">index 721de254ba7a..c314fe2e0f46 100644</span>
<span class="p_header">--- a/include/linux/ftrace.h</span>
<span class="p_header">+++ b/include/linux/ftrace.h</span>
<span class="p_chunk">@@ -541,6 +541,7 @@</span> <span class="p_context"> extern int ftrace_arch_read_dyn_info(char *buf, int size);</span>
 
 extern int skip_trace(unsigned long ip);
 extern void ftrace_module_init(struct module *mod);
<span class="p_add">+extern void ftrace_release_mod(struct module *mod);</span>
 
 extern void ftrace_disable_daemon(void);
 extern void ftrace_enable_daemon(void);
<span class="p_header">diff --git a/include/linux/mmdebug.h b/include/linux/mmdebug.h</span>
<span class="p_header">index edd82a105220..e23860eb29c1 100644</span>
<span class="p_header">--- a/include/linux/mmdebug.h</span>
<span class="p_header">+++ b/include/linux/mmdebug.h</span>
<span class="p_chunk">@@ -1,6 +1,7 @@</span> <span class="p_context"></span>
 #ifndef LINUX_MM_DEBUG_H
 #define LINUX_MM_DEBUG_H 1
 
<span class="p_add">+#include &lt;linux/bug.h&gt;</span>
 #include &lt;linux/stringify.h&gt;
 
 struct page;
<span class="p_header">diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h</span>
<span class="p_header">index 94038f93f145..010bc80be91c 100644</span>
<span class="p_header">--- a/include/linux/skbuff.h</span>
<span class="p_header">+++ b/include/linux/skbuff.h</span>
<span class="p_chunk">@@ -2525,7 +2525,7 @@</span> <span class="p_context"> unsigned int datagram_poll(struct file *file, struct socket *sock,</span>
 int skb_copy_datagram_iovec(const struct sk_buff *from, int offset,
 			    struct iovec *to, int size);
 int skb_copy_and_csum_datagram_iovec(struct sk_buff *skb, int hlen,
<span class="p_del">-				     struct iovec *iov, int len);</span>
<span class="p_add">+				     struct iovec *iov);</span>
 int skb_copy_datagram_from_iovec(struct sk_buff *skb, int offset,
 				 const struct iovec *from, int from_offset,
 				 int len);
<span class="p_header">diff --git a/include/linux/usb/quirks.h b/include/linux/usb/quirks.h</span>
<span class="p_header">index 4a185a0f6242..8f4f2214652f 100644</span>
<span class="p_header">--- a/include/linux/usb/quirks.h</span>
<span class="p_header">+++ b/include/linux/usb/quirks.h</span>
<span class="p_chunk">@@ -47,4 +47,7 @@</span> <span class="p_context"></span>
 /* device can&#39;t handle device_qualifier descriptor requests */
 #define USB_QUIRK_DEVICE_QUALIFIER	0x00000100
 
<span class="p_add">+/* device can&#39;t handle Link Power Management */</span>
<span class="p_add">+#define USB_QUIRK_NO_LPM			BIT(10)</span>
<span class="p_add">+</span>
 #endif /* __LINUX_USB_QUIRKS_H */
<span class="p_header">diff --git a/include/net/sock.h b/include/net/sock.h</span>
<span class="p_header">index dd06b32abea3..2b2960fcc878 100644</span>
<span class="p_header">--- a/include/net/sock.h</span>
<span class="p_header">+++ b/include/net/sock.h</span>
<span class="p_chunk">@@ -376,8 +376,8 @@</span> <span class="p_context"> struct sock {</span>
 				sk_no_check_rx : 1,
 				sk_userlocks : 4,
 				sk_protocol  : 8,
<span class="p_del">-#define SK_PROTOCOL_MAX U8_MAX</span>
 				sk_type      : 16;
<span class="p_add">+#define SK_PROTOCOL_MAX U8_MAX</span>
 	kmemcheck_bitfield_end(flags);
 	int			sk_wmem_queued;
 	gfp_t			sk_allocation;
<span class="p_header">diff --git a/include/sound/soc.h b/include/sound/soc.h</span>
<span class="p_header">index a34d34649195..4dc6904ebbf9 100644</span>
<span class="p_header">--- a/include/sound/soc.h</span>
<span class="p_header">+++ b/include/sound/soc.h</span>
<span class="p_chunk">@@ -1390,7 +1390,7 @@</span> <span class="p_context"> extern const struct dev_pm_ops snd_soc_pm_ops;</span>
 /* Helper functions */
 static inline void snd_soc_dapm_mutex_lock(struct snd_soc_dapm_context *dapm)
 {
<span class="p_del">-	mutex_lock(&amp;dapm-&gt;card-&gt;dapm_mutex);</span>
<span class="p_add">+	mutex_lock_nested(&amp;dapm-&gt;card-&gt;dapm_mutex, SND_SOC_DAPM_CLASS_RUNTIME);</span>
 }
 
 static inline void snd_soc_dapm_mutex_unlock(struct snd_soc_dapm_context *dapm)
<span class="p_header">diff --git a/include/xen/interface/io/ring.h b/include/xen/interface/io/ring.h</span>
<span class="p_header">index 7d28aff605c7..7dc685b4057d 100644</span>
<span class="p_header">--- a/include/xen/interface/io/ring.h</span>
<span class="p_header">+++ b/include/xen/interface/io/ring.h</span>
<span class="p_chunk">@@ -181,6 +181,20 @@</span> <span class="p_context"> struct __name##_back_ring {						\</span>
 #define RING_GET_REQUEST(_r, _idx)					\
     (&amp;((_r)-&gt;sring-&gt;ring[((_idx) &amp; (RING_SIZE(_r) - 1))].req))
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Get a local copy of a request.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Use this in preference to RING_GET_REQUEST() so all processing is</span>
<span class="p_add">+ * done on a local copy that cannot be modified by the other end.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Note that https://gcc.gnu.org/bugzilla/show_bug.cgi?id=58145 may cause this</span>
<span class="p_add">+ * to be ineffective where _req is a struct which consists of only bitfields.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define RING_COPY_REQUEST(_r, _idx, _req) do {				\</span>
<span class="p_add">+	/* Use volatile to force the copy into _req. */			\</span>
<span class="p_add">+	*(_req) = *(volatile typeof(_req))RING_GET_REQUEST(_r, _idx);	\</span>
<span class="p_add">+} while (0)</span>
<span class="p_add">+</span>
 #define RING_GET_RESPONSE(_r, _idx)					\
     (&amp;((_r)-&gt;sring-&gt;ring[((_idx) &amp; (RING_SIZE(_r) - 1))].rsp))
 
<span class="p_header">diff --git a/kernel/events/core.c b/kernel/events/core.c</span>
<span class="p_header">index 259b9fdb6ba4..db2f2cfb58e3 100644</span>
<span class="p_header">--- a/kernel/events/core.c</span>
<span class="p_header">+++ b/kernel/events/core.c</span>
<span class="p_chunk">@@ -3692,7 +3692,14 @@</span> <span class="p_context"> retry:</span>
 		goto retry;
 	}
 
<span class="p_del">-	__perf_event_period(&amp;pe);</span>
<span class="p_add">+	if (event-&gt;attr.freq) {</span>
<span class="p_add">+		event-&gt;attr.sample_freq = value;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		event-&gt;attr.sample_period = value;</span>
<span class="p_add">+		event-&gt;hw.sample_period = value;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	local64_set(&amp;event-&gt;hw.period_left, 0);</span>
 	raw_spin_unlock_irq(&amp;ctx-&gt;lock);
 
 	return 0;
<span class="p_header">diff --git a/kernel/irq/manage.c b/kernel/irq/manage.c</span>
<span class="p_header">index 3dc6a61bf06a..efd80f0af47f 100644</span>
<span class="p_header">--- a/kernel/irq/manage.c</span>
<span class="p_header">+++ b/kernel/irq/manage.c</span>
<span class="p_chunk">@@ -1311,6 +1311,7 @@</span> <span class="p_context"> static struct irqaction *__free_irq(unsigned int irq, void *dev_id)</span>
 	if (!desc)
 		return NULL;
 
<span class="p_add">+	chip_bus_lock(desc);</span>
 	raw_spin_lock_irqsave(&amp;desc-&gt;lock, flags);
 
 	/*
<span class="p_chunk">@@ -1324,7 +1325,7 @@</span> <span class="p_context"> static struct irqaction *__free_irq(unsigned int irq, void *dev_id)</span>
 		if (!action) {
 			WARN(1, &quot;Trying to free already-free IRQ %d\n&quot;, irq);
 			raw_spin_unlock_irqrestore(&amp;desc-&gt;lock, flags);
<span class="p_del">-</span>
<span class="p_add">+			chip_bus_sync_unlock(desc);</span>
 			return NULL;
 		}
 
<span class="p_chunk">@@ -1349,6 +1350,7 @@</span> <span class="p_context"> static struct irqaction *__free_irq(unsigned int irq, void *dev_id)</span>
 #endif
 
 	raw_spin_unlock_irqrestore(&amp;desc-&gt;lock, flags);
<span class="p_add">+	chip_bus_sync_unlock(desc);</span>
 
 	unregister_handler_proc(irq, action);
 
<span class="p_chunk">@@ -1422,9 +1424,7 @@</span> <span class="p_context"> void free_irq(unsigned int irq, void *dev_id)</span>
 		desc-&gt;affinity_notify = NULL;
 #endif
 
<span class="p_del">-	chip_bus_lock(desc);</span>
 	kfree(__free_irq(irq, dev_id));
<span class="p_del">-	chip_bus_sync_unlock(desc);</span>
 }
 EXPORT_SYMBOL(free_irq);
 
<span class="p_header">diff --git a/kernel/module.c b/kernel/module.c</span>
<span class="p_header">index ed4d3b7ec58a..365b0a9d87b3 100644</span>
<span class="p_header">--- a/kernel/module.c</span>
<span class="p_header">+++ b/kernel/module.c</span>
<span class="p_chunk">@@ -3339,6 +3339,12 @@</span> <span class="p_context"> static int load_module(struct load_info *info, const char __user *uargs,</span>
 	wake_up_all(&amp;module_wq);
 	mutex_unlock(&amp;module_mutex);
  free_module:
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Ftrace needs to clean up what it initialized.</span>
<span class="p_add">+	 * This does nothing if ftrace_module_init() wasn&#39;t called,</span>
<span class="p_add">+	 * but it must be called outside of module_mutex.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ftrace_release_mod(mod);</span>
 	module_deallocate(mod, info);
  free_copy:
 	free_copy(info);
<span class="p_header">diff --git a/kernel/trace/trace_printk.c b/kernel/trace/trace_printk.c</span>
<span class="p_header">index 2900817ba65c..7c8cef653166 100644</span>
<span class="p_header">--- a/kernel/trace/trace_printk.c</span>
<span class="p_header">+++ b/kernel/trace/trace_printk.c</span>
<span class="p_chunk">@@ -269,6 +269,7 @@</span> <span class="p_context"> static const char **find_next(void *v, loff_t *pos)</span>
 	if (*pos &lt; last_index + start_index)
 		return __start___tracepoint_str + (*pos - last_index);
 
<span class="p_add">+	start_index += last_index;</span>
 	return find_next_mod_format(start_index, v, fmt, pos);
 }
 
<span class="p_header">diff --git a/lib/dma-debug.c b/lib/dma-debug.c</span>
<span class="p_header">index 98f2d7e91a91..1c741f900028 100644</span>
<span class="p_header">--- a/lib/dma-debug.c</span>
<span class="p_header">+++ b/lib/dma-debug.c</span>
<span class="p_chunk">@@ -1440,7 +1440,7 @@</span> <span class="p_context"> void debug_dma_alloc_coherent(struct device *dev, size_t size,</span>
 	entry-&gt;type      = dma_debug_coherent;
 	entry-&gt;dev       = dev;
 	entry-&gt;pfn	 = page_to_pfn(virt_to_page(virt));
<span class="p_del">-	entry-&gt;offset	 = (size_t) virt &amp; PAGE_MASK;</span>
<span class="p_add">+	entry-&gt;offset	 = (size_t) virt &amp; ~PAGE_MASK;</span>
 	entry-&gt;size      = size;
 	entry-&gt;dev_addr  = dma_addr;
 	entry-&gt;direction = DMA_BIDIRECTIONAL;
<span class="p_chunk">@@ -1456,7 +1456,7 @@</span> <span class="p_context"> void debug_dma_free_coherent(struct device *dev, size_t size,</span>
 		.type           = dma_debug_coherent,
 		.dev            = dev,
 		.pfn		= page_to_pfn(virt_to_page(virt)),
<span class="p_del">-		.offset		= (size_t) virt &amp; PAGE_MASK,</span>
<span class="p_add">+		.offset		= (size_t) virt &amp; ~PAGE_MASK,</span>
 		.dev_addr       = addr,
 		.size           = size,
 		.direction      = DMA_BIDIRECTIONAL,
<span class="p_header">diff --git a/mm/backing-dev.c b/mm/backing-dev.c</span>
<span class="p_header">index 1706cbbdf5f0..035be81fb150 100644</span>
<span class="p_header">--- a/mm/backing-dev.c</span>
<span class="p_header">+++ b/mm/backing-dev.c</span>
<span class="p_chunk">@@ -611,8 +611,9 @@</span> <span class="p_context"> EXPORT_SYMBOL(congestion_wait);</span>
  * jiffies for either a BDI to exit congestion of the given @sync queue
  * or a write to complete.
  *
<span class="p_del">- * In the absence of zone congestion, cond_resched() is called to yield</span>
<span class="p_del">- * the processor if necessary but otherwise does not sleep.</span>
<span class="p_add">+ * In the absence of zone congestion, a short sleep or a cond_resched is</span>
<span class="p_add">+ * performed to yield the processor and to allow other subsystems to make</span>
<span class="p_add">+ * a forward progress.</span>
  *
  * The return value is 0 if the sleep is for the full timeout. Otherwise,
  * it is the number of jiffies that were still remaining when the function
<span class="p_chunk">@@ -632,7 +633,19 @@</span> <span class="p_context"> long wait_iff_congested(struct zone *zone, int sync, long timeout)</span>
 	 */
 	if (atomic_read(&amp;nr_bdi_congested[sync]) == 0 ||
 			!zone_is_reclaim_congested(zone)) {
<span class="p_del">-		cond_resched();</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Memory allocation/reclaim might be called from a WQ</span>
<span class="p_add">+		 * context and the current implementation of the WQ</span>
<span class="p_add">+		 * concurrency control doesn&#39;t recognize that a particular</span>
<span class="p_add">+		 * WQ is congested if the worker thread is looping without</span>
<span class="p_add">+		 * ever sleeping. Therefore we have to do a short sleep</span>
<span class="p_add">+		 * here rather than calling cond_resched().</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (current-&gt;flags &amp; PF_WQ_WORKER)</span>
<span class="p_add">+			schedule_timeout(1);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			cond_resched();</span>
 
 		/* In case we scheduled, work out time remaining */
 		ret = timeout - (jiffies - start);
<span class="p_header">diff --git a/mm/hugetlb.c b/mm/hugetlb.c</span>
<span class="p_header">index f3111955b701..c83332d80152 100644</span>
<span class="p_header">--- a/mm/hugetlb.c</span>
<span class="p_header">+++ b/mm/hugetlb.c</span>
<span class="p_chunk">@@ -1398,7 +1398,10 @@</span> <span class="p_context"> static struct page *alloc_huge_page(struct vm_area_struct *vma,</span>
 		page = alloc_buddy_huge_page(h, NUMA_NO_NODE);
 		if (!page)
 			goto out_uncharge_cgroup;
<span class="p_del">-</span>
<span class="p_add">+		if (!avoid_reserve &amp;&amp; vma_has_reserves(vma, chg)) {</span>
<span class="p_add">+			SetPagePrivate(page);</span>
<span class="p_add">+			h-&gt;resv_huge_pages--;</span>
<span class="p_add">+		}</span>
 		spin_lock(&amp;hugetlb_lock);
 		list_move(&amp;page-&gt;lru, &amp;h-&gt;hugepage_activelist);
 		/* Fall through */
<span class="p_chunk">@@ -3167,12 +3170,12 @@</span> <span class="p_context"> int hugetlb_fault(struct mm_struct *mm, struct vm_area_struct *vma,</span>
 		} else if (unlikely(is_hugetlb_entry_hwpoisoned(entry)))
 			return VM_FAULT_HWPOISON_LARGE |
 				VM_FAULT_SET_HINDEX(hstate_index(h));
<span class="p_add">+	} else {</span>
<span class="p_add">+		ptep = huge_pte_alloc(mm, address, huge_page_size(h));</span>
<span class="p_add">+		if (!ptep)</span>
<span class="p_add">+			return VM_FAULT_OOM;</span>
 	}
 
<span class="p_del">-	ptep = huge_pte_alloc(mm, address, huge_page_size(h));</span>
<span class="p_del">-	if (!ptep)</span>
<span class="p_del">-		return VM_FAULT_OOM;</span>
<span class="p_del">-</span>
 	mapping = vma-&gt;vm_file-&gt;f_mapping;
 	idx = vma_hugecache_offset(h, vma, address);
 
<span class="p_header">diff --git a/mm/memory_hotplug.c b/mm/memory_hotplug.c</span>
<span class="p_header">index 2c38c4fe9631..4ec1d4d7521a 100644</span>
<span class="p_header">--- a/mm/memory_hotplug.c</span>
<span class="p_header">+++ b/mm/memory_hotplug.c</span>
<span class="p_chunk">@@ -1308,23 +1308,30 @@</span> <span class="p_context"> int is_mem_section_removable(unsigned long start_pfn, unsigned long nr_pages)</span>
  */
 static int test_pages_in_a_zone(unsigned long start_pfn, unsigned long end_pfn)
 {
<span class="p_del">-	unsigned long pfn;</span>
<span class="p_add">+	unsigned long pfn, sec_end_pfn;</span>
 	struct zone *zone = NULL;
 	struct page *page;
 	int i;
<span class="p_del">-	for (pfn = start_pfn;</span>
<span class="p_add">+	for (pfn = start_pfn, sec_end_pfn = SECTION_ALIGN_UP(start_pfn);</span>
 	     pfn &lt; end_pfn;
<span class="p_del">-	     pfn += MAX_ORDER_NR_PAGES) {</span>
<span class="p_del">-		i = 0;</span>
<span class="p_del">-		/* This is just a CONFIG_HOLES_IN_ZONE check.*/</span>
<span class="p_del">-		while ((i &lt; MAX_ORDER_NR_PAGES) &amp;&amp; !pfn_valid_within(pfn + i))</span>
<span class="p_del">-			i++;</span>
<span class="p_del">-		if (i == MAX_ORDER_NR_PAGES)</span>
<span class="p_add">+	     pfn = sec_end_pfn + 1, sec_end_pfn += PAGES_PER_SECTION) {</span>
<span class="p_add">+		/* Make sure the memory section is present first */</span>
<span class="p_add">+		if (!present_section_nr(pfn_to_section_nr(pfn)))</span>
 			continue;
<span class="p_del">-		page = pfn_to_page(pfn + i);</span>
<span class="p_del">-		if (zone &amp;&amp; page_zone(page) != zone)</span>
<span class="p_del">-			return 0;</span>
<span class="p_del">-		zone = page_zone(page);</span>
<span class="p_add">+		for (; pfn &lt; sec_end_pfn &amp;&amp; pfn &lt; end_pfn;</span>
<span class="p_add">+		     pfn += MAX_ORDER_NR_PAGES) {</span>
<span class="p_add">+			i = 0;</span>
<span class="p_add">+			/* This is just a CONFIG_HOLES_IN_ZONE check.*/</span>
<span class="p_add">+			while ((i &lt; MAX_ORDER_NR_PAGES) &amp;&amp;</span>
<span class="p_add">+				!pfn_valid_within(pfn + i))</span>
<span class="p_add">+				i++;</span>
<span class="p_add">+			if (i == MAX_ORDER_NR_PAGES)</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			page = pfn_to_page(pfn + i);</span>
<span class="p_add">+			if (zone &amp;&amp; page_zone(page) != zone)</span>
<span class="p_add">+				return 0;</span>
<span class="p_add">+			zone = page_zone(page);</span>
<span class="p_add">+		}</span>
 	}
 	return 1;
 }
<span class="p_header">diff --git a/mm/vmstat.c b/mm/vmstat.c</span>
<span class="p_header">index b37bd49bfd55..038f9418b234 100644</span>
<span class="p_header">--- a/mm/vmstat.c</span>
<span class="p_header">+++ b/mm/vmstat.c</span>
<span class="p_chunk">@@ -1226,13 +1226,14 @@</span> <span class="p_context"> static const struct file_operations proc_vmstat_file_operations = {</span>
 #endif /* CONFIG_PROC_FS */
 
 #ifdef CONFIG_SMP
<span class="p_add">+static struct workqueue_struct *vmstat_wq;</span>
 static DEFINE_PER_CPU(struct delayed_work, vmstat_work);
 int sysctl_stat_interval __read_mostly = HZ;
 
 static void vmstat_update(struct work_struct *w)
 {
 	refresh_cpu_vm_stats();
<span class="p_del">-	schedule_delayed_work(this_cpu_ptr(&amp;vmstat_work),</span>
<span class="p_add">+	queue_delayed_work(vmstat_wq, this_cpu_ptr(&amp;vmstat_work),</span>
 		round_jiffies_relative(sysctl_stat_interval));
 }
 
<span class="p_chunk">@@ -1241,7 +1242,7 @@</span> <span class="p_context"> static void start_cpu_timer(int cpu)</span>
 	struct delayed_work *work = &amp;per_cpu(vmstat_work, cpu);
 
 	INIT_DEFERRABLE_WORK(work, vmstat_update);
<span class="p_del">-	schedule_delayed_work_on(cpu, work, __round_jiffies_relative(HZ, cpu));</span>
<span class="p_add">+	queue_delayed_work_on(cpu, vmstat_wq, work, __round_jiffies_relative(HZ, cpu));</span>
 }
 
 static void vmstat_cpu_dead(int node)
<span class="p_chunk">@@ -1304,6 +1305,8 @@</span> <span class="p_context"> static int __init setup_vmstat(void)</span>
 #ifdef CONFIG_SMP
 	int cpu;
 
<span class="p_add">+	vmstat_wq = alloc_workqueue(&quot;vmstat&quot;, WQ_FREEZABLE|WQ_MEM_RECLAIM, 0);</span>
<span class="p_add">+</span>
 	cpu_notifier_register_begin();
 	__register_cpu_notifier(&amp;vmstat_notifier);
 
<span class="p_header">diff --git a/net/core/datagram.c b/net/core/datagram.c</span>
<span class="p_header">index 169f742d1464..3c69a464595e 100644</span>
<span class="p_header">--- a/net/core/datagram.c</span>
<span class="p_header">+++ b/net/core/datagram.c</span>
<span class="p_chunk">@@ -818,7 +818,6 @@</span> <span class="p_context"> EXPORT_SYMBOL(__skb_checksum_complete);</span>
  *	@skb: skbuff
  *	@hlen: hardware length
  *	@iov: io vector
<span class="p_del">- *	@len: amount of data to copy from skb to iov</span>
  *
  *	Caller _must_ check that skb will fit to this iovec.
  *
<span class="p_chunk">@@ -828,14 +827,11 @@</span> <span class="p_context"> EXPORT_SYMBOL(__skb_checksum_complete);</span>
  *			   can be modified!
  */
 int skb_copy_and_csum_datagram_iovec(struct sk_buff *skb,
<span class="p_del">-				     int hlen, struct iovec *iov, int len)</span>
<span class="p_add">+				     int hlen, struct iovec *iov)</span>
 {
 	__wsum csum;
 	int chunk = skb-&gt;len - hlen;
 
<span class="p_del">-	if (chunk &gt; len)</span>
<span class="p_del">-		chunk = len;</span>
<span class="p_del">-</span>
 	if (!chunk)
 		return 0;
 
<span class="p_header">diff --git a/net/core/dst.c b/net/core/dst.c</span>
<span class="p_header">index a80e92346b9b..57746a18c957 100644</span>
<span class="p_header">--- a/net/core/dst.c</span>
<span class="p_header">+++ b/net/core/dst.c</span>
<span class="p_chunk">@@ -282,10 +282,11 @@</span> <span class="p_context"> void dst_release(struct dst_entry *dst)</span>
 {
 	if (dst) {
 		int newrefcnt;
<span class="p_add">+		unsigned short nocache = dst-&gt;flags &amp; DST_NOCACHE;</span>
 
 		newrefcnt = atomic_dec_return(&amp;dst-&gt;__refcnt);
 		WARN_ON(newrefcnt &lt; 0);
<span class="p_del">-		if (!newrefcnt &amp;&amp; unlikely(dst-&gt;flags &amp; DST_NOCACHE))</span>
<span class="p_add">+		if (!newrefcnt &amp;&amp; unlikely(nocache))</span>
 			call_rcu(&amp;dst-&gt;rcu_head, dst_destroy_rcu);
 	}
 }
<span class="p_header">diff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c</span>
<span class="p_header">index 43404d3f9da8..036615125532 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_input.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_input.c</span>
<span class="p_chunk">@@ -4903,7 +4903,7 @@</span> <span class="p_context"> static int tcp_copy_to_iovec(struct sock *sk, struct sk_buff *skb, int hlen)</span>
 		err = skb_copy_datagram_iovec(skb, hlen, tp-&gt;ucopy.iov, chunk);
 	else
 		err = skb_copy_and_csum_datagram_iovec(skb, hlen,
<span class="p_del">-						       tp-&gt;ucopy.iov, chunk);</span>
<span class="p_add">+						       tp-&gt;ucopy.iov);</span>
 
 	if (!err) {
 		tp-&gt;ucopy.len -= chunk;
<span class="p_header">diff --git a/net/ipv4/udp.c b/net/ipv4/udp.c</span>
<span class="p_header">index 4b9e4aba11b0..2478b20692e8 100644</span>
<span class="p_header">--- a/net/ipv4/udp.c</span>
<span class="p_header">+++ b/net/ipv4/udp.c</span>
<span class="p_chunk">@@ -1272,6 +1272,7 @@</span> <span class="p_context"> int udp_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,</span>
 	int peeked, off = 0;
 	int err;
 	int is_udplite = IS_UDPLITE(sk);
<span class="p_add">+	bool checksum_valid = false;</span>
 	bool slow;
 
 	if (flags &amp; MSG_ERRQUEUE)
<span class="p_chunk">@@ -1297,17 +1298,18 @@</span> <span class="p_context"> try_again:</span>
 	 */
 
 	if (copied &lt; ulen || UDP_SKB_CB(skb)-&gt;partial_cov) {
<span class="p_del">-		if (udp_lib_checksum_complete(skb))</span>
<span class="p_add">+		checksum_valid = !udp_lib_checksum_complete(skb);</span>
<span class="p_add">+		if (!checksum_valid)</span>
 			goto csum_copy_err;
 	}
 
<span class="p_del">-	if (skb_csum_unnecessary(skb))</span>
<span class="p_add">+	if (checksum_valid || skb_csum_unnecessary(skb))</span>
 		err = skb_copy_datagram_iovec(skb, sizeof(struct udphdr),
 					      msg-&gt;msg_iov, copied);
 	else {
 		err = skb_copy_and_csum_datagram_iovec(skb,
 						       sizeof(struct udphdr),
<span class="p_del">-						       msg-&gt;msg_iov, copied);</span>
<span class="p_add">+						       msg-&gt;msg_iov);</span>
 
 		if (err == -EINVAL)
 			goto csum_copy_err;
<span class="p_header">diff --git a/net/ipv6/addrlabel.c b/net/ipv6/addrlabel.c</span>
<span class="p_header">index 731e1e1722d9..eb525d5908c3 100644</span>
<span class="p_header">--- a/net/ipv6/addrlabel.c</span>
<span class="p_header">+++ b/net/ipv6/addrlabel.c</span>
<span class="p_chunk">@@ -558,7 +558,7 @@</span> <span class="p_context"> static int ip6addrlbl_get(struct sk_buff *in_skb, struct nlmsghdr *nlh)</span>
 
 	rcu_read_lock();
 	p = __ipv6_addr_label(net, addr, ipv6_addr_type(addr), ifal-&gt;ifal_index);
<span class="p_del">-	if (p &amp;&amp; ip6addrlbl_hold(p))</span>
<span class="p_add">+	if (p &amp;&amp; !ip6addrlbl_hold(p))</span>
 		p = NULL;
 	lseq = ip6addrlbl_table.seq;
 	rcu_read_unlock();
<span class="p_header">diff --git a/net/ipv6/raw.c b/net/ipv6/raw.c</span>
<span class="p_header">index a652fdb6bd5d..1463757e8682 100644</span>
<span class="p_header">--- a/net/ipv6/raw.c</span>
<span class="p_header">+++ b/net/ipv6/raw.c</span>
<span class="p_chunk">@@ -492,7 +492,7 @@</span> <span class="p_context"> static int rawv6_recvmsg(struct kiocb *iocb, struct sock *sk,</span>
 			goto csum_copy_err;
 		err = skb_copy_datagram_iovec(skb, 0, msg-&gt;msg_iov, copied);
 	} else {
<span class="p_del">-		err = skb_copy_and_csum_datagram_iovec(skb, 0, msg-&gt;msg_iov, copied);</span>
<span class="p_add">+		err = skb_copy_and_csum_datagram_iovec(skb, 0, msg-&gt;msg_iov);</span>
 		if (err == -EINVAL)
 			goto csum_copy_err;
 	}
<span class="p_header">diff --git a/net/ipv6/udp.c b/net/ipv6/udp.c</span>
<span class="p_header">index eb38829d8919..ef7a2eb481b3 100644</span>
<span class="p_header">--- a/net/ipv6/udp.c</span>
<span class="p_header">+++ b/net/ipv6/udp.c</span>
<span class="p_chunk">@@ -389,6 +389,7 @@</span> <span class="p_context"> int udpv6_recvmsg(struct kiocb *iocb, struct sock *sk,</span>
 	int peeked, off = 0;
 	int err;
 	int is_udplite = IS_UDPLITE(sk);
<span class="p_add">+	bool checksum_valid = false;</span>
 	int is_udp4;
 	bool slow;
 
<span class="p_chunk">@@ -420,16 +421,16 @@</span> <span class="p_context"> try_again:</span>
 	 */
 
 	if (copied &lt; ulen || UDP_SKB_CB(skb)-&gt;partial_cov) {
<span class="p_del">-		if (udp_lib_checksum_complete(skb))</span>
<span class="p_add">+		checksum_valid = !udp_lib_checksum_complete(skb);</span>
<span class="p_add">+		if (!checksum_valid)</span>
 			goto csum_copy_err;
 	}
 
<span class="p_del">-	if (skb_csum_unnecessary(skb))</span>
<span class="p_add">+	if (checksum_valid || skb_csum_unnecessary(skb))</span>
 		err = skb_copy_datagram_iovec(skb, sizeof(struct udphdr),
 					      msg-&gt;msg_iov, copied);
 	else {
<span class="p_del">-		err = skb_copy_and_csum_datagram_iovec(skb, sizeof(struct udphdr),</span>
<span class="p_del">-						       msg-&gt;msg_iov, copied);</span>
<span class="p_add">+		err = skb_copy_and_csum_datagram_iovec(skb, sizeof(struct udphdr), msg-&gt;msg_iov);</span>
 		if (err == -EINVAL)
 			goto csum_copy_err;
 	}
<span class="p_header">diff --git a/net/rfkill/core.c b/net/rfkill/core.c</span>
<span class="p_header">index b3b16c070a7f..5307a99c1838 100644</span>
<span class="p_header">--- a/net/rfkill/core.c</span>
<span class="p_header">+++ b/net/rfkill/core.c</span>
<span class="p_chunk">@@ -49,7 +49,6 @@</span> <span class="p_context"></span>
 struct rfkill {
 	spinlock_t		lock;
 
<span class="p_del">-	const char		*name;</span>
 	enum rfkill_type	type;
 
 	unsigned long		state;
<span class="p_chunk">@@ -73,6 +72,7 @@</span> <span class="p_context"> struct rfkill {</span>
 	struct delayed_work	poll_work;
 	struct work_struct	uevent_work;
 	struct work_struct	sync_work;
<span class="p_add">+	char			name[];</span>
 };
 #define to_rfkill(d)	container_of(d, struct rfkill, dev)
 
<span class="p_chunk">@@ -862,14 +862,14 @@</span> <span class="p_context"> struct rfkill * __must_check rfkill_alloc(const char *name,</span>
 	if (WARN_ON(type == RFKILL_TYPE_ALL || type &gt;= NUM_RFKILL_TYPES))
 		return NULL;
 
<span class="p_del">-	rfkill = kzalloc(sizeof(*rfkill), GFP_KERNEL);</span>
<span class="p_add">+	rfkill = kzalloc(sizeof(*rfkill) + strlen(name) + 1, GFP_KERNEL);</span>
 	if (!rfkill)
 		return NULL;
 
 	spin_lock_init(&amp;rfkill-&gt;lock);
 	INIT_LIST_HEAD(&amp;rfkill-&gt;node);
 	rfkill-&gt;type = type;
<span class="p_del">-	rfkill-&gt;name = name;</span>
<span class="p_add">+	strcpy(rfkill-&gt;name, name);</span>
 	rfkill-&gt;ops = ops;
 	rfkill-&gt;data = ops_data;
 
<span class="p_header">diff --git a/net/sunrpc/svc.c b/net/sunrpc/svc.c</span>
<span class="p_header">index 5de6801cd924..78c809c1f819 100644</span>
<span class="p_header">--- a/net/sunrpc/svc.c</span>
<span class="p_header">+++ b/net/sunrpc/svc.c</span>
<span class="p_chunk">@@ -1359,6 +1359,19 @@</span> <span class="p_context"> bc_svc_process(struct svc_serv *serv, struct rpc_rqst *req,</span>
 	memcpy(&amp;rqstp-&gt;rq_arg, &amp;req-&gt;rq_rcv_buf, sizeof(rqstp-&gt;rq_arg));
 	memcpy(&amp;rqstp-&gt;rq_res, &amp;req-&gt;rq_snd_buf, sizeof(rqstp-&gt;rq_res));
 
<span class="p_add">+	/* Adjust the argument buffer length */</span>
<span class="p_add">+	rqstp-&gt;rq_arg.len = req-&gt;rq_private_buf.len;</span>
<span class="p_add">+	if (rqstp-&gt;rq_arg.len &lt;= rqstp-&gt;rq_arg.head[0].iov_len) {</span>
<span class="p_add">+		rqstp-&gt;rq_arg.head[0].iov_len = rqstp-&gt;rq_arg.len;</span>
<span class="p_add">+		rqstp-&gt;rq_arg.page_len = 0;</span>
<span class="p_add">+	} else if (rqstp-&gt;rq_arg.len &lt;= rqstp-&gt;rq_arg.head[0].iov_len +</span>
<span class="p_add">+			rqstp-&gt;rq_arg.page_len)</span>
<span class="p_add">+		rqstp-&gt;rq_arg.page_len = rqstp-&gt;rq_arg.len -</span>
<span class="p_add">+			rqstp-&gt;rq_arg.head[0].iov_len;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		rqstp-&gt;rq_arg.len = rqstp-&gt;rq_arg.head[0].iov_len +</span>
<span class="p_add">+			rqstp-&gt;rq_arg.page_len;</span>
<span class="p_add">+</span>
 	/* reset result send buffer &quot;put&quot; position */
 	resv-&gt;iov_len = 0;
 
<span class="p_header">diff --git a/scripts/recordmcount.c b/scripts/recordmcount.c</span>
<span class="p_header">index 650ecc83d7d7..56f497b27c49 100644</span>
<span class="p_header">--- a/scripts/recordmcount.c</span>
<span class="p_header">+++ b/scripts/recordmcount.c</span>
<span class="p_chunk">@@ -47,12 +47,17 @@</span> <span class="p_context"></span>
 
 static int fd_map;	/* File descriptor for file being modified. */
 static int mmap_failed; /* Boolean flag. */
<span class="p_del">-static void *ehdr_curr; /* current ElfXX_Ehdr *  for resource cleanup */</span>
 static char gpfx;	/* prefix for global symbol name (sometimes &#39;_&#39;) */
 static struct stat sb;	/* Remember .st_size, etc. */
 static jmp_buf jmpenv;	/* setjmp/longjmp per-file error escape */
 static const char *altmcount;	/* alternate mcount symbol name */
 static int warn_on_notrace_sect; /* warn when section has mcount not being recorded */
<span class="p_add">+static void *file_map;	/* pointer of the mapped file */</span>
<span class="p_add">+static void *file_end;	/* pointer to the end of the mapped file */</span>
<span class="p_add">+static int file_updated; /* flag to state file was changed */</span>
<span class="p_add">+static void *file_ptr;	/* current file pointer location */</span>
<span class="p_add">+static void *file_append; /* added to the end of the file */</span>
<span class="p_add">+static size_t file_append_size; /* how much is added to end of file */</span>
 
 /* setjmp() return values */
 enum {
<span class="p_chunk">@@ -66,10 +71,14 @@</span> <span class="p_context"> static void</span>
 cleanup(void)
 {
 	if (!mmap_failed)
<span class="p_del">-		munmap(ehdr_curr, sb.st_size);</span>
<span class="p_add">+		munmap(file_map, sb.st_size);</span>
 	else
<span class="p_del">-		free(ehdr_curr);</span>
<span class="p_del">-	close(fd_map);</span>
<span class="p_add">+		free(file_map);</span>
<span class="p_add">+	file_map = NULL;</span>
<span class="p_add">+	free(file_append);</span>
<span class="p_add">+	file_append = NULL;</span>
<span class="p_add">+	file_append_size = 0;</span>
<span class="p_add">+	file_updated = 0;</span>
 }
 
 static void __attribute__((noreturn))
<span class="p_chunk">@@ -91,12 +100,22 @@</span> <span class="p_context"> succeed_file(void)</span>
 static off_t
 ulseek(int const fd, off_t const offset, int const whence)
 {
<span class="p_del">-	off_t const w = lseek(fd, offset, whence);</span>
<span class="p_del">-	if (w == (off_t)-1) {</span>
<span class="p_del">-		perror(&quot;lseek&quot;);</span>
<span class="p_add">+	switch (whence) {</span>
<span class="p_add">+	case SEEK_SET:</span>
<span class="p_add">+		file_ptr = file_map + offset;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case SEEK_CUR:</span>
<span class="p_add">+		file_ptr += offset;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case SEEK_END:</span>
<span class="p_add">+		file_ptr = file_map + (sb.st_size - offset);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (file_ptr &lt; file_map) {</span>
<span class="p_add">+		fprintf(stderr, &quot;lseek: seek before file\n&quot;);</span>
 		fail_file();
 	}
<span class="p_del">-	return w;</span>
<span class="p_add">+	return file_ptr - file_map;</span>
 }
 
 static size_t
<span class="p_chunk">@@ -113,12 +132,38 @@</span> <span class="p_context"> uread(int const fd, void *const buf, size_t const count)</span>
 static size_t
 uwrite(int const fd, void const *const buf, size_t const count)
 {
<span class="p_del">-	size_t const n = write(fd, buf, count);</span>
<span class="p_del">-	if (n != count) {</span>
<span class="p_del">-		perror(&quot;write&quot;);</span>
<span class="p_del">-		fail_file();</span>
<span class="p_add">+	size_t cnt = count;</span>
<span class="p_add">+	off_t idx = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	file_updated = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (file_ptr + count &gt;= file_end) {</span>
<span class="p_add">+		off_t aoffset = (file_ptr + count) - file_end;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (aoffset &gt; file_append_size) {</span>
<span class="p_add">+			file_append = realloc(file_append, aoffset);</span>
<span class="p_add">+			file_append_size = aoffset;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		if (!file_append) {</span>
<span class="p_add">+			perror(&quot;write&quot;);</span>
<span class="p_add">+			fail_file();</span>
<span class="p_add">+		}</span>
<span class="p_add">+		if (file_ptr &lt; file_end) {</span>
<span class="p_add">+			cnt = file_end - file_ptr;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			cnt = 0;</span>
<span class="p_add">+			idx = aoffset - count;</span>
<span class="p_add">+		}</span>
 	}
<span class="p_del">-	return n;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (cnt)</span>
<span class="p_add">+		memcpy(file_ptr, buf, cnt);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (cnt &lt; count)</span>
<span class="p_add">+		memcpy(file_append + idx, buf + cnt, count - cnt);</span>
<span class="p_add">+</span>
<span class="p_add">+	file_ptr += count;</span>
<span class="p_add">+	return count;</span>
 }
 
 static void *
<span class="p_chunk">@@ -175,9 +220,7 @@</span> <span class="p_context"> static int make_nop_x86(void *map, size_t const offset)</span>
  */
 static void *mmap_file(char const *fname)
 {
<span class="p_del">-	void *addr;</span>
<span class="p_del">-</span>
<span class="p_del">-	fd_map = open(fname, O_RDWR);</span>
<span class="p_add">+	fd_map = open(fname, O_RDONLY);</span>
 	if (fd_map &lt; 0 || fstat(fd_map, &amp;sb) &lt; 0) {
 		perror(fname);
 		fail_file();
<span class="p_chunk">@@ -186,15 +229,58 @@</span> <span class="p_context"> static void *mmap_file(char const *fname)</span>
 		fprintf(stderr, &quot;not a regular file: %s\n&quot;, fname);
 		fail_file();
 	}
<span class="p_del">-	addr = mmap(0, sb.st_size, PROT_READ|PROT_WRITE, MAP_PRIVATE,</span>
<span class="p_del">-		    fd_map, 0);</span>
<span class="p_add">+	file_map = mmap(0, sb.st_size, PROT_READ|PROT_WRITE, MAP_PRIVATE,</span>
<span class="p_add">+			fd_map, 0);</span>
 	mmap_failed = 0;
<span class="p_del">-	if (addr == MAP_FAILED) {</span>
<span class="p_add">+	if (file_map == MAP_FAILED) {</span>
 		mmap_failed = 1;
<span class="p_del">-		addr = umalloc(sb.st_size);</span>
<span class="p_del">-		uread(fd_map, addr, sb.st_size);</span>
<span class="p_add">+		file_map = umalloc(sb.st_size);</span>
<span class="p_add">+		uread(fd_map, file_map, sb.st_size);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	close(fd_map);</span>
<span class="p_add">+</span>
<span class="p_add">+	file_end = file_map + sb.st_size;</span>
<span class="p_add">+</span>
<span class="p_add">+	return file_map;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void write_file(const char *fname)</span>
<span class="p_add">+{</span>
<span class="p_add">+	char tmp_file[strlen(fname) + 4];</span>
<span class="p_add">+	size_t n;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!file_updated)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	sprintf(tmp_file, &quot;%s.rc&quot;, fname);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * After reading the entire file into memory, delete it</span>
<span class="p_add">+	 * and write it back, to prevent weird side effects of modifying</span>
<span class="p_add">+	 * an object file in place.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	fd_map = open(tmp_file, O_WRONLY | O_TRUNC | O_CREAT, sb.st_mode);</span>
<span class="p_add">+	if (fd_map &lt; 0) {</span>
<span class="p_add">+		perror(fname);</span>
<span class="p_add">+		fail_file();</span>
<span class="p_add">+	}</span>
<span class="p_add">+	n = write(fd_map, file_map, sb.st_size);</span>
<span class="p_add">+	if (n != sb.st_size) {</span>
<span class="p_add">+		perror(&quot;write&quot;);</span>
<span class="p_add">+		fail_file();</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (file_append_size) {</span>
<span class="p_add">+		n = write(fd_map, file_append, file_append_size);</span>
<span class="p_add">+		if (n != file_append_size) {</span>
<span class="p_add">+			perror(&quot;write&quot;);</span>
<span class="p_add">+			fail_file();</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	close(fd_map);</span>
<span class="p_add">+	if (rename(tmp_file, fname) &lt; 0) {</span>
<span class="p_add">+		perror(fname);</span>
<span class="p_add">+		fail_file();</span>
 	}
<span class="p_del">-	return addr;</span>
 }
 
 /* w8rev, w8nat, ...: Handle endianness. */
<span class="p_chunk">@@ -301,7 +387,6 @@</span> <span class="p_context"> do_file(char const *const fname)</span>
 	Elf32_Ehdr *const ehdr = mmap_file(fname);
 	unsigned int reltype = 0;
 
<span class="p_del">-	ehdr_curr = ehdr;</span>
 	w = w4nat;
 	w2 = w2nat;
 	w8 = w8nat;
<span class="p_chunk">@@ -421,6 +506,7 @@</span> <span class="p_context"> do_file(char const *const fname)</span>
 	}
 	}  /* end switch */
 
<span class="p_add">+	write_file(fname);</span>
 	cleanup();
 }
 
<span class="p_chunk">@@ -473,11 +559,14 @@</span> <span class="p_context"> main(int argc, char *argv[])</span>
 		case SJ_SETJMP:    /* normal sequence */
 			/* Avoid problems if early cleanup() */
 			fd_map = -1;
<span class="p_del">-			ehdr_curr = NULL;</span>
 			mmap_failed = 1;
<span class="p_add">+			file_map = NULL;</span>
<span class="p_add">+			file_ptr = NULL;</span>
<span class="p_add">+			file_updated = 0;</span>
 			do_file(file);
 			break;
 		case SJ_FAIL:    /* error in do_file or below */
<span class="p_add">+			fprintf(stderr, &quot;%s: failed\n&quot;, file);</span>
 			++n_error;
 			break;
 		case SJ_SUCCEED:    /* premature success */
<span class="p_header">diff --git a/security/keys/process_keys.c b/security/keys/process_keys.c</span>
<span class="p_header">index 0cf8a130a267..4e56371f239f 100644</span>
<span class="p_header">--- a/security/keys/process_keys.c</span>
<span class="p_header">+++ b/security/keys/process_keys.c</span>
<span class="p_chunk">@@ -793,6 +793,7 @@</span> <span class="p_context"> long join_session_keyring(const char *name)</span>
 		ret = PTR_ERR(keyring);
 		goto error2;
 	} else if (keyring == new-&gt;session_keyring) {
<span class="p_add">+		key_put(keyring);</span>
 		ret = 0;
 		goto error2;
 	}
<span class="p_header">diff --git a/sound/pci/hda/hda_intel.c b/sound/pci/hda/hda_intel.c</span>
<span class="p_header">index d4268a2bbca7..2f523b08f576 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_intel.c</span>
<span class="p_header">+++ b/sound/pci/hda/hda_intel.c</span>
<span class="p_chunk">@@ -663,6 +663,36 @@</span> <span class="p_context"> static int azx_resume(struct device *dev)</span>
 }
 #endif /* CONFIG_PM_SLEEP || SUPPORT_VGA_SWITCHEROO */
 
<span class="p_add">+#ifdef CONFIG_PM_SLEEP</span>
<span class="p_add">+/* put codec down to D3 at hibernation for Intel SKL+;</span>
<span class="p_add">+ * otherwise BIOS may still access the codec and screw up the driver</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define IS_SKL(pci) ((pci)-&gt;vendor == 0x8086 &amp;&amp; (pci)-&gt;device == 0xa170)</span>
<span class="p_add">+#define IS_SKL_LP(pci) ((pci)-&gt;vendor == 0x8086 &amp;&amp; (pci)-&gt;device == 0x9d70)</span>
<span class="p_add">+#define IS_BXT(pci) ((pci)-&gt;vendor == 0x8086 &amp;&amp; (pci)-&gt;device == 0x5a98)</span>
<span class="p_add">+#define IS_SKL_PLUS(pci) (IS_SKL(pci) || IS_SKL_LP(pci) || IS_BXT(pci))</span>
<span class="p_add">+</span>
<span class="p_add">+static int azx_freeze_noirq(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct pci_dev *pci = to_pci_dev(dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (IS_SKL_PLUS(pci))</span>
<span class="p_add">+		pci_set_power_state(pci, PCI_D3hot);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int azx_thaw_noirq(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct pci_dev *pci = to_pci_dev(dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (IS_SKL_PLUS(pci))</span>
<span class="p_add">+		pci_set_power_state(pci, PCI_D0);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif /* CONFIG_PM_SLEEP */</span>
<span class="p_add">+</span>
 #ifdef CONFIG_PM_RUNTIME
 static int azx_runtime_suspend(struct device *dev)
 {
<span class="p_chunk">@@ -748,6 +778,10 @@</span> <span class="p_context"> static int azx_runtime_idle(struct device *dev)</span>
 #ifdef CONFIG_PM
 static const struct dev_pm_ops azx_pm = {
 	SET_SYSTEM_SLEEP_PM_OPS(azx_suspend, azx_resume)
<span class="p_add">+#ifdef CONFIG_PM_SLEEP</span>
<span class="p_add">+	.freeze_noirq = azx_freeze_noirq,</span>
<span class="p_add">+	.thaw_noirq = azx_thaw_noirq,</span>
<span class="p_add">+#endif</span>
 	SET_RUNTIME_PM_OPS(azx_runtime_suspend, azx_runtime_resume, azx_runtime_idle)
 };
 
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index a9bbfefb9d4a..9131899af1d8 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -1844,6 +1844,7 @@</span> <span class="p_context"> enum {</span>
 	ALC889_FIXUP_MBA11_VREF,
 	ALC889_FIXUP_MBA21_VREF,
 	ALC889_FIXUP_MP11_VREF,
<span class="p_add">+	ALC889_FIXUP_MP41_VREF,</span>
 	ALC882_FIXUP_INV_DMIC,
 	ALC882_FIXUP_NO_PRIMARY_HP,
 	ALC887_FIXUP_ASUS_BASS,
<span class="p_chunk">@@ -1932,7 +1933,7 @@</span> <span class="p_context"> static void alc889_fixup_mbp_vref(struct hda_codec *codec,</span>
 				  const struct hda_fixup *fix, int action)
 {
 	struct alc_spec *spec = codec-&gt;spec;
<span class="p_del">-	static hda_nid_t nids[2] = { 0x14, 0x15 };</span>
<span class="p_add">+	static hda_nid_t nids[3] = { 0x14, 0x15, 0x19 };</span>
 	int i;
 
 	if (action != HDA_FIXUP_ACT_INIT)
<span class="p_chunk">@@ -2222,6 +2223,12 @@</span> <span class="p_context"> static const struct hda_fixup alc882_fixups[] = {</span>
 		.chained = true,
 		.chain_id = ALC885_FIXUP_MACPRO_GPIO,
 	},
<span class="p_add">+	[ALC889_FIXUP_MP41_VREF] = {</span>
<span class="p_add">+		.type = HDA_FIXUP_FUNC,</span>
<span class="p_add">+		.v.func = alc889_fixup_mbp_vref,</span>
<span class="p_add">+		.chained = true,</span>
<span class="p_add">+		.chain_id = ALC885_FIXUP_MACPRO_GPIO,</span>
<span class="p_add">+	},</span>
 	[ALC882_FIXUP_INV_DMIC] = {
 		.type = HDA_FIXUP_FUNC,
 		.v.func = alc_fixup_inv_dmic_0x12,
<span class="p_chunk">@@ -2304,7 +2311,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc882_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x106b, 0x3f00, &quot;Macbook 5,1&quot;, ALC889_FIXUP_IMAC91_VREF),
 	SND_PCI_QUIRK(0x106b, 0x4000, &quot;MacbookPro 5,1&quot;, ALC889_FIXUP_IMAC91_VREF),
 	SND_PCI_QUIRK(0x106b, 0x4100, &quot;Macmini 3,1&quot;, ALC889_FIXUP_IMAC91_VREF),
<span class="p_del">-	SND_PCI_QUIRK(0x106b, 0x4200, &quot;Mac Pro 5,1&quot;, ALC885_FIXUP_MACPRO_GPIO),</span>
<span class="p_add">+	SND_PCI_QUIRK(0x106b, 0x4200, &quot;Mac Pro 4,1/5,1&quot;, ALC889_FIXUP_MP41_VREF),</span>
 	SND_PCI_QUIRK(0x106b, 0x4300, &quot;iMac 9,1&quot;, ALC889_FIXUP_IMAC91_VREF),
 	SND_PCI_QUIRK(0x106b, 0x4600, &quot;MacbookPro 5,2&quot;, ALC889_FIXUP_IMAC91_VREF),
 	SND_PCI_QUIRK(0x106b, 0x4900, &quot;iMac 9,1 Aluminum&quot;, ALC889_FIXUP_IMAC91_VREF),
<span class="p_chunk">@@ -4029,6 +4036,18 @@</span> <span class="p_context"> static void alc_fixup_disable_aamix(struct hda_codec *codec,</span>
 	}
 }
 
<span class="p_add">+/* additional fixup for Thinkpad T440s noise problem */</span>
<span class="p_add">+static void alc_fixup_tpt440(struct hda_codec *codec,</span>
<span class="p_add">+				  const struct hda_fixup *fix, int action)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct alc_spec *spec = codec-&gt;spec;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (action == HDA_FIXUP_ACT_PRE_PROBE) {</span>
<span class="p_add">+		spec-&gt;shutup = alc_no_shutup; /* reduce click noise */</span>
<span class="p_add">+		spec-&gt;gen.mixer_nid = 0; /* reduce background noise */</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static unsigned int alc_power_filter_xps13(struct hda_codec *codec,
 				hda_nid_t nid,
 				unsigned int power_state)
<span class="p_chunk">@@ -4325,8 +4344,10 @@</span> <span class="p_context"> enum {</span>
 	ALC293_FIXUP_DELL1_MIC_NO_PRESENCE,
 	ALC292_FIXUP_TPT440_DOCK,
 	ALC292_FIXUP_TPT440_DOCK2,
<span class="p_add">+	ALC292_FIXUP_TPT440,</span>
 	ALC275_FIXUP_DELL_XPS,
 	ALC256_FIXUP_DELL_XPS_13_HEADPHONE_NOISE,
<span class="p_add">+	ALC293_FIXUP_LENOVO_SPK_NOISE,</span>
 };
 
 static const struct hda_fixup alc269_fixups[] = {
<span class="p_chunk">@@ -4779,6 +4800,12 @@</span> <span class="p_context"> static const struct hda_fixup alc269_fixups[] = {</span>
 		.chained = true,
 		.chain_id = ALC269_FIXUP_LIMIT_INT_MIC_BOOST
 	},
<span class="p_add">+	[ALC292_FIXUP_TPT440] = {</span>
<span class="p_add">+		.type = HDA_FIXUP_FUNC,</span>
<span class="p_add">+		.v.func = alc_fixup_tpt440,</span>
<span class="p_add">+		.chained = true,</span>
<span class="p_add">+		.chain_id = ALC292_FIXUP_TPT440_DOCK,</span>
<span class="p_add">+	},</span>
 	[ALC275_FIXUP_DELL_XPS] = {
 		.type = HDA_FIXUP_VERBS,
 		.v.verbs = (const struct hda_verb[]) {
<span class="p_chunk">@@ -4801,6 +4828,12 @@</span> <span class="p_context"> static const struct hda_fixup alc269_fixups[] = {</span>
 		.chained = true,
 		.chain_id = ALC255_FIXUP_DELL1_MIC_NO_PRESENCE
 	},
<span class="p_add">+	[ALC293_FIXUP_LENOVO_SPK_NOISE] = {</span>
<span class="p_add">+		.type = HDA_FIXUP_FUNC,</span>
<span class="p_add">+		.v.func = alc_fixup_disable_aamix,</span>
<span class="p_add">+		.chained = true,</span>
<span class="p_add">+		.chain_id = ALC269_FIXUP_THINKPAD_ACPI</span>
<span class="p_add">+	},</span>
 };
 
 static const struct snd_pci_quirk alc269_fixup_tbl[] = {
<span class="p_chunk">@@ -4954,14 +4987,16 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc269_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x17aa, 0x21fb, &quot;Thinkpad T430s&quot;, ALC269_FIXUP_LENOVO_DOCK),
 	SND_PCI_QUIRK(0x17aa, 0x2203, &quot;Thinkpad X230 Tablet&quot;, ALC269_FIXUP_LENOVO_DOCK),
 	SND_PCI_QUIRK(0x17aa, 0x2208, &quot;Thinkpad T431s&quot;, ALC269_FIXUP_LENOVO_DOCK),
<span class="p_del">-	SND_PCI_QUIRK(0x17aa, 0x220c, &quot;Thinkpad T440s&quot;, ALC292_FIXUP_TPT440_DOCK),</span>
<span class="p_add">+	SND_PCI_QUIRK(0x17aa, 0x220c, &quot;Thinkpad T440s&quot;, ALC292_FIXUP_TPT440),</span>
 	SND_PCI_QUIRK(0x17aa, 0x220e, &quot;Thinkpad T440p&quot;, ALC292_FIXUP_TPT440_DOCK),
 	SND_PCI_QUIRK(0x17aa, 0x2210, &quot;Thinkpad T540p&quot;, ALC292_FIXUP_TPT440_DOCK),
 	SND_PCI_QUIRK(0x17aa, 0x2212, &quot;Thinkpad T440&quot;, ALC292_FIXUP_TPT440_DOCK),
 	SND_PCI_QUIRK(0x17aa, 0x2214, &quot;Thinkpad X240&quot;, ALC292_FIXUP_TPT440_DOCK),
 	SND_PCI_QUIRK(0x17aa, 0x2215, &quot;Thinkpad&quot;, ALC269_FIXUP_LIMIT_INT_MIC_BOOST),
<span class="p_add">+	SND_PCI_QUIRK(0x17aa, 0x2218, &quot;Thinkpad X1 Carbon 2nd&quot;, ALC292_FIXUP_TPT440_DOCK),</span>
 	SND_PCI_QUIRK(0x17aa, 0x2223, &quot;ThinkPad T550&quot;, ALC292_FIXUP_TPT440_DOCK),
 	SND_PCI_QUIRK(0x17aa, 0x2226, &quot;ThinkPad X250&quot;, ALC292_FIXUP_TPT440_DOCK),
<span class="p_add">+	SND_PCI_QUIRK(0x17aa, 0x2233, &quot;Thinkpad&quot;, ALC293_FIXUP_LENOVO_SPK_NOISE),</span>
 	SND_PCI_QUIRK(0x17aa, 0x3977, &quot;IdeaPad S210&quot;, ALC283_FIXUP_INT_MIC),
 	SND_PCI_QUIRK(0x17aa, 0x3978, &quot;IdeaPad Y410P&quot;, ALC269_FIXUP_NO_SHUTUP),
 	SND_PCI_QUIRK(0x17aa, 0x5013, &quot;Thinkpad&quot;, ALC269_FIXUP_LIMIT_INT_MIC_BOOST),
<span class="p_chunk">@@ -4970,6 +5005,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc269_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x17aa, 0x5034, &quot;Thinkpad T450&quot;, ALC292_FIXUP_TPT440_DOCK),
 	SND_PCI_QUIRK(0x17aa, 0x5036, &quot;Thinkpad T450s&quot;, ALC292_FIXUP_TPT440_DOCK),
 	SND_PCI_QUIRK(0x17aa, 0x503c, &quot;Thinkpad L450&quot;, ALC292_FIXUP_TPT440_DOCK),
<span class="p_add">+	SND_PCI_QUIRK(0x17aa, 0x504b, &quot;Thinkpad&quot;, ALC293_FIXUP_LENOVO_SPK_NOISE),</span>
 	SND_PCI_QUIRK(0x17aa, 0x5109, &quot;Thinkpad&quot;, ALC269_FIXUP_LIMIT_INT_MIC_BOOST),
 	SND_PCI_QUIRK(0x17aa, 0x3bf8, &quot;Quanta FL1&quot;, ALC269_FIXUP_PCM_44K),
 	SND_PCI_QUIRK(0x17aa, 0x9e54, &quot;LENOVO NB&quot;, ALC269_FIXUP_LENOVO_EAPD),
<span class="p_chunk">@@ -5041,6 +5077,7 @@</span> <span class="p_context"> static const struct hda_model_fixup alc269_fixup_models[] = {</span>
 	{.id = ALC283_FIXUP_CHROME_BOOK, .name = &quot;alc283-dac-wcaps&quot;},
 	{.id = ALC283_FIXUP_SENSE_COMBO_JACK, .name = &quot;alc283-sense-combo&quot;},
 	{.id = ALC292_FIXUP_TPT440_DOCK, .name = &quot;tpt440-dock&quot;},
<span class="p_add">+	{.id = ALC292_FIXUP_TPT440, .name = &quot;tpt440&quot;},</span>
 	{}
 };
 
<span class="p_chunk">@@ -6002,6 +6039,7 @@</span> <span class="p_context"> static const struct hda_fixup alc662_fixups[] = {</span>
 static const struct snd_pci_quirk alc662_fixup_tbl[] = {
 	SND_PCI_QUIRK(0x1019, 0x9087, &quot;ECS&quot;, ALC662_FIXUP_ASUS_MODE2),
 	SND_PCI_QUIRK(0x1025, 0x022f, &quot;Acer Aspire One&quot;, ALC662_FIXUP_INV_DMIC),
<span class="p_add">+	SND_PCI_QUIRK(0x1025, 0x0241, &quot;Packard Bell DOTS&quot;, ALC662_FIXUP_INV_DMIC),</span>
 	SND_PCI_QUIRK(0x1025, 0x0308, &quot;Acer Aspire 8942G&quot;, ALC662_FIXUP_ASPIRE),
 	SND_PCI_QUIRK(0x1025, 0x031c, &quot;Gateway NV79&quot;, ALC662_FIXUP_SKU_IGNORE),
 	SND_PCI_QUIRK(0x1025, 0x0349, &quot;eMachines eM250&quot;, ALC662_FIXUP_INV_DMIC),
<span class="p_header">diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c</span>
<span class="p_header">index 76169929770d..bde4c7330f30 100644</span>
<span class="p_header">--- a/sound/pci/rme96.c</span>
<span class="p_header">+++ b/sound/pci/rme96.c</span>
<span class="p_chunk">@@ -742,10 +742,11 @@</span> <span class="p_context"> snd_rme96_playback_setrate(struct rme96 *rme96,</span>
 	{
 		/* change to/from double-speed: reset the DAC (if available) */
 		snd_rme96_reset_dac(rme96);
<span class="p_add">+		return 1; /* need to restore volume */</span>
 	} else {
 		writel(rme96-&gt;wcreg, rme96-&gt;iobase + RME96_IO_CONTROL_REGISTER);
<span class="p_add">+		return 0;</span>
 	}
<span class="p_del">-	return 0;</span>
 }
 
 static int
<span class="p_chunk">@@ -983,6 +984,7 @@</span> <span class="p_context"> snd_rme96_playback_hw_params(struct snd_pcm_substream *substream,</span>
 	struct rme96 *rme96 = snd_pcm_substream_chip(substream);
 	struct snd_pcm_runtime *runtime = substream-&gt;runtime;
 	int err, rate, dummy;
<span class="p_add">+	bool apply_dac_volume = false;</span>
 
 	runtime-&gt;dma_area = (void __force *)(rme96-&gt;iobase +
 					     RME96_IO_PLAY_BUFFER);
<span class="p_chunk">@@ -996,24 +998,26 @@</span> <span class="p_context"> snd_rme96_playback_hw_params(struct snd_pcm_substream *substream,</span>
 	{
                 /* slave clock */
                 if ((int)params_rate(params) != rate) {
<span class="p_del">-			spin_unlock_irq(&amp;rme96-&gt;lock);</span>
<span class="p_del">-			return -EIO;                    </span>
<span class="p_del">-                }</span>
<span class="p_del">-	} else if ((err = snd_rme96_playback_setrate(rme96, params_rate(params))) &lt; 0) {</span>
<span class="p_del">-		spin_unlock_irq(&amp;rme96-&gt;lock);</span>
<span class="p_del">-		return err;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	if ((err = snd_rme96_playback_setformat(rme96, params_format(params))) &lt; 0) {</span>
<span class="p_del">-		spin_unlock_irq(&amp;rme96-&gt;lock);</span>
<span class="p_del">-		return err;</span>
<span class="p_add">+			err = -EIO;</span>
<span class="p_add">+			goto error;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		err = snd_rme96_playback_setrate(rme96, params_rate(params));</span>
<span class="p_add">+		if (err &lt; 0)</span>
<span class="p_add">+			goto error;</span>
<span class="p_add">+		apply_dac_volume = err &gt; 0; /* need to restore volume later? */</span>
 	}
<span class="p_add">+</span>
<span class="p_add">+	err = snd_rme96_playback_setformat(rme96, params_format(params));</span>
<span class="p_add">+	if (err &lt; 0)</span>
<span class="p_add">+		goto error;</span>
 	snd_rme96_setframelog(rme96, params_channels(params), 1);
 	if (rme96-&gt;capture_periodsize != 0) {
 		if (params_period_size(params) &lt;&lt; rme96-&gt;playback_frlog !=
 		    rme96-&gt;capture_periodsize)
 		{
<span class="p_del">-			spin_unlock_irq(&amp;rme96-&gt;lock);</span>
<span class="p_del">-			return -EBUSY;</span>
<span class="p_add">+			err = -EBUSY;</span>
<span class="p_add">+			goto error;</span>
 		}
 	}
 	rme96-&gt;playback_periodsize =
<span class="p_chunk">@@ -1024,9 +1028,16 @@</span> <span class="p_context"> snd_rme96_playback_hw_params(struct snd_pcm_substream *substream,</span>
 		rme96-&gt;wcreg &amp;= ~(RME96_WCR_PRO | RME96_WCR_DOLBY | RME96_WCR_EMP);
 		writel(rme96-&gt;wcreg |= rme96-&gt;wcreg_spdif_stream, rme96-&gt;iobase + RME96_IO_CONTROL_REGISTER);
 	}
<span class="p_add">+</span>
<span class="p_add">+	err = 0;</span>
<span class="p_add">+ error:</span>
 	spin_unlock_irq(&amp;rme96-&gt;lock);
<span class="p_del">-		</span>
<span class="p_del">-	return 0;</span>
<span class="p_add">+	if (apply_dac_volume) {</span>
<span class="p_add">+		usleep_range(3000, 10000);</span>
<span class="p_add">+		snd_rme96_apply_dac_volume(rme96);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return err;</span>
 }
 
 static int
<span class="p_header">diff --git a/sound/soc/codecs/arizona.c b/sound/soc/codecs/arizona.c</span>
<span class="p_header">index 29e198f57d4c..131fc593a4e8 100644</span>
<span class="p_header">--- a/sound/soc/codecs/arizona.c</span>
<span class="p_header">+++ b/sound/soc/codecs/arizona.c</span>
<span class="p_chunk">@@ -1188,7 +1188,7 @@</span> <span class="p_context"> static int arizona_hw_params(struct snd_pcm_substream *substream,</span>
 	int chan_limit = arizona-&gt;pdata.max_channels_clocked[dai-&gt;id - 1];
 	int bclk, lrclk, wl, frame, bclk_target;
 
<span class="p_del">-	if (params_rate(params) % 8000)</span>
<span class="p_add">+	if (params_rate(params) % 4000)</span>
 		rates = &amp;arizona_44k1_bclk_rates[0];
 	else
 		rates = &amp;arizona_48k_bclk_rates[0];
<span class="p_header">diff --git a/sound/soc/codecs/wm8974.c b/sound/soc/codecs/wm8974.c</span>
<span class="p_header">index 0627c56fa44e..c2248db97fc4 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8974.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8974.c</span>
<span class="p_chunk">@@ -587,6 +587,7 @@</span> <span class="p_context"> static const struct regmap_config wm8974_regmap = {</span>
 	.max_register = WM8974_MONOMIX,
 	.reg_defaults = wm8974_reg_defaults,
 	.num_reg_defaults = ARRAY_SIZE(wm8974_reg_defaults),
<span class="p_add">+	.cache_type = REGCACHE_FLAT,</span>
 };
 
 static int wm8974_probe(struct snd_soc_codec *codec)
<span class="p_header">diff --git a/sound/usb/mixer.c b/sound/usb/mixer.c</span>
<span class="p_header">index 1550e15e9179..21c60eff920e 100644</span>
<span class="p_header">--- a/sound/usb/mixer.c</span>
<span class="p_header">+++ b/sound/usb/mixer.c</span>
<span class="p_chunk">@@ -1334,6 +1334,8 @@</span> <span class="p_context"> static void build_feature_ctl(struct mixer_build *state, void *raw_desc,</span>
 		}
 	}
 
<span class="p_add">+	snd_usb_mixer_fu_apply_quirk(state-&gt;mixer, cval, unitid, kctl);</span>
<span class="p_add">+</span>
 	range = (cval-&gt;max - cval-&gt;min) / cval-&gt;res;
 	/*
 	 * Are there devices with volume range more than 255? I use a bit more
<span class="p_header">diff --git a/sound/usb/mixer_maps.c b/sound/usb/mixer_maps.c</span>
<span class="p_header">index 9a3e1076a5b1..e89789a9baed 100644</span>
<span class="p_header">--- a/sound/usb/mixer_maps.c</span>
<span class="p_header">+++ b/sound/usb/mixer_maps.c</span>
<span class="p_chunk">@@ -343,13 +343,6 @@</span> <span class="p_context"> static struct usbmix_name_map bose_companion5_map[] = {</span>
 	{ 0 }	/* terminator */
 };
 
<span class="p_del">-/* Dragonfly DAC 1.2, the dB conversion factor is 1 instead of 256 */</span>
<span class="p_del">-static struct usbmix_dB_map dragonfly_1_2_dB = {0, 5000};</span>
<span class="p_del">-static struct usbmix_name_map dragonfly_1_2_map[] = {</span>
<span class="p_del">-	{ 7, NULL, .dB = &amp;dragonfly_1_2_dB },</span>
<span class="p_del">-	{ 0 }	/* terminator */</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
 /*
  * Control map entries
  */
<span class="p_chunk">@@ -461,11 +454,6 @@</span> <span class="p_context"> static struct usbmix_ctl_map usbmix_ctl_maps[] = {</span>
 		.id = USB_ID(0x05a7, 0x1020),
 		.map = bose_companion5_map,
 	},
<span class="p_del">-	{</span>
<span class="p_del">-		/* Dragonfly DAC 1.2 */</span>
<span class="p_del">-		.id = USB_ID(0x21b4, 0x0081),</span>
<span class="p_del">-		.map = dragonfly_1_2_map,</span>
<span class="p_del">-	},</span>
 	{ 0 } /* terminator */
 };
 
<span class="p_header">diff --git a/sound/usb/mixer_quirks.c b/sound/usb/mixer_quirks.c</span>
<span class="p_header">index 9484d02d5f2c..614f33e63c3a 100644</span>
<span class="p_header">--- a/sound/usb/mixer_quirks.c</span>
<span class="p_header">+++ b/sound/usb/mixer_quirks.c</span>
<span class="p_chunk">@@ -37,6 +37,7 @@</span> <span class="p_context"></span>
 #include &lt;sound/control.h&gt;
 #include &lt;sound/hwdep.h&gt;
 #include &lt;sound/info.h&gt;
<span class="p_add">+#include &lt;sound/tlv.h&gt;</span>
 
 #include &quot;usbaudio.h&quot;
 #include &quot;mixer.h&quot;
<span class="p_chunk">@@ -1711,3 +1712,39 @@</span> <span class="p_context"> void snd_usb_mixer_rc_memory_change(struct usb_mixer_interface *mixer,</span>
 	}
 }
 
<span class="p_add">+static void snd_dragonfly_quirk_db_scale(struct usb_mixer_interface *mixer,</span>
<span class="p_add">+					 struct snd_kcontrol *kctl)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* Approximation using 10 ranges based on output measurement on hw v1.2.</span>
<span class="p_add">+	 * This seems close to the cubic mapping e.g. alsamixer uses. */</span>
<span class="p_add">+	static const DECLARE_TLV_DB_RANGE(scale,</span>
<span class="p_add">+		 0,  1, TLV_DB_MINMAX_ITEM(-5300, -4970),</span>
<span class="p_add">+		 2,  5, TLV_DB_MINMAX_ITEM(-4710, -4160),</span>
<span class="p_add">+		 6,  7, TLV_DB_MINMAX_ITEM(-3884, -3710),</span>
<span class="p_add">+		 8, 14, TLV_DB_MINMAX_ITEM(-3443, -2560),</span>
<span class="p_add">+		15, 16, TLV_DB_MINMAX_ITEM(-2475, -2324),</span>
<span class="p_add">+		17, 19, TLV_DB_MINMAX_ITEM(-2228, -2031),</span>
<span class="p_add">+		20, 26, TLV_DB_MINMAX_ITEM(-1910, -1393),</span>
<span class="p_add">+		27, 31, TLV_DB_MINMAX_ITEM(-1322, -1032),</span>
<span class="p_add">+		32, 40, TLV_DB_MINMAX_ITEM(-968, -490),</span>
<span class="p_add">+		41, 50, TLV_DB_MINMAX_ITEM(-441, 0),</span>
<span class="p_add">+	);</span>
<span class="p_add">+</span>
<span class="p_add">+	usb_audio_info(mixer-&gt;chip, &quot;applying DragonFly dB scale quirk\n&quot;);</span>
<span class="p_add">+	kctl-&gt;tlv.p = scale;</span>
<span class="p_add">+	kctl-&gt;vd[0].access |= SNDRV_CTL_ELEM_ACCESS_TLV_READ;</span>
<span class="p_add">+	kctl-&gt;vd[0].access &amp;= ~SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void snd_usb_mixer_fu_apply_quirk(struct usb_mixer_interface *mixer,</span>
<span class="p_add">+				  struct usb_mixer_elem_info *cval, int unitid,</span>
<span class="p_add">+				  struct snd_kcontrol *kctl)</span>
<span class="p_add">+{</span>
<span class="p_add">+	switch (mixer-&gt;chip-&gt;usb_id) {</span>
<span class="p_add">+	case USB_ID(0x21b4, 0x0081): /* AudioQuest DragonFly */</span>
<span class="p_add">+		if (unitid == 7 &amp;&amp; cval-&gt;min == 0 &amp;&amp; cval-&gt;max == 50)</span>
<span class="p_add">+			snd_dragonfly_quirk_db_scale(mixer, kctl);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_header">diff --git a/sound/usb/mixer_quirks.h b/sound/usb/mixer_quirks.h</span>
<span class="p_header">index bdbfab093816..177c329cd4dd 100644</span>
<span class="p_header">--- a/sound/usb/mixer_quirks.h</span>
<span class="p_header">+++ b/sound/usb/mixer_quirks.h</span>
<span class="p_chunk">@@ -9,5 +9,9 @@</span> <span class="p_context"> void snd_emuusb_set_samplerate(struct snd_usb_audio *chip,</span>
 void snd_usb_mixer_rc_memory_change(struct usb_mixer_interface *mixer,
 				    int unitid);
 
<span class="p_add">+void snd_usb_mixer_fu_apply_quirk(struct usb_mixer_interface *mixer,</span>
<span class="p_add">+				  struct usb_mixer_elem_info *cval, int unitid,</span>
<span class="p_add">+				  struct snd_kcontrol *kctl);</span>
<span class="p_add">+</span>
 #endif /* SND_USB_MIXER_QUIRKS_H */
 
<span class="p_header">diff --git a/tools/Makefile b/tools/Makefile</span>
<span class="p_header">index 9a617adc6675..f0fd70a5bd68 100644</span>
<span class="p_header">--- a/tools/Makefile</span>
<span class="p_header">+++ b/tools/Makefile</span>
<span class="p_chunk">@@ -25,6 +25,10 @@</span> <span class="p_context"> help:</span>
 	@echo &#39;  from the kernel command line to build and install one of&#39;
 	@echo &#39;  the tools above&#39;
 	@echo &#39;&#39;
<span class="p_add">+	@echo &#39;  $$ make tools/all&#39;</span>
<span class="p_add">+	@echo &#39;&#39;</span>
<span class="p_add">+	@echo &#39;  builds all tools.&#39;</span>
<span class="p_add">+	@echo &#39;&#39;</span>
 	@echo &#39;  $$ make tools/install&#39;
 	@echo &#39;&#39;
 	@echo &#39;  installs all tools.&#39;
<span class="p_chunk">@@ -62,6 +66,11 @@</span> <span class="p_context"> turbostat x86_energy_perf_policy: FORCE</span>
 tmon: FORCE
 	$(call descend,thermal/$@)
 
<span class="p_add">+all: acpi cgroup cpupower hv firewire lguest \</span>
<span class="p_add">+		perf selftests turbostat usb \</span>
<span class="p_add">+		virtio vm net x86_energy_perf_policy \</span>
<span class="p_add">+		tmon</span>
<span class="p_add">+</span>
 acpi_install:
 	$(call descend,power/$(@:_install=),install)
 

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



